\chapter{Developer Tutorials}\label{developer-tutorials}

Liferay's developer tutorials help you learn from scratch. They are the
``opinionated'' way to work with code on Liferay's platform. Here,
you'll learn these things:

\begin{itemize}
\item
  Writing applications on various frameworks, such as Bean Portlet,
  PortletMVC4Spring, and Liferay MVC Portlet (coming soon)
\item
  Writing front-end applications using Angular, React, and Vue (coming
  soon)
\item
  Upgrading your code from older versions of Liferay DXP
\item
  Creating back-end and headless services (coming soon)
\end{itemize}

\chapter{Developing a Web
Application}\label{developing-a-web-application}

This tutorial shows you how to build a Liferay application from
beginning to end. Starting by designing the back-end using Liferay's
object-relational mapper Service Builder, you'll move from there to
designing the widget that calls all of those services. In the process,
you'll learn about many of Liferay's development frameworks, including

\begin{itemize}
\tightlist
\item
  Permissions
\item
  Search
\item
  Assets
\item
  REST Builder web services
\item
  Workflow
\item
  Staging
\end{itemize}

When you're finished, the application looks like this:

\begin{figure}
\centering
\includegraphics{./images/finished-guestbook-intro.png}
\caption{It looks humble, but there's a lot of functionality packed in
this application.}
\end{figure}

This tutorial assumes nothing, so it starts at the beginning: setting up
a Liferay development environment. Though you can use anything from a
text editor and the command line to your Java IDE of choice, Liferay Dev
Studio DXP optimizes development on Liferay's platform. It integrates
Liferay's Blade tools for modular development.

Once you have an environment ready, you'll jump right in and start
creating your object-relational map. After you've created your back-end,
you'll move to the front-end.

From there you'll see everything from UI standards to providing remote
services. Once everything is completed and wrapped up with a bow, you
can distribute the application on Marketplace.

Let's Go!{}

\chapter{Setting Up a Development
Environment}\label{setting-up-a-development-environment}

Liferay's development tools help you get started fast. All you need as a
prerequisite is a Java Development Kit version 8
(\href{http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}{JDK}
or \href{https://jdk.java.net/java-se-ri/8}{OpenJDK} is fine). Once
that's installed, there are only three steps.

\begin{itemize}
\item
  Download a Liferay Dev Studio DXP bundle.
\item
  Unzip the downloaded package to a location on your system.
\item
  Start Dev Studio DXP.
\end{itemize}

You'll follow these steps and then generate a Liferay Workspace for
developing your first Liferay DXP application.

\section{Installing a Liferay Dev Studio DXP
Bundle}\label{installing-a-liferay-dev-studio-dxp-bundle}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and install
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-liferay-dev-studio}{Liferay
  Dev Studio DXP} Installing it is easy: run the installer.
\item
  To run Liferay Dev Studio DXP, run the \texttt{DeveloperStudio}
  executable. On Windows, the installer doesn't create a menu entry, so
  you should add a shortcut to it to your desktop or task bar.
\end{enumerate}

The first time you start Liferay Dev Studio DXP, it prompts you to
select an Eclipse workspace. If you specify an empty folder, Liferay Dev
Studio DXP creates a new workspace in that folder. Follow these steps to
create a new workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When prompted, indicate your workspace's path. Name your new workspace
  \texttt{guestbook-workspace} and click \emph{OK}. Windows has path
  length limitations, so on that OS, you may want to create your
  workspace the root folder (\texttt{C:\textbackslash{}}).
\item
  When Liferay Dev Studio DXP first launches, it presents a welcome
  page. Click the \emph{Workbench} icon to continue.
\end{enumerate}

Nice job! Your development environment is installed and your Eclipse
workspace is set up.

\section{Creating a Liferay
Workspace}\label{creating-a-liferay-workspace}

Now you'll create another kind of workspace: a
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace}. Liferay Workspace helps manage Liferay projects by providing
various build scripts, properties, and configuration for you. Liferay
Workspace uses
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} and
\href{https://gradle.org/}{Gradle} to manage dependencies and organize
your build environment. Note that to avoid configuration issues, you can
only create one Liferay Workspace for each Eclipse Workspace.

Follow these steps to create a Liferay Workspace in Liferay Dev Studio
DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{File} → \emph{New} → \emph{Liferay Workspace Project}.
  Note: you may have to select \emph{File} → \emph{New} → \emph{Other},
  then choose \emph{Liferay Workspace Project} in the \emph{Liferay}
  category.

  \begin{figure}
  \centering
  \includegraphics{./images/dev-studio-create-workspace.png}
  \caption{By selecting \emph{Liferay Workspace}, you begin the process
  of creating a new workspace for your Liferay DXP projects.}
  \end{figure}

  A \emph{New Liferay Workspace} dialog appears, which presents several
  configuration options.
\item
  Give your workspace the name \texttt{com-liferay-docs-guestbook}.
\item
  Next, choose your workspace's location. Leave the default setting
  checked. This places your Liferay Workspace inside your Eclipse
  workspace.
\item
  For \emph{Liferay Version}, 7.2 should already be selected.
\item
  Leave the rest of the defaults.
\item
  Check the \emph{Download Liferay bundle} checkbox to download and
  unzip a Liferay DXP instance in your workspace automatically. When
  prompted, name the server \texttt{liferay-tomcat-bundle}.
\item
  Click \emph{Finish} to create your Liferay Workspace. This may take a
  while because Liferay Liferay DXP downloads the Liferay DXP bundle in
  the background.
\end{enumerate}

Congratulations! Your development environment is ready! Next, you'll get
started developing your first Liferay DXP application.

\chapter{Generating the Back-end}\label{generating-the-back-end}

You can start writing an application in either the front-end or the
back-end. If you start with the front-end, you design the screens and
forms first, using mock data. If you start with the back-end, you create
your data store up front, and then you can create your front-end later.
This is what you'll do with the Guestbook application.

A \emph{persistence} layer and a \emph{service} layer make up the bottom
layers of your back-end. You'll persist guestbooks and their entries to
a database. Your service layer calls your persistence layer, providing a
buffer in case you wish to swap out your persistence technology later.

\begin{figure}
\centering
\includegraphics{./images/application-layers.png}
\caption{Service Builder generates the shaded layers of your
application.}
\end{figure}

\emph{Service Builder} is Liferay's code generation tool for defining
object models and mapping those models to SQL databases. By defining
your model in a single XML file, you can generate your object model (the
M in MVC), your service layer, and your persistence layer all in one
shot. At the same time, you can support every database Liferay DXP
supports.

Ready to begin?

Let's Go!{}

\chapter{What is Service Builder?}\label{what-is-service-builder}

\begin{verbatim}
<p id="stepTitle">Generating the Back-End</p><p>Step 1 of 3</p>
\end{verbatim}

Now you'll use Service Builder to generate your application's Model,
Service, and Persistence layers. Then you can add your application's
necessary business logic.

\section{Guestbook Application
Design}\label{guestbook-application-design}

The Guestbook application handles multiple Guestbooks and their entries.
To make this work, you'll create two tables in the database: one for
guestbooks and one for guestbook entries.

\begin{figure}
\centering
\includegraphics{./images/guestbook-final.png}
\caption{When you're done, the Guestbook supports multiple guestbooks
and makes use of many Liferay features.}
\end{figure}

\section{Service Layer}\label{service-layer}

This application is data-driven. It uses services for storing and
retrieving data. The application asks for data, and the service fetches
it from the persistence layer. The application can then display this
data to the user, who reads or modifies it. If the data is modified, the
application passes it back to the service, which calls the persistence
layer to store it. The application doesn't need to know anything about
how the service does what it does.

To get started, you'll create a Service Builder project and populate its
\texttt{service.xml} file with all the necessary entities to generate
this code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay Dev Studio DXP, click \emph{File} → \emph{New} →
  \emph{Liferay Module Project}.
\item
  Name the project \texttt{guestbook}.
\item
  Select \texttt{service-builder} for the Project Template Name.
\item
  Click \emph{Next}.
\item
  Enter \texttt{com.liferay.docs.guestbook} for the \emph{Package Name}.
\item
  Click \emph{Finish}.
\end{enumerate}

This creates two modules: an API module (\texttt{guestbook-api}) and a
service module (\texttt{guestbook-service}). Next, you'll learn how to
use them.

\begin{figure}
\centering
\includegraphics{./images/guestbook-service-project.png}
\caption{Your current project structure.}
\end{figure}

\chapter{Generating Model, Service, and Persistence
Layers}\label{generating-model-service-and-persistence-layers}

\begin{verbatim}
<p id="stepTitle">Generating the Back-End</p><p>Step 2 of 3</p>
\end{verbatim}

To model the guestbooks and entries, you'll create guestbook and entry
model classes. But you won't do this directly in Java. Instead, you'll
define them in Service Builder, which generates your object model and
maps it to all the SQL databases Liferay DXP supports.

This application's design allows for multiple guestbooks, each
containing different sets of entries. All users with permission to
access the application can add entries, but only administrative users
can add guestbooks.

It's time to get started. You'll create the \texttt{Guestbook} entity
first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} project, open \texttt{service.xml}.
  Make sure the \emph{Source} tab is selected.
\item
  When Liferay Dev Studio DXP generated your project, it filled this
  file with dummy entities, which you'll replace. Remove everything in
  the file below the \texttt{DOCTYPE}. Replace the file's opening
  contents with the following code:

\begin{verbatim}
<service-builder dependency-injector="ds" package-path="com.liferay.docs.guestbook" mvcc-enabled="true">
    <author>liferay</author>
    <namespace>GB</namespace>
    <entity name="Guestbook" local-service="true" uuid="true" remote-service="true">
\end{verbatim}

  This defines the author, namespace, and the entity name. The namespace
  keeps the database field names from conflicting. The last tag is the
  opening tag for the \texttt{Guestbook} entity definition. In this tag,
  you enable local and remote services for the entity, define its name,
  and specify that it should have a
  \href{https://en.wikipedia.org/wiki/Universally_unique_identifier}{universally
  unique identifier (UUID)}.
\item
  The Guestbook requires only two fields: a primary key to identify it
  uniquely in the database, and a name. Add these fields:

\begin{verbatim}
<!-- Guestbook fields -->

<column name="guestbookId" primary="true" type="long" />
<column name="name" type="String" />
\end{verbatim}

  This defines \texttt{guestbookId} as the entity's primary key of the
  type \texttt{long} and the name as a \texttt{String}.
\item
  Next, define the group instance. The \texttt{groupId} defines the ID
  of the Site in Liferay DXP where the entity instance exists. The
  \texttt{companyId} is the primary key of a
  \href{/docs/7-2/user/-/knowledge_base/u/setting-up}{portal instance}.

\begin{verbatim}
<!-- Group instance -->

<column name="groupId" type="long" />
<column name="companyId" type="long" />
\end{verbatim}
\item
  Next, add audit fields. These fields help you track owners of entity
  instances, along with those instances' create and modify dates:

\begin{verbatim}
<!-- Audit fields -->

<column name="userId" type="long" />
<column name="userName" type="String" />
<column name="createDate" type="Date" />
<column name="modifiedDate" type="Date" />
\end{verbatim}
\item
  After this, add fields that support Liferay's workflow system. These
  provide fields in the database to track your entity's status as it
  passes through the workflow.

\begin{verbatim}
<!-- Status fields -->

<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}
\item
  Before the closing \texttt{\textless{}/entity\textgreater{}} tag, add
  this finder definition:

\begin{verbatim}
    <finder name="GroupId" return-type="Collection">
        <finder-column name="groupId" />
    </finder>

</entity>
\end{verbatim}
\end{enumerate}

A
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{finder}
generates a \texttt{get} method for retrieving Guestbook entities. The
fields used by the finder define the scope of the data retrieved. This
finder gets all Guestbooks by their \texttt{groupId}. This is how
administrators put Guestbooks on multiple Sites, and each
\texttt{Guestbook} has its own data scoped to its Site.

The \texttt{Guestbook} entity is finished for now. Next, you'll create
the \texttt{GuestbookEntry} entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the opening entity tag:

\begin{verbatim}
<entity name="GuestbookEntry" local-service="true" remote-service="true" uuid="true">
\end{verbatim}

  As with the \texttt{Guestbook} entity, you enable local and remote
  services, define the entity's name, and specify that it should have a
  UUID.
\item
  Add the fields that define the \texttt{GuestbookEntry}'s data:

\begin{verbatim}
<!-- Guestbook Entry fields -->

<column name="entryId" primary="true" type="long" />
<column name="name" type="String" />
<column name="email" type="String" />
<column name="message" type="String" />
<column name="guestbookId" type="long" />
\end{verbatim}

  The \texttt{name}, \texttt{email}, and \texttt{message} fields
  comprise a \texttt{GuestbookEntry}. These fields define the name of
  the person creating the entry, an email address, and the Guestbook
  message, respectively. The \texttt{guestbookId} is assigned
  automatically by code you'll write, and is a foreign key to the
  \texttt{Guestbook} where this entry belongs.
\item
  Add fields to track the portal instance and group:

\begin{verbatim}
<!-- Group instance -->

<column name="groupId" type="long" />
<column name="companyId" type="long" />
\end{verbatim}
\item
  Add audit fields:

\begin{verbatim}
<!-- Audit fields -->

<column name="userId" type="long" />
<column name="userName" type="String" />
<column name="createDate" type="Date" />
<column name="modifiedDate" type="Date" />
\end{verbatim}
\item
  Add status fields to track workflow:

\begin{verbatim}
<!-- Status fields -->

<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}
\item
  When querying for \texttt{GuestbookEntry}s, you can order them by one
  or more columns. Since visitors sign \texttt{Guestbook}s in order by
  time, order your \texttt{GuestbookEntry} instances by the date they
  were created:

\begin{verbatim}
<order>
    <order-column name="createDate" order-by="desc" />
</order>
\end{verbatim}
\item
  Add a finder that retrieves \texttt{GuestbooEntry}s by a combination
  of \texttt{groupId} and \texttt{guestbookId}. This supports Liferay
  DXP's multi-tenancy by only returning those entries that belong both
  to the current Site and the current Guestbook. After defining your
  finder add the closing entity tag:

\begin{verbatim}
    <finder name="G_G" return-type="Collection">
        <finder-column name="groupId" />
        <finder-column name="guestbookId" />
    </finder>
</entity>
\end{verbatim}
\item
  Define exception types outside the
  \texttt{\textless{}entity\textgreater{}} tags, just before the closing
  \texttt{\textless{}/service-builder\textgreater{}} tag:

\begin{verbatim}
    <exceptions>
        <exception>GuestbookEntryEmail</exception>
        <exception>GuestbookEntryMessage</exception>
        <exception>GuestbookEntryName</exception>
        <exception>GuestbookName</exception>
    </exceptions>

</service-builder>
\end{verbatim}

  These generate exception classes you'll use later in try/catch
  statements.
\item
  Save your \texttt{service.xml} file.
\end{enumerate}

Now you're ready to run Service Builder to generate your model, service,
and persistence layers!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Gradle Tasks pane on the right side of Dev Studio DXP, open
  \texttt{com-liferay-docs-guestbook} → \texttt{modules} →
  \texttt{guestbook} → \texttt{guestbook-service} → \texttt{build}.
\item
  Run \texttt{buildService} by right-clicking it and selecting \emph{Run
  Gradle Tasks}. Make sure you're connected to the Internet, as Gradle
  downloads dependencies the first time you run it.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the new classes and
  interfaces generated by Service Builder show up in Dev Studio DXP.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

Service Builder is based on a design philosophy called loose coupling.
It generates three layers of your application: the model, the service,
and the persistence layers. Loose coupling means you can swap out the
persistence layer with little to no change in the model and service
layers. The model is in the \texttt{-api} module, and the service and
persistence layers are in the \texttt{-service} module.

\begin{figure}
\centering
\includegraphics{./images/model-service-persistence.png}
\caption{The Model, Service, and Persistence Layer comprise a loose
coupling design.}
\end{figure}

Each layer is implemented using Java Interfaces and implementations of
those interfaces. Rather than have one \texttt{Guestbook} class that
represents your model, Service Builder generates a system of classes
that includes a \texttt{Guestbook} interface, a
\texttt{GuestbookBaseImpl} abstract class that Service Builder manages,
and a \texttt{GuestbookImpl} class that you can customize. With this
design, you can customize your model and let Service Builder generate
the tedious-to-write code. That's why Service Builder is a code
generator for code generator haters.

Next, you'll create the service implementations.

\chapter{Implementing Service
Methods}\label{implementing-service-methods}

\begin{verbatim}
<p id="stepTitle">Generating the Back-End</p><p>Step 3 of 3</p>
\end{verbatim}

When you use Service Builder, you implement the services in the service
module. Because your application's projects are
\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{components},
you can reference your service layer from your web module.

You'll implement services for guestbooks and entries in the
\texttt{guestbook-service} module's \texttt{GuestbookLocalServiceImpl}
and \texttt{GuestbookEntryLocalServiceImpl}, respectively.

Follow these steps to implement services for guestbooks in
\texttt{GuestbookLocalServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{GuestbookLocalServiceImpl}. Then add this
  \texttt{addGuestbook} method:

\begin{verbatim}
public Guestbook addGuestbook(long userId, String name,
        ServiceContext serviceContext) throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name);

    long guestbookId = counterLocalService.increment();

    Guestbook guestbook = guestbookPersistence.create(guestbookId);

    guestbook.setUuid(serviceContext.getUuid());
    guestbook.setUserId(userId);
    guestbook.setGroupId(groupId);
    guestbook.setCompanyId(user.getCompanyId());
    guestbook.setUserName(user.getFullName());
    guestbook.setCreateDate(serviceContext.getCreateDate(now));
    guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
    guestbook.setName(name);
    guestbook.setExpandoBridgeAttributes(serviceContext);

    guestbookPersistence.update(guestbook);

    return guestbook;
}
\end{verbatim}

  This method adds a guestbook to the database. It retrieves metadata
  from the environment (such as the current user's ID, the group ID,
  etc.), along with data passed from the user. It validates this data
  and uses it to construct a \texttt{Guestbook} object. The method then
  persists this object to the database and returns the object. You
  implement the business logic here because Service Builder already
  generated the model and all the code that maps that model to the
  database.
\item
  Add the methods for getting \texttt{Guestbook} objects:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId) {

    return guestbookPersistence.findByGroupId(groupId);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end,
        OrderByComparator<Guestbook> obc) {

    return guestbookPersistence.findByGroupId(groupId, start, end, obc);
}

public List<Guestbook> getGuestbooks(long groupId, int start, int end) {

    return guestbookPersistence.findByGroupId(groupId, start, end);
}

public int getGuestbooksCount(long groupId) {

    return guestbookPersistence.countByGroupId(groupId);
}
\end{verbatim}

  These call the finders you generated with Service Builder. The first
  method retrieves a list of guestbooks from the Site specified by
  \texttt{groupId}. The next two methods get paginated lists, optionally
  in a particular order. The final method gives you the total number of
  guestbooks for a given Site.
\item
  Finally, add the guestbook validator method:

\begin{verbatim}
protected void validate(String name) throws PortalException {
    if (Validator.isNull(name)) {
        throw new GuestbookNameException();
    }
}
\end{verbatim}

  This method uses Liferay DXP's \texttt{Validator} to make sure the
  user entered text for the guestbook name.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following classes when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.List}
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Now you're ready to implement services for entries in
\texttt{GuestbookEntryLocalServiceImpl}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.service.impl} package, open
  \texttt{GuestbookEntryLocalServiceImpl}. Add this \texttt{addEntry}
  method:

\begin{verbatim}
public GuestbookEntry addGuestbookEntry(long userId, long guestbookId, String name,
        String email, String message, ServiceContext serviceContext)
    throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name, email, message);

    long entryId = counterLocalService.increment();

    GuestbookEntry entry = guestbookEntryPersistence.create(entryId);

    entry.setUuid(serviceContext.getUuid());
    entry.setUserId(userId);
    entry.setGroupId(groupId);
    entry.setCompanyId(user.getCompanyId());
    entry.setUserName(user.getFullName());
    entry.setCreateDate(serviceContext.getCreateDate(now));
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setExpandoBridgeAttributes(serviceContext);
    entry.setGuestbookId(guestbookId);
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);

    guestbookEntryPersistence.update(entry);

    // Calls to other Liferay frameworks go here

    return entry;
}
\end{verbatim}

  Like the \texttt{addGuestbook} method, \texttt{addGuestbookEntry}
  takes data from the current context along with data the user entered,
  validates it, and creates a model object. That object is then
  persisted to the database and returned.
\item
  Add this \texttt{updateGuestbookEntry} method:

\begin{verbatim}
public GuestbookEntry updateGuestbookEntry(long userId, long guestbookId,
        long entryId, String name, String email, String message,
        ServiceContext serviceContext)
    throws PortalException, SystemException {

    Date now = new Date();

    validate(name, email, message);

    GuestbookEntry entry =
        guestbookEntryPersistence.findByPrimaryKey(entryId);

    User user = userLocalService.getUserById(userId);

    entry.setUserId(userId);
    entry.setUserName(user.getFullName());
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);
    entry.setExpandoBridgeAttributes(serviceContext);

    guestbookEntryPersistence.update(entry);

    // Integrate with Liferay frameworks here.

    return entry;
}
\end{verbatim}

  This method first retrieves the entry and updates its data to reflect
  what the user submitted, including its date modified.
\item
  Add two \texttt{deleteGuestbookEntry} methods:

\begin{verbatim}
public GuestbookEntry deleteGuestbookEntry(GuestbookEntry entry)
    throws PortalException {

    guestbookEntryPersistence.remove(entry);

    return entry;
}

public GuestbookEntry deleteGuestbookEntry(long entryId) throws PortalException {

    GuestbookEntry entry =
        guestbookEntryPersistence.findByPrimaryKey(entryId);

    return deleteGuestbookEntry(entry);
}
\end{verbatim}

  These methods delete entries using the \texttt{entryId} or the object.
  If you supply the \texttt{entryId}, the object is retrieved and passed
  to the method that deletes the object.
\item
  Add the methods for getting \texttt{GuestbookEntry} objects:

\begin{verbatim}
public List<GuestbookEntry> getGuestbookEntries(long groupId, long guestbookId) {
    return guestbookEntryPersistence.findByG_G(groupId, guestbookId);
}

public List<GuestbookEntry> getGuestbookEntries(long groupId, long guestbookId,
        int start, int end) throws SystemException {

    return guestbookEntryPersistence.findByG_G(groupId, guestbookId, start,
            end);
}

public List<GuestbookEntry> getGuestbookEntries(long groupId, long guestbookId,
        int start, int end, OrderByComparator<GuestbookEntry> obc) {

    return guestbookEntryPersistence.findByG_G(groupId, guestbookId, start,
            end, obc);
}

public GuestbookEntry getGuestbookEntry(long entryId) throws PortalException {
    return guestbookEntryPersistence.findByPrimaryKey(entryId);
}

public int getGuestbookEntriesCount(long groupId, long guestbookId) {
    return guestbookEntryPersistence.countByG_G(groupId, guestbookId);
}
\end{verbatim}

  These methods, like the getters in \texttt{GuestbookLocalServiceImpl},
  call the finders you generated with Service Builder. These
  \texttt{getGuestbookEntries*} methods, however, retrieve entries from
  a specified Guestbook and Site. The first method gets a list of
  entries. The next method gets a paginated list. The third method sorts
  the paginated list, and the last method gets the total number of
  entries as an integer.
\item
  Add the \texttt{validate} method:

\begin{verbatim}
protected void validate(String name, String email, String entry)
    throws PortalException {

    if (Validator.isNull(name)) {
        throw new GuestbookEntryNameException();
    }

    if (!Validator.isEmailAddress(email)) {
        throw new GuestbookEntryEmailException();
    }

    if (Validator.isNull(entry)) {
        throw new GuestbookEntryMessageException();
    }
}
\end{verbatim}

  This method makes sure the user entered relevant data when creating an
  entry.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and select the
  following classes when prompted:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.List}
  \item
    \texttt{java.util.Date}
  \item
    \texttt{com.liferay.portal.kernel.util.Validator}
  \end{itemize}
\end{enumerate}

Nice work! These local service methods implement the services that are
referenced in the portlet class.

\section{Updating Generated Classes}\label{updating-generated-classes}

Now that you've implemented the service methods, you must make them
available to the rest of your application. To do this, run
\texttt{buildService} again:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \emph{Gradle Tasks} → \emph{guestbook-service} → \emph{build},
  right-click \texttt{buildService} and select \emph{Run Gradle Tasks}.
  In the utility classes, Service Builder populates calls to your newly
  created service methods.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Refresh}. Repeat this step for the
  \texttt{guestbook-api} module. This ensures that the changes made by
  Service Builder show up in Liferay Dev Studio DXP.
\item
  In the Project Explorer, right-click the \texttt{guestbook-service}
  module and select \emph{Gradle} → \emph{Refresh Gradle Project}.
  Repeat this step for the \texttt{guestbook-api} module. This ensures
  that your modules' Gradle dependencies are up to date.
\end{enumerate}

\noindent\hrulefill

\textbf{Tip:} If something goes awry when working with Service Builder,
repeat these steps to run Service Builder again and refresh your API and
service modules.

\noindent\hrulefill

Excellent! Your new back-end has been generated. Now it's time to create
a web application that uses it.

\chapter{Building the Web Front-End}\label{building-the-web-front-end}

You now have a back-end: you created a \texttt{service.xml} file to
define your application's data model, and generated the back-end code
(the model, service, and persistence layers) with Service Builder. You
also added service methods using the appropriate extension points: your
entities' \texttt{*LocalServiceImpl} classes. Now you can add a
front-end to match new back-end, creating a fully functional
application.

You'll create two portlets: the Guestbook portlet for users to use to
add entries and in a later step, a Guestbook Admin portlet for
administrators to add Guestbooks.

Starting with this step,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/04-web-front-end}{source
code is provided} in case you get stuck.

Ready to begin?

Let's Go!{}

\chapter{Creating the Web Project}\label{creating-the-web-project}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 1 of 11</p>
\end{verbatim}

Your first step is to create another Liferay Module Project. Modules are
the core building blocks of Liferay DXP applications. Every application
is made from one or more modules. Each module encapsulates a functional
piece of an application. Multiple modules form a complete application.

Modules can be web modules or \href{https://www.osgi.org/}{OSGi}
modules. Since you'll be creating a Liferay MVC Portlet, you'll create
an OSGI module. The OSGi container in Liferay DXP can run any OSGi
module. Each module is packaged as a JAR file that contains a manifest
file. The manifest is needed for the container to recognize the module.
Technically, a module that contains only a manifest is still valid. Of
course, such a module wouldn't be very interesting.

You already created Service Builder modules. Now you'll create your MVC
Portlet module. For the purpose of this tutorial, you'll create your
modules inside your Liferay Workspace.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay Dev Studio DXP, select \emph{File} → \emph{New} →
  \emph{Liferay Module Project}.
\item
  Complete the first screen of the wizard with the following
  information:

  \begin{figure}
  \centering
  \includegraphics{./images/new-module-project.png}
  \caption{Complete the New Module Project wizard.}
  \end{figure}

  \begin{itemize}
  \tightlist
  \item
    Enter \texttt{guestbook-web} for the Project name.
  \item
    Use the \emph{Gradle} Build type.
  \item
    The Liferay version is \emph{7.2}.
  \item
    Select \texttt{mvc-portlet} for the Project Template.
  \end{itemize}

  Click \emph{Next}.
\item
  On the second screen of the wizard, enter \texttt{Guestbook} for the
  component class name, and \texttt{com.liferay.docs.guestbook.portlet}
  for the package name. Click \emph{Finish}.
\end{enumerate}

Note that it may take a while for Dev Studio DXP to create your project,
because Gradle downloads your project's dependencies for you during
project creation. Once this is done, you have a module project named
\texttt{guestbook-web}. The \texttt{mvc-portlet} template configured the
project with the proper dependencies and generated all the files you
need to get started:

\begin{itemize}
\tightlist
\item
  The portlet class (in the package you specified)
\item
  JSP files (in \texttt{/src/main/resources})
\item
  Language properties (also in \texttt{/src/main/resources})
\end{itemize}

Your new module project is a \emph{portlet} application. You'll learn
what that is in a moment, but first there's some housekeeping to do.

In larger projects, it is important to have all of your files and
modules well organized. Since the \texttt{guestbook-web} module really
goes with your Service Builder modules, it should be in the
\texttt{guestbook} folder.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \emph{Project Explorer}, right-click on \texttt{guestbook-web}
  and select \emph{Move}.
\item
  In the window that appears, click \emph{Browse}, choose the
  \texttt{guestbook} folder and then click \emph{OK}.
\end{enumerate}

Your \texttt{guestbook-web} folder now appears in the structure with the
other modules.

\begin{figure}
\centering
\includegraphics{./images/guestbook-refactor.png}
\caption{After you move it, all of your modules are in the same
folder..}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Sometimes Eclipse refuses to move your project. If that
happens, close Eclipse, use your operating system's file manager to move
the \texttt{guestbook-web} folder into the \texttt{guestbook} folder,
and then restart Eclipse.

\noindent\hrulefill

You're now ready to begin writing your front-end, but first some
explanation is in order.

\section{What is a Portlet?}\label{what-is-a-portlet}

Web applications can be simple or complex: they might display an article
or calculate your taxes. These applications run on a \emph{platform}
that provides application developers the building blocks they need to
make applications.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{Many Liferay applications can run at the same time on the same
page.}
\end{figure}

Liferay DXP provides a platform that contains common features needed by
today's applications, including user management, security, user
interfaces, services, and more. Portlets are one of those basic building
blocks. Often a web application takes up the entire page. Portlets can
do this or share the page with many applications at the same time.
Liferay DXP's framework takes this into account at every step.

\section{What is a Component?}\label{what-is-a-component}

Liferay MVC Portlets are \emph{Components}. If a module (sometimes also
called a \emph{bundle}) encapsulates pieces of your application, a
component is the object that contains the core functionality. A
Component is managed by a component framework or container. Components
are deployed inside modules, and they're created, started, stopped, and
destroyed as needed by the container. What a perfect model for a web
application! It can be made available only when needed, and when it's
not, the container can make sure it doesn't use resources needed by
other components.

In this case, you created a Declarative Services (DS) component. With
Declarative Services, you declare that an object is a component, and you
define data about the component so the container knows how to manage it.
A default configuration was created for you; you'll examine it later.

\section{Deploying the Application}\label{deploying-the-application}

Even though all you've done is generate it, the \texttt{guestbook-web}
project is ready to be built and deployed.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure that your server is running, and if it isn't, select it in
  Dev Studio DXP's Servers pane and click the start button
  (\includegraphics{./images/icon-start-server.png}).
\item
  After it starts, drag and drop the \texttt{guestbook-web} project from
  the Project Explorer to the server.

  \begin{figure}
  \centering
  \includegraphics{./images/deploy-module.png}
  \caption{Drag and drop the module.}
  \end{figure}
\item
  Open a browser and navigate to Liferay DXP
  (\url{http://localhost:8080} by default).

  If this is your first time starting Liferay DXP, you'll go through a
  short wizard to set up your server. In this wizard, make sure you use
  the default database (Hypersonic). Although this database isn't
  intended for production use, it works fine for development and
  testing.
\item
  Click the menu button at the top left and select \emph{Site Builder} →
  \emph{Pages}.
\item
  Click the \includegraphics{./images/icon-add.png} button at the top
  right to add a Public Page.
\item
  Choose \emph{Widget Page} and name it \emph{Guestbook}.
\item
  Choose the \emph{One Column} layout and click \emph{Save}.
\item
  Click \emph{Go to Site} on the left, and then navigate to your new
  Guestbook page.
\item
  Click \emph{Add} (\includegraphics{./images/icon-add-app.png}) in the
  upper right hand corner.
\item
  Select \emph{Widgets}. In the Applications list, your application
  appears in the Sample category. Its name is \texttt{Guestbook}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/default-guestbook-application.png}
\caption{This is your new page with the Guestbook application that you
created.}
\end{figure}

Now you're ready to jump in and start developing your Guestbook portlet.

\chapter{Defining the Component Metadata
Properties}\label{defining-the-component-metadata-properties}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 2 of 11</p>
\end{verbatim}

When users add applications to a page, they pick them from a list of
\emph{display categories}.

\begin{figure}
\centering
\includegraphics{./images/display-categories.png}
\caption{Users choose applications from a list of display categories.}
\end{figure}

A portlet's display category is defined in its component class as a
metadata property. Since the Guestbook portlet lets users communicate
with each other, you'll add it to the Social category. Only one
Guestbook portlet should be added to a page, so you'll also define it as
a \emph{non-instanceable} portlet. Such a portlet can appear only once
on a page or Site, depending on its scope.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookPortlet} class and update the component
  class metadata properties to match this configuration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
      "com.liferay.portlet.display-category=category.social",
      "com.liferay.portlet.instanceable=false",
      "com.liferay.portlet.scopeable=true",
      "javax.portlet.display-name=Guestbook",
      "javax.portlet.expiration-cache=0",
      "javax.portlet.init-param.template-path=/",
      "javax.portlet.init-param.view-template=/guestbook/view.jsp",
      "javax.portlet.resource-bundle=content.Language",
      "javax.portlet.security-role-ref=power-user,user",
      "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
\end{verbatim}
\end{enumerate}

The \texttt{com.liferay.portlet.display-category=category.social}
property sets the Guestbook portlet's display category to \emph{Social}.
The \texttt{com.liferay.portlet.instanceable=false} property specifies
that the Guestbook portlet is non-instanceable, so only one instance of
the portlet can be added to a page. In the property
\texttt{javax.portlet.init-param.view-template}, you also update the
location of the main \texttt{view.jsp} to a folder in
\texttt{src/main/resources/META-INF/resources} called
\texttt{/guestbook}. You'll wind up creating two folders there for the
two different portlets you'll create: \texttt{guestbook} and
\texttt{guestbook-admin}. For now, just create the \texttt{guestbook}
folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{src/main/resources}, then open \texttt{META-INF}.
  Right-click on the \texttt{resources} folder and select \emph{New} →
  \emph{Folder}.
\item
  Name the folder \emph{guestbook} and hit \emph{Enter} (or click OK).
\item
  Drag \texttt{view.jsp} and drop it onto the \texttt{guestbook} folder
  to move it there.
\item
  Open \texttt{view.jsp} and modify the path to \texttt{init.jsp} to
  include it from the parent folder:

\begin{verbatim}
<%@ include file="../init.jsp" %>
\end{verbatim}
\end{enumerate}

Since you edited the portlet's metadata, you must remove and re-add the
portlet to the page before continuing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to \texttt{localhost:8080} in your web browser.
\item
  Sign in to your administrative account.
\item
  The Guestbook portlet now shows an error on the page. Click its
  portlet menu (at the top-right of the portlet), then select
  \emph{Remove} and click \emph{OK} to confirm.
\item
  Open the \emph{Add} menu and select \emph{Widgets}.
\item
  Open the \emph{Social} category and drag and drop the \emph{Guestbook}
  widget onto the page.
\end{enumerate}

Great! Now the Guestbook portlet appears in an appropriate category.
Though you were able to add it to the page before, the user experience
is better.

\chapter{Creating Portlet Keys}\label{creating-portlet-keys}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 3 of 11</p>
\end{verbatim}

\texttt{PortletKeys} manage important things like the portlet name or
other repeatable, commonly used variables in one place. This way, if you
must change the portlet's name, you can do it in one place and then
reference it in every class that needs it. Keys are created in a
\texttt{PortletKeys} class and then referenced in a component property.

Follow these steps to create your application's \texttt{PortletKeys}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{com.liferay.docs.guestbook.constants} package.
\item
  Open \texttt{GuestbookPortletKeys} and make sure there's a public,
  static, final String called \texttt{GUESTBOOK} with a value of
  \texttt{com\_liferay\_docs\_guestbook\_portlet\_GuestbookPortlet}:

\begin{verbatim}
public static final String GUESTBOOK =
         "com_liferay_docs_guestbook_portlet_GuestbookPortlet";
\end{verbatim}
\item
  Save the file.
\item
  In your \texttt{guestbook-web} module, open the
  \texttt{GuestbookPortlet} class and update the component class
  metadata properties by adding one new property:

\begin{verbatim}
"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK,
\end{verbatim}

  Note that you need the trailing comma if you've added the property to
  the middle of the list. If you've added it to the end of the last,
  leave it off (but add a trailing comma to the prior property!).
\item
  Save \texttt{GuestbookPortlet}.
\end{enumerate}

Nice job!

Next, you'll integrate your application with the back-end you generated
with Service Builder.

\chapter{Integrating the Back-end}\label{integrating-the-back-end}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 4 of 11</p>
\end{verbatim}

To use your Service Builder-generated back-end in your front-end, you
must tell your front-end project that the back-end exists and where to
find it.

For the web module to access the generated services, you must make it
aware of the API and service modules:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{guestbook-web}'s \texttt{build.gradle} file and add these
  dependencies:

\begin{verbatim}
compileOnly project(":modules:guestbook:guestbook-api")
compileOnly project(":modules:guestbook:guestbook-service")
\end{verbatim}
\item
  Save the file. Right-click on the \texttt{guestbook-web} project and
  select \emph{Gradle} → \emph{Refresh Gradle Project}.
\item
  Now you must add \emph{references} to the Service Builder services you
  need. To do this, add them as class variables with \texttt{@Reference}
  annotations on their setter methods. Open \texttt{GuestbookPortlet}
  and add these references to the bottom of the file:

\begin{verbatim}
@Reference
private GuestbookEntryLocalService _guestbookEntryLocalService;

@Reference
private GuestbookLocalService _guestbookLocalService;
\end{verbatim}

  Note that it's Liferay's code style to add class variables this way.
  The \texttt{@Reference} annotation causes Liferay's OSGi container to
  inject references to your generated services so you can use them.
\item
  Press Ctrl-Shift-O to add the import you need:

  \begin{itemize}
  \tightlist
  \item
    \texttt{org.osgi.service.component.annotations.Reference}
  \end{itemize}
\end{enumerate}

Now you're ready to begin building your front-end.

\chapter{Creating an Add Entry
Button}\label{creating-an-add-entry-button}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 5 of 11</p>
\end{verbatim}

A guestbook application is pretty simple, right? People come to your
site and post their names and brief messages. Others can read these
entries and post their own.

When you created your project, it generated a file named
\texttt{view.jsp}, which you've already moved to
\texttt{src/main/resources/META-INF/resources/guestbook} folder. This
file contains the default view for users when the portlet is added to
the page. Right now it contains sample content:

\begin{verbatim}
<%@ include file="../init.jsp" %>

<p>
    <b><liferay-ui:message key="guestbook-web.caption"/></b>
</p>
\end{verbatim}

First, \texttt{view.jsp} imports \texttt{init.jsp}. By Liferay
convention, we declare imports and tag library declarations in an
\texttt{init.jsp} file. The other JSP files in the application import
\texttt{init.jsp}. This reserves JSP dependency management to a single
file.

Besides importing \texttt{init.jsp}, \texttt{view.jsp} displays a
message defined by a language key. This key and its value are declared
in your project's
\texttt{src/main/resources/content/Language.properties} file.

It's time to start developing the Guestbook application. First, users
need a way to add a Guestbook entry. In \texttt{view.jsp}, follow these
steps to add this button:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove everything under the include for \texttt{init.jsp}.
\item
  Below the include, add the following
  \href{http://alloyui.com/}{AlloyUI} tags to display an Add Entry
  button inside of a button row:

\begin{verbatim}
<aui:button-row>
    <aui:button value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

You can use \texttt{aui} tags in \texttt{view.jsp} since
\texttt{init.jsp} declares the AlloyUI tag library by default (as well
as other important imports and tags):

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<portlet:defineObjects />

<liferay-theme:defineObjects />
\end{verbatim}

Your application now displays a button instead of a message, but the
button doesn't do anything. Next, you'll create a URL for your button.

\begin{figure}
\centering
\includegraphics{./images/guestbook-new-button.png}
\caption{Your new button is awesome, but it doesn't work yet.}
\end{figure}

\chapter{Generating Portlet URLs}\label{generating-portlet-urls}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 6 of 11</p>
\end{verbatim}

Since users can place multiple portlets on a single page, you have no
idea what other portlets may share a page with yours. This means that
you can't define URLs for various functions in your application like you
otherwise would.

For example, consider a Calendar application that a user puts on the
same page as a Blog application. To implement the functionality for
deleting calendar events and blog entries in the respective application,
both application developers append the \texttt{del} parameter to the URL
and give it a primary key value so the application can look up and
delete the calendar event or blog entry. Since both applications read
this parameter, their delete functionality clashes.

System-generated URLs prevent this. If the system generates a unique URL
for each piece of functionality, multiple applications can coexist in
perfect harmony.

In \texttt{view.jsp}, follow these steps to create system-generated URLs
in your portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these tags below
  \texttt{\textless{}\%@\ include\ file="../init.jsp"\ \%\textgreater{}},
  but above the \texttt{\textless{}aui:button-row\textgreater{}} tag:

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/guestbook/edit_entry.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\item
  Add this attribute to the \texttt{\textless{}aui:button\textgreater{}}
  tag, before \texttt{value="Add\ Entry"}:

\begin{verbatim}
onClick="<%= addEntryURL.toString() %>"
\end{verbatim}

  Your \texttt{view.jsp} page should now look like this:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/guestbook/edit_entry.jsp"></portlet:param>
</portlet:renderURL>

<aui:button-row>
    <aui:button onClick="<%= addEntryURL.toString() %>" value="Add Entry"></aui:button>
</aui:button-row>
\end{verbatim}
\end{enumerate}

The \texttt{\textless{}portlet:renderURL\textgreater{}} tag's
\texttt{var} attribute creates the \texttt{addEntryURL} variable to hold
the system-generated URL. The
\texttt{\textless{}portlet:param\textgreater{}} tag defines a URL
parameter to append to the URL. In this example, a URL parameter named
\texttt{mvcPath} with a value of \texttt{/edit\_entry.jsp} is appended
to the URL.

Note that your \texttt{GuestbookPortlet} class (located in your
\texttt{guestbook-web} module's
\texttt{com.liferay.docs.guestbook.portlet} package) extends Liferay's
\texttt{MVCPortlet} class. In a
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC portlet}, the \texttt{mvcPath} URL parameter indicates a page within
your portlet. To navigate to another page in your portlet, use a portal
URL with the parameter \texttt{mvcPath} to link to the specific page.

In the example above, you created a \texttt{renderURL} that points to
your application's \texttt{edit\_entry.jsp} page, which you haven't yet
created. Note that using an AlloyUI button to follow the generated URL
isn't required. You can use any HTML construct that contains a link.
Users can click your button to access your application's
\texttt{edit\_entry.jsp} page. This currently produces an error since no
\texttt{edit\_entry.jsp} exists yet. Creating \texttt{edit\_entry.jsp}
is your next step.

\chapter{Linking to Another Page}\label{linking-to-another-page}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 7 of 11</p>
\end{verbatim}

In the same folder your \texttt{view.jsp} is in, create the
\texttt{edit\_entry.jsp} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click your project's
  \texttt{src/main/resources/META-INF/resources/guestbook} folder and
  choose \emph{New} → \emph{File}.
\item
  Name the file \texttt{edit\_entry.jsp} and click \emph{Finish}.
\item
  Add this line to the top of the file:

\begin{verbatim}
<%@ include file="../init.jsp" %>
\end{verbatim}

  Remember, it's a best practice to add all JSP imports and tag library
  declarations to a single file that's imported by your application's
  other JSP files. For \texttt{edit\_entry.jsp}, you need these imports
  to access the portlet tags that create URLs and the Alloy tags that
  create the form.
\item
  Next, you need a scriptlet that helps determine the function the user
  accessed. You named this JSP \texttt{edit\_entry.jsp} because it's
  used both for adding and editing. Add this scriptlet to add logic for
  determining which function the user wants:

\begin{verbatim}
<% 

long entryId = ParamUtil.getLong(renderRequest, "entryId");

GuestbookEntry entry = null;
if (entryId > 0) {
  entry = GuestbookEntryLocalServiceUtil.getGuestbookEntry(entryId);
}

long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

%>
\end{verbatim}

  If an \texttt{entryId} greater than \texttt{0} is found in the
  request, editing a \texttt{GuestbookEntry} is assumed. Otherwise, the
  user is adding.
\item
  You'll create two URLs: one in the next step to submit the form and
  one in this step to go back to \texttt{view.jsp}. To create the URL to
  go back to \texttt{view.jsp}, add the following tag below the first
  line you added:

\begin{verbatim}
<portlet:renderURL var="viewURL">
    <portlet:param name="mvcPath" value="/guestbook/view.jsp"></portlet:param>
</portlet:renderURL>
\end{verbatim}
\end{enumerate}

Next, you must create a new URL for submitting the form. This is a
different kind of URL, for it triggers a portlet action.

\chapter{Forms and Action URLs}\label{forms-and-action-urls}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End/p><p>Step 8 of 11</p>
\end{verbatim}

Recall that portlets run in a portion of a page, and a page can contain
multiple portlets. Because of this, portlets have \emph{phases} of
operation. Here, you'll learn about the most important two. The first
phase is the one you've already used: the \emph{render} phase. All this
means is that the portlet draws itself, using the JSPs you write for it.

The other phase is called the \emph{action} phase. This phase runs once,
when a user triggers a portlet action. The portlet performs whatever
action the user triggered, such as performing a search or adding a
record to a database. Then the portlet goes back to the render phase and
re-renders itself according to its new state.

\section{Action URLs}\label{action-urls}

To save a guestbook entry, you must trigger a portlet action. For this,
you'll create an action URL.

Add the following tag in \texttt{edit\_entry.jsp} after the closing
\texttt{\textless{}/portlet:renderURL\textgreater{}} tag:

\begin{verbatim}
<portlet:actionURL name="addEntry" var="addEntryURL" />
\end{verbatim}

You now have the two required URLs for your form.

\section{Forms}\label{forms}

The form for creating guestbook entries has three fields: one for the
name of the person submitting the entry, one for the person's email
address, and one for the entry itself.

Add the following tags to the end of your \texttt{edit\_entry.jsp} file:

\begin{verbatim}
<aui:form action="<%= addEntryURL %>" name="<portlet:namespace />fm">

<aui:model-context bean="<%= entry %>" model="<%= GuestbookEntry.class %>" />

    <aui:fieldset>

        <aui:input name="name" />
        <aui:input name="email" />
        <aui:input name="message" />
        <aui:input name="entryId" type="hidden" />
        <aui:input name="guestbookId" type="hidden" value='<%= entry == null ? guestbookId : entry.getGuestbookId() %>'/>

    </aui:fieldset>

    <aui:button-row>

        <aui:button type="submit"></aui:button>
        <aui:button type="cancel" onClick="<%= viewURL.toString() %>"></aui:button>

    </aui:button-row>
</aui:form>
\end{verbatim}

Liferay uses its Alloy UI tag library to create forms.

Save \texttt{edit\_entry.jsp} and redeploy your application. If you
refresh the page and click the \emph{Add Entry} button, your form
appears. If you click the \emph{Cancel} button, you go back to
\texttt{view.jsp}, but don't try the \emph{Save} button yet. You haven't
yet created the action that saves a guestbook entry, so clicking
\emph{Save} produces an error.

\begin{figure}
\centering
\includegraphics{./images/first-guestbook-portlet-edit-entry.png}
\caption{This is the Guestbook application's form for adding entries.}
\end{figure}

Implementing portlet actions (what happens when the user clicks
\emph{Save} or \emph{Delete}) is your next task.

\chapter{Implementing Portlet
Actions}\label{implementing-portlet-actions}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 9 of 11</p>
\end{verbatim}

When users submit the form, your application stores the form data for
display in the guestbook. This is where you call the back-end you
generated to store the data for later retrieval in the database.

To make your portlet do anything other than re-render itself, you must
implement portlet actions. An action defines some processing, usually
based on user input, that the portlet must perform before it renders
itself. In the case of the guestbook portlet, the action you'll
implement next saves a guestbook entry that a user typed into the form.
Saved guestbook entries can be retrieved and displayed later.

Since you're using Liferay's MVC Portlet framework, you have an easy way
to implement actions. Portlet actions are implemented in the portlet
class, which is the controller. In the form you just created, you made
an action URL, and you called it \texttt{addEntry}. To create a portlet
action, you create a method in the portlet class with the same name.
\texttt{MVCPortlet} calls that method when a user triggers its matching
URL.

\section{Creating an Add Entry
Action}\label{creating-an-add-entry-action}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookPortlet}.
\item
  Create a method with the following signature:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response) {

}
\end{verbatim}
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and import the
  required \texttt{javax.portlet.ActionRequest} and
  \texttt{javax.portlet.ActionResponse} classes.
\end{enumerate}

You've now created a portlet action. It doesn't do anything, but at
least you won't get an error now if you submit your form. Next, you
should make the action save the form data.

The following method implements adding a guestbook entry using the
back-end you generated with Service Builder:

\begin{verbatim}
public void addEntry(ActionRequest request, ActionResponse response)
            throws PortalException {

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            GuestbookEntry.class.getName(), request);

        String userName = ParamUtil.getString(request, "name");
        String email = ParamUtil.getString(request, "email");
        String message = ParamUtil.getString(request, "message");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");
        long entryId = ParamUtil.getLong(request, "entryId");

    if (entryId > 0) {

        try {

            _guestbookEntryLocalService.updateGuestbookEntry(
                serviceContext.getUserId(), guestbookId, entryId, userName,
                email, message, serviceContext);

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            System.out.println(e);

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbook/edit_entry.jsp");
        }

    }
    else {

        try {
            _guestbookEntryLocalService.addGuestbookEntry(
                serviceContext.getUserId(), guestbookId, userName, email,
                message, serviceContext);

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

        }
        catch (Exception e) {
            System.out.println(e);

            PortalUtil.copyRequestParameters(request, response);

            response.setRenderParameter(
                "mvcPath", "/guestbook/edit_entry.jsp");
        }
    }
}
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace your existing \texttt{addEntry} method with the above method.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports.
\end{enumerate}

This \texttt{addEntry} method gets the name, message, and email fields
that the user submits in the JSP and passes them to the service to be
stored as entry data. It also gets a
\href{/docs/7-2/frameworks/-/knowledge_base/f/understanding-servicecontext}{\texttt{ServiceContext}}
so information about the request's current context can be retrieved,
such as the ID of the current user. The \texttt{if-else} logic checks
whether there's an existing \texttt{entryId}. If there is, the
\texttt{update} service method is called, and if not, the \texttt{add}
service method is called. In both cases, it sets a render parameter with
the Guestbook ID so the application can display the guestbook's entries
after this one has been added. This is all done in \texttt{try...catch}
statements. Note the setting of the \texttt{mvcPath} render parameter to
direct processing to the proper JSP based on what happens.

\section{Creating a Delete Entry
Action}\label{creating-a-delete-entry-action}

Next, create an action that deletes an entry:

\begin{verbatim}
public void deleteEntry(ActionRequest request, ActionResponse response) throws PortalException {
        long entryId = ParamUtil.getLong(request, "entryId");
        long guestbookId = ParamUtil.getLong(request, "guestbookId");

        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            GuestbookEntry.class.getName(), request);

        try {

            response.setRenderParameter(
                "guestbookId", Long.toString(guestbookId));

            _guestbookEntryLocalService.deleteGuestbookEntry(entryId);
        }

        catch (Exception e) {
            Logger.getLogger(GuestbookPortlet.class.getName()).log(
                Level.SEVERE, null, e);
        }
}
\end{verbatim}

This action accepts an \texttt{entryId} from the request and calls the
service to delete it.

But there's something missing, isn't there? These methods expect a
\texttt{guestbookId} to be in the request, so the
\texttt{GuestbookEntry} can be connected to its \texttt{Guestbook}.
You'll create that next, as well as a mechanism for viewing guestbook
entries.

\chapter{Displaying Guestbook
Entries}\label{displaying-guestbook-entries}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 10 of 11</p>
\end{verbatim}

To display guestbook entries, you must do the reverse of what you did to
store them: retrieve them the database, loop through them, and present
them on the page. To do this, you must override the default MVC Portlet
\texttt{render} method so you can tell your portlet how to render
itself.

\section{Rendering the Portlet}\label{rendering-the-portlet}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following \texttt{render} method to \texttt{GuestbookPortlet}:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest, RenderResponse renderResponse)
    throws IOException, PortletException {

    try {
        ServiceContext serviceContext = ServiceContextFactory.getInstance(
            Guestbook.class.getName(), renderRequest);

        long groupId = serviceContext.getScopeGroupId();

        long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

        List<Guestbook> guestbooks = _guestbookLocalService.getGuestbooks(
            groupId);

        if (guestbooks.isEmpty()) {
            Guestbook guestbook = _guestbookLocalService.addGuestbook(
                serviceContext.getUserId(), "Main", serviceContext);

            guestbookId = guestbook.getGuestbookId();
        }

        if (guestbookId == 0) {
            guestbookId = guestbooks.get(0).getGuestbookId();
        }

        renderRequest.setAttribute("guestbookId", guestbookId);
    }
    catch (Exception e) {
        throw new PortletException(e);
    }

    super.render(renderRequest, renderResponse);
}
\end{verbatim}

  This \texttt{render} method checks for guestbooks in the current Site.
  If there aren't any, it creates one. The \texttt{guestbookId} that it
  has (either the first one or one that has been selected in
  functionality you haven't written yet) is set in the request object so
  that it becomes the current guestbook.
\item
  Press {[}CTRL{]}+{[}SHIFT{]}+O to organize imports and then save the
  file.
\end{enumerate}

\noindent\hrulefill

Note: When you are prompted to choose imports, here are some guidelines:

\begin{itemize}
\item
  Always use \texttt{org.osgi...} packages instead of
  \texttt{aQute.bnd...}
\item
  Generally use \texttt{java.util...} or \texttt{javax.portlet...}
  packages.
\item
  You never use \texttt{java.awt...} in this project.
\item
  Only use \texttt{com.liferay...} when it is for a Liferay specific
  implementation or your custom implementation of a concept.
\end{itemize}

For example:

\begin{itemize}
\item
  If you are given the choice between \texttt{javax.portlet.Portlet} and
  \texttt{com.liferay.portlet.Portlet} choose
  \texttt{javax.portlet.Portlet}.
\item
  If you are given the choice between \texttt{org.osgi.component} and
  \texttt{aQute.bnd.annotation.component} choose
  \texttt{org.osgi.component}
\end{itemize}

If at some point you think you chose an incorrect import, but you're not
sure what it might be, you can erase all of the imports from the file
and press {[}CTRL{]}+{[}SHIFT{]}+O again and see if you can identify
where you went wrong.

\noindent\hrulefill

Now that you have your controller preparing your data for display, your
next step is to implement the view so users can see guestbook entries.

\section{Displaying Guestbook
Entries}\label{displaying-guestbook-entries-1}

Liferay's development framework makes it easy to loop through data and
display it nicely to the end user. You'll use a Liferay UI construct
called \emph{Search Container} to make this happen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace the contents of \texttt{view.jsp} with this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
long guestbookId = Long.valueOf((Long) renderRequest
        .getAttribute("guestbookId"));
%>

<aui:button-row cssClass="guestbook-buttons">

    <portlet:renderURL var="addEntryURL">
        <portlet:param name="mvcPath" value="/guestbook/edit_entry.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbookId)%>" />
    </portlet:renderURL>

    <aui:button onClick="<%=addEntryURL.toString()%>" value="Add Entry"></aui:button>

</aui:button-row>

<liferay-ui:search-container total="<%=GuestbookEntryLocalServiceUtil.getGuestbookEntriesCount()%>">
<liferay-ui:search-container-results
    results="<%=GuestbookEntryLocalServiceUtil.getGuestbookEntries(scopeGroupId.longValue(),
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />

<liferay-ui:search-container-row
    className="com.liferay.docs.guestbook.model.GuestbookEntry" modelVar="entry">

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

    <liferay-ui:search-container-column-jsp
        align="right"
        path="/guestbook/entry_actions.jsp" />

</liferay-ui:search-container-row>

<liferay-ui:search-iterator />

</liferay-ui:search-container>
\end{verbatim}
\item
  You've used a lot of new objects in this JSP, so you must declare them
  in \texttt{init.jsp}. Replace the contents of \texttt{init.jsp} with
  this:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet"%>
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui"%>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet"%>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme"%>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui"%>
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
<%@ taglib uri="http://liferay.com/tld/security" prefix="liferay-security" %>

<%@ page import="java.util.List" %>
<%@ page import="com.liferay.portal.kernel.util.ParamUtil" %>
<%@ page import="com.liferay.portal.kernel.util.HtmlUtil" %>
<%@ page import="com.liferay.portal.kernel.util.WebKeys" %>
<%@ page import="com.liferay.petra.string.StringPool" %>
<%@ page import="com.liferay.portal.kernel.model.PersistedModel" %>
<%@ page import="com.liferay.portal.kernel.dao.search.SearchEntry" %>
<%@ page import="com.liferay.portal.kernel.dao.search.ResultRow" %>
<%@ page import="com.liferay.docs.guestbook.model.Guestbook" %>
<%@ page import="com.liferay.docs.guestbook.service.GuestbookEntryLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.service.GuestbookLocalServiceUtil" %>
<%@ page import="com.liferay.docs.guestbook.model.GuestbookEntry" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}
\end{enumerate}

Many of these objects, such as \texttt{HtmlUtil}, \texttt{ParamUtil},
and \texttt{StringPool}, are Liferay helper utilities that enable you
with a single line of code do things like extract parameters, escape
data, or provide \texttt{String}s that otherwise have to be escaped.

Save your work.

\section{Creating an Actions JSP}\label{creating-an-actions-jsp}

Actions can be performed on your entities once they're stored. Users who
enter Guestbook entries may wish to edit them or delete them. Now you'll
provide that functionality.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click on the
  \texttt{src/main/resources/META-INF/resources/guestbook} folder and
  select \emph{New} → \emph{File}.
\item
  Name the file \texttt{entry\_actions.jsp}.
\item
  Paste the following code into the file:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
String mvcPath = ParamUtil.getString(request, "mvcPath");

ResultRow row = (ResultRow)request.getAttribute(WebKeys.SEARCH_CONTAINER_RESULT_ROW);

GuestbookEntry entry = (GuestbookEntry)row.getObject();
%>

<liferay-ui:icon-menu>

        <portlet:renderURL var="editURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="mvcPath" value="/guestbook/edit_entry.jsp" />
        </portlet:renderURL>

        <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />

        <portlet:actionURL name="deleteEntry" var="deleteURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(entry.getGuestbookId()) %>" />
        </portlet:actionURL>

        <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />

</liferay-ui:icon-menu>
\end{verbatim}
\end{enumerate}

You may have noticed this JSP was included in the Search Container rows
in your \texttt{view.jsp}. As the Search Container loops through
Guestbook entries, this JSP generates an Actions button for each of them
containing two functions: a call to your \texttt{addEntry} method (which
both adds and edits) and a call to your \texttt{deleteEntry} method.
Both calls supply the current \texttt{guestbookId} and \texttt{entryId}
parameters so the Action method has everything it needs to call the
service method that does the work.

Awesome! You've now completed the first iteration of your Guestbook
application.

\begin{figure}
\centering
\includegraphics{./images/guestbook-prototype-form.png}
\caption{You have a form to enter information.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/guestbook-prototype-container.png}
\caption{Submitted entries are displayed here.}
\end{figure}

Next you'll review what's been done so far, and you'll deploy and test
your application.

\chapter{Fitting it All Together}\label{fitting-it-all-together}

\begin{verbatim}
<p id="stepTitle">Building the Web Front-End</p><p>Step 11 of 11</p>
\end{verbatim}

You've created a complete data-driven application from the back-end to
the display. It's a great time to review how everything connects
together.

\section{The Back-End}\label{the-back-end}

The first thing you did was generate back-end services for your
application using Liferay's object-relational mapper, Service Builder.

\begin{figure}
\centering
\includegraphics{./images/service-builder-guestbook.png}
\caption{Service Builder makes generating your database entities and
your Java objects a snap.}
\end{figure}

Using a single \texttt{service.xml} file, you generated your object
model, SQL to create your tables, a persistence layer to perform all
CRUD operations on your data, and a service layer for your business
logic. Then you added business logic to your service layer to expose the
persistence layer's functionality according to your business rules.

With all of that ready, it was time to build a front-end client.

\section{The Front-End}\label{the-front-end}

Once you completed your back-end, you decided to develop a web front-end
using Liferay's MVC Portlet framework. You generated a Liferay MVC
Portlet project and used its Model View Controller development paradigm
to implement a user interface for your back-end functionality.

\begin{figure}
\centering
\includegraphics{./images/guestbook-mvc-diagram-1.png}
\caption{The controller directs page flow in an MVC Portlet
application.}
\end{figure}

First, you created a default view in \texttt{view.jsp}. You created a
button there that links to \texttt{edit\_entry.jsp}, which is used for
both adding and editing Guestbook entries (though you haven't
implemented editing yet). Here, you created a form to capture
information from Users adding Guestbook entries. The form's Action URL
directs processing to your controller's portlet action of the same name.
This action extracts the data from the form (in the
\texttt{ActionRequest} object) and passes it to the business logic you
created in your service layer.

After the business logic runs, your controller passes processing back to
\texttt{view.jsp}, where the new Guestbook entry is displayed.

Now that you've built the application and you can see a clear picture of
how it all works, it's time to test it.

\section{Deploying and Testing the
Application}\label{deploying-and-testing-the-application}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Drag and drop the \texttt{guestbook-api} module onto the server.
\item
  Drag and drop the \texttt{guestbook-service} module onto the server.
\item
  Look for the STARTED messages from the console.
\item
  Go to your Liferay DXP instance at \texttt{localhost:8080} in your
  browser to test your updated application.
\item
  Like you did before, use your administrative account to remove the
  Guestbook from the page and add it again.
\item
  Click \emph{Add Entry}.
\item
  Enter a \emph{Name}, \emph{Message}, and \emph{Email Address}.
\item
  Click \emph{Submit}.
\item
  Verify that your entry appears.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/guestbook-entry-test.png}
\caption{Your first guestbook and entry appears. Nice job!}
\end{figure}

\section{What's Next?}\label{whats-next}

You've created a working web application and deployed it on Liferay DXP.
If you've created web applications before, though, you know that it's
missing some important features: security, front-end validation, and an
interface for administrators to create multiple guestbooks per portlet.
In the next section, you'll begin adding these features.

\chapter{Writing an Administrative
Portlet}\label{writing-an-administrative-portlet}

The Guestbook application lets users add and view guestbook entries. The
application's back-end, however, is much more powerful. It can support
many guestbooks and their associated entries. But at this point, there's
no UI to support these added features. When you create this UI, you must
also make sure that only administrators can add guestbooks.

To accomplish this, you'll create a Guestbook Admin portlet and place it
in Liferay DXP's administrative interface---specifically, within the
Content menu. This way, the Guestbook Admin portlet is accessible only
to Site Administrators, while users use the Guestbook portlet to create
entries.

In short, this is a simple application with a simple interface:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet lets administrators manage
Guestbooks.}
\end{figure}

If you get stuck,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/05-admin-portlet}{source
code} for this step is provided.

Are you ready to begin?

Let's Go!{}

\chapter{Creating the Classes}\label{creating-the-classes}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 1 of 6</p>
\end{verbatim}

Because the Guestbook and Guestbook Admin applications should be bundled
together, you'll create the new application inside the
\texttt{guestbook-web} project. If you disagree with this design
decision, you can create a separate project for Guestbook Admin; the
project template you'd use is \emph{panel-app}. For now, however, it's
better to go through the process manually to learn how it all works:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{com.liferay.docs.guestbook.portlet} package in
  the \texttt{guestbook-web} project and select \emph{New} →
  \emph{Class}.
\item
  Name the class \texttt{GuestbookAdminPortlet}.
\item
  Click \emph{Browse} next to the Superclass and search for
  \texttt{MVCPortlet}. Click it and select \emph{OK}.
\item
  Click \emph{Finish}.
\end{enumerate}

You now have your Guestbook Admin application's portlet class. For an
administrative application, however, you need at least one more
component.

\section{Panels and Categories}\label{panels-and-categories}

As described in the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{product
menu tutorial}, there are three sections of the product menu as
illustrated below.

\begin{figure}
\centering
\includegraphics{./images/product-menu-parts.png}
\caption{The product menu is split into three sections: the Control
Panel, the User menu, and the Sites menu.}
\end{figure}

Each section is called a \emph{panel category}. A panel category can
hold various menu items called \emph{panel apps}. In the illustration
above, the Sites menu is open to reveal its panel apps and categories
(yes, you can nest them).

The most natural place for the Guestbook Admin portlet is in the
\emph{Content \& Data} panel category with Liferay DXP's other
content-based apps. This integrates it nicely in the spot where Site
administrators expect it to be. This also means you don't have to create
a new category for it: you can just create the panel entry, which is
what you'll do next. If you'd like to learn more about panel categories
and apps after this, see the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{product
menu tutorial} and the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-control-menu}{control
menu tutorial}.

Follow these steps to create the panel entry for the Guestbook Admin
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the dependency you need to extend Liferay DXP's panel categories
  and apps. To do this, open \texttt{guestbook-web}'s
  \texttt{build.gradle} file and add these dependencies:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.application.list.api"
compileOnly group: "com.liferay", name: "com.liferay.petra.string"
\end{verbatim}
\item
  After saving the file, right-click \texttt{guestbook-web} and select
  \emph{Gradle} → \emph{Refresh Gradle Project}.
\item
  Right-click \texttt{src/main/java} in the \texttt{guestbook-web}
  project and select \emph{New} → \emph{Package}. Name the package
  \texttt{com.liferay.docs.guestbook.application.list} and click
  \emph{Finish}.
\item
  Right-click your new package and select \emph{New} → \emph{Class}.
  Name the class \texttt{GuestbookAdminPanelApp}.
\item
  Click \emph{Browse} next to Superclass, search for
  \texttt{BasePanelApp}, select it, and click \emph{OK}. Then click
  \emph{Finish}.
\end{enumerate}

Great! You've created the classes you need, and you're ready to begin
working on them.

\chapter{Adding Metadata}\label{adding-metadata}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 2 of 6</p>
\end{verbatim}

Now that you've generated the classes, you must turn them into OSGi
components. Remember that because components are container-managed
objects, you must provide metadata that tells Liferay DXP's OSGi
container how to manage their life cycles.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following portlet key to the \texttt{GuestbookPortletKeys}
  class (it's in the \texttt{com.liferay.docs.guestbook.constants}
  package):

\begin{verbatim}
public static final String GUESTBOOK_ADMIN =
  "com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet";
\end{verbatim}

  Save the file.
\item
  Open the \texttt{GuestbookAdminPortlet} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
            "com.liferay.portlet.display-category=category.hidden",
            "com.liferay.portlet.scopeable=true",
            "javax.portlet.display-name=Guestbooks",
            "javax.portlet.expiration-cache=0",
            "javax.portlet.init-param.portlet-title-based-navigation=true",
            "javax.portlet.init-param.template-path=/",
            "javax.portlet.init-param.view-template=/guestbook_admin/view.jsp",
            "javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN,
            "javax.portlet.resource-bundle=content.Language",
            "javax.portlet.security-role-ref=administrator",
            "javax.portlet.supports.mime-type=text/html",
            "com.liferay.portlet.add-default-resource=true"
    },
    service = Portlet.class
)
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to add the \texttt{javax.portlet.Portlet}
  and other imports.
\end{enumerate}

There are only a few new things here. Note the value of the
\texttt{javax.portlet.display-name} property: \texttt{Guestbooks}. This
is the name that appears in the Site menu. Also note the value of the
\texttt{javax.portlet.name} property:
\texttt{+\ GuestbookPortletKeys.GUESTBOOK\_ADMIN}. This specifies the
portlet's title via the \texttt{GUESTBOOK\_ADMIN} portlet key that you
just created.

Pay special attention to the following metadata property:

\begin{verbatim}
com.liferay.portlet.display-category=category.hidden
\end{verbatim}

This is the same property you used before with the Guestbook portlet.
You placed that portlet in the Social category. The value
\texttt{category.hidden} specifies a special category that doesn't
appear anywhere. The Guestbook Admin portlet goes here because you don't
want users adding it to a page. This prevents them from doing that.

Next, you can configure the Panel app class. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{GuestbookAdminPanelApp} class and add the
  \texttt{@Component} annotation immediately above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=300",
        "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
    },
    service = PanelApp.class
)
\end{verbatim}

  The \texttt{panel.category.key} metadata property determines where to
  place the Guestbook Admin portlet in the Product Menu. Remember that
  the Product Menu is divided into three main sections: the Control
  Panel, the User Menu, and the Site Administration area. The value of
  the \texttt{panel.category.key} property is
  \texttt{PanelCategoryKeys.SITE\_ADMINISTRATION\_CONTENT}, which means
  Guestbook Admin is in \emph{Site Builder} → \emph{Content \& Data}.
  The key is provided by
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/application-list/application-list-api/src/main/java/com/liferay/application/list/constants/PanelCategoryKeys.java}{the
  \texttt{PanelCategoryKeys} class}. The \texttt{panel.app.order} value
  determines the rank for the Guestbook Admin portlet in the list.
\item
  Finally, update the class to use the proper name and portlet keys:

\begin{verbatim}
public class GuestbookAdminPanelApp extends BasePanelApp {

    @Override
    public String getPortletId() {
        return GuestbookPortletKeys.GUESTBOOK_ADMIN;
    }

    @Override
    @Reference(
        target = "(javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK_ADMIN + ")",
        unbind = "-"
    )
    public void setPortlet(Portlet portlet) {
        super.setPortlet(portlet);
    }

}
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. This time, import
  \texttt{com.liferay.portal.kernel.model.Portlet} instead of
  \texttt{javax.portlet.Portlet}.
\end{enumerate}

Now that the configuration is out of the way, you're free to implement
the app's functionality: adding, editing, and deleting Guestbooks.
That's the next step.

\chapter{Updating Your Service Layer}\label{updating-your-service-layer}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 3 of 6</p>
\end{verbatim}

Earlier, you wrote an \texttt{addGuestbook} service method in
\texttt{GuestbookLocalServiceImpl} and only used it to add a default
guestbook. To have full functionality over guestbooks, you must also add
methods for updating and deleting guestbooks, as well as for returning
the number of guestbooks in a Site.

\section{Adding Guestbook Service
Methods}\label{adding-guestbook-service-methods}

Remember that when working with Service Builder, you define your service
in the \texttt{*Impl} classes. After you add, remove, or change the
signature of a method in an \texttt{*Impl} class, you must run Service
Builder. Service Builder updates the affected interfaces and any other
generated code.

Follow these steps to add the required guestbook service methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \texttt{guestbook-service} project and open
  \texttt{GuestbookLocalServiceImpl.java} in the
  \texttt{com.liferay.docs.guestbook.service.impl} package. Add the
  following method for updating a guestbook:

\begin{verbatim}
public Guestbook updateGuestbook(long userId, long guestbookId,
    String name, ServiceContext serviceContext) throws PortalException,
                SystemException {

        Date now = new Date();

        validate(name);

        Guestbook guestbook = getGuestbook(guestbookId);

        User user = userLocalService.getUser(userId);

        guestbook.setUserId(userId);
        guestbook.setUserName(user.getFullName());
        guestbook.setModifiedDate(serviceContext.getModifiedDate(now));
        guestbook.setName(name);
        guestbook.setExpandoBridgeAttributes(serviceContext);

        guestbookPersistence.update(guestbook);

        return guestbook;
}
\end{verbatim}

  The \texttt{updateGuestbook} method retrieves the \texttt{Guestbook}
  by its ID, replaces its data with what the user entered, and then
  calls the persistence layer to save it back to the database.
\item
  Next, add the following method for deleting a guestbook:

\begin{verbatim}
public Guestbook deleteGuestbook(long guestbookId,
                ServiceContext serviceContext) throws PortalException,
                SystemException {

        Guestbook guestbook = getGuestbook(guestbookId);

        List<GuestbookEntry> entries = _guestbookEntryLocalService.getGuestbookEntries(
                        serviceContext.getScopeGroupId(), guestbookId);

        for (GuestbookEntry entry : entries) {
                _guestbookEntryLocalService.deleteGuestbookEntry(entry.getEntryId());
        }

        guestbook = deleteGuestbook(guestbook);

        return guestbook;
}
\end{verbatim}

  It's important to consider what should happen if you delete a
  guestbook that has existing entries. If you only deleted the
  guestbook, the guestbook's orphaned entries would still exist in the
  database. Your \texttt{deleteGuestbook} service method makes a service
  call to delete a guestbook's entries before deleting that guestbook.
  This way, guestbook entries are never orphaned.
\item
  Add a reference to the \texttt{GuestbookEntry} local service, so it
  can be injected and used by the \texttt{deleteGuestbook} method:

\begin{verbatim}
@Reference
private GuestbookEntryLocalService _guestbookEntryLocalService;
\end{verbatim}

  By convention, Liferay adds these to the bottom of the class.
\item
  Use {[}CTRL{]}+{[}SHIFT{]}+O to update your imports, choosing
  \texttt{com.liferay.portal.kernel.exception.SystemException}, and then
  save \texttt{GuestbookLocalServiceImpl.java}.
\item
  In the Gradle Tasks pane on the right side in Liferay Dev Studio DXP,
  run Service Builder by opening the \texttt{guestbook-service} module
  and double-clicking \texttt{buildService}.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} If you prefer, you can use
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} to
run your Gradle tasks. If you have Blade CLI installed, go to the
\texttt{guestbook-service} folder on your CLI and enter the command
\texttt{blade\ gw\ \ buildService}. This runs Service Builder to build
your services outside of Eclipse.

\noindent\hrulefill

Now that you've finished updating the service layer, it's time to work
on the Guestbook Admin portlet itself.

\chapter{Defining Portlet Actions}\label{defining-portlet-actions}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 4 of 6</p>
\end{verbatim}

The Guestbook Admin portlet now needs action methods for adding,
updating, and deleting guestbooks. As with the Guestbook portlet, action
methods call the corresponding service methods. Note that since your
services all run in the same container, any application can call the
Guestbook services. This is an advantage of Liferay DXP's OSGi-based
architecture: different applications or modules can call services
published by other modules. If a service is published, it can be used
via \texttt{@Reference}. You'll take advantage of this here in the
Guestbook Admin portlet to consume one of the same services consumed by
the Guestbook portlet (the \texttt{addGuestbook} service).

\section{Adding Three Portlet
Actions}\label{adding-three-portlet-actions}

The Guestbook Admin portlet must let administrators add, update, and
delete \texttt{Guestbook} objects. You'll create portlet actions to meet
these requirements. Open \texttt{GuestbookAdminPortlet.java} and follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following action method and instance variables needed for
  adding a new guestbook:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookLocalService.addGuestbook(
            serviceContext.getUserId(), name, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbook_admin/edit_guestbook.jsp");
    }
}

@Reference
private GuestbookLocalService _guestbookLocalService;
\end{verbatim}

  Since \texttt{addGuestbook} is a portlet action method, it takes
  \texttt{ActionRequest} and \texttt{ActionResponse} parameters. To make
  the service call to add a new guestbook, the guestbook's name must be
  retrieved from the request. The \texttt{serviceContext} must also be
  retrieved from the request and passed as an argument in the service
  call. If an exception is thrown, you should display the Add Guestbook
  form and not the default view. That's why you add this line in the
  \texttt{catch} block:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbook_admin/edit_guestbook.jsp");
\end{verbatim}

  Later, you'll use this for field validation and to show error messages
  to the user. Note that \texttt{/guestbook\_admin/edit\_guestbook.jsp}
  doesn't exist yet; you'll create it in the next step.
\item
  Add the following action method for updating an existing guestbook:

\begin{verbatim}
public void updateGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");
    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.updateGuestbook(
            serviceContext.getUserId(), guestbookId, name, serviceContext);

    } catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);

        response.setRenderParameter(
            "mvcPath", "/guestbook_admin/edit_guestbook.jsp");
    }
}
\end{verbatim}

  This method retrieves the guestbook name, ID, and the
  \texttt{serviceContext} from the request. The \texttt{updateGuestbook}
  service call uses the guestbook's ID to identify the guestbook to
  update. If there's a problem with the service call, the Guestbook
  Admin portlet displays the Edit Guestbook form again so that the user
  can edit the form and resubmit:

\begin{verbatim}
response.setRenderParameter("mvcPath",
        "/guestbook_admin/edit_guestbook.jsp");
\end{verbatim}

  Note that the Edit Guestbook form uses the same JSP as the Add
  Guestbook form to avoid duplication of code.
\item
  Add the following action method for deleting a guestbook:

\begin{verbatim}
public void deleteGuestbook(ActionRequest request, ActionResponse response)
    throws PortalException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    long guestbookId = ParamUtil.getLong(request, "guestbookId");

    try {
        _guestbookLocalService.deleteGuestbook(guestbookId, serviceContext);
    }
    catch (PortalException pe) {

        Logger.getLogger(GuestbookAdminPortlet.class.getName()).log(
            Level.SEVERE, null, pe);
    }
}
\end{verbatim}

  This method uses the service layer to delete the guestbook by its ID.
  Since the \texttt{deleteGuestbook} action is invoked from the
  Guestbook Admin portlet's default view, there's no need to set the
  \texttt{mvcPath} render parameter to point to a particular JSP if
  there was a problem with the \texttt{deleteGuestbook} service call.
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize imports. Import the logging
  classes from \texttt{java.util}. Save the file.
\end{enumerate}

You now have your service methods and portlet action methods in place.
Before you implement the Guestbook Admin portlet's user interface, you
should update the Guestbook portlet so it can show users all the
Guestbooks your administrators add.

\chapter{Adding Tabs to the Guestbook
Portlet}\label{adding-tabs-to-the-guestbook-portlet}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 5 of 6</p>
\end{verbatim}

Before you finish the Guestbook Admin portlet, you must prepare the
Guestbook portlet's UI to display multiple Guestbooks. As administrators
add Guestbooks using the Guestbook Admin portlet, users must be able to
choose which Guestbook they want to sign. They'll do this using a series
of tabs across the top:

\begin{figure}
\centering
\includegraphics{./images/guestbook-tabs.png}
\caption{Users can click a tab to choose which Guestbook to sign.}
\end{figure}

This is surprisingly easy to do using Liferay's Alloy UI tag library:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{view.jsp} from the
  \texttt{src/main/resources/META-INF/resources/guestbook} folder.
\item
  After the first Java snippet (the one that gets the
  \texttt{guestbookId} out of the request), add this code:

\begin{verbatim}

<aui:nav cssClass="nav-tabs">

    <%
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

            for (int i = 0; i < guestbooks.size(); i++) {

                Guestbook curGuestbook = (Guestbook) guestbooks.get(i);
                String cssClass = StringPool.BLANK;

                if (curGuestbook.getGuestbookId() == guestbookId) {
                    cssClass = "active";
                }

    %>

    <portlet:renderURL var="viewPageURL">
        <portlet:param name="mvcPath" value="/guestbook/view.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(curGuestbook.getGuestbookId())%>" />
    </portlet:renderURL>


    <aui:nav-item cssClass="<%=cssClass%>" href="<%=viewPageURL%>"
        label="<%=HtmlUtil.escape(curGuestbook.getName())%>" />

    <%  
                }

    %>

</aui:nav>
\end{verbatim}
\item
  Save the file.
\end{enumerate}

This code declares the AUI navigation tabs. Then a code scriptlet gets
all the Guestbooks in this scope and loops through each one. As it
examines them, it checks to see if the one it's examining is the current
Guestbook. If so, a CSS style called \texttt{active} is applied.

After this, a new URL called \texttt{viewPageURL} is created that points
to \texttt{view.jsp} with a \texttt{guestbookId} parameter containing
the current Guestbook in the loop. Finally, an
\texttt{\textless{}aui:nav-item\textgreater{}} tag declares the markup
for the tab, using the CSS class, the URL containing the parameters to
navigate to the new Guestbook, and the name to label it.

The loop continues until all the retrieved Guestbooks have tabs.

Awesome! You've updated the Guestbook portlet so it can display all the
Guestbooks administrators add. Now it's time to provide a UI for your
Guestbook Admin portlet so they can do just that.

\chapter{Creating a User Interface}\label{creating-a-user-interface}

\begin{verbatim}
<p id="stepTitle">Writing the Guestbook Admin App</p><p>Step 6 of 6</p>
\end{verbatim}

It's time to create the Guestbook Admin portlet's user interface. The
portlet's default view has a button for adding new guestbooks. It must
also display the guestbooks that already exist.

Each guestbook's name appears next to an Actions button. The Actions
button reveals options for editing the guestbook, configuring its
permissions, or deleting it.

\section{Step 1: Creating the Default
View}\label{step-1-creating-the-default-view}

The Guestbook Admin portlet's user interface is made up of three JSPs:
the default view, the Actions button, and the form for adding or editing
a guestbook.

Create the default view first:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{src/main/resources/META-INF/resources}, create a folder
  called \texttt{guestbook\_admin}, where you'll create your JSPs.
\item
  Create a file in this folder called \texttt{view.jsp} and fill it with
  this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<liferay-ui:search-container
    total="<%= GuestbookLocalServiceUtil.getGuestbooksCount(scopeGroupId) %>">
    <liferay-ui:search-container-results
        results="<%= GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId, 
            searchContainer.getStart(), searchContainer.getEnd()) %>" />

    <liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.Guestbook" modelVar="guestbook">

        <liferay-ui:search-container-column-text property="name" />

        <liferay-ui:search-container-column-jsp
            align="right" 
            path="/guestbook_admin/guestbook_actions.jsp" />

    </liferay-ui:search-container-row>

    <liferay-ui:search-iterator />
</liferay-ui:search-container>

<aui:button-row cssClass="guestbook-admin-buttons">
    <portlet:renderURL var="addGuestbookURL">
        <portlet:param name="mvcPath"
            value="/guestbook_admin/edit_guestbook.jsp" />
        <portlet:param name="redirect" value="<%= "currentURL" %>" />
    </portlet:renderURL>

    <aui:button onClick="<%= addGuestbookURL.toString() %>"
        value="Add Guestbook" />
</aui:button-row>
\end{verbatim}
\end{enumerate}

First is the \texttt{init.jsp} include to gain access to the imports.

Next is a button row with a single button for adding new guestbooks:
\texttt{\textless{}aui:button-row\ cssClass="guestbook-admin-buttons"\textgreater{}}.
The \texttt{cssClass} attribute specifies a custom CSS class for
additional styling. The
\texttt{\textless{}portlet:renderURL\textgreater{}} tag constructs a URL
that points to the \texttt{edit\_guestbook.jsp}. You haven't created
this JSP yet, but you'll use it for adding a new guestbook and editing
an existing one.

Finally, a Liferay search container displays the list of guestbooks.
Three sub-tags define the search container:

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
\item
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
\item
  \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
\end{itemize}

The
\texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
tag's \texttt{results} attribute uses a service call to retrieve the
guestbooks in the scope. The \texttt{total} attribute uses another
service call to get a count of guestbooks.

The \texttt{\textless{}liferay-ui:search-container-row\textgreater{}}
tag defines what rows contain. In this case, the \texttt{className}
attribute defines \texttt{com.liferay.docs.guestbook.model.Guestbook}.
The \texttt{modelVar} attribute defines \texttt{guestbook} as the
variable for the currently iterated guestbook. In the search container
row, two columns are defined. The
\texttt{\textless{}liferay-ui:search-container-column-text\ property="name"\ /\textgreater{}}
tag specifies the first column. This tag displays text. Its
\texttt{property="name"} attribute specifies that the text to be
displayed is the current guestbook object's \texttt{name} attribute. The
tag \texttt{\textless{}liferay-ui:search-container-column-jsp}
\texttt{path="/guestbook\_admin/guestbook\_actions.jsp"\ align="right"\ /\textgreater{}}
specifies the second (and last) column. This tag includes another JSP
file within a search container column. Its \texttt{path} attribute
specifies the path to the JSP file that should be displayed:
\texttt{guestbook\_actions.jsp}.

Finally, the
\texttt{\textless{}liferay-ui:search-iterator\ /\textgreater{}} tag
iterates through and displays the list of guestbooks. Using Liferay's
search container makes the Guestbook Admin portlet look like a native
Liferay DXP portlet. It also provides built-in pagination so that your
portlet can automatically display large numbers of guestbooks on one
Site.

\section{Step 2: Creating the Actions
Button}\label{step-2-creating-the-actions-button}

Now create the \texttt{guestbook\_actions.jsp} file that displays the
list of possible actions for each guestbook.

Create a new file called \texttt{guestbook\_actions.jsp} in your
project's \texttt{/guestbook\_admin} folder. Paste in this code:

\begin{verbatim}
<%@include file="../init.jsp"%>

<%
    String mvcPath = ParamUtil.getString(request, "mvcPath");

    ResultRow row = (ResultRow) request
                    .getAttribute("SEARCH_CONTAINER_RESULT_ROW");

    Guestbook guestbook = (Guestbook) row.getObject();
%>

<liferay-ui:icon-menu>

    <portlet:renderURL var="editURL">
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(guestbook.getGuestbookId()) %>" />
        <portlet:param name="mvcPath"
            value="/guestbook_admin/edit_guestbook.jsp" />
    </portlet:renderURL>

    <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />

    <portlet:actionURL name="deleteGuestbook" var="deleteURL">
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(guestbook.getGuestbookId()) %>" />
    </portlet:actionURL>

    <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />

</liferay-ui:icon-menu>
\end{verbatim}

This JSP comprises the pop-up actions menu that shows the actions users
can perform on a guestbook: editing it or deleting it. First,
\texttt{init.jsp} is included because it contains all the JSP imports.
Because \texttt{guestbook\_actions.jsp} is included for every Search
Container row, it retrieves the guestbook in the current iteration. The
scriptlet grabs that guestbook so its ID can be supplied to the menu
tags.

The \texttt{\textless{}liferay-ui:icon-menu\textgreater{}} tag dominates
\texttt{guestbook\_actions.jsp}. It's a container for menu items, of
which there are currently only two (you'll add more later). The Edit
menu item displays the Edit icon and the message \emph{Edit}:

\begin{verbatim}
<liferay-ui:icon image="edit" message="Edit"
        url="<%=editURL.toString() %>" />
\end{verbatim}

The \texttt{editURL} variable comes from the
\texttt{\textless{}portlet:renderURL\ var="editURL"\textgreater{}} tag
with two parameters: \texttt{guestbookId} and \texttt{mvcPath}. The
\texttt{guestbookId} parameter specifies the guestbook to edit (it's the
one from the selected search container result row), and the
\texttt{mvcPath} parameter specifies the Edit Guestbook form's path.

The Delete menu item displays a delete icon and the default message
\emph{Delete}:

\begin{verbatim}
<liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
\end{verbatim}

Unlike the \texttt{editURL}, which is a render URL that links to the
\texttt{edit\_guestbook.jsp}, the \texttt{deleteURL} is an action URL
that invokes the portlet's \texttt{deleteGuestbook} action. The tag
\texttt{\textless{}portlet:actionURL\ name="deleteGuestbook"\ var="deleteURL"\textgreater{}}
creates this action URL, which only takes one parameter: the
\texttt{guestbookId} of the guestbook to be deleted.

\section{Step 3: Creating the Edit Guestbook
JSP}\label{step-3-creating-the-edit-guestbook-jsp}

Now there's just one more JSP file left to create: the
\texttt{edit\_guestbook.jsp} that contains the form for adding a new
guestbook and editing an existing one.

Create a new file called \texttt{edit\_guestbook.jsp} in your project's
\texttt{/guestbook\_admin} directory. Then add the following code to it:

\begin{verbatim}
<%@include file = "../init.jsp" %>

<%
        long guestbookId = ParamUtil.getLong(request, "guestbookId");
        
        Guestbook guestbook = null;

        if (guestbookId > 0) {
                guestbook = GuestbookLocalServiceUtil.getGuestbook(guestbookId);
        }
%>

<portlet:renderURL var="viewURL">
        <portlet:param name="mvcPath" value="/guestbook_admin/view.jsp" />
</portlet:renderURL>

<portlet:actionURL name='<%= guestbook == null ? "addGuestbook" : "updateGuestbook" %>' var="editGuestbookURL" />

<aui:form action="<%= editGuestbookURL %>" name="fm">

        <aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />

        <aui:input type="hidden" name="guestbookId"
            value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />

        <aui:fieldset>
             <aui:input name="name" />
        </aui:fieldset>

        <aui:button-row>
             <aui:button type="submit" />
             <aui:button onClick="<%= viewURL %>" type="cancel"  />
        </aui:button-row>
</aui:form>
\end{verbatim}

After the \texttt{init.jsp} import, you declare a \texttt{null}
guestbook variable. If there's a \texttt{guestbookId} parameter in the
request, you use the \texttt{guestbookId} to retrieve the corresponding
guestbook via a service call for edit. Otherwise, you know that you're
adding a new guestbook.

Next is a view URL that points to the Guestbook Admin portlet's default
view. This URL is invoked if the user clicks \emph{Cancel} on the Add
Guestbook or Edit Guestbook form. After that, you create an action URL
that invokes either the Guestbook Admin portlet's \texttt{addGuestbook}
method or its \texttt{updateGuestbook} method, depending on whether the
\texttt{guestbook} variable is null.

If a guestbook is being edited, its name should appear in the form's
name field. You use the following tag to define a model of the guestbook
that can be used in the AlloyUI form:

\begin{verbatim}
<aui:model-context bean="<%= guestbook %>" model="<%= Guestbook.class %>" />
\end{verbatim}

The form is created with the following tag:

\begin{verbatim}
<aui:form action="<%= editGuestbookURL %>" name="<portlet:namespace />fm">
\end{verbatim}

The form is submitted via the \texttt{editGuestbookURL}, which calls the
Guestbook Admin portlet's \texttt{addGuestbook} or
\texttt{updateGuestbook} action method, as discussed above.

The \texttt{guestbookId} must appear on the form so that it can be
submitted. The user, however, doesn't need to see it. Thus, you specify
\texttt{type="hidden"}:

\begin{verbatim}
<aui:input type="hidden" name="guestbookId"
        value='<%= guestbook == null ? "" : guestbook.getGuestbookId() %>' />
\end{verbatim}

The name, of course, should be editable by the user so it's not hidden.

The last item on the form is a button row with two buttons. The
\emph{Submit} button submits the form, invoking the
\texttt{editGuestbookURL} which, in turn, invokes either the
\texttt{addGuestbook} or \texttt{updateGuestbook} method. The
\emph{Cancel} button invokes the \texttt{viewURL} which displays the
default view.

Excellent! You've now finished creating the UI for the Guestbook Admin
portlet. It should now match the figure below:

\begin{figure}
\centering
\includegraphics{./images/admin-app-start.png}
\caption{The Guestbook Admin portlet can add or edit guestbooks,
configure their permissions, or delete them.}
\end{figure}

Save all your files and wait for redeploy. Test out the Guestbook Admin
portlet! Try adding, editing, and deleting guestbooks.

\noindent\hrulefill

\textbf{Note:} If you get ``Guestbook is unavailable'' errors, remove
the modules from the server, redeploy them, and test again.

\noindent\hrulefill

Now all the Guestbook application's primary functions work. There are
still many missing features, however. For example, if there's ever an
error, users never see it: all the code written so far just prints
messages in the logs. Next, you'll learn how to display those errors to
the user.

\chapter{Displaying Messages and
Errors}\label{displaying-messages-and-errors}

When users interact with your application, they perform tasks it
defines, like saving or editing things. The Guestbook application is no
different. Your application should provide feedback on these operations
so users can know they completed. Up to now, you've been placing this
information in logs that only administrators can access. Wouldn't it be
better to show users these messages?

\begin{figure}
\centering
\includegraphics{./images/guestbook-status-message.png}
\caption{You can use Liferay's APIs to display helpful messages.}
\end{figure}

That's exactly what you'll do next, in three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create language keys for your messages.
\item
  Add the error messages to your action methods.
\item
  Report those error messages in your JSPs.
\end{enumerate}

If you get stuck,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/06-messages/com-liferay-docs-guestbook}{source
code} for this step is provided.

Ready to get started?

Let's Go!{}

\chapter{Creating Language Keys}\label{creating-language-keys}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 1 of 3</p>
\end{verbatim}

Modern applications should place messages and form field labels in a
language keys files that hold multiple language translations. Here,
you'll learn how to provide a \emph{default} set of English language
keys for your application. For more information on language keys and
providing automatically translated language keys,
\href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-generating-translations}{see
Generating Translations}.

Language keys are stored in the \texttt{Language.properties} file
included in your \texttt{guestbook-web} module.
\texttt{Language.properties} is the default, but you can create more
translations by appending the ISO-639 language code to the file name
(e.g., \texttt{Language\_es.properties} for Spanish or
\texttt{Language\_de.properties} for German). For now, stick to the
default language keys.

Follow these steps to create your language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/src/main/resources/content/Language.properties} in your
  \texttt{guestbook-web} module. Remove the default keys in this file.
\item
  Paste in the following keys:

\begin{verbatim}
entry-added=Entry added successfully.
entry-deleted=Entry deleted successfully.
guestbook-added=Guestbook added successfully.
guestbook-updated=Guestbook updated successfully.
guestbook-deleted=Guestbook deleted successfully.
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Your messages are now in place, and your application can use them. Next,
you'll add them to your action methods.

\chapter{Adding Failure and Success
Messages}\label{adding-failure-and-success-messages}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 2 of 3</p>
\end{verbatim}

To display feedback to users properly, you must edit your portlet
classes to use Liferay DXP's \texttt{SessionMessages} and
\texttt{SessionErrors} classes. These classes collect messages that the
view layer shows to the user through a tag.

You'll add these messages to code that runs when the user triggers a
system function that can succeed or fail, such as creating, editing, or
deleting a Guestbook or Guestbook entry. This happens in action methods.
You must update these methods to handle failure and success states in
\texttt{GuestbookPortlet.java} and \texttt{GuestbookAdminPortlet.java}.
Start by updating \texttt{addEntry} and \texttt{deleteEntry} in
\texttt{GuestbookPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{addEntry} method in \texttt{GuestbookPortlet.java}.
  In the first \texttt{try...catch} block's \texttt{try} section, and
  add the success message just before the closing \texttt{\}}:

\begin{verbatim}
SessionMessages.add(request, "entryAdded");
\end{verbatim}

  This uses Liferay's \texttt{SessionMessages} API to add a success
  message whenever a Guestbook is successfully added. It looks up the
  message you placed in the \texttt{Language.properties} file and
  inserts the message for the key \texttt{entry-added} (it automatically
  converts the key from camel case).
\item
  Below that, in the \texttt{catch} block, find the following code:

\begin{verbatim}
System.out.println(e);
\end{verbatim}
\item
  Beneath it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}

  Now you not only log the message to the console, you also use the
  \texttt{SessionErrors} object to show the message to the user.
\end{enumerate}

Next, do the same for the \texttt{deleteEntry} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  After the logic to delete the entry, add a success message:

\begin{verbatim}
SessionMessages.add(request, "entryDeleted");
\end{verbatim}
\item
  Find the \texttt{Logger...} block of code in the \texttt{deleteEntry}
  method and after it, paste this line:

\begin{verbatim}
SessionErrors.add(request, e.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import
  \texttt{com.liferay.portal.kernel.servlet.SessionErrors} and
  \texttt{com.liferay.portal.kernel.servlet.SessionMessages}. Save the
  file.
\end{enumerate}

Well done! You've added the messages to \texttt{GuestbookPortlet}. Now
you must update \texttt{GuestbookAdminPortlet.java}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookAdminPortlet.java} and look for the same cues.
\item
  Add the appropriate success messages to the \texttt{try} section of
  the \texttt{try...catch} in \texttt{addGuestbook},
  \texttt{updateGuestbook}, and \texttt{deleteGuestbook}, respectively:

\begin{verbatim}
SessionMessages.add(request, "guestbookAdded");

SessionMessages.add(request, "guestbookUpdated");

SessionMessages.add(request, "guestbookDeleted");
\end{verbatim}
\item
  In the \texttt{catch} section of those same methods, find
  \texttt{Logger.getlogger...} and paste the \texttt{SessionErrors}
  block beneath it:

\begin{verbatim}
SessionErrors.add(request, pe.getClass().getName());
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to import \texttt{SessionErrors} and
  \texttt{SessionMessages}. Save the file.
\end{enumerate}

Great! The controller now makes relevant and detailed feedback
available. Now all you need to do is publish this feedback in the view
layer.

\chapter{Adding Messages to JSPs}\label{adding-messages-to-jsps}

\begin{verbatim}
<p id="stepTitle">Displaying Messages and Errors</p><p>Step 3 of 3</p>
\end{verbatim}

Any messages the user should see are now stored in either
\texttt{SessionMessages} or \texttt{SessionErrors}. Next, you'll make
these messages appear in your JSPs.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module, open
  \texttt{guestbook/view.jsp}. Add the following block of success
  messages to the top of the file, just below the \texttt{init.jsp}
  include statement:

\begin{verbatim}
<liferay-ui:success key="entryAdded" message="entry-added" />
<liferay-ui:success key="entryDeleted" message="entry-deleted" />
\end{verbatim}

  This tag accesses what's stored in \texttt{SessionMessages}. It has
  two attributes. The first is the \texttt{SessionMessages} key that you
  provided in the \texttt{GuestbookPortlet.java} class's add and delete
  methods. The second looks up the specified key in the
  \texttt{Language.properties} file. You could have specified a
  hard-coded message here, but it's far better to provide a localized
  key.
\item
  Now open \texttt{guestbook\_admin/view.jsp}. Add the following block
  of success messages in the same spot below the include:

\begin{verbatim}
<liferay-ui:success key="guestbookAdded" message="guestbook-added" />
<liferay-ui:success key="guestbookUpdated" message="guestbook-updated" />
<liferay-ui:success key="guestbookDeleted" message="guestbook-deleted" />
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/message-complete.png}
\caption{Now the message displays the value you specified in
\texttt{Language.properties}.}
\end{figure}

Congratulations! You've added useful feedback for operations in your
application.

Your application is shaping up, but it is missing another important
feature: permissions. Next, you'll add permission checking for your
guestbooks and entries.

Look for the next part soon!

\chapter{Using Resources and
Permissions}\label{using-resources-and-permissions}

Your application is a great foundation to build on. What comes next?
What if users want a Guestbook that's limited to certain trusted people?
What if you don't want just any old user to go around editing or
deleting people's Guestbook entries? To do that, you have to implement
permissions.

Thankfully, with Liferay DXP you don't have to write an entire
permissions system from scratch: the framework provides a robust and
well-tested permissions system that you can implement quickly. You'll
follow Liferay's well-defined process for implementing permissions,
called \emph{DRAC}:

\begin{itemize}
\tightlist
\item
  \textbf{Define} all resources and permissions
\item
  \textbf{Register} all defined resources in the permissions system
\item
  \textbf{Associate} permissions with resources
\item
  \textbf{Check} for permission before returning resources
\end{itemize}

If you get stuck,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/07-permissions/com-liferay-docs-guestbook}{source
code} for this step is provided.

Ready to start?

Let's Go!{}

\chapter{Defining Permissions}\label{defining-permissions}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 1 of 5</p>
\end{verbatim}

Liferay DXP's permissions framework is configured declaratively, like
Service Builder. You define all your permissions in an XML file that by
convention is called \texttt{default.xml} (but you could really call it
whatever you want). Then you implement permissions checks in the
following places in your code:

\begin{itemize}
\tightlist
\item
  In the view layer, when showing links or buttons to protected
  functionality
\item
  In the actions, before performing a protected action
\item
  Later, in your service, before calling the remote service
\end{itemize}

You should first define the permissions you want. To get started, think
of your application's use cases and how access to that functionality
should be controlled:

\begin{itemize}
\item
  The Add Guestbook button should be available only to administrators.
\item
  The Guestbook tabs should be filtered by permissions so administrators
  can control who can see them.
\item
  To prevent anonymous users from spamming the guestbook, the Add Entry
  button should be available only to Site members.
\item
  Users should be able to set permissions on their own entries.
\end{itemize}

Now you're ready to create the permissions configuration. Objects in
your application (such as \texttt{Guestbook} and
\texttt{GuestbookEntry}) are defined as \emph{resources}, and
\emph{resource actions} manage how users can interact with those
resources. There are therefore two kinds of permissions: portlet
permissions and resource (or model) permissions. Portlet permissions
protect access to global functions, such as \emph{Add Entry}. If users
don't have permission to access that global function, they're missing a
portlet permission. Resource permissions protect access to objects, such
as \texttt{Guestbook} and \texttt{GuestbookEntry}. A user may have
permission to view one \texttt{GuestbookEntry}, view and edit another
\texttt{GuestbookEntry}, and may not be able to access another
\texttt{GuestbookEntry} at all. This is due to a resource permission.

\begin{figure}
\centering
\includegraphics{./images/permission-types.png}
\caption{Portlet permissions and resource permissions cover different
parts of the application.}
\end{figure}

\section{Defining Model Permissions}\label{defining-model-permissions}

First, create the permissions file in the \texttt{guestbook-service}
project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{/src/main/resources/META-INF} folder, create a
  subfolder called \texttt{resource-actions}.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Click the \emph{Source} tab. Add the following \texttt{DOCTYPE}
  declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.2.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_2_0.dtd">
\end{verbatim}
\item
  Place the following wrapper tags into your \texttt{default.xml} file,
  below the \texttt{DOCTYPE} declaration:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your resource and model permissions inside these tags.
\item
  Next, place the permissions for your
  \texttt{com.liferay.docs.guestbook} package between the
  \texttt{\textless{}resource-action-mapping\textgreater{}} tags:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <root>true</root>
    <permissions>
        <supports>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ADD_GUESTBOOK</action-key>
            <action-key>ADD_ENTRY</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the baseline configuration for the \texttt{Guestbook} and
  \texttt{GuestbookEntry} entities. The supported actions are
  \texttt{ADD\_GUESTBOOK} and \texttt{ADD\_ENTRY}. Site members can
  \texttt{ADD\_ENTRY} by default, and guests can't perform either action
  (but they can view).
\item
  Below that, but above the closing
  \texttt{\textless{}/resource-action-mapping\textgreater{}}, place the
  \texttt{Guestbook} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.Guestbook</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>ADD_ENTRY</action-key>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_ENTRY</action-key>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines the \texttt{Guestbook} specific actions, including
  adding, deleting, updating, and viewing. By default, Site members and
  guests can view guestbooks, but guests can't update them.
\item
  Below the \texttt{Guestbook} model permissions, but still above the
  closing \texttt{\textless{}/resource-action-mapping\textgreater{}},
  place the \texttt{GuestbookEntry} model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.docs.guestbook.model.GuestbookEntry</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    </portlet-ref>
    <permissions>
        <supports>
            <action-key>DELETE</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>UPDATE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  This defines \texttt{GuestbookEntry} specific actions. By default, a
  Site member can add or view a Guestbook entry, and a guest can only
  view a Guestbook entry.
\item
  Save the file.
\end{enumerate}

Next, you must tell the framework where your permissions are defined.
You'll define resource and model permissions in the module where your
model is defined:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-service}'s \texttt{src/main/resources} folder,
  create a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\end{enumerate}

This property defines the name and location of your permissions
definition file.

\section{Defining Portlet
Permissions}\label{defining-portlet-permissions}

You now have permissions defined at the model level, but you must also
define portlet permissions. These are managed in the
\texttt{guestbook-web} module, which contains the portlet class. Follow
these steps to add the portlet permissions in the \texttt{guestbook-web}
module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a subfolder called \texttt{resource-actions} in the
  \texttt{src/main/resources/META-INF} folder.
\item
  Create a new file in this folder called \texttt{default.xml}.
\item
  Add the following \texttt{DOCTYPE} declaration to the top of the file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action  
Mapping 7.2.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_2_0.dtd">
\end{verbatim}
\item
  Below the \texttt{DOCTYPE} declaration, add the following
  \texttt{resource-action-mapping} tags:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping>
\end{verbatim}

  You'll define your portlet permissions inside these tags.
\item
  Insert this block of code inside the \texttt{resource-action-mapping}
  tags:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookAdminPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines the default permissions for the Guestbook Admin portlet.
  It supports the actions \texttt{ACCESS\_IN\_CONTROL\_PANEL},
  \texttt{CONFIGURATION}, and \texttt{VIEW}. While anyone can view the
  app, guests and Site members can't configure it or access it in the
  Control Panel. Since it's a Control Panel portlet, this effectively
  means that only administrators can access it.
\item
  Below the Guestbook Admin permissions, insert this block of code:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_docs_guestbook_portlet_GuestbookPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ADD_TO_PAGE</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported />
    </permissions>
</portlet-resource>
\end{verbatim}

  This defines permissions for the Guestbook portlet. It supports the
  actions \texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and
  \texttt{VIEW}. Site members and guests get the \texttt{VIEW}
  permission by default.
\item
  Save the file.
\item
  In \texttt{guestbook-web}'s \texttt{src/main/resources} folder, create
  a file called \texttt{portlet.properties}.
\item
  In this file, place the following property:

\begin{verbatim}
resource.actions.configs=META-INF/resource-actions/default.xml
\end{verbatim}
\item
  Save the file.
\end{enumerate}

Great job! You've now successfully designed and implemented a
permissions scheme for your application. Next, you'll create the Java
code to support permissions in the service layer.

\chapter{Registering Your Permissions in the
Database}\label{registering-your-permissions-in-the-database}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 2 of 5</p>
\end{verbatim}

The last step introduced the concept of \emph{resources}. Resources are
data stored with your entities that define how they can be accessed. For
example, when the configuration in your \texttt{default.xml} files is
applied to your application's entities in the database, resources are
created. These resources are then used in conjunction with Liferay DXP's
permissions system to determine who can do what to the entities.

To use these resources, Liferay DXP must know about them. To do that you
\emph{register} the resources with the system, both in the database and
with the running permissions system in the OSGi container.

Liferay DXP provides a complete API---integrated with Service
Builder---for managing resources. This API is injected into your
implementation classes automatically. To manage the resources, you need
only call the API in the service's add and delete methods. Follow these
steps to do this in your application.

\section{Registering Guestbook
Resources}\label{registering-guestbook-resources}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{guestbook-service} module, open
  \texttt{GuestbookLocalServiceImpl.java} from the
  \texttt{com.liferay.docs.guestbook.service.impl} package.
\item
  Just before the \texttt{addGuestbook} method's \texttt{return}
  statement, add this code:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    Guestbook.class.getName(), guestbookId, false, true, true);
\end{verbatim}

  Note that the \texttt{resourceLocalService} object is already there,
  ready for you to use. This is one of several utilities that are
  injected automatically by Service Builder into the base class your
  implementation class extends. You'll see the rest in the future.

  This code adds a resource to Liferay DXP's database to correspond with
  your entity (note that the \texttt{guestbookId} is included in the
  call). The three booleans at the end are settings. The first is
  whether to add portlet action permissions. This should only be
  \texttt{true} if the permission is for a portlet resource. Since this
  permission is for a model resource (an entity), it's \texttt{false}.
  The other two are settings for adding group and guest permissions. If
  you set these to \texttt{true}, you'll add the default permissions you
  defined in the permissions configuration file (\texttt{default.xml})
  in the previous step. Since you definitely want to do this, these
  booleans are set to \texttt{true}.
\item
  Next, go to the \texttt{updateGuestbook} method. Add a similar bit of
  code in between \texttt{guestbookPersistence.update(guestbook);} and
  the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(serviceContext.getCompanyId(),
    serviceContext.getScopeGroupId(), 
    Guestbook.class.getName(), guestbookId,
    serviceContext.getModelPermissions());
\end{verbatim}
\item
  Now you'll do the same for \texttt{deleteGuestbook}. Add this code in
  between \texttt{guestbook\ =\ deleteGuestbook(guestbook);} and the
  \texttt{return} statement:

\begin{verbatim}
resourceLocalService.deleteResource(serviceContext.getCompanyId(),
    Guestbook.class.getName(), ResourceConstants.SCOPE_INDIVIDUAL,
    guestbookId);
\end{verbatim}
\item
  Hit {[}CTRL{]}+{[}SHIFT{]}+O to organize the imports and save the
  file.
\end{enumerate}

\section{Registering Guestbook Entry
Resources}\label{registering-guestbook-entry-resources}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Now you'll add resources for the \texttt{GuestbookEntry} entity. Open
  \texttt{GuestbookEntryLocalServiceImpl.java} from the same package.
  For \texttt{addGuestbookEntry}, add a line of code that adds resources
  for this entity, just before the return statement:

\begin{verbatim}
resourceLocalService.addResources(user.getCompanyId(), groupId, userId,
    GuestbookEntry.class.getName(), entryId, false, true, true);
\end{verbatim}
\item
  Find \texttt{updateEntry} and add its resource action, also just
  before the \texttt{return} statement:

\begin{verbatim}
resourceLocalService.updateResources(
      user.getCompanyId(), serviceContext.getScopeGroupId(), 
      GuestbookEntry.class.getName(), entryId, 
      serviceContext.getModelPermissions());
\end{verbatim}
\item
  For \texttt{deleteGuestbookEntry}, add this code just before the
  \texttt{return} statement and just after the call to
  \texttt{guestbookEntryPersistence}:

\begin{verbatim}
resourceLocalService.deleteResource(
   entry.getCompanyId(), GuestbookEntry.class.getName(),
   ResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());
\end{verbatim}
\item
  Hit Ctrl-Shift-O to add imports and save the file.
\end{enumerate}

That's all it takes to add permissions resources to the database. Future
entities added to the database are fully permissions-enabled. Note,
however, that entities you've already added to your Guestbook
application in the portal don't have resources and thus can't be
protected by permissions. You'll fix this later. Now you must register
permissions with the permissions system, so it knows how to check for
them.

\chapter{Registering Permissions with the
Container}\label{registering-permissions-with-the-container}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 3 of 5</p>
\end{verbatim}

A running service checks permissions, but since the Guestbook portlet,
Guestbooks, and Guestbook Entries are new to the system, it must be
taught about them. You do this by creating permissions registrar
classes. These follow what you did in \texttt{default.xml}: you need one
for your portlet permissions and one for each of your entities. First,
you must do a little reorganization.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your API module, create a \texttt{GuestbookConstants} class in a
  new package called \texttt{com.liferay.docs.guestbook.constants}:

\begin{verbatim}
package com.liferay.docs.guestbook.constants;

public class GuestbookConstants {

    public static final String RESOURCE_NAME = "com.liferay.docs.guestbook";

}
\end{verbatim}

  The \texttt{RESOURCE\_NAME} string must match exactly your resource
  name from \texttt{default.xml}. You'll see why in a moment.
\item
  You have a \texttt{GuestbookPortletKeys} class in your web module.
  These keys must now be accessible to all modules, so drag this class
  from the web module and drop it into the new
  \texttt{com.liferay.docs.guestbook.constants} package in your API
  module.
\end{enumerate}

Now you're ready to create your permissions registrar classes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  module.
\item
  Add the following three dependencies and save the file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.petra.function"
compileOnly group: "com.liferay", name: "com.liferay.petra.model.adapter"
compileOnly group: "com.liferay", name: "com.liferay.petra.reflect"
\end{verbatim}
\item
  In your service module, create a package that by convention ends in
  \texttt{internal.security.permission.resource}.
\item
  Create a class in this package called
  \texttt{GuestbookModelResourcePermissionRegistrar} with the contents
  below.

\begin{verbatim}
package com.liferay.docs.guestbook.internal.security.permission.resource;

import java.util.Dictionary;

import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceRegistration;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.constants.GuestbookConstants;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.docs.guestbook.service.GuestbookLocalService;
import com.liferay.exportimport.kernel.staging.permission.StagingPermission;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermissionFactory;
import com.liferay.portal.kernel.security.permission.resource.PortletResourcePermission;
import com.liferay.portal.kernel.security.permission.resource.StagedModelPermissionLogic;
import com.liferay.portal.kernel.security.permission.resource.WorkflowedModelPermissionLogic;
import com.liferay.portal.kernel.service.GroupLocalService;
import com.liferay.portal.kernel.util.HashMapDictionary;
import com.liferay.portal.kernel.workflow.permission.WorkflowPermission;

@Component (immediate=true)
public class GuestbookModelResourcePermissionRegistrar {

 @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", Guestbook.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                Guestbook.class, Guestbook::getGuestbookId,
                _guestbookLocalService::getGuestbook, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, GuestbookPortletKeys.GUESTBOOK,
                            Guestbook::getGuestbookId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                                _workflowPermission, modelResourcePermission,
                                _groupLocalService, Guestbook::getGuestbookId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private GuestbookLocalService _guestbookLocalService;

    @Reference(target = "(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

    @Reference
    private GroupLocalService _groupLocalService;
}
\end{verbatim}
\end{enumerate}

This class registers a chain of permission logic classes for checking
permissions for Guestbook entities. Since this functionality is the same
for all entities, all that's necessary is to specify yours in addition
to the standard Liferay ones for staging and workflow. Introspection is
done on your entity by the factory to create the necessary permissions
service. You implemented the constants class so you can specify the
resource model name you defined in \texttt{default.xml}. The
\texttt{model.class.name} is set so that any module needing this service
can find this model resource permission by its type.

Now create the registrar for the \texttt{GuestbookEntry} entity:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookEntryModelResourcePermissionRegistrar}.
\item
  The only difference between this class and the one above is that it
  operates on \texttt{GuestbookEntry} entities instead of
  \texttt{Guestbook} entities (the imports have been left off in the
  snippet below):

\begin{verbatim}
package com.liferay.docs.guestbook.internal.security.permission.resource;

@Component(immediate = true)
public class GuestbookEntryModelResourcePermissionRegistrar {

 @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", GuestbookEntry.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                GuestbookEntry.class, GuestbookEntry::getEntryId,
                _guestbookEntryLocalService::getGuestbookEntry, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, GuestbookPortletKeys.GUESTBOOK,
                            GuestbookEntry::getEntryId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                                _workflowPermission, modelResourcePermission,
                                _groupLocalService, GuestbookEntry::getEntryId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private GuestbookEntryLocalService _guestbookEntryLocalService;

    @Reference(target = "(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

    @Reference
    private GroupLocalService _groupLocalService;
}
\end{verbatim}
\item
  Hit Ctrl-Shift-O to add the imports, and then save the file.
\end{enumerate}

Finally, create the registrar for the portlet permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookPortletResourcePermissionRegistrar}.
\item
  This class is simpler because you don't have to tell it how to
  retrieve primary keys from any entity:

\begin{verbatim}
package com.liferay.docs.guestbook.internal.security.permission.resource;

@Component (immediate = true)
public class GuestbookPortletResourcePermissionRegistrar {

        @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("resource.name", GuestbookConstants.RESOURCE_NAME);

        _serviceRegistration = bundleContext.registerService(
            PortletResourcePermission.class,
            PortletResourcePermissionFactory.create(
                GuestbookConstants.RESOURCE_NAME,
                new StagedPortletPermissionLogic(
                    _stagingPermission, GuestbookPortletKeys.GUESTBOOK)),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    private ServiceRegistration<PortletResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

}
\end{verbatim}
\item
  Type Ctrl-Shift-O to add the imports. Save the file.
\end{enumerate}

You've now completed step two: the R in DRAC: registering permissions.
Next, you'll enable users to associate permissions with resources.

\chapter{Assigning Permissions to
Resources}\label{assigning-permissions-to-resources}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 4 of 5</p>
\end{verbatim}

You've now defined your permissions and registered them in both the
container and the database so permissions can be checked. Now you'll
create a UI for users to assign permissions along with helper classes to
make it easy to check permissions in the final step.

Here's how it works. You have a permission, such as \texttt{ADD\_ENTRY},
and a resource, such as a \texttt{Guestbook}. For a user to add an entry
to a guestbook, you must check if that user has the \texttt{ADD\_ENTRY}
permission for that guestbook. Helper classes make it easier to check
permissions.

\section{Creating a Guestbook Portlet Permission
Helper}\label{creating-a-guestbook-portlet-permission-helper}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Right-click the \texttt{guestbook-web} module and select \emph{New} →
  \emph{Package}. To follow Liferay's practice, name the package
  \texttt{com.liferay.docs.guestbook.web.security.permission.resource}.
  This is where you'll place your helper classes.
\item
  Right-click the new package and select \emph{New} → \emph{Class}. Name
  the class \texttt{GuestbookPermission}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.security.permission.resource;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.constants.GuestbookConstants;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.PortletResourcePermission;

@Component(immediate=true)
public class GuestbookPermission {

    public static boolean contains(PermissionChecker permissionChecker, long groupId, String actionId) {

        return _portletResourcePermission.contains(permissionChecker, groupId, actionId);

    }

    @Reference(
            target="(resource.name=" + GuestbookConstants.RESOURCE_NAME + ")",
            unbind="-"
            )
    protected void setPortletResourcePermission(PortletResourcePermission portletResourcePermission) {

        _portletResourcePermission = portletResourcePermission;
    }

    private static PortletResourcePermission _portletResourcePermission;

}
\end{verbatim}
\end{enumerate}

This class is a component defining one static method (so you don't have
to instantiate the class) that encapsulates the model you're checking
permissions for. Liferay's \texttt{PermissionChecker} class does most of
the work: give it the proper resource and action, such as
\texttt{ADD\_ENTRY}, and it returns whether the permission exists or
not.

There's only one method: a \texttt{check} method that throws an
exception if the user doesn't have permission.

\section{Creating Model Permission
Helpers}\label{creating-model-permission-helpers}

Next, you'll create helpers for your two entities:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookModelPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.security.permission.resource;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.model.Guestbook;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;

@Component(immediate = true)
public class GuestbookModelPermission {

    public static boolean contains(
            PermissionChecker permissionChecker, Guestbook guestbook, String actionId) throws PortalException {

        return _guestbookModelResourcePermission.contains(permissionChecker, guestbook, actionId);
    }

    public static boolean contains(
            PermissionChecker permissionChecker, long guestbookId, String actionId) throws PortalException {

        return _guestbookModelResourcePermission.contains(permissionChecker, guestbookId, actionId);
    }

    @Reference(
            target = "(model.class.name=com.liferay.docs.guestbook.model.Guestbook)",
            unbind = "-")
    protected void setEntryModelPermission(ModelResourcePermission<Guestbook> modelResourcePermission) {

        _guestbookModelResourcePermission = modelResourcePermission;
    }

    private static ModelResourcePermission<Guestbook>_guestbookModelResourcePermission;

}
\end{verbatim}
\end{enumerate}

As you can see, this class is similar to \texttt{GuestbookPermission}.
The difference is that \texttt{GuestbookModelPermission} is for the
model/resource permission, so you supply the entity or its primary key
(\texttt{guestbookId}).

Your final class is almost identical to
\texttt{GuestbookModelPermission}, but it's for the
\texttt{GuestbookEntry} entity. Follow these steps to create it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class in the same package called
  \texttt{GuestbookEntryPermission.java}.
\item
  Replace this class's contents with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.security.permission.resource;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.guestbook.model.GuestbookEntry;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;

@Component(immediate = true)
public class GuestbookEntryPermission {

    public static boolean contains(
            PermissionChecker permissionChecker, GuestbookEntry entry, String actionId) throws PortalException {

        return _guestbookEntryModelResourcePermission.contains(permissionChecker, entry, actionId);
    }

    public static boolean contains(
            PermissionChecker permissionChecker, long entryId, String actionId) throws PortalException {

        return _guestbookEntryModelResourcePermission.contains(permissionChecker, entryId, actionId);
    }

    @Reference(
            target = "(model.class.name=com.liferay.docs.guestbook.model.GuestbookEntry)",
            unbind = "-")
    protected void setEntryModelPermission(ModelResourcePermission<GuestbookEntry> modelResourcePermission) {

        _guestbookEntryModelResourcePermission = modelResourcePermission;
    }

    private static ModelResourcePermission<GuestbookEntry>_guestbookEntryModelResourcePermission;

}
\end{verbatim}
\end{enumerate}

This class is almost identical to \texttt{GuestbookModelPermission}. The
only difference is that \texttt{GuestbookEntryPermission} is for the
\texttt{GuestbookEntry} entity.

Now you can expose the permissions UI to your users so they can assign
permissions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \texttt{init.jsp} in your \texttt{guestbook-web} project.
  Add the following imports to the file:

\begin{verbatim}
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookModelPermission" %>
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookPermission" %>
<%@ page import="com.liferay.docs.guestbook.web.security.permission.resource.GuestbookEntryPermission" %>
<%@ page import="com.liferay.portal.kernel.util.WebKeys" %>
<%@ page import="com.liferay.portal.kernel.security.permission.ActionKeys" %>
\end{verbatim}

  The first three are the permissions helper classes you just created.
\item
  Save the file.
\item
  Open \texttt{guestbook\_actions.jsp} from the
  \texttt{guestbook\_admin} folder. Add this code just after the
  \texttt{\textless{}liferay-ui:icon-delete\textgreater{}} tag:

\begin{verbatim}
<c:if
test="<%=GuestbookModelPermission.contains(permissionChecker, guestbook.getGuestbookId(), ActionKeys.PERMISSIONS) %>">

    <liferay-security:permissionsURL
        modelResource="<%= Guestbook.class.getName() %>"
        modelResourceDescription="<%= guestbook.getName() %>"
        resourcePrimKey="<%= String.valueOf(guestbook.getGuestbookId()) %>"
        var="permissionsURL" />

    <liferay-ui:icon image="permissions" url="<%= permissionsURL %>" />

</c:if>
\end{verbatim}
\item
  Save the file.
\end{enumerate}

You just added an action button that displays Liferay's permissions UI
for Guestbooks. On top of that, you used the permissions helper you just
created to test whether users can even see the action button. It only
appears if users have the \emph{permissions} permission.

You'll implement this for Guestbook entries in the next step.

Congratulations! You've now created helper classes for your permissions,
and you've enabled users to associate permissions with their resources.
The only thing left is to implement permission checks in the
application's view layer. You'll do this next.

\chapter{Checking for Permission in
JSPs}\label{checking-for-permission-in-jsps}

\begin{verbatim}
<p id="stepTitle">Implementing Permissions</p><p>Step 5 of 5</p>
\end{verbatim}

You've already seen how user interface components can be wrapped in
permission checks pretty easily. In this step, you'll implement the
rest.

\section{Checking Permissions in the
UI}\label{checking-permissions-in-the-ui}

Recall that you want to restrict access to three areas in your
application:

\begin{itemize}
\tightlist
\item
  The guestbook tabs across the top of your application
\item
  The Add Guestbook button
\item
  The Add Entry button
\end{itemize}

First, you'll check permissions for the guestbook tabs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{/guestbook/view.jsp} and find the scriptlet that gets the
  \texttt{guestbookId} from the request. Below this are the
  \texttt{\textless{}aui-nav\textgreater{}} tags that generate the tabs.
  Remove those tags and all the code between them. In its place, add the
  following code, which is the same thing with the addition of
  permission checks:

\begin{verbatim}
<aui:nav cssClass="nav-tabs">

    <%
        List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

            for (int i = 0; i < guestbooks.size(); i++) {

                Guestbook curGuestbook = guestbooks.get(i);
                String cssClass = StringPool.BLANK;

                if (curGuestbook.getGuestbookId() == guestbookId) {
                    cssClass = "active";
                }

                if (GuestbookModelPermission.contains(
                    permissionChecker, curGuestbook.getGuestbookId(), "VIEW")) {

    %>

    <portlet:renderURL var="viewPageURL">
        <portlet:param name="mvcPath" value="/guestbookwebportlet/view.jsp" />
        <portlet:param name="guestbookId"
            value="<%=String.valueOf(curGuestbook.getGuestbookId())%>" />
    </portlet:renderURL>


    <aui:nav-item cssClass="<%=cssClass%>" href="<%=viewPageURL%>"
        label="<%=HtmlUtil.escape(curGuestbook.getName())%>" />

    <%  
                }

            }
    %>

</aui:nav>
\end{verbatim}

  This code gets a list of guestbooks from the database, iterates
  through them, checks the permission for each against the current
  user's Roles, and adds the guestbooks the user can access to a list of
  tabs.

  You've now implemented your first permission check. As you can see,
  it's relatively straightforward thanks to the static methods in your
  helper classes. The code above shows the tab only if the current user
  has the \texttt{VIEW} permission for the guestbook.

  Next, you'll add permission checks to the Add Entry button.
\item
  Scroll down to the line that reads
  \texttt{\textless{}aui:button-row\ cssClass="guestbook-buttons"\textgreater{}}.
  Just below this line, add the following line of code to check for the
  \texttt{ADD\_ENTRY} permission:

\begin{verbatim}
<c:if test='<%= GuestbookPermission.contains(permissionChecker, scopeGroupId, "ADD_ENTRY") %>'>
\end{verbatim}
\item
  After this is the code that creates the \texttt{addEntryURL} and the
  Add Entry button. After the \texttt{aui:button} tag and above the
  \texttt{\textless{}/aui:button-row\textgreater{}} tag, add the closing
  tag for the \texttt{\textless{}c:if\textgreater{}} statement:

\begin{verbatim}
</c:if>
\end{verbatim}

  You've now implemented your permission check for the Add Entry button
  by using JSTL tags.
\item
  Save the file.
\end{enumerate}

Next, you'll add permission checking to \texttt{entry\_actions.jsp} to
determine what options appear for logged in users who can see the
actions menu in the portlet. Just like before, you'll wrap each
\texttt{renderURL} in an \texttt{if} statement that checks the
permissions against available actions. To do this, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open
  \texttt{src/main/resources/META-INF/resources/guestbook/entry\_actions.jsp}.
\item
  Remove all the code from this file and replace it with what's below:

  ```markup \textless\%@include file=``../init.jsp''\%\textgreater{}

\begin{verbatim}
<%
String mvcPath = ParamUtil.getString(request, "mvcPath");

ResultRow row = (ResultRow)request.getAttribute(WebKeys.SEARCH_CONTAINER_RESULT_ROW);

GuestbookEntry entry = (GuestbookEntry)row.getObject(); 
%>

<liferay-ui:icon-menu>

    <c:if
        test="<%= GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.UPDATE) %>">
        <portlet:renderURL var="editURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="mvcPath" value="/guestbook/edit_entry.jsp" />
        </portlet:renderURL>

        <liferay-ui:icon image="edit" message="Edit"
            url="<%=editURL.toString() %>" />
    </c:if>

    <c:if
    test="<%=GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.PERMISSIONS) %>">

        <liferay-security:permissionsURL
            modelResource="<%= GuestbookEntry.class.getName() %>"
            modelResourceDescription="<%= entry.getMessage() %>"
            resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
            var="permissionsURL" />

        <liferay-ui:icon image="permissions" url="<%= permissionsURL %>" />

    </c:if>

    <c:if
        test="<%=GuestbookEntryPermission.contains(permissionChecker, entry.getEntryId(), ActionKeys.DELETE) %>">

        <portlet:actionURL name="deleteEntry" var="deleteURL">
            <portlet:param name="entryId"
                value="<%= String.valueOf(entry.getEntryId()) %>" />
            <portlet:param name="guestbookId"
                value="<%= String.valueOf(entry.getGuestbookId()) %>" />
        </portlet:actionURL>

        <liferay-ui:icon-delete url="<%=deleteURL.toString() %>" />
    </c:if>

</liferay-ui:icon-menu>
```
\end{verbatim}
\item
  Save the file.
\end{enumerate}

This code updates each button with a permissions check. If the current
user can't perform the given action, the action doesn't appear.

Excellent! You've now implemented all the permissions checks for the
Guestbook portlet.

\section{Testing the Application}\label{testing-the-application}

Before testing the application, you must reset your database, because
guestbook entries you created without resources won't work with
permissions.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If your server is running, shut it down.
\item
  Find your Liferay Workspace on your file system (it should be inside
  your Eclipse workspace). Inside the \texttt{bundles/data} folder is a
  \texttt{hypersonic} folder.
\item
  Remove everything from the \texttt{hypersonic} folder.
\item
  Restart your server.
\end{enumerate}

Add new guestbooks and entries to test your application with different
users. Administrative users see all the buttons, regular users see the
Add Entry button, and guests see no buttons at all (but can navigate).

Now see if you can do the same for the Guestbook Admin portlet. Don't
worry if you can't: at the end of this Learning Path is a link to the
completed project for you to examine.

Great! The next step is to integrate search and indexing into your
application. This is a prerequisite for the much more powerful stuff to
come.

\chapter{Search and Indexing}\label{search-and-indexing}

The Guestbook and Guestbook Admin portlets are up and running. The
Guestbook portlet lets users add, edit, delete, and configure
permissions for Guestbook Entries. The Guestbook Admin portlet lets Site
administrators create, edit, delete, and configure permissions for
Guestbooks. In the case of a very popular event (maybe a \emph{Lunar
Luau} dinner at the Lunar Resort), there could be many Guestbook Entries
in the portlet, and users might want to search for Entries that
mentioned the delicious low-gravity ham that was served (melts in your
mouth). Searching for the word \emph{ham} should display these Guestbook
entries. In short, Guestbook entries must be searchable via a search bar
in the Guestbook portlet.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay DXP, search was only
\emph{permissions aware} (indexed with the entity's permissions and
searched with those permissions intact) if the application developer
specified this line in the \texttt{Indexer} class's constructor:

\begin{verbatim}
 setPermissionAware(true);
\end{verbatim}

Now, search is permissions aware by default \emph{if the new permissions
approach}, as described in the previous step of this tutorial and in
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{these
articles}, is implemented for an application.

\noindent\hrulefill

To enable search, you must index Guestbooks and Guestbook entries.
Although you probably won't have enough Guestbooks in a Site to warrant
searching the Guestbook Admin portlet, indexing Guestbooks has other
benefits. In a later step, you'll asset-enable Guestbooks and Guestbook
entries so the Asset Publisher can display them. Enabling search is a
prerequisite for this, because the Asset Publisher uses the index to
find assets.

If you get stuck,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/08-search/com-liferay-docs-guestbook}{source
code} for this step is provided.

But assets are for later. Right now it's time to index those Guestbooks.
Ready?

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search.png}
\caption{Add a search bar so users can search for Guestbook Entries. If
a message or name matches the search query, the Entry is displayed in
the search results.}
\end{figure}

Let's Go!{}

\chapter{Enabling Search and Indexing for
Guestbooks}\label{enabling-search-and-indexing-for-guestbooks}

In this section, you'll create the classes that control these aspects of
the search functionality:

\begin{itemize}
\item
  Registration:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookSearchRegistrar} registers the search services to
    the search framework for the Guestbook entity.
  \end{itemize}
\item
  Indexing:

  \begin{itemize}
  \item
    \texttt{GuestbookModelDocumentContributor} controls which Guestbook
    fields are indexed in the search engine.
  \item
    \texttt{GuestbookModelIndexerWriterContributor} configures the
    re-indexing and batch re-indexing behavior for Guestbooks.
  \end{itemize}
\item
  Querying:

  \begin{itemize}
  \item
    \texttt{GuestbookKeywordQueryContributor} contributes clauses to the
    ongoing search query.
  \item
    \texttt{GuestbookModelPreFilterContributor} controls how search
    results are filtered before they're returned from the search engine.
  \end{itemize}
\item
  Generating Result Summaries:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookModelSummaryContributor} constructs the result
    summary for Guestbooks, including specifying which fields to use.
  \end{itemize}
\end{itemize}

After creating the search classes, you'll modify the service layer to
update the search index when a guestbook is persisted. Specifically,
\texttt{GuestbookLocalServiceImpl}'s \texttt{addGuestbook},
\texttt{updateGuestbook}, and \texttt{deleteGuestbook} methods are
updated to invoke the guestbook indexer.

In prior versions of Liferay DXP, search and indexing was accomplished
with one \texttt{*Indexer} class that extended \texttt{BaseIndexer}. In
7.0 is a new pattern that relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. If you want to use the old approach, feel free
to extend \texttt{BaseIndexer}. It's still supported.

Since there's no reason to search for guestbooks in the UI, only
back-end work is necessary.

Let's Go!{}

\chapter{Understanding Search and
Indexing}\label{understanding-search-and-indexing}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 1 of 6</p>
\end{verbatim}

By default, Liferay DXP uses Elasticsearch, a search engine backed by
the popular Lucene search library, to implement its search and indexing
functionality. You could search the database, but that requires
resource-hogging table merges. Instead, a search engine like
Elasticsearch converts searchable entities into \emph{documents}. In
Elasticsearch, documents are searchable database entities converted into
JSON objects. After you implement indexing for guestbook entries,
Liferay DXP creates a document for each entry. The indexing code
specifies which guestbook entry fields to add to each guestbook entry
document, and it adds all the guestbook entry documents to an index. A
search returns a \emph{hits} object containing pointers to documents
matching the search query. Searching for entities with a search engine
via an index is faster than searching for entities in the database.
Elasticsearch provides some additional features like relevancy scoring
and fuzzy search queries.

Along with the search engine, Liferay DXP has its own search
infrastructure. Liferay DXP adds the following features to the existing
Elasticsearch API:

\begin{itemize}
\tightlist
\item
  Indexed documents include the fields needed by Liferay DXP (e.g.,
  \texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status).
\item
  It ensures the scope of returned search results is appropriate by
  applying the right filters to search requests.
\item
  It provides permission checking and hit summaries to display in the
  search portlet.
\end{itemize}

To understand how the search and indexing code presented here makes your
custom models seamlessly searchable, you must know how to influence each
portion of the search and indexing cycle:

\textbf{Indexing}: Model entities store data fields in the database. For
example, Guestbooks store the \emph{name} field. During the cycle's
Indexing step, you prepare the model entity to be searchable by defining
the model's fields that are sent to the search engine, later used during
a search.

\textbf{To influence the way model entity fields are indexed in search
engine documents,}

\texttt{ModelDocumentContributor} classes specify which database fields
are indexed in the model entity's search engine documents. This class's
\texttt{contribute} method is called each time the \texttt{add} and
\texttt{update} methods in the entity's service layer are called.

\texttt{ModelIndexerWriterContributor} classes configure the re-indexing
and batch re-indexing behavior for the model entity. This class's method
is called when a re-index is triggered from the Search administrative
application found in Control Panel → Configuration → Search.

\textbf{Searching:} Most searches start with a user entering keywords
into a search bar. The entered keywords are processed by the back-end
search infrastructure, transformed into a \emph{query} the search engine
can understand, and used to match against each search document's fields.

\textbf{To exert control over the way your model entity documents are
searched,}

\texttt{KeywordQueryContributor} classes contribute clauses to the
ongoing search query. This is called at search time, and ensures that
all the fields you indexed are also the ones searched. For example, if
you index fields with the Site locale appended to them
(\texttt{title\_en\_us}, for example), you want the search query to
include the same locale when the document is searched. If the search
query contain another locale (like \texttt{title\_es\_ES}) or searches
the plain field (\texttt{title}), inaccurate results are returned.

\texttt{ModelPreFilterContributor}s control how search results are
filtered before they're returned from the search engine. For example,
adding the workflow status to the query ensures that an entity in the
trash isn't returned in the search results. For the Guestbook
application, a \texttt{ModelPrefilterContributor} isn't necessary until
you get to the section on workflow-enabling Guestbooks.

\textbf{Returning Results:} When a model entity's indexed search
document is obtained during a search request, it's converted into a
summary of the model entity.

\textbf{To influence the result summaries for your model entity
documents,}

\texttt{ModelSummaryContributor} classes get the \texttt{Summary} object
created for each search document, so you can manipulate it by adding
specific fields or setting the length of the displayed content.

\texttt{ModelVisibilityContributor} classes control the visibility of
model entities that can be attached to other asset types (for example,
File Entries can be attached to Wiki Pages), in the search context.
Since Guestbooks and Guestbook entries won't be attached to other
assets, a model visibility contributor isn't necessary.

One important step must occur to make sure the above classes are
discovered by the search framework.

\textbf{Registration}

To register the model entity with Liferay's search framework,

\texttt{SearchRegistrar}s use the search framework's registry to define
certain things about your model entity's \texttt{ModelSearchDefinition}:
which fields are used by default to retrieve documents from the search
engine, and which optional search services are registered for your
entity. Registration occurs as soon as the Component is activated
(during portal startup).

Let's index some Guestbooks, shall we?

\chapter{Registering Guestbooks with the Search
Framework}\label{registering-guestbooks-with-the-search-framework}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 2 of 6</p>
\end{verbatim}

First, update your \texttt{build.gradle} with the necessary imports.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  project.
\item
  Add the Search Service Provider Interface and API dependencies to the
  \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.portal.search.spi"
compileOnly group: "com.liferay", name: "com.liferay.portal.search.api"
\end{verbatim}
\item
  Save the file and run \texttt{Refresh\ Gradle\ Project}.
\end{enumerate}

Once the dependency is configured, register the Search services that
build the entity's \texttt{ModelSearchDefinition}.

A \texttt{*SearchRegistrar} specifies the classes that the entity uses
to contribute to building a \texttt{ModelSearchDefinition}. Activation
of the \texttt{SearchRegistrar} component results in a cascade of
activity in the search framework, culminating with the building of a
\texttt{DefaultIndexer}. The \texttt{DefaultIndexer} is registered under
the class name defined in the registrar, and then used for
indexing/searching objects of that class.

Create the \texttt{GuestbookSearchRegistrar}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in the \texttt{guestbook-service} module
  project's \texttt{src/main/java} folder called
  \texttt{com.liferay.docs.guestbook.search}. In this package, create a
  new class called \texttt{GuestbookSearchRegistrar} and populate it
  with two methods, \texttt{activate} and \texttt{deactivate}.

\begin{verbatim}
@Component(immediate = true)
public class GuestbookSearchRegistrar {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _serviceRegistration = modelSearchRegistrarHelper.register(
            Guestbook.class, bundleContext, modelSearchDefinition -> {
                modelSearchDefinition.setDefaultSelectedFieldNames(
                    Field.ASSET_TAG_NAMES, Field.COMPANY_ID, Field.CONTENT,
                    Field.ENTRY_CLASS_NAME, Field.ENTRY_CLASS_PK,
                    Field.GROUP_ID, Field.MODIFIED_DATE, Field.SCOPE_GROUP_ID,
                    Field.TITLE, Field.UID);

                modelSearchDefinition.setModelIndexWriteContributor(
                    modelIndexWriterContributor);
                modelSearchDefinition.setModelSummaryContributor(
                    modelSummaryContributor);
            });
    }

    @Deactivate
    protected void deactivate() {

        _serviceRegistration.unregister();
    }
\end{verbatim}

  The annotations \texttt{@Activate} and \texttt{@Deactivate} ensure
  each method is invoked as soon as the Component is started (activated)
  or when it's about to be stopped (deactivated). On activation of the
  Component, a chain of search and indexing classes is registered for
  the Guestbook entity. Set the default selected field names used to
  retrieve results documents from the search engine. Then set the
  contributors used to build a model search definition.
\item
  Specify the service references for the class:

\begin{verbatim}
    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Guestbook)")
    protected ModelIndexerWriterContributor<Guestbook> modelIndexWriterContributor;

    @Reference
    protected ModelSearchRegistrarHelper modelSearchRegistrarHelper;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.Guestbook)")
    protected ModelSummaryContributor modelSummaryContributor;

    private ServiceRegistration<?> _serviceRegistration;

}
\end{verbatim}

  Target the \texttt{Guestbook} model while looking up a reference to
  the contributor classes. Later, when you create these contributor
  classes, you'll specify the model name again to complete the circle.
\item
  Add the imports by Organizing Imports (Ctrl-Shift-O). Choose the
  \texttt{com.liferay.portal.kernel.search.Field} class.
\item
  Export the \texttt{com.liferay.docs.guestbook.search} package in the
  \texttt{guestbook-service} module's \texttt{bnd.bnd} file. The export
  section should look like this:

\begin{verbatim}
Export-Package: com.liferay.docs.guestbook.search
\end{verbatim}
\end{enumerate}

The Guestbook search and indexing class registration is completed. Next,
you'll write the search and indexing logic.

\chapter{Indexing Guestbooks}\label{indexing-guestbooks}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 3 of 6</p>
\end{verbatim}

To control how Guestbook objects are translated into search engine
documents, create two classes in the new search package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a \texttt{ModelDocumentContributor} that ``contributes''
  fields to a search document indexed by the search engine. The main
  searchable field for guestbooks is the guestbook name.
\item
  \texttt{ModelIndexerWriterContributor} configures the batch indexing
  behavior for Guestbooks. This code is executed when Guestbooks are
  re-indexed from the Search administration section of the Control
  Panel.
\end{enumerate}

\section{\texorpdfstring{Implementing
\texttt{ModelDocumentContributor}}{Implementing ModelDocumentContributor}}\label{implementing-modeldocumentcontributor}

Create \texttt{GuestbookModelDocumentContributor} and populate it with
this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelDocumentContributor.class
)
public class GuestbookModelDocumentContributor
    implements ModelDocumentContributor<Guestbook> {

    @Override
    public void contribute(Document document, Guestbook guestbook) {
        try {
            document.addDate(Field.MODIFIED_DATE, guestbook.getModifiedDate());

            Locale defaultLocale = PortalUtil.getSiteDefaultLocale(
    guestbook.getGroupId());

            String localizedTitle = LocalizationUtil.getLocalizedName(
    Field.TITLE, defaultLocale.toString());

            document.addText(localizedTitle, guestbook.getName());
        } catch (PortalException pe) {
            if (_log.isWarnEnabled()) {
                _log.warn(
    "Unable to index guestbook " + guestbook.getGuestbookId(), pe);
            }
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
    GuestbookModelDocumentContributor.class);

}
\end{verbatim}

Because Liferay DXP supports localization, you should too. The above
code gets the default locale from the Site by passing the
\texttt{Guestbook}'s group ID to the \texttt{getSiteDefaultLocale}
method, then using it to get the localized name of the Guestbook's title
field. The retrieved Site locale is appended to the field (e.g.,
\texttt{title\_en\_US}), so the field gets passed to the search engine
and goes through the right analysis and
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/analysis-tokenizers.html}{tokenization}.

Use Ctrl-Shift-O to add these imports, and then save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Field}
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\end{itemize}

\section{\texorpdfstring{Implementing
\texttt{ModelIndexerWriterContributor}}{Implementing ModelIndexerWriterContributor}}\label{implementing-modelindexerwritercontributor}

Create \texttt{GuestbookModelIndexerWriterContributor} and populate it
with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelIndexerWriterContributor.class
)
public class GuestbookModelIndexerWriterContributor
    implements ModelIndexerWriterContributor<Guestbook> {

    @Override
    public void customize(
        BatchIndexingActionable batchIndexingActionable,
        ModelIndexerWriterDocumentHelper modelIndexerWriterDocumentHelper) {

        batchIndexingActionable.setPerformActionMethod((Guestbook guestbook) -> {
            Document document = modelIndexerWriterDocumentHelper.getDocument(
    guestbook);

            batchIndexingActionable.addDocuments(document);
        });
    }

    @Override
    public BatchIndexingActionable getBatchIndexingActionable() {
        return dynamicQueryBatchIndexingActionableFactory.getBatchIndexingActionable(
    guestbookLocalService.getIndexableActionableDynamicQuery());
    }

    @Override
    public long getCompanyId(Guestbook guestbook) {
        return guestbook.getCompanyId();
    }

    @Override
    public void modelIndexed(Guestbook guestbook) {
        guestbookEntryBatchReindexer.reindex(
    guestbook.getGuestbookId(), guestbook.getCompanyId());
    }

    @Reference
    protected DynamicQueryBatchIndexingActionableFactory
    dynamicQueryBatchIndexingActionableFactory;

    @Reference
    protected GuestbookEntryBatchReindexer guestbookEntryBatchReindexer;

    @Reference
    protected GuestbookLocalService guestbookLocalService;

}
\end{verbatim}

First look at the \texttt{customize} method. Configure the batch
indexing behavior for the entity's documents by calling
\texttt{BatchIndexingActionable} methods. This code uses the Guestbook's
actionable dynamic query helper method to retrieve all Guestbooks in the
virtual instance (identified by the Company ID). Service Builder
generated this query method for you when you built the services. Each
Guestbook's document is then retrieved and added to a collection.

When you write the indexing classes for Guestbook entries, you'll add
the Guestbook title to the \texttt{GuestbookEntry} document. Thus, you
must provide a way to update the indexed \texttt{GuestbookEntry}
documents if a Guestbook title is changed. The \texttt{modelIndexed}
method calls a \texttt{reindex} method from an interface that will be
created later for \texttt{GuestbookEntry}s. For now, ignore the error in
the \texttt{modelIndexed} method.

Use Ctrl-Shift-O to add this import, and save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\end{itemize}

Once the re-indexing behavior is in place, you can move on to
controlling how Guestbook documents are queried from the search engine.

\chapter{Querying for Guestbook
Documents}\label{querying-for-guestbook-documents}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 4 of 6</p>
\end{verbatim}

The code is in place for for indexing Guestbooks to the search engine.
Next, you'll code the behavior necessary for querying the indexed
documents.

Implement two interfaces:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{KeywordQueryContributor} contributes clauses to the ongoing
  search query.
\item
  \texttt{ModelPreFilterContributor} controls how search results are
  filtered before they're returned from the search engine.
\end{enumerate}

\section{\texorpdfstring{Implementing
\texttt{KeywordQueryContributor}}{Implementing KeywordQueryContributor}}\label{implementing-keywordquerycontributor}

Create \texttt{GuestbookKeywordQueryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = KeywordQueryContributor.class
)
public class GuestbookKeywordQueryContributor
    implements KeywordQueryContributor {

    @Override
    public void contribute(
        String keywords, BooleanQuery booleanQuery,
        KeywordQueryContributorHelper keywordQueryContributorHelper) {

        SearchContext searchContext =
    keywordQueryContributorHelper.getSearchContext();

        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.TITLE, false);
    }

    @Reference
    protected QueryHelper queryHelper;

}
\end{verbatim}

This class adds Guestbook fields to the search query constructed by the
Search application in Liferay DXP. Later, when you asset-enable
Guestbooks, this code allows indexed Guestbooks to be searched from the
Search application when a keyword is entered into the search bar. Use
the query helper to add search terms to the query that allow Guestbooks
to be found. Here it's important to note that adding the localized
search term is important. Since the localized Guestbook title was
indexed, you must retrieve the localized value from the search engine.

Don't forget to add imports with Ctrl-Shift-O. Choose
\texttt{com.liferay.portal.kernel.search.BooleanQuery} and
\texttt{com.liferay.portal.kernel.search.Field}.

Once the query code is in place, define how returned Guestbook documents
are summarized.

\chapter{Generating Results
Summaries}\label{generating-results-summaries}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 5 of 6</p>
\end{verbatim}

The Search application and the Asset Publisher application must display
results retrieved from the search engine. Control the summarized content
by implementing a \texttt{ModelSummaryContributor}.

A summary is a condensed, text-based version of the entity's document
that can be displayed generically. You create it by combining key parts
of the entity's data so users can browse through search resmlts to find
the entity they want.

Create a \texttt{GuestbookModelSummaryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.Guestbook",
        service = ModelSummaryContributor.class
)
public class GuestbookModelSummaryContributor
    implements ModelSummaryContributor {

    @Override
    public Summary getSummary(
        Document document, Locale locale, String snippet) {

        Summary summary = createSummary(document);

        summary.setMaxContentLength(200);

        return summary;
    }

    private Summary createSummary(Document document) {
        String prefix = Field.SNIPPET + StringPool.UNDERLINE;

        String title = document.get(prefix + Field.TITLE, Field.TITLE);

        return new Summary(title, StringPool.BLANK);
    }

}
\end{verbatim}

First override \texttt{getSummary} and set the maximum summary length on
the summary returned. The value \texttt{200} is a Liferay standard.
Control the summary creation in a utility method called
\texttt{createSummary}. Create a \texttt{prefix} variable using two
constants, \texttt{Field.SNIPPET} and \texttt{Stringpool.UNDERLINE}. The
\texttt{snippet\_title} field is returned from the \texttt{document.get}
call, and added to the summary. Using the snippet field provides two
benefits:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Snippet text can be highlighted so matching keywords are emphasized.
\item
  Snippet text can be shortened automatically by the Search application
  so a sensible portion of the field's text is displayed in the search
  results.
\end{enumerate}

Guestbook titles are likely short, so only the highlighting behavior is
useful for the title field of Guestbooks. For longer fields (like some
\texttt{content} fields), the clipping behavior is more useful.
Additional highlighting behavior can be configured via the
\texttt{index.search.highlight.*} properties in
\href{https://docs.liferay.com/portal/7.2-latest/propertiesdoc/portal.properties.html\#Lucene\%20Search}{portal.properties}.

Create summaries by combining key parts of the entity's data so users
can browse through search results to find the entity they want.

Don't forget to Ctrl-Shift-O and import these classes:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Field}
\item
  \texttt{com.liferay.petra.string.StringPool}
\item
  \texttt{com.liferay.portal.kernel.search.Summary}
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\end{itemize}

Save your file.

Once all the search and indexing logic is in place, update the service
layer so \texttt{add}, \texttt{update}, and \texttt{delete} service
calls trigger the new logic.

\chapter{Handling Indexing in the Guestbook Service
Layer}\label{handling-indexing-in-the-guestbook-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Guestbooks</p><p>Step 6 of 6</p>
\end{verbatim}

Whenever a Guestbook database entity is added, updated, or deleted, the
search index must be updated accordingly. The Liferay DXP annotation
\texttt{@Indexable} combines with the \texttt{IndexableType} to mark
your service methods so documents can be updated or deleted. Next,
you'll annotate \texttt{addGuestbook}, \texttt{updateGuestbook}, and
\texttt{deleteGuestbook} service methods.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookLocalServiceImpl} in the
  \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.service.impl} package and add the
  following annotation above the method signature for the
  \texttt{addGuestbook} and \texttt{updateGuestbook} methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public Guestbook addGuestbook(...)

@Indexable(type = IndexableType.REINDEX)
public Guestbook updateGuestbook(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following the method execution. The indexing classes control
  the type of index: setting the \texttt{@Indexable} annotation type to
  \texttt{IndexableType.REINDEX} updates the document in the index that
  corresponds to the updated Guestbook.
\item
  Add the following annotation above the method signature for the
  \texttt{deleteGuestbook} method:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public Guestbook deleteGuestbook(...)
\end{verbatim}

  When a Guestbook is deleted from the database, its document shouldn't
  remain in the search index. This ensures that it is deleted.
\item
  Use Ctrl-Shift-O to add the necessary imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay Dev Studio
  DXP, double-click \texttt{buildService} in \texttt{guestbook-service}
  → \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{GuestbookLocalServiceImpl}.
\end{enumerate}

Next, you'll enable search and indexing for Guestbook Entries.

\chapter{Enabling Search and Indexing for
Entries}\label{enabling-search-and-indexing-for-entries}

Now you'll create the classes that control these aspects of the search
functionality:

\begin{itemize}
\item
  Registration:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookEntrySearchRegistrar} registers the search service
    for the \texttt{GuestbookEntry} entity.
  \end{itemize}
\item
  Indexing:

  \begin{itemize}
  \item
    \texttt{GuestbookEntryModelDocumentContributor} controls which
    \texttt{GuestbookEntry} fields are indexed in the search engine.
  \item
    \texttt{GuestbookEntryModelIndexerWriterContributor} configures the
    re-indexing and batch re-indexing behavior for
    \texttt{GuestbookEntry}s.
  \item
    \texttt{GuestbookEntryBatchReindexer}, an interface, and its
    \texttt{GuestbookEntryBatchReindexerImpl}, for re-indexing
    \texttt{GuestbookEntries}when their Guestbook is updated.
  \end{itemize}
\item
  Querying:

  \begin{itemize}
  \item
    \texttt{GuestbookEntryKeywordQueryContributor} contributes clauses
    to the ongoing search query.
  \item
    \texttt{GuestbookEntryModelPreFilterContributor} controls how search
    results are filtered before they're returned from the search engine.
  \end{itemize}
\item
  Generating Result Summaries:

  \begin{itemize}
  \tightlist
  \item
    \texttt{GuestbookEntryModelSummaryContributor} constructs the result
    summary for \texttt{GuestbookEntry}s, including specifying which
    fields to use.
  \end{itemize}
\end{itemize}

After creating the search classes, modify the service layer to update
the search index when a \texttt{GuestbookEntry}is persisted:

\begin{itemize}
\tightlist
\item
  Update \texttt{GuestbookEntryLocalServiceImpl}'s \texttt{addEntry},
  \texttt{updateEntry}, and \texttt{deleteEntry} methods to update the
  index so it matches the database.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} In prior versions of Liferay DXP, search and indexing was
accomplished with one \texttt{*Indexer} class that extended
\texttt{BaseIndexer}. This tutorial demonstrates a new pattern that
relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. If you desire to use the old approach, feel
free to extend \texttt{BaseIndexer}. It's still supported.

\noindent\hrulefill

Let's Go!{}

\chapter{Registering Entries with the Search
Framework}\label{registering-entries-with-the-search-framework}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 1 of 5</p>
\end{verbatim}

The search registrar for Entries is very similar to the one created for
Guestbooks. You'll even put it in the same package
(\texttt{com.liferay.docs.guestbook.search}).

Create the \texttt{GuestbookEntrySearchRegistrar}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{com.liferay.docs.guestbook.search}, create a new class
  called \texttt{GuestbookEntrySearchRegistrar} and populate it with two
  methods, \texttt{activate} and \texttt{deactivate}.

\begin{verbatim}
@Component(immediate = true)
public class GuestbookEntrySearchRegistrar {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _serviceRegistration = modelSearchRegistrarHelper.register(
            GuestbookEntry.class, bundleContext, modelSearchDefinition -> {
                modelSearchDefinition.setDefaultSelectedFieldNames(
                    Field.COMPANY_ID, Field.ENTRY_CLASS_NAME,
                    Field.ENTRY_CLASS_PK, Field.UID, 
                    Field.SCOPE_GROUP_ID, Field.GROUP_ID);

                modelSearchDefinition.setDefaultSelectedLocalizedFieldNames(
                    Field.TITLE, Field.CONTENT);

                modelSearchDefinition.setModelIndexWriteContributor(
                    modelIndexWriterContributor);
                modelSearchDefinition.setModelSummaryContributor(
                    modelSummaryContributor);
                modelSearchDefinition.setSelectAllLocales(true);

            });
    }

    @Deactivate
    protected void deactivate() {
        _serviceRegistration.unregister();
    }
\end{verbatim}
\end{enumerate}

As you did with Guestbooks, set the default selected field names used to
retrieve results documents from the search engine. For entries, call
\texttt{setDefaultSelectedLocalizedFieldNames} for the title and content
fields. This ensures that the localized version of the field is searched
and returned. The only other difference with Entries is the call to
\texttt{setSelectAllLocales(true)}. It takes the fields set in
\texttt{setDefaultSelectedLocalizedFieldNames} and sets those fields for
each available locale in the \texttt{stored\_fields} parameter of the
search request. If not set to \texttt{true}, only a single locale is
searched.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Specify the service references for the class:

\begin{verbatim}
    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry)")
    protected ModelIndexerWriterContributor<GuestbookEntry> modelIndexWriterContributor;

    @Reference
    protected ModelSearchRegistrarHelper modelSearchRegistrarHelper;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry)")
    protected ModelSummaryContributor modelSummaryContributor;

    private ServiceRegistration<?> _serviceRegistration;

}
\end{verbatim}

  Target the \texttt{GuestbookEntry} model while looking up a reference
  to the contributor classes. Later, when you create these contributor
  classes, you'll specify the model name again to complete the circle.
\item
  Use Ctrl-Shift-O to add imports:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.liferay.portal.kernel.search.Field}
  \end{itemize}
\end{enumerate}

The entry search and indexing class registration is completed. Next,
you'll write the search and indexing logic.

\chapter{Indexing Entries}\label{indexing-entries}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 2 of 5</p>
\end{verbatim}

To control how \texttt{GuestbookEntry}objects are translated into search
engine documents, create these classes in the search package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{ModelDocumentContributor}: The main searchable fields for
  entries are \emph{Name} and \emph{Message}. The Guestbook name
  associated with the entry is indexed, too.
\item
  \texttt{ModelIndexerWriterContributor} configures the batch indexing
  behavior for entries. This code is executed when Entries are
  re-indexed from the Search administration section of the Control
  Panel.
\item
  A new interface, \texttt{GuestbookEntryBatchReindexer}, with its
  implementation, \texttt{GuestbookEntryBatchReindexerImpl}. These
  classes contain code to ensure that entries are re-indexed when their
  Guestbook is updated.
\end{enumerate}

\section{\texorpdfstring{Implementing
\texttt{ModelDocumentContributor}}{Implementing ModelDocumentContributor}}\label{implementing-modeldocumentcontributor-1}

Create \texttt{GuestbookEntryModelDocumentContributor} and populate it
with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry",
        service = ModelDocumentContributor.class
)
public class GuestbookEntryModelDocumentContributor
    implements ModelDocumentContributor<GuestbookEntry> {

    @Override
    public void contribute(Document document, GuestbookEntry entry) {
        try {
            Locale defaultLocale = PortalUtil.getSiteDefaultLocale(
    entry.getGroupId());

            document.addDate(Field.MODIFIED_DATE, entry.getModifiedDate());
            document.addText("entryEmail", entry.getEmail());

            String localizedTitle = LocalizationUtil.getLocalizedName(
    Field.TITLE, defaultLocale.toString());
            String localizedContent = LocalizationUtil.getLocalizedName(
    Field.CONTENT, defaultLocale.toString());

            document.addText(localizedTitle, entry.getName());
            document.addText(localizedContent, entry.getMessage());

            long guestbookId = entry.getGuestbookId();

            Guestbook guestbook = _guestbookLocalService.getGuestbook(
    guestbookId);

            String guestbookName = guestbook.getName();

            String localizedGbName = LocalizationUtil.getLocalizedName(
    Field.NAME, defaultLocale.toString());

            document.addText(localizedGbName, guestbookName);
        } catch (PortalException pe) {
            if (_log.isWarnEnabled()) {
                _log.warn("Unable to index entry " + entry.getEntryId(), pe);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
    GuestbookEntryModelDocumentContributor.class);

    @Reference
    private GuestbookLocalService _guestbookLocalService;

}
\end{verbatim}

As with Guestbooks, add the localized values for fields that might be
translated. The Site locale is appended to the field (e.g.,
\texttt{title\_en\_US}), so the field gets passed to the search engine
and goes through the right analysis and
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/analysis-tokenizers.html}{tokenization}.

Use Ctrl-Shift-O to add the following imports and save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\item
  \texttt{com.liferay.portal.kernel.search.Field}
\end{itemize}

\section{\texorpdfstring{Implementing
\texttt{ModelIndexerWriterContributor}}{Implementing ModelIndexerWriterContributor}}\label{implementing-modelindexerwritercontributor-1}

Create \texttt{GuestbookEntryModelIndexerWriterContributor} and populate
it with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry",
        service = ModelIndexerWriterContributor.class
)
public class GuestbookEntryModelIndexerWriterContributor
    implements ModelIndexerWriterContributor<GuestbookEntry> {

    @Override
    public void customize(
        BatchIndexingActionable batchIndexingActionable,
        ModelIndexerWriterDocumentHelper modelIndexerWriterDocumentHelper) {

        batchIndexingActionable.setPerformActionMethod((GuestbookEntry entry) -> {
            Document document = modelIndexerWriterDocumentHelper.getDocument(
    entry);

            batchIndexingActionable.addDocuments(document);
            
        });
    }

    @Override
    public BatchIndexingActionable getBatchIndexingActionable() {
        return dynamicQueryBatchIndexingActionableFactory.getBatchIndexingActionable(
    guestbookEntryLocalService.getIndexableActionableDynamicQuery());
    }

    @Override
    public long getCompanyId(GuestbookEntry entry) {
        return entry.getCompanyId();
    }

    @Reference
    protected DynamicQueryBatchIndexingActionableFactory
    dynamicQueryBatchIndexingActionableFactory;

    @Reference
    protected GuestbookEntryLocalService guestbookEntryLocalService;

}
\end{verbatim}

The interesting work is done in the \texttt{customize} method, where all
entries are retrieved and added to a collection.

Use Ctrl-Shift-O to add an import for
\texttt{com.liferay.portal.kernel.search.Document} and save the file.

\section{\texorpdfstring{Implementing
\texttt{GuestbookEntryBatchReindexer}}{Implementing GuestbookEntryBatchReindexer}}\label{implementing-guestbookentrybatchreindexer}

Create a new interface, \texttt{GuestbookEntryBatchReindexer}, with one
method called \texttt{reindex}:

\begin{verbatim}
package com.liferay.docs.guestbook.search;

public interface GuestbookEntryBatchReindexer {

    public void reindex(long guestbookId, long companyId);

}
\end{verbatim}

Then create the implementation class,
\texttt{GuestbookEntryBatchReindexerImpl}:

\begin{verbatim}
@Component(immediate = true, service = GuestbookEntryBatchReindexer.class)
public class GuestbookEntryBatchReindexerImpl implements GuestbookEntryBatchReindexer {

    @Override
    public void reindex(long guestbookId, long companyId) {
        BatchIndexingActionable batchIndexingActionable =
    indexerWriter.getBatchIndexingActionable();

        batchIndexingActionable.setAddCriteriaMethod(dynamicQuery -> {
            Property guestbookIdPropery = PropertyFactoryUtil.forName(
    "guestbookId");

            dynamicQuery.add(guestbookIdPropery.eq(guestbookId));
        });

        batchIndexingActionable.setCompanyId(companyId);

        batchIndexingActionable.setPerformActionMethod((GuestbookEntry entry) -> {
            Document document = indexerDocumentBuilder.getDocument(entry);

            batchIndexingActionable.addDocuments(document);
        });

        batchIndexingActionable.performActions();

    }

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry)")
    protected IndexerDocumentBuilder indexerDocumentBuilder;

    @Reference(target = "(indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry)")
    protected IndexerWriter<GuestbookEntry> indexerWriter;

}
\end{verbatim}

The \texttt{reindex} method of the interface is called when a Guestbook
is updated. The entry documents are re-indexed to include the update
Guestbook title.

Use Ctrl-Shift-O to add the following imports, and save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\item
  \texttt{com.liferay.portal.kernel.dao.orm.Property}
\end{itemize}

You should notice that errors in the project go away at this point.

Once the re-indexing behavior is in place, you can move on to the code
for controlling how \texttt{GuestbookEntry} documents are queried from
the search engine.

\chapter{Querying for Guestbook Entry
Documents}\label{querying-for-guestbook-entry-documents}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 3 of 5</p>
\end{verbatim}

The code is in place for indexing Guestbook entries to the search
engine. Next code the behavior necessary for querying the indexed
documents.

Implement two classes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{GuestbookEntryKeywordQueryContributor} contributes clauses to
  the ongoing search query.
\item
  \texttt{GuestbookEntryModelPreFilterContributor} controls how search
  results are filtered before they're returned from the search engine.
\end{enumerate}

\section{\texorpdfstring{Implementing
\texttt{KeywordQueryContributor}}{Implementing KeywordQueryContributor}}\label{implementing-keywordquerycontributor-1}

Create \texttt{GuestbookEntryKeywordQueryContributor} and populate it
with this:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry",
        service = KeywordQueryContributor.class
)
public class GuestbookEntryKeywordQueryContributor implements KeywordQueryContributor {

    @Override
    public void contribute(
        String keywords, BooleanQuery booleanQuery,
        KeywordQueryContributorHelper keywordQueryContributorHelper) {

        SearchContext searchContext =
    keywordQueryContributorHelper.getSearchContext();

        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.TITLE, false);
        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, Field.CONTENT, false);
        queryHelper.addSearchLocalizedTerm(
    booleanQuery, searchContext, "entryEmail", false);
    }

    @Reference
    protected QueryHelper queryHelper;

}
\end{verbatim}

Adding the localized search terms is important. For all localized
\texttt{GuestbookEntry} fields in the index, retrieve the localized
value from the search engine.

Use Ctrl-Shift-O to add these imports, and then save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.BooleanQuery}
\item
  \texttt{com.liferay.portal.kernel.search.Field}
\end{itemize}

Now that the query code is in place, you can define how returned
\texttt{GuestbookEntry} documents are summarized.

\chapter{Generating Results
Summaries}\label{generating-results-summaries-1}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 3 of 5</p>
\end{verbatim}

The Search application and the Asset Publisher application display
results retrieved from the search engine. You can control the display by
implementing a \texttt{ModelSummaryContributor}.

Create a \texttt{GuestbookEntryModelSummaryContributor}:

\begin{verbatim}
@Component(
        immediate = true,
        property = "indexer.class.name=com.liferay.docs.guestbook.model.GuestbookEntry",
        service = ModelSummaryContributor.class
)
public class GuestbookEntryModelSummaryContributor implements ModelSummaryContributor {

    @Override
    public Summary getSummary(
        Document document, Locale locale, String snippet) {

        Summary summary = createSummary(document);

        summary.setMaxContentLength(128);

        return summary;
    }

    private Summary createSummary(Document document) {
        String prefix = Field.SNIPPET + StringPool.UNDERLINE;

        String title = document.get(prefix + Field.TITLE, Field.CONTENT);
        String content = document.get(prefix + Field.CONTENT, Field.CONTENT);

        return new Summary(title, content);
    }

}
\end{verbatim}

First override \texttt{getSummary}, and set the maximum summary length
on the summary returned. The value \texttt{200} is a Liferay standard.
Control the summary creation in a utility method called
\texttt{createSummary}. Guestbooks only included the title in the
summary, but Entries use the title and the content (the Entry message
field) to populate the summary.

Create summaries by combining key parts of the entity's data.

Use Ctrl-Shift-O to add these imports, and then save the file:

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.kernel.search.Field}
\item
  \texttt{com.liferay.petra.string.StringPool}
\item
  \texttt{com.liferay.portal.kernel.search.Summary}
\item
  \texttt{com.liferay.portal.kernel.search.Document}
\end{itemize}

Now that the search and indexing logic is in place, you can update the
service layer so \texttt{add}, \texttt{update}, and \texttt{delete}
service calls trigger the new logic.

\chapter{Handling Indexing in the Entry Service
Layer}\label{handling-indexing-in-the-entry-service-layer}

\begin{verbatim}
<p id="stepTitle">Enabling Search and Indexing for Entries</p><p>Step 5 of 5</p>
\end{verbatim}

Whenever a Guestbook entry is added, updated, or deleted, the
corresponding document should also be updated or deleted. A minor update
to each of the \texttt{addEntry}, \texttt{updateEntry}, and
\texttt{deleteEntry} service methods for Entries is all it takes.

Follow these steps to update the methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookEntryLocalServiceImpl} in the
  \texttt{guestbook-service} module's
  \texttt{com.liferay.docs.guestbook.service.impl} package, and add the
  annotation \texttt{@Indexable(type\ =\ IndexableType.REINDEX)} above
  the signature for the \texttt{addGuestbookEntry} and
  \texttt{updateGuestbookEntry} methods:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public GuestbookEntry addGuestbookEntry(...)

@Indexable(type = IndexableType.REINDEX)
public GuestbookEntry updateGuestbookEntry(...)
\end{verbatim}

  The \texttt{@Indexable} annotation indicates that an index update is
  required following method execution. The indexing classes control
  exactly how the indexing happens. Setting the \texttt{@Indexable}
  annotation's type to \texttt{IndexableType.REINDEX} updates the
  indexed document that corresponds to the updated
  \texttt{GuestbookEntry}.
\item
  Add the \texttt{@Indexable(type\ =\ IndexableType.DELETE)} annotation
  above the signature for the \texttt{deleteEntry} method. The indexable
  type \texttt{IndexableType.DELETE} ensures that the
  \texttt{GuestbookEntry} is deleted from the index:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
public GuestbookEntry deleteGuestbookEntry(...)
\end{verbatim}
\item
  Use Ctrl-Shift-O to add the required imports:

\begin{verbatim}
import com.liferay.portal.kernel.search.Indexable;
import com.liferay.portal.kernel.search.IndexableType;
\end{verbatim}

  Save the file.
\item
  In the Gradle Tasks pane on the right-hand side of Liferay Dev Studio
  DXP, double-click \texttt{buildService} in \texttt{guestbook-service}
  → \texttt{build}. This re-runs Service Builder to incorporate your
  changes to \texttt{GuestbookEntryLocalServiceImpl}.
\end{enumerate}

Guestbooks and their entries now have search and indexing support in the
back-end. Next, you'll enable search in the Guestbook portlet's
front-end.

\chapter{Updating Your User Interface For
Search}\label{updating-your-user-interface-for-search}

Updating the Guestbook portlet's user interface for search takes two
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the Guestbook portlet's default view JSP to display a search
  bar for submitting queries.
\item
  Create a new JSP for the Guestbook portlet to display search results.
\end{enumerate}

You'll start by updating the Guestbook portlet's view JSP.

Let's Go!{}

\chapter{Adding a Search Bar to the Guestbook
Portlet}\label{adding-a-search-bar-to-the-guestbook-portlet}

\begin{verbatim}
<p id="stepTitle">Updating Your UI for Search</p><p>Step 1 of 2</p>
\end{verbatim}

Create the search bar UI for the Guestbook portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{guestbook-web}, open the file
  \texttt{src/main/resources/META-INF/resources/guestbook/view.jsp}. Add
  a render URL near the top of the file, just after the scriptlet that
  gets the \texttt{guestbookId} from the request:

\begin{verbatim}
<portlet:renderURL var="searchURL">
    <portlet:param name="mvcPath" 
    value="/guestbook/view_search.jsp" />
</portlet:renderURL>
\end{verbatim}

  The render URL points to \texttt{/guestbook/view\_search.jsp} (created
  in the next step). You construct the URL first to specify what happens
  when the user submits a search query.
\item
  Right after the render URL, create an AUI form that adds an input
  field for search keywords and a \emph{Submit} button that executes the
  form action, which is mapped to the \texttt{searchURL}.

\begin{verbatim}
<aui:form action="${searchURL}" name="fm">

    <div class="row">
        <div class="col-md-8">
            <aui:input inlineLabel="left" label="" name="keywords" placeholder="search-entries" size="256" />
        </div>

        <div class="col-md-4">
            <aui:button type="submit" value="search" />
        </div>
    </div>

 </aui:form>
\end{verbatim}
\end{enumerate}

The body of the search form consists of a
\texttt{\textless{}div\textgreater{}} with one row containing two
fields: an input field, named \texttt{keywords} and a \emph{Submit}
button. Its \texttt{name="keywords"} attribute specifies the name of the
URL parameter that contains the search query. The
\texttt{\textless{}aui:button\textgreater{}} tag defines the search
button. The \texttt{type="submit"} attribute specifies that when the
button is clicked (or the \emph{Enter} key is pressed), the AUI form is
submitted. The \texttt{value="search"} attribute specifies the name that
appears on the button.

That's all there is to the search form! When the form is submitted, the
\texttt{mvcPath} parameter pointing to the \texttt{view\_search.jsp} is
included in the URL along with the \texttt{keywords} parameter
containing the search query. Next you'll create the
\texttt{view\_search.jsp} file to display the search results.

\chapter{Creating a Search Results JSP for the Guestbook
Portlet}\label{creating-a-search-results-jsp-for-the-guestbook-portlet}

\begin{verbatim}
<p id="stepTitle">Updating Your UI for Search</p><p>Step 2 of 2</p>
\end{verbatim}

There are several design goals to implement in the search results JSP:

\begin{itemize}
\tightlist
\item
  Use a search container to display guestbook entries matching a search
  query.
\item
  Make the Actions button available for each guestbook entry in the
  results, like it is in the main view's search container.
\item
  Include the search bar so that users can edit and resubmit their
  queries without having to click the back link to go to the portlet's
  default view.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search-results.png}
\caption{The search results should appear in a search container, and the
Actions button should appear for each entry. The search bar should also
be displayed.}
\end{figure}

Follow these steps to create the search results JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new file called \texttt{view\_search.jsp} in your
  \texttt{guestbook-web} module's
  \texttt{src/main/resources/META-INF/resources/guestbook} folder. In
  this file, include the \texttt{init.jsp}:

\begin{verbatim}
<%@include file="../init.jsp"%>
\end{verbatim}
\item
  Extract the \texttt{keywords} and \texttt{guestbookId} parameters from
  the request. The \texttt{keywords} parameter contains the search
  query, and the \texttt{guestbookId} parameter contains the ID of the
  guestbook being searched:

\begin{verbatim}
<%
  String keywords = ParamUtil.getString(request, "keywords");
  long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");
%>
\end{verbatim}
\item
  Define the \texttt{searchURL} and \texttt{viewURL} as
  \texttt{renderURL}s. Both use the \texttt{mvcPath} parameter that's
  available to Liferay MVC Portlets:

\begin{verbatim}
<portlet:renderURL var="searchURL">
        <portlet:param name="mvcPath" 
        value="/guestbook/view_search.jsp" />
</portlet:renderURL>

<portlet:renderURL var="viewURL">
    <portlet:param 
        name="mvcPath" 
        value="/guestbook/view.jsp" 
    />
</portlet:renderURL>
\end{verbatim}

  The \texttt{searchURL} points to the current JSP:
  \texttt{view\_search.jsp}. The \texttt{viewURL} points back to the
  Guestbook portlet's main view. These URLs are used in the AUI form
  that you'll create next.
\item
  Add this AUI form:

\begin{verbatim}
<aui:form action="${searchURL}" name="fm">

    <liferay-ui:header backURL="${viewURL}" title="back" />

    <div class="row">
        <div class="col-md-8">
            <aui:input inlineLabel="left" label="" name="keywords" placeholder="search-entries" size="256" />
        </div>

        <div class="col-md-4">
            <aui:button type="submit" value="search" />
        </div>
    </div>
</aui:form>
\end{verbatim}

  This form is identical to the one that you added to the Guestbook
  portlet's \texttt{view.jsp}, except that this one contains a
  \texttt{\textless{}liferay-ui:header\textgreater{}} tag that displays
  the Back icon next to the word \emph{Back}. The \texttt{backURL}
  attribute in the header uses the \texttt{viewURL} defined above.
  Submitting the form invokes the \texttt{searchURL} with the user's
  search query added to the URL in the \texttt{keywords} parameter.
\item
  Start a scriptlet to get a search context and set some attributes in
  it:

\begin{verbatim}
<%
    SearchContext searchContext = SearchContextFactory.getInstance(request);

    searchContext.setKeywords(keywords);
    searchContext.setAttribute("paginationType", "more");
    searchContext.setStart(0);
    searchContext.setEnd(10);
\end{verbatim}

  To execute a search, you need a \texttt{SearchContext} object.
  \texttt{SearchContextFactory} creates a \texttt{SearchContext} from
  the request object. Add the user's search query to the
  \texttt{SearchContext} by passing the \texttt{keywords} URL parameter
  to the \texttt{setKeywords} method. Then specify details about
  pagination and how the search results should be displayed.
\item
  Still in the scriptlet, obtain an \texttt{Indexer} to run a search.
  Retrieve the entry indexer from the map in Liferay DXP's indexer
  registry by passing in the indexer's class or class name:

\begin{verbatim}
Indexer<GuestbookEntry> indexer = IndexerRegistryUtil.getIndexer(GuestbookEntry.class);
\end{verbatim}
\item
  In the same scriptlet, use the indexer and the search context to run a
  search:

\begin{verbatim}
Hits hits = indexer.search(searchContext);

List<GuestbookEntry> entries = new ArrayList<GuestbookEntry>();

for (int i = 0; i < hits.getDocs().length; i++) {
        Document doc = hits.doc(i);

        long entryId = GetterUtil
        .getLong(doc.get(Field.ENTRY_CLASS_PK));

        GuestbookEntry entry = null;

        try {
                entry = GuestbookEntryLocalServiceUtil.getGuestbookEntry(entryId);
        } catch (PortalException pe) {
                _log.error(pe.getLocalizedMessage());
        } catch (SystemException se) {
                _log.error(se.getLocalizedMessage());
        }

        entries.add(entry);
}
\end{verbatim}

  The search results return as \texttt{Hits} objects containing pointers
  to documents that correspond to guestbook entries. You then loop
  through the hit documents, retrieving the corresponding guestbook
  entries and adding them to a list.
\item
  Finish the scriptlet by retrieving a list of all the guestbooks that
  exist in the current site. Create a map between the guestbook IDs and
  the guestbook names.

\begin{verbatim}
    List<Guestbook> guestbooks = GuestbookLocalServiceUtil.getGuestbooks(scopeGroupId);

    Map<String, String> guestbookMap = new HashMap<String, String>();

    for (Guestbook guestbook : guestbooks) {
            guestbookMap.put(Long.toString(guestbook.getGuestbookId()), guestbook.getName());
    }
%>
\end{verbatim}

  Making this single service call and creating a map is more efficient
  than making separate service calls for each guestbook.
\item
  Display the search results in a search container:

\begin{verbatim}
<liferay-ui:search-container delta="10" 
    emptyResultsMessage="no-entries-were-found" 
    total="<%= entries.size() %>">
        <liferay-ui:search-container-results
                results="<%= entries %>"
/>
\end{verbatim}

  This specifies three attributes for the
  \texttt{\textless{}liferay-ui:search-container\textgreater{}} tag:

  \begin{itemize}
  \tightlist
  \item
    \texttt{delta="10"}: specifies that at most, 10 entries can appear
    per page.
  \item
    \texttt{emptyResultsMessage}: specifies the message indicating there
    are no results.
  \item
    \texttt{total}: specifies the number of search results.
  \end{itemize}

  The \texttt{results} attribute of the tag
  \texttt{\textless{}liferay-ui:search-container-results\textgreater{}}
  specifies the search results. This is easy since you stored the
  entries resulting from the search in the \texttt{entries} list.
\item
  Use the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag
  to set the name of the class whose properties are displayed in each
  row:

\begin{verbatim}
<liferay-ui:search-container-row
        className="com.liferay.docs.guestbook.model.GuestbookEntry"
        keyProperty="entryId" modelVar="entry" escapedModel="<%=true%>">
\end{verbatim}

  This uses the \texttt{className} attribute for the class name and
  specifies the entity's primary key attribute in the
  \texttt{keyProperty} attribute. The \texttt{modelVar} property
  specifies the name of the \texttt{Entry} variable that's available to
  each search container row. To ensure that each field of the
  \texttt{entry} variable is escaped (sanitized), the
  \texttt{escapedModel} is \texttt{true}. This prevents potential hacks
  that could occur if users submitted malicious code into the Add
  Guestbook form, for example.
\item
  Inside the
  \texttt{\textless{}liferay-ui:search-container-row\textgreater{}} tag,
  specify the four columns to display: the guestbook entry's guestbook
  name, message, entry name, and the actions JSP. The guestbook name is
  retrieved from the map created in the scriptlet:

\begin{verbatim}
    <liferay-ui:search-container-column-text name="guestbook"
        value="<%=guestbookMap.get(Long.toString(entry.getGuestbookId()))%>" />

    <liferay-ui:search-container-column-text property="message" />

    <liferay-ui:search-container-column-text property="name" />

    <liferay-ui:search-container-column-jsp
        path="/guestbook/entry_actions.jsp"
        align="right" />
</liferay-ui:search-container-row>
\end{verbatim}
\item
  Use the \texttt{\textless{}liferay-ui:search-iterator\textgreater{}}
  tag to iterate through the search results and handle pagination. Close
  the search container tag:

\begin{verbatim}
        <liferay-ui:search-iterator />
</liferay-ui:search-container>
\end{verbatim}
\item
  At the bottom of \texttt{view\_search.jsp}, declare a \texttt{Log}
  object. You used this log in the \texttt{catch} clauses of the
  \texttt{try} clause that calls the
  \texttt{GuestbookEntryLocalServiceUtil.getGuestbookEntry} method to
  retrieve the guestbook entries. If this service call throws an
  exception, it's best to log the error so a server administrator can
  determine what went wrong. Liferay DXP's convention is to declare
  custom logs for individual classes or JSPs at the bottom of the file:

\begin{verbatim}
<%!
    private static Log _log = LogFactoryUtil.getLog("html.guestbook.view_search_jsp");
%>
\end{verbatim}
\item
  Finally, your \texttt{view\_search.jsp} requires some extra imports.
  Add the following imports to \texttt{init.jsp}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.dao.search.SearchContainer" %>
<%@ page import="com.liferay.portal.kernel.exception.PortalException" %>
<%@ page import="com.liferay.portal.kernel.exception.SystemException" %>
<%@ page import="com.liferay.portal.kernel.language.LanguageUtil" %>
<%@ page import="com.liferay.portal.kernel.log.Log" %>
<%@ page import="com.liferay.portal.kernel.log.LogFactoryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.Indexer" %>
<%@ page import="com.liferay.portal.kernel.search.IndexerRegistryUtil" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContext" %>
<%@ page import="com.liferay.portal.kernel.search.SearchContextFactory" %>
<%@ page import="com.liferay.portal.kernel.search.Hits" %>
<%@ page import="com.liferay.portal.kernel.search.Document" %>
<%@ page import="com.liferay.portal.kernel.search.Field" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
<%@ page import="com.liferay.portal.kernel.util.Validator" %>
<%@ page import="com.liferay.portal.kernel.util.PortalUtil" %>

<%@ page import="java.util.ArrayList" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.HashMap" %>

<%@ page import="javax.portlet.PortletURL" %>
\end{verbatim}
\end{enumerate}

Good work! The Guestbook portlet now supports search! Now your users can
find those Guestbook Entries they were looking for.

\begin{figure}
\centering
\includegraphics{./images/guestbook-portlet-search-conclusion.png}
\caption{The Guestbook Application now supports searching for indexed
Guestbook Entries.}
\end{figure}

As before, remove the \texttt{hypersonic} folder from the \texttt{data}
folder of your Liferay bundle, and remove the modules from your server
in Dev Studio DXP. Start your server and redeploy all three modules, add
some Guestbook entries, and try searching for them.

Once indexing is in place, the asset framework can be added to the
Guestbook application. It provides functionality that's shared across
different types of content like blog posts, message board posts, wiki
articles, and more. This is the heart of integration with Liferay DXP's
development platform.

\chapter{Assets: Integrating with Liferay's
Framework}\label{assets-integrating-with-liferays-framework}

The asset framework transforms entities into a common format that can be
published anywhere in your Site. Web content articles, blog posts, wiki
articles, and documents are some asset-enabled entities that come
out-of-the-box. By asset-enabling your own applications, you can take
advantage of Liferay DXP's functionality for publishing your
application's data across your Site in the form of asset publisher
entries, notifications, social activities, and more.

The asset framework includes these features:

\begin{itemize}
\tightlist
\item
  Tags and categories
\item
  Comments and ratings
\item
  Related assets (a.k.a. Asset links)
\item
  Faceted search
\item
  Integration with the Asset Publisher portlet
\item
  Integration with the Search portlet
\item
  Integration with the Tags Navigation, Tag Cloud, and Categories
  Navigation portlets
\end{itemize}

Now you'll asset-enable the guestbook and guestbook entry entities.
You'll implement tags, categories, and related assets for guestbooks and
guestbook entries. You'll implement comments and ratings in guestbook
entries. You'll also learn how asset-enabled guestbooks and guestbook
entries integrate with core portlets like the Asset Publisher, Tags
Navigation, Tag Cloud, and Categories Navigation portlets.

As always,
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/guestbook/09-assets/com-liferay-docs-guestbook}{source
code} is provided in case you get stuck.

Ready to start?

Let's Go!{}

\chapter{Enabling Assets at the Service
Layer}\label{enabling-assets-at-the-service-layer}

\begin{verbatim}
<p>Enabling Assets at the Service Layer</p><p>Step 1 of 3</p>
\end{verbatim}

Each row in the \texttt{AssetEntry} table represents an asset. It has an
\texttt{entryId} primary key along with \texttt{classNameId} and
\texttt{classPK} foreign keys. The \texttt{classNameId} specifies the
asset's type. For example, an asset with a \texttt{classNameId} of
\texttt{JournalArticle} means that the asset represents a web content
article (\texttt{JournalArticle} is the back-end name for a web content
article). An asset's \texttt{classPK} is the primary key of the entity
represented by the asset.

Follow these steps to make asset services available to your entities'
service layers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-service} module's \texttt{service.xml} file,
  add the following references directly above the closing
  \texttt{\textless{}/entity\textgreater{}} tags for \texttt{Guestbook}
  and \texttt{GuestbookEntry}:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}

  As mentioned above, you must use the \texttt{AssetEntry} service so
  your application can add asset entries corresponding to guestbooks and
  guestbook entries. You also use the \texttt{AssetLink} service to
  support related assets. \emph{Asset links} are Liferay DXP's back-end
  term for related assets.
\item
  You must add finders---two for \texttt{Guestbook}s and two for
  \texttt{GuestbookEntry}s---so your assets show in Asset Publisher,
  because it searches for entities by \texttt{status} (i.e., is it
  Workflow-approved?) and by \texttt{groupId} (i.e., is it in this
  Site?). Add these below the existing finders for the
  \texttt{Guestbook} and \texttt{GuestbookEntry} entities:

\begin{verbatim}
<finder name="Status" return-type="Collection">
    <finder-column name="status" />
</finder>

<finder name="G_S" return-type="Collection">
    <finder-column name="groupId" />
    <finder-column name="status" />
</finder>
\end{verbatim}
\item
  Run the \texttt{buildService} Gradle task. This task injects the
  objects referenced above into your services for use.
\item
  Right-click \texttt{build.gradle} and select \emph{Gradle} →
  \emph{Refresh Gradle Project}.
\end{enumerate}

Great! Next, you'll handle assets in your service layer.

\chapter{Handling Assets for the Guestbook
Service}\label{handling-assets-for-the-guestbook-service}

\begin{verbatim}
<p id="stepTitle">Enabling Assets at the Service Layer</p><p>Step 2 of 3</p>
\end{verbatim}

Before you can update the Service Layer to add the Asset Renderers, you
must update your \texttt{build.gradle} to provide the
\texttt{portlet-api} and \texttt{javax.servlet-api} libraries that the
asset link service needs to function.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{build.gradle} file in your \texttt{guestbook-service}
  module.
\item
  Add the following two lines in the \texttt{dependencies} section:

\begin{verbatim}
compileOnly group: "javax.portlet", name: "portlet-api"
compileOnly group: "javax.servlet", name: "javax.servlet-api"
\end{verbatim}
\item
  Save your \texttt{build.gradle} file, which refreshes your project.
\end{enumerate}

Now you'll update the guestbook service layer to use assets. You must
update the \texttt{add}, \texttt{update}, and \texttt{delete} methods of
your project's \texttt{GuestbookLocalServiceImpl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{GuestbookLocalServiceImpl} class and find
  the \texttt{addGuestbook} method. Add the call to add the asset
  entries below the call that adds resources:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                  groupId, guestbook.getCreateDate(),
                  guestbook.getModifiedDate(), Guestbook.class.getName(),
                  guestbookId, guestbook.getUuid(), 0,
                  serviceContext.getAssetCategoryIds(),
                  serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                  ContentTypes.TEXT_HTML, guestbook.getName(), null, null, null,
                  null, 0, 0, null);

assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                  serviceContext.getAssetLinkEntryIds(),
                  AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Calling \texttt{assetEntryLocalService.updateEntry} adds a new row
  (corresponding to the guestbook that's being added) to the
  \texttt{AssetEntry} table in Liferay DXP's database.
  \texttt{AssetEntryLocalServiceImpl}'s \texttt{updateEntry} method both
  adds and updates asset entries because it checks to see whether the
  asset entry already exists in the database and then takes the
  appropriate action. If you check the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html}{Javadoc}
  for \texttt{AssetEntryLocalServiceUtil.updateEntry}, you'll see that
  this method is overloaded. Now, why did you use a version of this
  method with such a long method signature? Because there's only one
  version of \texttt{updateEntry} that takes a \texttt{title} parameter
  (to set the asset entry's title). Since you want to set the asset
  title to \texttt{guestbook.getName()}, that's the version you use.

  Later, you'll update the Guestbook Admin portlet's form for adding
  guestbooks to allow the selection of related assets, which are stored
  in the database's \texttt{AssetLink} table. The
  \texttt{assetLinkLocalService.updateLinks} call adds the appropriate
  entries to the table so related assets work for your guestbook
  entities. The \texttt{updateEntry} method adds and updates asset
  entries the same way \texttt{updateLink} adds and updates asset links.
\item
  Next, add the asset calls to \texttt{GuestbookLocalServiceImpl}'s
  \texttt{updateGuestbook} method, directly after the resource call:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(guestbook.getUserId(),
                  guestbook.getGroupId(), guestbook.getCreateDate(),
                  guestbook.getModifiedDate(), Guestbook.class.getName(),
                  guestbookId, guestbook.getUuid(), 0,
                  serviceContext.getAssetCategoryIds(),
                  serviceContext.getAssetTagNames(), true, true, guestbook.getCreateDate(), 
                  null, null, null, ContentTypes.TEXT_HTML, guestbook.getName(), null, null, 
                  null, null, 0, 0, serviceContext.getAssetPriority());

assetLinkLocalService.updateLinks(serviceContext.getUserId(),
                  assetEntry.getEntryId(), serviceContext.getAssetLinkEntryIds(),
                  AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  Here, \texttt{assetEntryLocalService.updateEntry} updates an existing
  asset entry and \texttt{assetLinkLocalService.updateLinks} adds or
  updates that entry's asset links (related assets).
\item
  Next, add the asset calls to the \texttt{deleteGuestbook} method,
  directly after the resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                  Guestbook.class.getName(), guestbookId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}

  Here, you use the guestbook's class name and ID to retrieve the
  corresponding asset entry. Then you delete that asset entry's asset
  links and the asset entry itself.
\item
  Finally, organize your imports, save the file, and run Service Builder
  to apply the changes.
\end{enumerate}

Next, you'll do the same thing for guestbook entries.

\chapter{Handling Assets for the GuestbookEntry
Service}\label{handling-assets-for-the-guestbookentry-service}

\begin{verbatim}
<p id="stepTitle">Enabling Assets at the Service Layer</p><p>Step 3 of 3</p>
\end{verbatim}

Now you must update the guestbook entry entity's service methods. In
these methods, the calls you'll make to \texttt{assetEntryLocalService}
and \texttt{assetLinkLocalService} are identical to the ones you made in
the guestbook entity's service methods, except you're specifying assets
for \texttt{GuestbookEntry} entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookEntryLocalServiceImpl} and add the asset calls
  to the \texttt{addGuestbookEntry} method after the resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
                  groupId, entry.getCreateDate(), entry.getModifiedDate(),
                  GuestbookEntry.class.getName(), entryId, entry.getUuid(), 0,
                  serviceContext.getAssetCategoryIds(),
                  serviceContext.getAssetTagNames(), true, true, null, null, null, null,
                  ContentTypes.TEXT_HTML, entry.getMessage(), null, null, null,
                  null, 0, 0, null);

assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
                  serviceContext.getAssetLinkEntryIds(),
                  AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Next, add the asset calls to the \texttt{updateGuestbookEntry} method
  after the resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(userId,
              serviceContext.getScopeGroupId(),
              entry.getCreateDate(), entry.getModifiedDate(),
              GuestbookEntry.class.getName(), entryId, entry.getUuid(),
              0, serviceContext.getAssetCategoryIds(),
              serviceContext.getAssetTagNames(), true, true,
              entry.getCreateDate(), null, null, null,
              ContentTypes.TEXT_HTML, entry.getMessage(), null,
              null, null, null, 0, 0,
              serviceContext.getAssetPriority());

assetLinkLocalService.updateLinks(userId, assetEntry.getEntryId(),
              serviceContext.getAssetLinkEntryIds(),
              AssetLinkConstants.TYPE_RELATED);
\end{verbatim}
\item
  Add the asset calls to the \texttt{deleteGuestbookEntry} method after
  the resource calls:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
                      GuestbookEntry.class.getName(), entry.getEntryId());

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());

assetEntryLocalService.deleteEntry(assetEntry);
\end{verbatim}
\item
  Organize your imports, save the file, and run Service Builder.
\item
  Finally, add these language keys to the
  \texttt{guestbook-web/src/main/resources/content/Language.properties}
  file:

\begin{verbatim}
model.resource.com.liferay.docs.guestbook.model.Guestbook=Guestbook
model.resource.com.liferay.docs.guestbook.model.GuestbookEntry=Guestbook Entry
\end{verbatim}
\end{enumerate}

Excellent! You've asset-enabled your guestbook and guestbook entry
entities at the service layer. Your next step is to implement asset
renderers for these entities so they can be fully integrated into the
asset framework. Every asset needs an asset renderer class so the Asset
Publisher portlet can display it.

\chapter{Implementing Asset
Renderers}\label{implementing-asset-renderers}

Assets are display versions of entities, so they contain fields like
\texttt{title}, \texttt{description}, and \texttt{summary}. Liferay DXP
uses these fields to display assets. Asset Renderers translate an entity
into an asset via these fields. You must therefore create and register
Asset Renderer classes for your guestbook and guestbook entry entities.
Without these classes, Liferay DXP can't display your entities in Asset
Publisher, Notifications, Activities, or anywhere else that displays
assets.

Your next task is to create these Asset Renderers. Ready to begin?

Let's Go!{}

\chapter{Implementing a Guestbook Asset
Renderer}\label{implementing-a-guestbook-asset-renderer}

\begin{verbatim}
<p id="stepTitle">Implementing Asset Renderers</p><p>Step 1 of 2</p>
\end{verbatim}

Liferay DXP's asset renderers follow the factory pattern, so you must
create a \texttt{GuestbookAssetRendererFactory} that instantiates the
\texttt{GuestbookAssetRenderer}'s private guestbook object. Here, you'll
create both classes.

You'll create the Asset Renderer class first.

\section{Creating the AssetRenderer
Class}\label{creating-the-assetrenderer-class}

Follow these steps to create the \texttt{GuestbookAssetRenderer} class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package called
  \texttt{com.liferay.docs.guestbook.web.internal.asset} in the
  \texttt{guestbook-web} module's \texttt{src/main/java} folder. In this
  package, create a \texttt{GuestbookAssetRenderer} class that extends
  Liferay DXP's \texttt{BaseJSPAssetRenderer} class. Extending this
  class gives you a head-start on implementing the
  \texttt{AssetRenderer} interface:

\begin{verbatim}
public class GuestbookAssetRenderer extends BaseJSPAssetRenderer<Guestbook> {

}
\end{verbatim}
\item
  Add the constructor, the guestbook class variable, and the permissions
  model resource. Most of the methods in this class are getters that
  return fields from the private \texttt{\_guestbook} object. Methods
  requiring a permission check use
  \texttt{\_guestbookModelResourcePermission}:

\begin{verbatim}
public GuestbookAssetRenderer(Guestbook guestbook, ModelResourcePermission<Guestbook> modelResourcePermission) {

            _guestbook = guestbook;
            _guestbookModelResourcePermission = modelResourcePermission;
}

// Add the other methods here

private Guestbook _guestbook;
private final ModelResourcePermission<Guestbook> _guestbookModelResourcePermission;   
private Logger logger = Logger.getLogger(this.getClass().getName());
\end{verbatim}
\item
  The \texttt{BaseJSPAssetRenderer} abstract class that you're extending
  contains dummy implementations of the \texttt{hasEditPermission} and
  \texttt{hasViewPermission} methods that you must override with actual
  permission checks using the permissions resources that you created
  earlier. Add these methods below the comment labeled
  \texttt{Add\ the\ other\ methods\ here}:

\begin{verbatim}
@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) 
{
    try {
        return _guestbookModelResourcePermission.contains(
            permissionChecker, _guestbook, ActionKeys.UPDATE);
    }
    catch (Exception e) {
    }

    return false;
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) 
{
    try {
        return _guestbookModelResourcePermission.contains(
            permissionChecker, _guestbook, ActionKeys.VIEW);
    }
    catch (Exception e) {
    }

    return true;
}
\end{verbatim}
\item
  Add the following getter methods to retrieve information about the
  guestbook asset:

\begin{verbatim}
@Override
public Guestbook getAssetObject() {
  return _guestbook;
}

@Override
public long getGroupId() {
  return _guestbook.getGroupId();
}

@Override
public long getUserId() {

  return _guestbook.getUserId();
}

@Override
public String getUserName() {
  return _guestbook.getUserName();
}

@Override
public String getUuid() {
  return _guestbook.getUuid();
}

@Override
public String getClassName() {
  return Guestbook.class.getName();
}

@Override
public long getClassPK() {
  return _guestbook.getGuestbookId();
}

@Override
public String getSummary(PortletRequest portletRequest, PortletResponse 
  portletResponse) {
    return "Name: " + _guestbook.getName();
}

@Override
public String getTitle(Locale locale) {
  return _guestbook.getName();
}

@Override
public boolean include(HttpServletRequest request, HttpServletResponse 
  response, String template) throws Exception {
    request.setAttribute("GUESTBOOK", _guestbook);
    request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
    request.setAttribute("StringUtil", new StringUtil());
    return super.include(request, response, template);
}
\end{verbatim}

  The final method makes several utilities and the \texttt{Guestbook}
  entity available in the \texttt{HttpServletRequest} object.
\item
  Override the \texttt{getJspPath} method. It returns a string
  representing the path to the JSP that renders the guestbook asset.
  When the Asset Publisher displays an asset's full content, it invokes
  the asset renderer class's \texttt{getJspPath} method and passes a
  \texttt{template} string parameter that equals
  \texttt{"full\_content"}. This returns
  \texttt{/asset/guestbook/full\_content.jsp} when the
  \texttt{full\_content} template string is passed as a parameter.
  You'll create this JSP later when updating your application's user
  interface:

\begin{verbatim}
@Override
public String getJspPath(HttpServletRequest request, String template) {

    if (template.equals(TEMPLATE_FULL_CONTENT)) {
      request.setAttribute("gb_guestbook", _guestbook);

      return "/asset/guestbook/" + template + ".jsp";
    } else {
      return null;
    }
}
\end{verbatim}
\item
  Override the \texttt{getURLEdit} method. This method returns a URL for
  editing the asset:

  @Override public PortletURL getURLEdit(LiferayPortletRequest
  liferayPortletRequest, LiferayPortletResponse liferayPortletResponse)
  throws Exception \{

\begin{verbatim}
PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
    getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
    PortletRequest.RENDER_PHASE);
portletURL.setParameter("mvcPath", "/guestbook/edit_guestbook.jsp");
portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));
portletURL.setParameter("showback", Boolean.FALSE.toString());

return portletURL;
\end{verbatim}

  \}
\item
  Override the \texttt{getURLViewInContext} method. This method returns
  a URL to view the asset in its native application:

\begin{verbatim}
@Override
public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
  LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) throws Exception {
    try {
      long plid = PortalUtil.getPlidFromPortletId(_guestbook.getGroupId(),
          GuestbookPortletKeys.GUESTBOOK);

      PortletURL portletURL;
      if (plid == LayoutConstants.DEFAULT_PLID) {
        portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
            GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
      } else {
        portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
            GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
      }

      portletURL.setParameter("mvcPath", "/guestbook/view.jsp");
      portletURL.setParameter("guestbookId", String.valueOf(_guestbook.getGuestbookId()));

      String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

      portletURL.setParameter("redirect", currentUrl);

      return portletURL.toString();

    } catch (PortalException e) {

        logger.log(Level.SEVERE, e.getMessage());

    } catch (SystemException e) {

        logger.log(Level.SEVERE, e.getMessage());

    }

    return noSuchEntryRedirect;
}
\end{verbatim}
\item
  Override the \texttt{getURLView} method. This method returns a URL to
  view the asset from within the Asset Publisher:

\begin{verbatim}
@Override
public String getURLView(LiferayPortletResponse liferayPortletResponse, 
WindowState windowState) throws Exception {

    return super.getURLView(liferayPortletResponse, windowState);
}
\end{verbatim}
\item
  Organize imports (Ctrl-Shift-O) and save the file. Choose these
  imports:
\end{enumerate}

\begin{verbatim}
- `java.util.logging.Logger` 
- `com.liferay.portal.kernel.exception.SystemException` 
- `java.util.logging.Level` 
- `com.liferay.petra.string.StringUtil`
\end{verbatim}

Next you can create the \texttt{AssetRendererFactory} class.

\section{Creating the GuestbookAssetRendererFactory
Class}\label{creating-the-guestbookassetrendererfactory-class}

Follow these steps to create the \texttt{GuestbookAssetRendererFactory}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{com.liferay.docs.guestbook.web.internal.asset} package,
  create a class called \texttt{GuestbookAssetRendererFactory} that
  extends Liferay DXP's \texttt{BaseAssetRendererFactory} class, and
  overwrite the generated constructor and class variables with this:

\begin{verbatim}
@Component(immediate = true, 
  property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK}, 
  service = AssetRendererFactory.class
  )
public class GuestbookAssetRendererFactory extends 
  BaseAssetRendererFactory<Guestbook> {

  public GuestbookAssetRendererFactory() {
    setClassName(CLASS_NAME);
    setLinkable(_LINKABLE);
    setPortletId(GuestbookPortletKeys.GUESTBOOK); setSearchable(true);
    setSelectable(true); 
  }         

  // Add the other methods here

  private ServletContext _servletContext;
  private GuestbookLocalService _guestbookLocalService;
  private static final boolean _LINKABLE = true;
  public static final String CLASS_NAME = Guestbook.class.getName();
  public static final String TYPE = "guestbook";
  private Logger logger = Logger.getLogger(this.getClass().getName());
  private ModelResourcePermission<Guestbook> _guestbookModelResourcePermission;
}
\end{verbatim}

  This code contains the class declaration, the constructor, and the
  class variables. It sets the class name it creates an
  \texttt{AssetRenderer} for, a portlet ID, and a \texttt{true} boolean
  (\texttt{\_LINKABLE}). The boolean denotes implemented methods that
  provide URLs in the generated \texttt{AssetRenderer}.

  Insert the methods below where you see the comment
  \texttt{Add\ the\ other\ methods\ here}.
\item
  Implement the \texttt{getAssetRenderer} method, which constructs new
  \texttt{GuestbookAssetRenderer} instances for particular guestbooks.
  It uses the \texttt{classPK} (primary key) parameter to retrieve the
  guestbook from the database. It then calls the
  \texttt{GuestbookAssetRenderer}'s constructor, passing the retrieved
  guestbook and permissions resource model as arguments:

\begin{verbatim}
@Override
public AssetRenderer<Guestbook> getAssetRenderer(long classPK, int type) 
throws PortalException {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);

  GuestbookAssetRenderer guestbookAssetRenderer = 
  new GuestbookAssetRenderer(guestbook, _guestbookModelResourcePermission);

  guestbookAssetRenderer.setAssetRendererType(type);
  guestbookAssetRenderer.setServletContext(_servletContext);

  return guestbookAssetRenderer;
}
\end{verbatim}
\item
  You're extending \texttt{BaseAssetRendererFactory}, an abstract class
  that implements the \texttt{AssetRendererFactory} interface. To ensure
  that your custom asset is associated with the correct entity, each
  asset renderer factory must implement the \texttt{getClassName} and
  \texttt{getType} methods (among others):

\begin{verbatim}
@Override
public String getClassName() {
    return CLASS_NAME;
}

@Override
public String getType() {
    return TYPE;
}
\end{verbatim}
\item
  Implement the \texttt{hasPermission} method via the
  \texttt{GuestbookPermission} class:

\begin{verbatim}
@Override
public boolean hasPermission(PermissionChecker permissionChecker, 
long classPK, String actionId) throws Exception {

  Guestbook guestbook = _guestbookLocalService.getGuestbook(classPK);
  long groupId = guestbook.getGroupId();
  return GuestbookPermission.contains(permissionChecker, groupId, 
  actionId);
}
\end{verbatim}
\item
  Add the remaining code to create the portlet URL for the asset and
  specify whether it's linkable:

\begin{verbatim}
@Override
public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
  LiferayPortletResponse liferayPortletResponse, long classTypeId) {
    PortletURL portletURL = null;

    try {
      ThemeDisplay themeDisplay = (ThemeDisplay) 
      liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

      portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
          GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
      portletURL.setParameter("mvcPath", "/guestbook/edit_guestbook.jsp");
      portletURL.setParameter("showback", Boolean.FALSE.toString());

      } catch (PortalException e) {

            logger.log(Level.SEVERE, e.getMessage()); 

      }

    return portletURL;
}

@Override
public boolean isLinkable() {
    return _LINKABLE;
}

@Override
public String getIconCssClass() {
  return "bookmarks";
}

@Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
    unbind = "-")
public void setServletContext(ServletContext servletContext) {
    _servletContext = servletContext;
}

@Reference(unbind = "-")
protected void setGuestbookLocalService(GuestbookLocalService guestbookLocalService) {
    _guestbookLocalService = guestbookLocalService; 
}
\end{verbatim}
\item
  Organize imports (Ctrl-Shift-O) and save the file. Select these
  imports:

  \begin{itemize}
  \tightlist
  \item
    \texttt{java.util.logging.Logger}
  \item
    \texttt{java.util.logging.Level}
  \end{itemize}
\end{enumerate}

Great! The guestbook asset renderer is complete. Next, you'll create the
entry asset renderer.

\chapter{Implementing a Guestbook Entry Asset
Renderer}\label{implementing-a-guestbook-entry-asset-renderer}

\begin{verbatim}
<p id="stepTitle">Implementing Asset Renderers</p><p>Step 2 of 2</p>
\end{verbatim}

The classes you'll create here are nearly identical to the
\texttt{GuestbookAssetRenderer} and
\texttt{GuestbookAssetRendererFactory} classes you created for
guestbooks in the previous step. This step provides the code needed for
guestbook entries. Please review the previous sections to learn how this
code works.

\section{Creating the GuestbookEntryAssetRenderer
Class}\label{creating-the-guestbookentryassetrenderer-class}

In the \texttt{com.liferay.docs.guestbook.web.internal.asset} package,
create a \texttt{GuestbookEntryAssetRenderer} class that extends Liferay
DXP's \texttt{BaseJSPAssetRenderer} class. Replace the contents of your
\texttt{GuestbookEntryAssetRenderer} class with the following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.internal.asset;

import com.liferay.asset.kernel.model.BaseJSPAssetRenderer;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.model.LayoutConstants;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.PortletURLFactoryUtil;
import com.liferay.portal.kernel.security.permission.ActionKeys;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.util.HtmlUtil;
import com.liferay.portal.kernel.util.PortalUtil;
import com.liferay.petra.string.StringUtil;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.GuestbookEntry;
import java.util.Locale;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class GuestbookEntryAssetRenderer extends BaseJSPAssetRenderer<GuestbookEntry> {

    public GuestbookEntryAssetRenderer(GuestbookEntry entry, ModelResourcePermission<GuestbookEntry> modelResourcePermission) {

        _entry = entry;
        _guestbookEntryModelResourcePermission = modelResourcePermission;
    }

    @Override
    public boolean hasViewPermission(PermissionChecker permissionChecker) 
    {
        try {
            return _guestbookEntryModelResourcePermission.contains(
                    permissionChecker, _entry, ActionKeys.VIEW);
        }
        catch (Exception e) {
        }

        return true;
    }

    @Override
    public GuestbookEntry getAssetObject() {
        return _entry;
    }

    @Override
    public long getGroupId() {
        return _entry.getGroupId();
    }

    @Override
    public long getUserId() {

        return _entry.getUserId();
    }

    @Override
    public String getUserName() {
        return _entry.getUserName();
    }

    @Override
    public String getUuid() {
        return _entry.getUuid();
    }

    @Override
    public String getClassName() {
        return GuestbookEntry.class.getName();
    }

    @Override
    public long getClassPK() {
        return _entry.getEntryId();
    }

    @Override
    public String getSummary(PortletRequest portletRequest, 
            PortletResponse portletResponse) {
        return "Name: " + _entry.getName() + ". Message: " + _entry.getMessage();
    }

    @Override
    public String getTitle(Locale locale) {
        return _entry.getMessage();
    }

    @Override
    public boolean include(HttpServletRequest request, 
            HttpServletResponse response, String template) throws Exception {
        request.setAttribute("ENTRY", _entry);
        request.setAttribute("HtmlUtil", HtmlUtil.getHtml());
        request.setAttribute("StringUtil", new StringUtil());
        return super.include(request, response, template);
    }

    @Override
    public String getJspPath(HttpServletRequest request, String template) {

        if (template.equals(TEMPLATE_FULL_CONTENT)) {
            request.setAttribute("gb_entry", _entry);

            return "/asset/entry/" + template + ".jsp";
        } else {
            return null;
        }
    }

    @Override
    public PortletURL getURLEdit(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse) throws Exception {
        PortletURL portletURL = liferayPortletResponse.createLiferayPortletURL(
                getControlPanelPlid(liferayPortletRequest), GuestbookPortletKeys.GUESTBOOK,
                PortletRequest.RENDER_PHASE);
        portletURL.setParameter("mvcPath", "/guestbook/edit_entry.jsp");
        portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
        portletURL.setParameter("showback", Boolean.FALSE.toString());

        return portletURL;
    }

    @Override
    public String getURLViewInContext(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse, String noSuchEntryRedirect) 
                    throws Exception {
        try {
            long plid = PortalUtil.getPlidFromPortletId(_entry.getGroupId(),
                    GuestbookPortletKeys.GUESTBOOK);

            PortletURL portletURL;
            if (plid == LayoutConstants.DEFAULT_PLID) {
                portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(liferayPortletRequest),
                        GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
            } else {
                portletURL = PortletURLFactoryUtil.create(liferayPortletRequest,
                        GuestbookPortletKeys.GUESTBOOK, plid, PortletRequest.RENDER_PHASE);
            }

            portletURL.setParameter("mvcPath", "/guestbook/view_entry.jsp");
            portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

            String currentUrl = PortalUtil.getCurrentURL(liferayPortletRequest);

            portletURL.setParameter("redirect", currentUrl);

            return portletURL.toString();

        } catch (PortalException e) {

        } catch (SystemException e) {
        }

        return noSuchEntryRedirect;
    }

    @Override
    public String getURLView(LiferayPortletResponse liferayPortletResponse, 
            WindowState windowState) throws Exception {

        return super.getURLView(liferayPortletResponse, windowState);
    }

    @Override
    public boolean isPrintable() {
        return true;
    }
    private final ModelResourcePermission<GuestbookEntry> _guestbookEntryModelResourcePermission;
    private GuestbookEntry _entry;
}
\end{verbatim}

This class is similar to the \texttt{GuestbookAssetRenderer} class. For
the \texttt{GuestbookEntryAssetRenderer.getSummary} method, you return a
summary that displays the entry name (the name of the user who created
the entry) and the entry message.

\texttt{GuestbookAssetRenderer.getSummary} returns a summary that
displays the guestbook name.
\texttt{GuestbookEntryAssetRenderer.getTitle} returns the entry message.
\texttt{GuestbookAssetRenderer.getTitle} returns the guestbook name. The
other methods of \texttt{GuestbookEntryAssetRenderer} are nearly
identical to those of \texttt{GuestbookAssetRenderer}.

\section{Creating the GuestbookEntryAssetRendererFactory
Class}\label{creating-the-guestbookentryassetrendererfactory-class}

Next, you must create the guestbook entry asset renderer's factory
class. In the \texttt{com.liferay.docs.guestbook.web.internal.asset}
package, create a class called
\texttt{GuestbookEntryAssetRendererFactory} that extends Liferay DXP's
\texttt{BaseAssetRendererFactory} class. Replace its content with the
following code:

\begin{verbatim}
package com.liferay.docs.guestbook.web.internal.asset;

import com.liferay.asset.kernel.model.AssetRenderer;
import com.liferay.asset.kernel.model.AssetRendererFactory;
import com.liferay.asset.kernel.model.BaseAssetRendererFactory;
import com.liferay.docs.guestbook.constants.GuestbookPortletKeys;
import com.liferay.docs.guestbook.model.GuestbookEntry;
import com.liferay.docs.guestbook.service.GuestbookEntryLocalService;
import com.liferay.docs.guestbook.web.internal.security.permission.resource.GuestbookEntryPermission;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.portlet.LiferayPortletRequest;
import com.liferay.portal.kernel.portlet.LiferayPortletResponse;
import com.liferay.portal.kernel.portlet.LiferayPortletURL;
import com.liferay.portal.kernel.security.permission.PermissionChecker;
import com.liferay.portal.kernel.security.permission.resource.ModelResourcePermission;
import com.liferay.portal.kernel.theme.ThemeDisplay;
import com.liferay.portal.kernel.util.WebKeys;

import javax.portlet.PortletRequest;
import javax.portlet.PortletURL;
import javax.portlet.WindowState;
import javax.portlet.WindowStateException;
import javax.servlet.ServletContext;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
        immediate = true,
        property = {"javax.portlet.name=" + GuestbookPortletKeys.GUESTBOOK},
        service = AssetRendererFactory.class
        )
public class GuestbookEntryAssetRendererFactory extends BaseAssetRendererFactory<GuestbookEntry> {

    public GuestbookEntryAssetRendererFactory() {
        setClassName(CLASS_NAME);
        setLinkable(_LINKABLE);
        setPortletId(GuestbookPortletKeys.GUESTBOOK);
        setSearchable(true);
        setSelectable(true);

    }

    @Override
    public AssetRenderer<GuestbookEntry> getAssetRenderer(long classPK, int type)
            throws PortalException {

        GuestbookEntry entry = _guestbookEntryLocalService.getGuestbookEntry(classPK);

        GuestbookEntryAssetRenderer guestbookEntryAssetRenderer = new GuestbookEntryAssetRenderer(entry, _guestbookEntryModelResourcePermission);

        guestbookEntryAssetRenderer.setAssetRendererType(type);
        guestbookEntryAssetRenderer.setServletContext(_servletContext);

        return guestbookEntryAssetRenderer;
    }

    @Override
    public String getClassName() {
        return CLASS_NAME;
    }

    @Override
    public String getType() {
        return TYPE;
    }

    @Override
    public boolean hasPermission(PermissionChecker permissionChecker,
            long classPK, String actionId) throws Exception {

        GuestbookEntry entry = _guestbookEntryLocalService.getGuestbookEntry(classPK);
        return GuestbookEntryPermission.contains(permissionChecker, entry, actionId);
    }

    @Override
    public PortletURL getURLAdd(LiferayPortletRequest liferayPortletRequest,
            LiferayPortletResponse liferayPortletResponse, long classTypeId) {

        PortletURL portletURL = null;

        try {
            ThemeDisplay themeDisplay = (ThemeDisplay) liferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY);

            portletURL = liferayPortletResponse.createLiferayPortletURL(getControlPanelPlid(themeDisplay),
                    GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);
            portletURL.setParameter("mvcRenderCommandName", "/guestbook/edit_entry");
            portletURL.setParameter("showback", Boolean.FALSE.toString());
        } catch (PortalException e) {
        }

        return portletURL;
    }

    @Override
    public PortletURL getURLView(LiferayPortletResponse liferayPortletResponse, WindowState windowState) {

        LiferayPortletURL liferayPortletURL
        = liferayPortletResponse.createLiferayPortletURL(
                GuestbookPortletKeys.GUESTBOOK, PortletRequest.RENDER_PHASE);

        try {
            liferayPortletURL.setWindowState(windowState);
        } catch (WindowStateException wse) {

        }
        return liferayPortletURL;
    }

    @Override
    public boolean isLinkable() {
        return _LINKABLE;
    }

    @Override
    public String getIconCssClass() {
        return "pencil";
    }

    @Reference(target = "(osgi.web.symbolicname=com.liferay.docs.guestbook.portlet)",
            unbind = "-")
    public void setServletContext (ServletContext servletContext) {
        _servletContext = servletContext;
    }

    @Reference(unbind = "-")
    protected void setGuestbookEntryLocalService(GuestbookEntryLocalService guestbookEntryLocalService) {
        _guestbookEntryLocalService = guestbookEntryLocalService;
    }


    private GuestbookEntryLocalService _guestbookEntryLocalService;
    private ServletContext _servletContext;
    private static final boolean _LINKABLE = true;
    public static final String CLASS_NAME = GuestbookEntry.class.getName();
    public static final String TYPE = "entry";

    private ModelResourcePermission<GuestbookEntry>
    _guestbookEntryModelResourcePermission;


}
\end{verbatim}

Now your guestbook project's entities are fully asset-enabled. To test
the functionality, add the Asset Publisher portlet to a page. Then add
and edit guestbooks and guestbook entries. Then check the Asset
Publisher portlet. The Asset Publisher dynamically displays assets of
any kind from the current Site.

\begin{figure}
\centering
\includegraphics{./images/custom-entities-asset-publisher.png}
\caption{After you've implemented and registered your asset renderers
for your custom entities, the Asset Publisher can display your
entities.}
\end{figure}

Confirm that the Asset Publisher displays the guestbooks and guestbook
entries that you added.

Great! Next, you'll update your portlets' user interfaces to use several
asset framework features: comments, ratings, tags, categories, and
related assets.

\chapter{Adding Asset Features to Your User
Interface}\label{adding-asset-features-to-your-user-interface}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 1 of 5</p>
\end{verbatim}

Now that your guestbook and guestbook entry entities are asset-enabled,
you can add asset functionality to your application. You'll start by
implementing comments, ratings, tags, categories, and related assets for
guestbooks. Then you'll do the same for guestbook entries. All the
back-end support for these features is already implemented. Your only
task is to update your applications' user interfaces to use these
features.

Now you'll create several new JSPs that need new imports. Add the
following imports to the \texttt{guestbook-web} module project's
\texttt{init.jsp} file:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/asset" prefix="liferay-asset" %>
<%@ taglib uri="http://liferay.com/tld/comment" prefix="liferay-comment" %>

<%@ page import="com.liferay.asset.kernel.service.AssetEntryLocalServiceUtil" %>
<%@ page import="com.liferay.asset.kernel.service.AssetTagLocalServiceUtil" %>
<%@ page import="com.liferay.asset.kernel.model.AssetEntry" %>
<%@ page import="com.liferay.asset.kernel.model.AssetTag" %>
<%@ page import="com.liferay.portal.kernel.util.ListUtil" %>
<%@ page import="com.liferay.portal.kernel.comment.Discussion" %>
<%@ page import="com.liferay.portal.kernel.comment.CommentManagerUtil" %>
<%@ page import="com.liferay.portal.kernel.service.ServiceContextFunction" %>
\end{verbatim}

Add these imports now so you don't run into errors as you work through
the steps.

\chapter{Creating JSPs for Displaying Custom Assets in the Asset
Publisher}\label{creating-jsps-for-displaying-custom-assets-in-the-asset-publisher}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 2 of 5</p>
\end{verbatim}

Before proceeding, you must tie up a loose end from the previous step.
Remember that you implemented \texttt{getJspPath} methods in your
\texttt{GuestbookAssetRenderer} and \texttt{GuestbookEntryAssetRenderer}
classes to JSPs that don't exist yet. These methods return paths to JSPs
the Asset Publisher uses to display the assets' full content. The
\texttt{getJspPath} method of \texttt{GuestbookAssetRenderer} returns
\texttt{"/asset/guestbook/full\_content.jsp"}, and the
\texttt{getJspPath} method of \texttt{EntryAssetRenderer} returns
\texttt{"/asset/entry/full\_content.jsp"}. It's time to create these
JSPs.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module project, create a new folder
  called \texttt{asset} under the \texttt{resources/META-INF/resources}
  folder. Add two folders to this new folder: \texttt{entry} and
  \texttt{guestbook}.
\item
  Create a new file called \texttt{full\_content.jsp} in the
  \texttt{/asset/guestbook} folder. This JSP displays a guestbook
  asset's full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
Guestbook guestbook = (Guestbook)request.getAttribute("gb_guestbook");

guestbook = guestbook.toEscapedModel();
%>

<dl>
        <dt>Name</dt>
        <dd><%= guestbook.getName() %></dd>
</dl>
\end{verbatim}

  This JSP grabs the guestbook object from the request and displays the
  guestbook's name. In \texttt{GuestbookAssetRenderer}, the
  \texttt{getJspPath} method added the \texttt{gb\_guestbook} request
  attribute:

\begin{verbatim}
request.setAttribute("gb_guestbook", _guestbook);
\end{verbatim}

  The guestbook's \texttt{toEscapedModel} method belongs to the
  \texttt{GuestbookModelImpl} class, which was generated by Service
  Builder. This method returns a \emph{safe} guestbook object (a
  guestbook in which each field is HTML-escaped). Calling
  \texttt{guestbook\ =\ guestbook.toEscapedModel()} before displaying
  the guestbook name ensures that your JSP won't display malicious code
  that's masquerading as a guestbook name.
\item
  Next, in the \texttt{/asset/entry} folder, create a
  \texttt{full\_content.jsp} for displaying a guestbook entry asset's
  full content. Add the following code to this file:

\begin{verbatim}
<%@include file="../../init.jsp"%>

<%
GuestbookEntry entry = (GuestbookEntry)request.getAttribute("gb_entry");

entry = entry.toEscapedModel();
%>

<dl>
        <dt>Guestbook</dt>
        <dd><%= GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName() %></dd>
        <dt>Name</dt>
        <dd><%= entry.getName() %></dd>
        <dt>Message</dt>
        <dd><%= entry.getMessage() %></dd>
</dl>
\end{verbatim}
\end{enumerate}

This JSP shows a combination of fields from the Guestbook and the
selected Guestbook Entry.

After deploying your changes, test your new JSPs by clicking a
guestbook's or guestbook entry's title in the Asset Publisher. The Asset
Publisher renders \texttt{full\_content.jsp}:

\begin{figure}
\centering
\includegraphics{./images/asset-publisher-full-content.png}
\caption{When you click the title for a guestbook or guestbook entry in
the Asset Publisher, your \texttt{full\_content.jsp} should be
displayed.}
\end{figure}

By default, when displaying an asset's full view, the Asset Publisher
displays additional links for social media so you can publicize your
asset. The \emph{Back} icon and the \emph{View in Context} link return
you to the Asset Publisher's default view.

\chapter{Enabling Tags, Categories, and Related Assets for
Guestbooks}\label{enabling-tags-categories-and-related-assets-for-guestbooks}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 3 of 5</p>
\end{verbatim}

Since you already asset-enabled guestbooks at the service layer,
guestbook entities can now support tags and categories. All that's left
is to enable them in the UI. In this step, you'll update the Guestbook
Admin portlet's \texttt{edit\_guestbook.jsp} so administrators can add,
edit, or remove tags and categories when adding or updating a guestbook.

\section{Enabling Asset Features}\label{enabling-asset-features}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{guestbook-web} module's
  \texttt{/guestbook\_admin/edit\_guestbook.jsp}, add the tags
  \texttt{\textless{}liferay-asset:asset-categories-error\ /\textgreater{}}
  and \texttt{\textless{}liferay-asset:asset-tags-error/\textgreater{}}
  to the \texttt{aui:form} below the closing
  \texttt{\textless{}/aui:button-row\textgreater{}} tag:

\begin{verbatim}
<liferay-asset:asset-categories-error />
<liferay-asset:asset-tags-error />
\end{verbatim}

  These tags display error messages if an error occurs with the tags or
  categories submitted in the form.
\item
  Below the error tags, add a
  \texttt{\textless{}liferay-ui:panel\textgreater{}} tag surrounded by a
  \texttt{\textless{}c:if\textgreater{}} statement:

\begin{verbatim}
<c:if test="<%= guestbook != null %>">

    <liferay-ui:panel defaultState="closed" extended="<%= false %>"
      id="guestbookCategorizationPanel" persistState="<%= true %>"
      title="categorization">

    </liferay-ui:panel>

</c:if>
\end{verbatim}

  The \texttt{\textless{}liferay-ui:panel\textgreater{}} tag generates a
  collapsible section. The tags you'll add in the next step don't work
  if \texttt{guestbook} is \texttt{null}, so you only display the panel
  if the current Guestbook is being edited.
\item
  Add input fields for tags and categories inside the panel section you
  just created. Specify the \texttt{assetCategories} and
  \texttt{assetTags} types for the
  \texttt{\textless{}aui:input\ /\textgreater{}} tags. These input tags
  represent asset categories and asset tags. You can group related input
  fields together with an \texttt{\textless{}aui:fieldset\textgreater{}}
  tag. The tags generate the appropriate selectors for tags and
  categories and displays those that have already been added to the
  guestbook:

\begin{verbatim}
<aui:fieldset>
    <liferay-asset:asset-categories-selector className="<%= Guestbook.class.getName() %>" classPK="<%= guestbook.getGuestbookId() %>" />
    <liferay-asset:asset-tags-selector className="<%= Guestbook.class.getName() %>" classPK="<%= guestbook.getGuestbookId() %>" />
</aui:fieldset>
\end{verbatim}
\item
  Add a second \texttt{\textless{}liferay-ui:panel\textgreater{}} tag
  under the existing one. In this new tag, add an
  \texttt{\textless{}aui:fieldset\textgreater{}} tag containing a
  \texttt{\textless{}liferay-ui:asset-links\textgreater{}} tag. To
  display the correct asset links (the selected guestbook's related
  assets), set the \texttt{className} and \texttt{classPK} attributes:

\begin{verbatim}
<liferay-ui:panel defaultState="closed" extended="<%= false %>"
  id="guestbookAssetLinksPanel" persistState="<%= true %>"
  title="related-assets">
  <aui:fieldset>
    <liferay-asset:input-asset-links
      className="<%= Guestbook.class.getName() %>"
      classPK="<%= guestbookId %>" />
  </aui:fieldset>
</liferay-ui:panel>
\end{verbatim}
\end{enumerate}

Test the updated \texttt{edit\_guestbook.jsp} page by navigating to the
Guestbook Admin portlet in the Control Panel and clicking \emph{Add
Guestbook}. After adding the Guestbook, edit it. You'll see a field for
adding tags and a selector for selecting related assets.

\begin{figure}
\centering
\includegraphics{./images/guestbook-tags-related-assets.png}
\caption{Once you've updated your Guestbook Admin portlet's
\texttt{edit\_guestbook.jsp} page, you'll see forms for adding tags and
selecting related assets.}
\end{figure}

Don't do anything with these fields yet, because you're not done
implementing assets. Next, you'll enable tags and categories for
guestbook entries.

\chapter{Enabling Tags, Categories, and Related Assets for Guestbook
Entries}\label{enabling-tags-categories-and-related-assets-for-guestbook-entries}

\begin{verbatim}
<p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 4 of 5</p>
\end{verbatim}

Enabling tags, categories, and related assets for guestbook entries is
similar to enabling them for guestbooks. Please refer back to the
previous step for a detailed explanation.

Open your \texttt{guestbook-web} module's
\texttt{guestbook/edit\_entry.jsp} file. You'll add two pieces of code:
a header for navigation and a panel for tags and categories similar to
the one you added to the \texttt{edit\_guestbook.jsp} file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the header after the \texttt{addEntry} action URL tag:

\begin{verbatim}
<liferay-ui:header
    backURL="<%= viewURL.toString() %>"
    title="<%= entry == null ? "Add Entry" : entry.getName() %>"
/>
\end{verbatim}
\item
  Add the asset tags/categories/links in a collapsible panel after the
  closing \texttt{\textless{}/aui:fieldset\textgreater{}}:

  ```markup
\end{enumerate}

\begin{verbatim}
<aui:fieldset>
   <liferay-asset:asset-categories-selector className="<%= GuestbookEntry.class.getName() %>" classPK="<%= entryId %>" />
   <liferay-asset:asset-tags-selector className="<%= GuestbookEntry.class.getName() %>" classPK="<%= entryId %>" />
</aui:fieldset>
\end{verbatim}

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="related-assets">
        
    <liferay-asset:input-asset-links
        className="<%= GuestbookEntry.class.getName() %>"
        classPK="<%= entryId %>"
    />
        
</aui:fieldset>
\end{verbatim}

\begin{verbatim}

Test your JSP by using the Guestbook portlet to add and update Guestbook 
entries. Add and remove tags, categories, and related assets. 


\noindent\hrulefill

 **Note:** Setting your custom asset as the *Main Asset* of a page is
 required to display related assets in the Related Assets portlet. This is done
 when creating
 [Friendly URLs](/docs/7-2/tutorials/-/knowledge_base/t/making-urls-friendlier)
 in a later step.

\noindent\hrulefill

Well done! Next, you'll enable comments and ratings for guestbook entries. 


# Enabling Comments and Ratings for Guestbook Entries


<div class="learn-path-step row">
    <p id="stepTitle">Adding Asset Features to Your UI</p><p>Step 5 of 5</p>
</div>

The asset framework lets users comment on and rate assets. As with tags,
categories, and related assets, you must update the user interface to expose
these features. Good application design requires that you have a View page where
users can rate and comment on assets. Follow these steps to enable comments and
ratings on guestbook entries: 

1.  Create a new file called `view_entry.jsp` in your `guestbook-web` module 
    project's `src/main/resources/META-INF/resources/guestbook` folder. 

2.  Add a Java scriptlet to the file you just created. In this scriptlet, use an 
    `entryId` request attribute to get a `GuestbookEntry` object. For security
    reasons, convert this object to an escaped model as discussed in the earlier
    step 
    [Creating JSPs for Displaying Custom Assets in the Asset Publisher](/docs/7.2/tutorials/-/knowledge_base/t/creating-jsps-for-displaying-custom-assets-in-the-asset-publisher):

    ```markup
    <%@ include file="../init.jsp"%>

    <%
      long entryId = ParamUtil.getLong(renderRequest, "entryId");

      long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

      GuestbookEntry entry = null;

      entry = GuestbookEntryLocalServiceUtil.getGuestbookEntry(entryId);

      entryId = entry.getEntryId();

      entry = entry.toEscapedModel();

      AssetEntry assetEntry = 
      AssetEntryLocalServiceUtil.getEntry(GuestbookEntry.class.getName(), 
      entry.getEntryId());
    ```

3.  Next, update the breadcrumb entry with the current entry's name: 

    ```markup
    String currentURL = PortalUtil.getCurrentURL(request);
    PortalUtil.addPortletBreadcrumbEntry(request, entry.getMessage(),
    currentURL);
    ```

4.  End the scriptlet by adding the names of the current entry's existing 
    asset tags as keywords to the portal page. These tag names appear in a 
    `<meta content="[tag names here]" lang="en-US" name="keywords" />` element 
    in your portal page's `<head>` section. These keywords can help search 
    engines find and index your page: 

    ```markup
        PortalUtil.setPageSubtitle(entry.getMessage(), request);
        PortalUtil.setPageDescription(entry.getMessage(), request);

        List<AssetTag> assetTags = 
        AssetTagLocalServiceUtil.getTags(GuestbookEntry.class.getName(), 
        entry.getEntryId());
        PortalUtil.setPageKeywords(ListUtil.toString(assetTags, "name"), 
        request);
    %>
    ```

5.  After the scriptlet, specify the URLs for the page and back link: 

    ```markup
    <liferay-portlet:renderURL varImpl="viewEntryURL">
      <portlet:param name="mvcPath"
        value="/guestbook/view_entry.jsp" />
      <portlet:param name="entryId" value="<%=String.valueOf(entryId)%>" />
    </liferay-portlet:renderURL>

    <liferay-portlet:renderURL varImpl="viewURL">
      <portlet:param name="mvcPath"
        value="/guestbook/view.jsp" />
    </liferay-portlet:renderURL>

    <liferay-ui:header backURL="<%=viewURL.toString()%>"
      title="<%=entry.getName()%>" 
    />
    ```

6.  Next, define the page's main content. Display the guestbook's name and the 
    entry's name and message with the `<dl>`, `<dt>`, and `<dd>` tags: 

    ```markup
    <dl>
      <dt>Guestbook</dt>
      <dd><%=GuestbookLocalServiceUtil.getGuestbook(entry.getGuestbookId()).getName()%></dd>
      <dt>Name</dt>
      <dd><%=entry.getName()%></dd>
      <dt>Message</dt>
      <dd><%=entry.getMessage()%></dd>
    </dl>
    ```

    This is the same way you defined the page's main content in 
    `/asset/full_content.jsp`. 

7.  Next, use a `<liferay-ui:panel-container>` tag to create a panel container. 
    Inside this tag, use a `<liferay-ui:panel>` tag to create a panel to display
    the comments and ratings components: 

    ```markup
    <liferay-ui:panel-container extended="<%=false%>"
      id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
      <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
        id="guestbookCollaborationPanel" persistState="<%=true%>"
        title="Collaboration">
    ```

8.  Add the ratings component with the `<liferay-ui:ratings>` tag:

    ```markup
    <liferay-ui:ratings className="<%=GuestbookEntry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>" type="stars" />

    <br />
    ```

9.  Next, add a scriptlet to retrieve the comments discussion object:

    ```markup
    <% 
        Discussion discussion = 
        CommentManagerUtil.getDiscussion(user.getUserId(), 
        scopeGroupId, GuestbookEntry.class.getName(), 
        entry.getEntryId(), new ServiceContextFunction(request));
    %>
    ```

10.  Below that add the tag for tracking the number of comments:

    ```markup
    <c:if test="<%= discussion != null %>">
      <h2>
        <strong><liferay-ui:message arguments="<%= discussion.getDiscussionCommentsCount() %>" key='<%= (discussion.getDiscussionCommentsCount() == 1) ? "x-comment" : "x-comments" %>' /></strong>
    ```

11. Create the `liferay-comment:discussion` tag, which creates the comments
    form, *Reply* button, and retrieves the discussion content. It also
    handles the form action of posting the comment without requiring
    you to create a portlet action URL.

    ```markup
      <liferay-comment:discussion
        className="<%= GuestbookEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        discussion="<%= discussion %>"
        formName="fm2"
        ratingsEnabled="true"
        redirect="<%= currentURL %>"
        userId="<%= entry.getUserId() %>"
        />
    </c:if>

  </liferay-ui:panel>
</liferay-ui:panel-container>
    ```

12. To restrict comments and ratings access to logged-in users, wrap the whole 
    panel container in a `<c:if>` tag that tests the expression 
    `themeDisplay.isSignedIn()`:

    ```markup
    <c:if test="<%= themeDisplay.isSignedIn() %>">
        ... your panel container ...
    </c:if>
    ```

    Make sure you add the closing `</c:if>` tag after the closing 
    `</liferay-ui:panel-container>` tag.


\noindent\hrulefill

 **Note:** Discussions (comments) are implemented as message board messages. In
 the `MBMessage` table, there's a `classPK` column. This `classPK` represents
 the guestbook entry's `entryId`, linking the comment to the guestbook. Ratings
 are stored in the `RatingsEntry` table. Similarly, the `RatingsEntry` table
 contains a `classPK` column that links the guestbook entry to the rating. Using
 a `classPK` foreign key in one table to represent the primary key of another
 table is a common pattern throughout Liferay DXP.

\noindent\hrulefill

Next, you'll update the guestbook actions to use the new view. 

## Updating the Entry Actions JSP

Your `view_entry.jsp` page is currently orphaned. Fix this by adding the *View*
option to the Actions Menu. Open the `/guestbook/entry_actions.jsp`
and find the following line:

```markup
<liferay-ui:icon-menu>
\end{verbatim}

Add the following lines below it:

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
  <portlet:param name="entryId"
    value="<%= String.valueOf(entry.getEntryId()) %>" />
  <portlet:param name="mvcPath"
    value="/guestbook/view_entry.jsp" />
</portlet:renderURL>

<liferay-ui:icon message="View" url="<%= viewEntryURL.toString() %>" />
\end{verbatim}

Here, you create a URL that points to \texttt{view\_entry.jsp}. Test
this link by selecting the \emph{View} option in a guestbook entry's
Actions Menu. Then test your comments and ratings.

Excellent! You've asset-enabled the guestbook and guestbook entry
entities and enabled tags, categories, and related assets for both
entities. You've also enabled comments and ratings for guestbook entry
entities! Great job!

\begin{figure}
\centering
\includegraphics{./images/asset-publisher-full-content-finished.png}
\caption{Now you can see comments, rating, and the full range of asset
features.}
\end{figure}

Your next task is to add Workflow, so you can approve or deny guestbook
entries, thereby preventing people from spamming your guestbook.

\chapter{Using Workflow}\label{using-workflow}

The Guestbook application accepts submissions from any logged in user,
so there's no telling what people could post. Illegal data,
objectionable content, the entire contents of Don Quixote: all of these
and more are possibilities. You can make sure user posts don't run afoul
of the law or policy by enabling \emph{workflow} in your application.

Workflow is a review process that ensures a submitted entity isn't
published before it's reviewed. To prevent posting objectionable
content, an initially submitted Guestbook entry should be marked as a
\emph{draft} and sent through the workflow framework. It comes back to
the application code ready to have any relevant fields updated in the
database based on its status. The view layer must filter entities by
status to display only reviewed entities.

\noindent\hrulefill

\textbf{Note:} The exact review process is defined separately from the
code that enables workflow. An XML file provides the definition of a
workflow in Liferay DXP. If you're a Liferay Digital Enterprise
subscriber, you have access to the Workflow Designer, which offers a
convenient drag-and-drop user interface for designing workflow
definition files. You can read more about this in Liferay DXP's
\href{https://help.liferay.com/hc/en-us/articles/360028821892-Workflow-Designer}{documentation}.
Liferay DXP comes with a workflow definition called the \emph{Single
Approver} definition, but you can write your own workflow definitions
according to your organization's requirements.

A few additional definitions are included in Liferay DXP's source code,
which you can use to see how workflow definitions are defined. To
discover how to access these files, see
\href{/docs/7-2/user/-/knowledge_base/u/enabling-workflow}{here}.

\noindent\hrulefill

This tutorial instructs the reader in workflow-enabling the Guestbook
App's \texttt{Guestbook} and \texttt{GuestbookEntry} entities to ensure
that only approved content is published after review.

\begin{figure}
\centering
\includegraphics{./images/workflow-config.png}
\caption{Enable workflow in your assets, just like Liferay DXP's own
assets.}
\end{figure}

There are five steps to enabling workflow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the service layer to set each entity's status fields.
\item
  Send the entity to Liferay DXP's workflow framework.
\item
  Add \emph{getter} methods that account for an entity's workflow
  status.
\item
  Handle the entity as it returns from the workflow framework.
\item
  Update the user interface to account for workflow status.
\end{enumerate}

The first three steps happen in the service layer, so that's a good
place to start.

Let's Go!{}

\chapter{Supporting Workflow at the Service
Layer}\label{supporting-workflow-at-the-service-layer}

When you
\href{/docs/7-2/tutorials/-/knowledge_base/t/assets-integrating-with-liferays-framework}{asset
enabled the Guestbook Application}, you used four database columns in
the Guestbook entities that keep track of workflow status (they were
added in the beginning; celebrate!). The necessary fields are
\texttt{status}, \texttt{statusByUserName}, \texttt{statusByUserId}, and
\texttt{statusDate}. The columns are defined in the
\texttt{guestbook-service} module's \texttt{service.xml} file.

\begin{verbatim}
<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

The \texttt{status} field tells you the current status of the entity (it
defaults to \texttt{0}, which evaluates to \emph{approved}). The other
status fields store the date of the last change (\texttt{statusDate})
along with the ID and name of the user (\texttt{statusByUserId} and
\texttt{statusByUserName}) who made the update.

Although the status columns are in the Guestbook application's entity
tables, you must update the local service implementation's \texttt{add}
methods to set them, and while you're there, send the entity to the
workflow framework. You'll also write a method to update the status
fields when the entity returns from the workflow framework, along with
getters that take workflow status as a parameter. That sounds like a lot
of work, but thanks to Service Builder, you must change only three
files: \texttt{service.xml}, \texttt{GuestbookLocalServiceImpl}, and
\texttt{GuestbookEntryLocalServiceImpl}.

Let's Go!{}

\chapter{Setting the Guestbook
Status}\label{setting-the-guestbook-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 1 of 3</p>
\end{verbatim}

Before now, you set the status of all added guestbooks to approved in
the service layer. Now you'll set it to draft and pass it to the
workflow framework.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From \texttt{guestbook-service}, open
  \texttt{GuestbookLocalServiceImpl} and add the status fields below the
  existing setter methods in the \texttt{addGuestbook} method:

\begin{verbatim}
guestbook.setStatus(WorkflowConstants.STATUS_DRAFT);
guestbook.setStatusByUserId(userId);
guestbook.setStatusByUserName(user.getFullName());
guestbook.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

  This manually populates the status fields and sets the workflow status
  as a draft in the \texttt{GB\_GuestbookEntry} database table. At this
  point they're identical to the similarly named non-status counterparts
  (like \texttt{setUserId} and \texttt{setStatusByUserId}), but they'll
  be updated independently in the \texttt{updateStatus} method you write
  later.
\item
  Still in the \texttt{addGuestbook} method, place the following code
  right before the \texttt{return} statement:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(guestbook.getCompanyId(), 
            guestbook.getGroupId(), guestbook.getUserId(), Guestbook.class.getName(), 
            guestbook.getPrimaryKey(), guestbook, serviceContext);
\end{verbatim}

  The call to \texttt{startWorkflowInstance} detects whether workflow is
  installed and enabled. If it isn't, the added entity is automatically
  marked as approved. The \texttt{startWorkflowInstance} call also calls
  your \texttt{GuestbookWorkflowHandler} class, which you'll create
  later.
\item
  Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), and save your
  work.
\end{enumerate}

The \texttt{startWorkflowInstance} method is where your entity enters
the workflow framework, but you're not finished yet. Just like you
wouldn't drop your child off at college and then change your number and
move to a new address, you're not going to abandon your
\texttt{Guestbook} entity (yet).

\section{Creating the updateStatus
Method}\label{creating-the-updatestatus-method}

Exert control over how the status fields are updated in the database.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{updateStatus} method in
  \texttt{GuestbookLocalServiceImpl}, immediately following the
  \texttt{deleteGuestbook} method. Here's the first half of it:

\begin{verbatim}
public Guestbook updateStatus(long userId, long guestbookId, int status,
        ServiceContext serviceContext) throws PortalException,
        SystemException {

    User user = userLocalService.getUser(userId);
    Guestbook guestbook = getGuestbook(guestbookId);

    guestbook.setStatus(status);
    guestbook.setStatusByUserId(userId);
    guestbook.setStatusByUserName(user.getFullName());
    guestbook.setStatusDate(new Date());

    guestbookPersistence.update(guestbook);
\end{verbatim}

  If this method is called, it's because your entity is returning from
  the workflow framework, and it's time to update the status values in
  the database. Set the status fields, then persist the updated entity
  to the database.
\item
  Before saving, finish the method:

\begin{verbatim}
    if (status == WorkflowConstants.STATUS_APPROVED) {

        assetEntryLocalService.updateVisible(Guestbook.class.getName(),
                guestbookId, true);

    } else {

        assetEntryLocalService.updateVisible(Guestbook.class.getName(),
                guestbookId, false);
    }

    return guestbook;
}
\end{verbatim}

  This \texttt{if} statement determines the visibility of the asset
  based on its workflow status. If it's approved, the
  \texttt{assetEntryLocalService.updateVisible} method sets the
  guestbook in question to \texttt{true} so it can be displayed in the
  Asset Publisher and in the search results. Otherwise (\texttt{else})
  it sets the visibility to \texttt{false} to ensure that unapproved
  guestbooks aren't displayed to users in the Asset Publisher or the
  Search portlet.
\item
  There's one more update to make in the \texttt{deleteGuestbook}
  method. When deleting, you must clean up the workflow system's
  database tables to avoid leaving orphaned entries when the backing
  entity is deleted. Before making the method call, open
  \texttt{service.xml} and add the following tag below the existing
  \texttt{\textless{}reference\textgreater{}} tags in the
  \texttt{Guestbook} entity:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}
\item
  Back in \texttt{GuestbookLocalServiceImpl}, find the
  \texttt{deleteGuestbook} method and put this method call right before
  the \texttt{return} statement:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    guestbook.getCompanyId(), guestbook.getGroupId(),
    Guestbook.class.getName(), guestbook.getGuestbookId());
\end{verbatim}
\item
  Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and save your work.
  Then run the \texttt{buildService} Gradle task. It injects the
  \texttt{WorkflowInstanceLinkLocalService} service into a protected
  variable in \texttt{GuesbookLocalServiceBaseImpl}. Since
  \texttt{GuestbookLocalServiceImpl} extends the base class, you can use
  it directly.
\item
  Run \emph{Refresh Gradle Project}.
\end{enumerate}

Now the guestbook entity's service layer populates the status fields in
the database, sends the entity into the workflow framework, and cleans
up when it's deleted. You'll do the same thing for guestbook entries
next.

\chapter{Setting the Entry Workflow
Status}\label{setting-the-entry-workflow-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 2 of 3</p>
\end{verbatim}

Now you'll set the status fields, introduce entries to the workflow
framework, and add the \texttt{updateStatus} method to
\texttt{GuestbookEntryLocalServiceImpl}. It works the same as it did for
guestbooks.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following lines in the \texttt{addGuestbookEntry} method,
  immediately after the existing setter methods (e.g.,
  \texttt{entry.setMessage(message)}):

\begin{verbatim}
entry.setStatus(WorkflowConstants.STATUS_DRAFT);
entry.setStatusByUserId(userId);
entry.setStatusByUserName(user.getFullName());
entry.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}
\item
  Still in the \texttt{addGuestbookEntry} method, place the following
  code right before the \texttt{return} statement:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(entry.getCompanyId(), 
            entry.getGroupId(), entry.getUserId(), GuestbookEntry.class.getName(), 
            entry.getPrimaryKey(), entry, serviceContext);
\end{verbatim}

  The \texttt{startWorkflowInstance} call eventually directs the
  workflow processing to your \texttt{GuestbookEntryWorkflowHandler}
  class, which you'll create later. That class is responsible for making
  sure the entity is updated in the database (via an
  \texttt{updateStatus} method), but it's best practice to make
  persistence calls in the service layer.
\item
  Add a corresponding \texttt{updateStatus} method here in
  \texttt{GuestbookEntryLocalServiceImpl}. Add this method to the bottom
  of the class:

\begin{verbatim}
public GuestbookEntry updateStatus(long userId, long guestbookId, long entryId, int status,
       ServiceContext serviceContext) throws PortalException,
       SystemException {

   User user = userLocalService.getUser(userId);
   GuestbookEntry entry = getGuestbookEntry(entryId);

   entry.setStatus(status);
   entry.setStatusByUserId(userId);
   entry.setStatusByUserName(user.getFullName());
   entry.setStatusDate(new Date());

   guestbookEntryPersistence.update(entry);

   if (status == WorkflowConstants.STATUS_APPROVED) {

       assetEntryLocalService.updateVisible(GuestbookEntry.class.getName(),
               entryId, true);

   } else {

       assetEntryLocalService.updateVisible(GuestbookEntry.class.getName(),
               entryId, false);
   }

   return entry;
}
\end{verbatim}
\item
  As with Guestbooks, you must add a call to
  \texttt{deleteWorkflowInstanceLinks} in the entry's delete method to
  avoid leaving orphaned database entries in the
  \texttt{workflowinstancelinks} table. First add the following
  \texttt{\textless{}reference\textgreater{}} tag to
  \texttt{service.xml}, this time in the \texttt{entry} entity section,
  below the existing reference tags:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}
\item
  Add the following method call to the \texttt{deleteGuestbookEntry}
  method in \texttt{GuestbookEntryLocalServiceImpl}, right before the
  \texttt{return} statement:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    entry.getCompanyId(), entry.getGroupId(),
    GuestbookEntry.class.getName(), entry.getEntryId());
\end{verbatim}
\item
  Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}), save your work,
  run Service Builder, and refresh the Gradle project.
\end{enumerate}

Now both entities support the status of the entity and can handle it as
it enters the workflow framework and as it returns from the workflow
framework. There's one more update to make in the local service
implementation classes: adding getter methods that take the status as a
parameter. Later you'll use these methods in the view layer so you can
display only approved guestbooks and entries.

\chapter{Retrieving Guestbooks and Entries by
Status}\label{retrieving-guestbooks-and-entries-by-status}

\begin{verbatim}
<p>Supporting Workflow at the Service Layer<br>Step 3 of 3</p>
\end{verbatim}

The service implementation for both entities now supports adding the
status fields to the database tables. There's one more update to make in
the service layer, but to understand why, you must think about the view
layer. When the Guestbook portlet displays entries, you must make sure
it doesn't show entries that haven't been approved. Currently, the
entry's view layer shows all guestbooks:

\begin{verbatim}
    List<Guestbook> guestbooks = GuestbookLocalServiceUtil
                .getGuestbooks(scopeGroupId);
\end{verbatim}

There's a problem: the getter only takes the \texttt{scopeGroupId} as a
parameter, so there's no way to get guestbooks by their status.

Likewise, unapproved entries must not be displayed, but the view layer
currently gets all entries:

\begin{verbatim}
    <liferay-ui:search-container total="<%=GuestbookEntryLocalServiceUtil.getGuestbookEntriesCount()%>">
    <liferay-ui:search-container-results
        results="<%=GuestbookEntryLocalServiceUtil.getGuestbookEntries(scopeGroupId.longValue(),
                        guestbookId, searchContainer.getStart(),
                        searchContainer.getEnd())%>" />
\end{verbatim}

The solution is to implement for guestbooks and entries a getter that
takes the \texttt{status} field as a parameter. Thankfully, Service
Builder makes it easy.

Open the \texttt{guestbook-service} module's \texttt{service.xml} file.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For the \texttt{GuestbookEntry} entity, remove the following finder:

\begin{verbatim}
 <finder name="G_S" return-type="Collection">
   <finder-column name="groupId" />
   <finder-column name="status" />
 </finder>
\end{verbatim}
\item
  Add this finder in its place:

\begin{verbatim}
<finder name="G_G_S" return-type="Collection">
   <finder-column name="groupId" />
   <finder-column name="guestbookId" />
   <finder-column name="status" />
</finder>
\end{verbatim}
\end{enumerate}

Run service builder (double-click
\texttt{guestbook-service/build/buildService} in the Gradle Tasks pane).
Service Builder generates finder methods in the persistence layer that
take the specified fields (for example, \texttt{status}) as parameters.

\section{Calling the Persistence
Layer}\label{calling-the-persistence-layer}

Don't call the persistence layer directly in the application code.
Instead expose the new persistence methods in the service layer.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{GuestbookLocalServiceImpl}, add this getter, and save the
  file:

\begin{verbatim}
public List<Guestbook> getGuestbooks(long groupId, int status)
    throws SystemException {

    return guestbookPersistence.findByG_S(
        groupId, WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}

  This getter gets only approved guestbooks. That's why you hard code
  the workflow constant \texttt{STATUS\_APPROVED} into the status
  parameter when calling the persistence method.
\item
  Now open \texttt{GuestbookEntryLocalServiceImpl}, add these two
  getters, and save the file:

\begin{verbatim}
public List<GuestbookEntry> getGuestbookEntries(
    long groupId, long guestbookId, int status, int start, int end)
    throws SystemException {

    return guestbookEntryPersistence.findByG_G_S(
        groupId, guestbookId, WorkflowConstants.STATUS_APPROVED);
}

public int getGuestbookEntriesCount(
    long groupId, long guestbookId, int status)
    throws SystemException {

    return guestbookEntryPersistence.countByG_G_S(
        groupId, guestbookId, WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}

  You'll replace the existing methods with these
  \texttt{getGuestbookEntries} and \texttt{getGuestbookEntriesCount}
  methods in the view layer, ensuring that only approved entries are
  displayed.
\item
  Save the file, run Service Builder, and refresh the Gradle project.
\end{enumerate}

The work here relates to the UI updates you'll make later. Next, you
must implement workflow handlers so that you can call the
\texttt{updateStatus} service method when the entity returns from the
workflow framework.

\chapter{Handling Workflow}\label{handling-workflow}

The guestbook project's service layer is now updated to handle workflow.
It now properly sets the status fields for guestbooks and guestbook
entries, gets entities by their statuses, and sends entities to Liferay
DXP's workflow framework whenever the \texttt{addGuestbook} or
\texttt{addGuestbookEntry} methods are called. Recall that you still
have an uncalled service method, \texttt{updateStatus}, for both
entities. Now you'll implement workflow handlers, classes that interact
with Liferay DXP's workflow framework and your service layer (by calling
\texttt{updateStatus} on the appropriate entity).

There's a handy abstract class you can extend to make the job easier,
called \texttt{BaseWorkflowHandler}. You'll do this next for both
entities of the guestbook project, starting with guestbooks.

Let's Go!{}

\chapter{Creating a Workflow Handler for
Guestbooks}\label{creating-a-workflow-handler-for-guestbooks}

\begin{verbatim}
<p>Handling Workflow<br>Step 1 of 2</p>
\end{verbatim}

Each workflow enabled entity needs a \texttt{WorkflowHandler}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in the \texttt{guestboook-service} module called
  \texttt{com.liferay.docs.guestbook.workflow}, then create the
  \texttt{GuestbookWorkflowHandler} class in it. Extend
  \texttt{BaseWorkflowHandler} and pass in \texttt{Guestbook} as the
  type parameter:

\begin{verbatim}
public class GuestbookWorkflowHandler extends BaseWorkflowHandler<Guestbook> {
\end{verbatim}
\item
  Make it a Component class:

\begin{verbatim}
@Component(immediate = true, service = WorkflowHandler.class)
\end{verbatim}
\item
  There are three abstract methods to implement: \texttt{getClassName},
  \texttt{getType}, and \texttt{updateStatus}. First add
  \texttt{getClassName}:

\begin{verbatim}
@Override
public String getClassName() {
    return Guestbook.class.getName();
}
\end{verbatim}

  \texttt{getClassName} returns the guestbook entity's fully qualified
  class name (\texttt{com.liferay.docs.guestbook.model.Guestbook}).
\item
  Next, add \texttt{getType}:

\begin{verbatim}
@Override
public String getType(Locale locale) {
    return _resourceActions.getModelResource(locale, getClassName());
}
\end{verbatim}

  \texttt{getType} returns the model resource name
  (\texttt{model.resource.com.liferay.docs.guestbook.model.Guestbook}).
\item
  Finally, add the meat of the workflow handler, which is in the
  \texttt{updateStatus} method:

\begin{verbatim}
@Override
public Guestbook updateStatus(
        int status, Map<String, Serializable> workflowContext)
    throws PortalException {

    long userId = GetterUtil.getLong(
        (String)workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
    long resourcePrimKey = GetterUtil.getLong(
        (String)workflowContext.get(
            WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

    ServiceContext serviceContext = (ServiceContext)workflowContext.get(
        "serviceContext");

    return _guestbookLocalService.updateStatus(
        userId, resourcePrimKey, status, serviceContext);
}
\end{verbatim}

  When you crafted the service layer's \texttt{updateStatus} method (see
  the last section for more details), you specified parameters that must
  be passed to the method. Here you're making sure that those parameters
  are available to pass to the service call. Get the \texttt{userId} and
  \texttt{resourcePrimKey} from \texttt{GetterUtil}. Its
  \texttt{getLong} method takes a \texttt{String}, which you can get
  from the \texttt{workflowContext} \texttt{Map} using
  \texttt{WorkflowConstants} for the context user ID and the context
  entry class PK.
\item
  Make sure you inject the \texttt{ResourceActions} service into a
  private variable at the end of the class, using the
  \texttt{@Reference} annotation:

\begin{verbatim}
@Reference(unbind = "-")
protected void setResourceActions(ResourceActions resourceActions) {

    _resourceActions = resourceActions;
}

private ResourceActions _resourceActions;
\end{verbatim}
\item
  Inject a \texttt{GuestbookLocalService} into a private variable using
  the \texttt{@Reference} annotation.

\begin{verbatim}
    @Reference(unbind = "-")
    protected void setGuestbookLocalService(
        GuestbookLocalService guestbookLocalService) {

        _guestbookLocalService = guestbookLocalService;
    }

    private GuestbookLocalService _guestbookLocalService;

}
\end{verbatim}
\item
  Organize imports (\emph{{[}CTRL{]}+{[}SHIFT{]}+O}) and save your work.
\end{enumerate}

Now the Guestbook application updates the database with the necessary
status information, interacting with Liferay's workflow classes to make
sure each entity is properly handled by Liferay DXP. At this point you
can enable workflow for the Guestbook inside Liferay DXP and see how it
works. Navigate to \emph{Control Panel → Workflow} → \emph{Process
Builder} → \emph{Configuration}. The Guestbook entity appears among
Liferay DXP's native entities. Enable the Single Approver Workflow for
Guestbooks; then go to the Guestbook Admin portlet and add a new
Guestbook. A notification appears next to your user name in the product
menu. You receive a notification from the workflow that a task is ready
for review. Click it, and you're taken to the My Workflow Tasks portlet,
where you can complete the review task.

\begin{figure}
\centering
\includegraphics{./images/workflow-notification.png}
\caption{Click the workflow notification in the Notifications portlet to
review the guestbook submitted to the workflow.}
\end{figure}

To complete the review, click the actions button
(\includegraphics{./images/icon-actions.png}) from My Workflow Tasks and
select \emph{Assign to Me}. Click the actions button again and select
\emph{Approve}.

\begin{figure}
\centering
\includegraphics{./images/workflow-assign-to-me.png}
\caption{Click the workflow notification in the Notifications portlet to
review the guestbook submitted to the workflow.}
\end{figure}

Right now the workflow process for guestbooks is functional, but the UI
isn't adapted for it. You'll write the workflow handler for guestbook
entries next, and then update the UI to account for each entity's
workflow status.

\chapter{Creating a Workflow Handler for Guestbook
Entries}\label{creating-a-workflow-handler-for-guestbook-entries}

\begin{verbatim}
<p>Handling Workflow<br>Step 2 of 2</p>
\end{verbatim}

The Guestbook entry's workflow handler is almost identical to the
guestbook's.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new class in the \texttt{com.liferay.docs.guestbook.workflow}
  package of the \texttt{guestbook-service} module. Name it
  \texttt{GuestbookEntryWorkflowHandler} and extend
  \texttt{BaseWorkflowHandler}. Paste this in as the class body:

\begin{verbatim}
@Component(immediate = true, service = WorkflowHandler.class)
public class GuestbookEntryWorkflowHandler extends BaseWorkflowHandler<GuestbookEntry> {

    @Override
    public String getClassName() {

        return GuestbookEntry.class.getName();

    }

    @Override
    public String getType(Locale locale) {

        return _resourceActions.getModelResource(locale, getClassName());

    }

    @Override
    public GuestbookEntry updateStatus(
        int status, Map<String, Serializable> workflowContext)
        throws PortalException {

        long userId = GetterUtil.getLong(
            (String) workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
        long resourcePrimKey = GetterUtil.getLong(
            (String) workflowContext.get(
                WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

        ServiceContext serviceContext =
            (ServiceContext) workflowContext.get("serviceContext");

        long guestbookId =
            _guestbookEntryLocalService.getGuestbookEntry(resourcePrimKey).getGuestbookId();

        return _guestbookEntryLocalService.updateStatus(
            userId, guestbookId, resourcePrimKey, status, serviceContext);
    }

    @Reference(unbind = "-")
    protected void setGuestbookEntryLocalService(GuestbookEntryLocalService guestbookEntryLocalService) {

        _guestbookEntryLocalService = guestbookEntryLocalService;
    }

    @Reference(unbind = "-")
    protected void setResourceActions(ResourceActions resourceActions) {

        _resourceActions = resourceActions;
    }

    private GuestbookEntryLocalService _guestbookEntryLocalService;
    private ResourceActions _resourceActions;
}
\end{verbatim}

  There is nothing unique about this code as compared with the
  guestbook's workflow handler, except that we need the
  \texttt{gustbookId} for the entry. That's easily obtained by getting
  the \texttt{GuestbookEntry} object with
  \texttt{guestbookEntryLocalService}, then getting its
  \texttt{guestbookId}. See the last article for the rest of the
  handler's implementation details.
\item
  Organize imports with \emph{CTRL+SHIFT+O} and save the file.
\end{enumerate}

The back-end of the guestbook project is fully workflow enabled. All
that's left is to update the Guestbook Application's UI to handle
workflow status.

\chapter{Displaying Approved Workflow
Items}\label{displaying-approved-workflow-items}

There's not much left to do. Both entities in the guestbook project's
back-end are workflow enabled, so it's time to update the UI. The
Guestbook Admin portlet and the Guestbook portlet each requires its own
display strategy.

The Guestbook Admin application is accessed by administrators, so it can
display all guestbooks that have been submitted, even if they're not
marked as approved. However, adding a \emph{Status} field to the search
container makes sense. That way admins can see which guestbooks are
already approved, which are drafts, which are pending, etc.

The Guestbook application is meant to be viewed by site members and even
guests (unauthenticated users of your site). Here it's smart to display
only approved guestbooks and approved entries.

Start by updating the Guestbook Admin UI.

Let's Go!{}

\chapter{Displaying Guestbook Status}\label{displaying-guestbook-status}

\begin{verbatim}
<p>Displaying Approved Workflow Items<br>Step 1 of 2</p>
\end{verbatim}

The Guestbook Admin application's main view currently has a search
container with two columns: the guestbook name and the guestbook actions
button.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-admin-nostatus.png}
\caption{The Guestbook Admin's main view currently shows the name of the
guestbook and its actions button.}
\end{figure}

Now you'll add a third column between the two existing ones:
\emph{Status}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open
  \texttt{guestbook-web/src/main/reosurces/META-INF/resources/guestbook\_admin/view.jsp}.
\item
  Find the existing \texttt{search-container-column} definitions:

\begin{verbatim}
<liferay-ui:search-container-column-text property="name" />

<liferay-ui:search-container-column-jsp align="right"
    path="/guestbook_admin/guestbook_actions.jsp" />
\end{verbatim}
\item
  Put the following new column between the existing columns:

\begin{verbatim}
<liferay-ui:search-container-column-status property="status" />
\end{verbatim}
\end{enumerate}

Save the file and wait for the \texttt{web} module to redeploy. With the
addition of one line in the JSP, the Guestbook Admin application now
displays the guestbook's workflow status.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-admin-status.png}
\caption{The Guestbook Admin's main view, displaying the status of each
guestbook.}
\end{figure}

Now you can move on to the Guestbook application's view layer.

\chapter{Displaying Approved Entries}\label{displaying-approved-entries}

\begin{verbatim}
<p>Displaying Approved Workflow Items<br>Step 2 of 2</p>
\end{verbatim}

The Guestbook application needs to be updated so that only guestbooks
and entries with a status of \emph{approved} appear in the UI.

Change the getters used to retrieve both entities in the view layer.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You need a new import, so first open
  \texttt{guestbook-web/src/main/resources/META-INF/resources/init.jsp}
  and add this line:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.workflow.WorkflowConstants"%>
\end{verbatim}
\item
  Now open
  \texttt{guestbook-web/src/main/resources/META-INF/resources/guestbook/view.jsp}.
  Find the scriptlet that retrieves guestbooks:

\begin{verbatim}
<%
    List<Guestbook> guestbooks = GuestbookLocalServiceUtil
                .getGuestbooks(scopeGroupId);
        for (int i = 0; i < guestbooks.size(); i++) {
            Guestbook curGuestbook = (Guestbook) guestbooks.get(i);
            String cssClass = StringPool.BLANK;
            if (curGuestbook.getGuestbookId() == guestbookId) {
                cssClass = "active";
            }
            if (GuestbookPermission.contains(
                permissionChecker, curGuestbook.getGuestbookId(), "VIEW")) {

%>
\end{verbatim}

  Change it so it calls the getter you added that takes workflow status
  into account. All you need to do is change this method call

\begin{verbatim}
List<Guestbook> guestbooks = GuestbookLocalServiceUtil
            .getGuestbooks(scopeGroupId);
\end{verbatim}

  to

\begin{verbatim}
List<Guestbook> guestbooks = GuestbookLocalServiceUtil
            .getGuestbooks(scopeGroupId, WorkflowConstants.STATUS_APPROVED);
\end{verbatim}

  Save the file, and now only approved guestbooks are displayed in the
  Guestbook application.
\item
  Next, update the entry's UI in the same \texttt{view.jsp}. Find the
  tags that set the search container's total and its results:

\begin{verbatim}
<liferay-ui:search-container total="<%=GuestbookEntryLocalServiceUtil.
                getGuestbookEntriesCount()%>">
<liferay-ui:search-container-results results=
                "<%=GuestbookEntryLocalServiceUtil.getGuestbookEntries
                (scopeGroupId.longValue(),
                guestbookId, searchContainer.getStart(),
                searchContainer.getEnd())%>" />
\end{verbatim}

  Replace the getters to use the ones that take workflow status as a
  parameter, and pass \texttt{WorkflowConstants.STATUS\_APPROVED} as the
  status. Here's what it looks like when you're finished:

\begin{verbatim}
<liferay-ui:search-container total="<%=GuestbookEntryLocalServiceUtil.
                getGuestbookEntriesCount(scopeGroupId.longValue(), 
                guestbookId, WorkflowConstants.STATUS_APPROVED)%>">
<liferay-ui:search-container-results results=
                "<%=GuestbookEntryLocalServiceUtil.getGuestbookEntries(
                scopeGroupId.longValue(), guestbookId, 
                WorkflowConstants.STATUS_APPROVED, 
                searchContainer.getStart(), searchContainer.getEnd())%>" />
\end{verbatim}
\end{enumerate}

Now only approved entries are displayed, and the search container's
counter only counts the approved entries. If you update the
\texttt{getGuestbookEntries} call but not the
\texttt{getGuestbookEntriesCount} call, the count that's displayed
includes approved entries and entries with any other workflow status,
and it won't match the total that's displayed at the bottom of the
search container.

\begin{figure}
\centering
\includegraphics{./images/lp-workflow-entries-count.png}
\caption{If you don't update the counter method to account for workflow
status, it displays an incorrect count in the search container.}
\end{figure}

Now Guestbooks and Guestbook Entries are now fully workflow enabled, to
the great relief of the Lunar Resort's site administrators. You've saved
them a lot of headaches dealing with inappropriate content, primarily
submitted by visitors from Mars. Those Martians really need some lessons
in netiquette.

\chapter{Upgrading Code to 7.0}\label{upgrading-code-to-7.0}

Upgrading to 7.0 involves migrating your installation and code (your
custom apps) to the new version. You'll learn how to upgrade your code
in this section.

These tutorials assume you're using the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-upgrade-planner}{Liferay
Upgrade Planner}. To follow along with this section, install the planner
and step through the upgrade instructions. You can also use the planner
to
\href{/docs/7-2/deploy/-/knowledge_base/d/upgrading-to-product-ver}{upgrade
your data}; this is a separate process that must be done independently
from the code upgrade process.

For convenience, this tutorial section also references documentation and
outlined steps to aid those opting to upgrade their code manually.

Here are the code upgrade steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \{.root\}\href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment}{Upgrade
  Your Development Environment}

  Legacy project environments should be upgraded to the latest version
  of Liferay Workspace to ensure you leverage all available
  features.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#setting-up-liferay-workspace}{Set
    Up Liferay Workspace}

    A Liferay Workspace is a generated environment that is built to hold
    and manage your Liferay projects. Create/import a workspace to get
    started.\{.summary\}

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#creating-new-liferay-workspace}{Create
      New Liferay Workspace}

      If you don't have an existing 7.x Liferay Workspace, you must
      create one. Skip to the next step if you have an existing
      workspace.\{.summary\}
    \item
      \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#importing-existing-liferay-workspace}{Import
      Existing Liferay Workspace}

      Import an existing Liferay Workspace. If you don't have one,
      revisit the previous step.\{.summary\}
    \end{enumerate}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configuring-liferay-workspace-settings}{Configure
    Liferay Workspace Settings}

    Set the Liferay DXP version in workspace's configuration you intend
    to upgrade to.\{.summary\}

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#configure-workspace-product-key}{Configure
      Workspace Product Key}

      Configure your workspace by setting a product key.\{.summay\}
    \item
      \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#initializing-server-bundle}{Initialize
      Server Bundle}

      Download the Liferay DXP bundle you're upgrading to.
    \item
      \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-your-development-environment\#migrate-cfg-files-to-config-files}{Migrate
      .cfg Files to .config Files}

      Convert \texttt{.cfg} files to \texttt{.config} files.\{.summay\}
    \end{enumerate}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace}{Migrate
  Plugins SDK Projects}

  Copy your Plugins SDK projects into workspace and convert them to
  Gradle/Maven projects.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#importing-existing-plugins-sdk-projects}{Import
    Existing Plugins SDK Projects}

    Import your existing Plugins SDK projects.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/migrating-plugins-sdk-projects-to-liferay-workspace\#migrating-existing-plugins-to-workspace}{Migrate
    Existing Plugins to Workspace}

    Migrate your existing plugins to workspace. This involves moving the
    plugin to workspace and converting it to the workspace's build
    environment.\{.summary\}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-build-dependencies}{Upgrade
  Build Dependencies}

  Optimize your workspace's build environment for the most efficient
  code upgrade experience.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-repository-url}{Update
    Repository URL}

    Update your repository URL to Liferay's frequently updated CDN
    repository.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#updating-the-workspace-plugin-version}{Update
    Workspace Plugin Version}

    Update your Workspace plugin version to leverage the latest features
    of Liferay Workspace.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-build-dependencies\#removing-your-projects-build-dependency-versions}{Remove
    Dependency Versions}

    Remove the project's dependency versions since it's leveraging
    target platform.\{.summary\}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/fixing-upgrade-problems}{Fix
  Upgrade Problems}

  Fix common upgrade problems dealing with your project's dependencies
  and breaking changes.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#auto-correcting-upgrade-problems}{Auto-Correct
    Upgrade Problems}

    Auto-correct straightforward upgrade problems.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#finding-upgrade-problems}{Find
    Upgrade Problems}

    Find upgrade problems. These are problems that cannot be
    auto-corrected; you can update them manually according to the
    breaking changes documentation.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#resolving-upgrade-problems}{Resolve
    Upgrade Problems}

    Mark upgrade problems as resolved after addressing them.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/fixing-upgrade-problems\#removing-problem-markers}{Remove
    Problem Markers}

    After fixing your upgrade problems, remove the problem
    markers.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
    a Project's Dependencies}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Resolving
    Breaking Changes}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-builder-services}{Upgrade
  Service Builder Services}

  Upgrade your Liferay Service Builder services.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/removing-legacy-files}{Remove
    Legacy Files}

    Remove legacy files that are no longer leveraged by Service
    Builder.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/converting-a-service-builder-module-from-spring-di-to-osgi-ds}{Migrate
    from Spring DI to OSGi Declarative Services}

    Leverage OSGi Declarative Services in your Service Builder
    project.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/rebuilding-services}{Rebuild
    Services}

    Rebuild your project's services to persist your updates.\{.summary\}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-customization-plugins}{Upgrade
  Customization Plugins}

  Upgrade your customization plugins so they're deployable to
  7.0.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Upgrade
    Customization Modules}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrade
    Core JSP Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portlet-jsp-hooks}{Upgrade
    Portlet JSP Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-wrapper-hooks}{Upgrade
    Service Wrapper Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrade
    Core Language Key Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Upgrade
    Portlet Language Key Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrade
    Model Listener Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-event-action-hooks}{Upgrade
    Event Action Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Upgrade
    Servlet Filter Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portal-property-hooks}{Upgrade
    Portal Properties Hooks}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-struts-action-hooks}{Upgrade
    Struts Action Hooks}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-theme-to-7-2}{Upgrade
  Themes}

  Upgrade your themes so they're deployable to 7.0.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-6-2-themes-to-7-2}{Upgrade
    6.2 Themes to 7.2}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-7-0-themes-to-7-2}{Upgrade
    7.0 Themes to 7.2}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-7-1-themes-to-7-2}{Upgrade
    7.1 Themes to 7.2}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-layout-template-to-7-2}{Upgrade
  Layout Templates}

  Upgrade your layout templates so they're deployable to
  7.0.\{.summary\}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-frameworks-and-features}{Upgrade
  Frameworks \& Features}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-jndi-data-source-usage}{Upgrade
    JNDI Data Source Usage}

    Use Liferay DXP's class loader to access the app server's JNDI
    API.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-builder-service-invocation}{Upgrade
    Service Builder Service Invocation}

    For Service Builder logic remaining in a WAR, you must implement a
    service tracker to call services. For logic divided into OSGi
    modules, you can leverage Declarative Services.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-builder}{Upgrade
    Service Builder}

    Adapt your app to account for Service Builder-specific
    changes.\{.summary\}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/migrating-off-of-velocity-templates}{Migrate
    Off of Velocity Templates}

    Velocity template usage is deprecated for 7.0. You should convert
    your template to FreeMarker.\{.summary\}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portlets}{Upgrade
  Portlets}

  Upgrade your portlets so they're deployable to 7.0.\{.summary\}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{Upgrade
    Generic Portlets}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Upgrade
    Liferay MVC Portlets}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Upgrade
    JSF Portlets}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Upgrade
    Servlet-based Portlets}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-spring-portlet-mvc-portlet}{Upgrading
    Spring Portlet MVC Portlets}
  \item
    \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-struts-1-portlet}{Upgrade
    Struts 1 Portlets}
  \end{enumerate}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-web-plugins}{Upgrade
  Web Plugins}

  Upgrade web plugins previously stored in the \texttt{webs} folder of
  your legacy Plugins SDK.\{.summary\}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-ext-plugins}{Upgrade
  Ext Plugins}

  Attempt to leverage an extension point instead of upgrading your Ext
  plugin. If an Ext plugin is necessary, you must review all changes
  between the previous Liferay Portal instance you were using and 7.0,
  and then manually modify your Ext plugin to merge your changes with
  Liferay DXP's.\{.summary\}
\end{enumerate}

Once you've finished the code upgrade steps, your custom apps will be
compatible with 7.0!

\chapter{Upgrading Your Development
Environment}\label{upgrading-your-development-environment}

A
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} is a generated environment that is built to hold and manage
your Liferay projects. It is intended to aid in the management of
Liferay projects by providing various build scripts and configured
properties.

Liferay Workspace is the recommended environment for your code
migration; therefore, it will be the assumed development environment in
this section.

Continue on to set up a workspace.

\section{Setting Up Liferay
Workspace}\label{setting-up-liferay-workspace}

You must set up your workspace development environment before you begin
upgrading your custom apps. If you don't have an existing workspace,
follow the step for creating one. If you have an existing workspace,
follow the step on importing it into the Upgrade Planner.

\section{Creating New Liferay
Workspace}\label{creating-new-liferay-workspace}

Initiating this step in the Upgrade Planner loads the Liferay Workspace
Project wizard.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Give your new workspace a name.
\item
  Choose the build type (Gradle or Maven) you prefer for your workspace
  environment and future Liferay projects.
\item
  Click Finish.
\end{enumerate}

You now have a new Liferay Workspace available in the Upgrade Planner!

For more information on creating a Liferay Workspace outside the
planner, see the
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-liferay-workspace}{Creating
a Liferay Workspace} section.

\section{Importing Existing Liferay
Workspace}\label{importing-existing-liferay-workspace}

If you already have an existing 7.x Liferay Workspace, you should import
it into the planner. Once you initiate this step, you're given a File
Explorer/Manager to select your existing workspace. After selecting it,
the workspace is imported into the Project Explorer.

For more information importing a workspace into your IDE, see
\href{/docs/7-2/reference/-/knowledge_base/r/importing-projects-in-dev-studio}{this
article}.

\section{Configuring Liferay Workspace
Settings}\label{configuring-liferay-workspace-settings}

You must configure your workspace with the Liferay DXP version you
intend to upgrade to.

\section{Configure Workspace Product
Key}\label{configure-workspace-product-key}

Configure your workspace by setting a product key. This automatically
sets the Target Platform version, Docker image name, bundle URL, and
other default settings for the Liferay DXP release.

\section{Initializing Server Bundle}\label{initializing-server-bundle}

Once your workspace is configured for the Liferay DXP version you're
upgrading to, you can initialize the server bundle. This involves
downloading the bundle and extracting it into its folder (e.g.,
\texttt{bundles}). If you have an existing workspace already equipped
with an older Liferay bundle, this deletes the old bundle and
initializes the new one.

If you're upgrading your code manually and working in Dev Studio, you
can do this by right-clicking the workspace project and selecting
\emph{Liferay} → \emph{Initialize Server Bundle}. See the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-a-server-in-intellij}{Installing
a Server in IntelliJ} article if you use IntelliJ instead. Visit the
\href{/docs/7-2/reference/-/knowledge_base/r/managing-your-liferay-server-with-blade-cli}{Managing
Your Liferay Server with Blade CLI} article for information on how to do
this via the command line.

\section{Migrate .cfg Files to .config
Files}\label{migrate-.cfg-files-to-.config-files}

\texttt{.config} files are preferred over \texttt{.cfg} files because
they allow specifying a property value's type, and allow multi-valued
properties.

\chapter{Migrating Plugins SDK Projects to Liferay
Workspace}\label{migrating-plugins-sdk-projects-to-liferay-workspace}

The Plugins SDK was deprecated for Liferay DXP 7.0 and removed for
Liferay DXP 7.1. Therefore, to upgrade your custom apps to 7.0, you must
migrate them to a new environment.
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} is the recommended environment for your code migration and
will be the assumed choice in this section.

There are two steps you must follow to migrate your custom code to
workspace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the Plugins SDK project into the Upgrade Planner.
\item
  Convert the Plugins SDK project to a supported workspace build type.
\end{enumerate}

You'll step through importing a Plugins SDK project first.

\section{Importing Existing Plugins SDK
Projects}\label{importing-existing-plugins-sdk-projects}

Initiating this step in the Upgrade Planner imports your Plugins SDK
projects into the Upgrade Planner. These projects originate from the
Plugins SDK you set when the Upgrade Planner process was started.

If you're manually upgrading your code, you can skip this step.

You're now ready to migrate your Plugins SDK projects to your new
workspace!

\section{Migrating Existing Plugins to
Workspace}\label{migrating-existing-plugins-to-workspace}

Liferay Workspace can be generated as a Gradle or Maven environment, but
it does not support the Plugins SDK's Ant build. Because of this, you
must convert your projects to one of the supported build tools:

\begin{itemize}
\tightlist
\item
  Gradle
\item
  Maven
\end{itemize}

When initiating this step for a Gradle-based workspace, your Ant-based
Plugins SDK project is copied to the applicable workspace folder based
on its project type (e.g., \texttt{wars}) and is converted to a Gradle
project. There is also a Blade CLI command that completes this via the
command line. Visit the
\href{/docs/7-2/reference/-/knowledge_base/r/converting-plugins-sdk-projects-with-blade-cli}{Converting
Plugins SDK Projects with Blade CLI} article for more information.

If you're migrating your Ant project to a Maven workspace, you must
manually copy the project to the applicable folder based on the project
type (e.g., \texttt{wars}). The majority of Plugins SDK projects belong
in the workspace's \texttt{wars} folder. You can consult the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace\#workspace-anatomy}{Workspace
Anatomy} section for a full overview of a workspace's folder structure
and choose where your custom app should reside. Once you've made the
decision, copy your custom app to the applicable workspace folder.

Then you must convert your project from Ant to Maven. You'll have to
complete this conversion manually.

Once you're finished, you should have your project(s) residing in the
applicable workspace folders as Gradle/Maven projects.

\chapter{Upgrading Build
Dependencies}\label{upgrading-build-dependencies}

Now that your projects are readily available in a workspace, you must
ensure your project build dependencies are upgraded. Your workspace
streamlines the build dependency upgrade process by only requiring three
modifications:

\begin{itemize}
\tightlist
\item
  \hyperref[updating-the-repository-url]{Update the repository URL}
  (Gradle only)
\item
  \hyperref[updating-the-workspace-plugin-version]{Update the workspace
  plugin version}
\item
  \hyperref[removing-your-projects-build-dependency-versions]{Remove
  your project's build dependency versions} (Gradle only)
\end{itemize}

If you're upgrading a recently created workspace, only a subset of these
tasks may be required.

You'll start by updating the repository URL.

\section{Updating the Repository URL}\label{updating-the-repository-url}

Initiating this step in the Upgrade Planner updates the repository URL
used to download artifacts for your workspace.

If you're using a Gradle-based workspace, the repository URL is updated
to point to the latest Liferay CDN repository. This is set in your
workspace's \texttt{settings.gradle} file within the
\texttt{buildscript} block like this:

\begin{verbatim}
repositories {
    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Once the repository URL is set to the proper CDN repository, your build
dependencies will be downloaded from Liferay's own managed repo.

For Maven-based workspaces, Maven Central is the default repository, so
no action is required.

\section{Updating the Workspace Plugin
Version}\label{updating-the-workspace-plugin-version}

For the best upgrade experience, you should ensure you're leveraging the
latest Liferay Workspace version so all the latest features are
available to you. Initiate this step to upgrade the appropriate plugin.

See the
\href{/docs/7-2/reference/-/knowledge_base/r/updating-liferay-workspace}{Updating
Liferay Workspace} article to do this for Gradle-based workspaces
manually. For Maven-based workspaces, make sure you set the latest
\href{/docs/7-2/reference/-/knowledge_base/r/bundle-support-plugin}{Bundle
Support plugin} version in your root \texttt{pom.xml} file.

\section{Removing Your Project's Build Dependency
Versions}\label{removing-your-projects-build-dependency-versions}

\noindent\hrulefill

\textbf{Note:} This step only applies to Gradle-based workspaces since
the target platform feature is only available for Gradle projects at
this time.

\noindent\hrulefill

Since your workspace is leveraging the target platform feature, there is
no need to set your plugin's dependency versions in its
\texttt{build.gradle} file. This is because the target platform version
you set already defines the artifact versions your project uses.
Therefore, if dependency versions are present in any of your projects'
\texttt{build.gradle} files, you must remove them.

Initiate this step to remove your dependency versions from your
project's \texttt{build.gradle} file

As an example of what a \texttt{build.gradle}'s \texttt{dependencies}
block should look like, see the below snippet:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel"
    compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib"
    compileOnly group: "javax.portlet", name: "portlet-api"
    compileOnly group: "javax.servlet", name: "javax.servlet-api"
    compileOnly group: "jstl", name: "jstl"
    compileOnly group: "org.osgi", name: "osgi.cmpn"
}
\end{verbatim}

If you have not set the target platform feature in your workspace, see
the
\href{/docs/7-2/reference/-/knowledge_base/r/managing-the-target-platform}{Managing
the Target Platform} article for more information.

Great! You've successfully upgraded your build dependencies! You likely
have compile errors in your project; this is because your dependencies
may have changed. You'll learn how to update that and more next.

\chapter{Fixing Upgrade Problems}\label{fixing-upgrade-problems}

Now that your development environment build configuration is settled,
you can start upgrading your project(s). The two most common upgrade
problems are

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Broken
  project dependencies}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-breaking-changes}{Breaking
  changes}
\end{itemize}

Visit these upgrade problem tutorials for tips on how to fix them.

This tutorial is heavily focused on the Liferay Upgrade Planner. If
you're upgrading your code manually, continue to the listed tutorials
above to fix your code upgrade problems.

You'll begin auto-correcting upgrade problems first.

\section{Auto-Correcting Upgrade
Problems}\label{auto-correcting-upgrade-problems}

Initiate this step to auto-correct straightforward updates like

\begin{itemize}
\tightlist
\item
  package imports
\item
  JSP tag names
\item
  Liferay descriptor versions
\item
  XML descriptor content
\item
  etc.
\end{itemize}

If you choose to preview the auto-correct upgrade problems first, you
can view them in the Project Explorer under the \emph{Liferay Upgrade
Problems} dropdown. If you click one of the upgrade problems listed with
the preview, you're offered documentation in the \emph{Liferay Upgrade
Plan Info} window on the proposed change.

Once you've performed this step, the result list is removed.

\section{Finding Upgrade Problems}\label{finding-upgrade-problems}

Initiating this step finds the upgrade problems that were not eligible
for auto-correction. The problems are listed under the \emph{Liferay
Upgrade Problems} dropdown. If you click one of the upgrade problems
listed with the preview, you're offered documentation in the
\emph{Liferay Upgrade Plan Info} window on the proposed change.

These upgrade problems are available in the
\href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-breaking-changes}{breaking
changes} for the version upgrade you're performing.

The next step is resolving the reported upgrade problems.

\section{Resolving Upgrade Problems}\label{resolving-upgrade-problems}

Now that the upgrade problems have been located, you must resolve them.
As you select each upgrade problem, the documentation for how to adapt
your code is displayed in the \emph{Liferay Upgrade Plan Info} window.

For each upgrade problem node, you're also given the version the upgrade
problem applies to (e.g., when upgrading to Liferay DXP 7.2 from Liferay
Portal 6.2, you could have upgrade problems from the 7.0, 7.1, or 7.2
upgrade). As you step through the reported problems, mark them as
resolved/skipped using the context menu. You can right-click on the
problem in the Project Explorer and choose from four options:

\begin{itemize}
\tightlist
\item
  Mark done
\item
  Mark undone
\item
  Ignore
\item
  Ignore all problems of this type
\end{itemize}

Leave this step marked as \emph{Incomplete} until you have resolved all
upgrade problems accordingly.

\section{Removing Problem Markers}\label{removing-problem-markers}

After resolving all the reported upgrade problems, you must remove all
previously found markers because, in most cases, the line number and
other accompanying marker information are out of date and must be
removed before continuing. Initiate this step to remove all the problem
markers.

Great! You've fixed all the upgrade problems that could be automatically
detected by the Code Upgrade Tool. Next, you'll take a deeper look at
resolving project dependency errors.

Let's Go!{}

\chapter{Resolving a Project's
Dependencies}\label{resolving-a-projects-dependencies}

\begin{verbatim}
<p id="stepTitle">Fixing Upgrade Problems</p><p>Step 1 of 2</p>
\end{verbatim}

You may have compile errors due to missing Liferay classes or unresolved
symbols because they've been moved, renamed, or removed. As a part of
modularization in Liferay DXP, many of these classes reside in new
modules.

You must resolve all of these Liferay classes for your project. Some of
the class changes are quick and easy to fix. Changes involving the new
modules require more effort to resolve, but doing so is still
straightforward.

Liferay class changes and required adaptations can be grouped into three
categories:

\begin{itemize}
\item
  \hyperref[class-moved-to-a-package-in-the-classpath]{Class moved to a
  package in the classpath}
\item
  \hyperref[class-moved-to-a-module-not-in-the-classpath]{Class moved to
  a module \emph{not} in the classpath}
\item
  \hyperref[class-replaced-or-removed]{Class replaced or removed}
\end{itemize}

Continue on to learn how to resolve each change.

\section{Class Moved to a Package in the
Classpath}\label{class-moved-to-a-package-in-the-classpath}

This change is common and easy to fix. Consider resolving these classes
first.

Since the module is already on your classpath, you need only update the
class import. You can do this by using the Liferay Upgrade Planner or by
organizing imports in Dev Studio/IntelliJ. The Upgrade Planner reports
each moved class for you to address one by one. Organizing imports in
Dev Studio/IntelliJ automatically resolves multiple classes at once.

It's typically faster to resolve moved classes using the mentioned IDEs.
You can follow similar instructions for both IDEs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Comment out or remove any imports marked as errors.
\item
  Execute the \emph{Organize Imports} keyboard sequence
  \emph{Ctrl-Shift-o} (Dev Studio) or \emph{Ctrl-Alt-o} (IntelliJ).
\end{enumerate}

The IDEs automatically generate the new import statements. If there is
more than one available import package for a class, a wizard appears
that lets you select the correct import.

Great! You've updated your class imports!

\section{Class Moved to a Module Not in the
Classpath}\label{class-moved-to-a-module-not-in-the-classpath}

You must resolve the new module as a dependency for your project. This
requires identifying the module and specifying your project's dependency
on it.

Before Liferay DXP 7.0, all the platform APIs were in
\texttt{portal-service.jar}. Many of these APIs are now in independent
modules. Modularization has resulted in many benefits, as described in
the article
\href{/docs/7-2/customization/-/knowledge_base/c/the-benefits-of-modularity}{The
Benefits of Modularity}. One such advantage is that these API modules
can evolve separately from the platform kernel. They also simplify
future upgrades. For example, instead of having to check all of
Liferay's APIs, each module's \href{http://semver.org}{Semantic
Versioning} indicates whether the module contains any
backwards-incompatible changes. You need only adapt your code to such
modules (if any).

As part of the modularization, \texttt{portal-service.jar} has been
renamed appropriately to \texttt{portal-kernel.jar}, as it continues to
hold the portal kernel's APIs.

\begin{figure}
\centering
\includegraphics{./images/from-liferay-6-portal-apis-before-after.png}
\caption{Liferay refactored the portal-service JAR for 7.0. Application
APIs now exist in their own modules, and the portal-service JAR is now
\emph{portal-kernel}.}
\end{figure}

Each app module consists of a set of classes that are highly cohesive
and have a specific purpose, such as providing the app's API,
implementation, or UI. The app modules are therefore much easier to
understand. Next, you'll track down the modules that now hold the
classes referenced by your plugin.

The reference article
\href{/docs/7-2/reference/-/knowledge_base/r/classes-moved-from-portal-service-jar}{Classes
Moved from \texttt{portal-service.jar}} contains a table that maps each
class moved from \texttt{portal-service.jar} to its new module in
Liferay DXP 7.1. The table includes each class's new package and
symbolic name (artifact ID). You'll use this information to configure
your plugin's dependencies on these modules.

For more information on finding and resolving your project dependencies,
see
\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}.

\section{Class Replaced or Removed}\label{class-replaced-or-removed}

In cases where the class has been replaced by another class or removed
from the product, some investigation is required. The easiest way to
resolve this type of issue is to use the Upgrade Planner. It finds
removed classes your project is referencing and explains what happened
to the class, how to handle the change, and why the change was made.
These are listed as breaking changes (among other types of changes).
Move on to the next section to learn about Liferay's breaking changes.

\chapter{Resolving Breaking Changes}\label{resolving-breaking-changes}

\begin{verbatim}
<p id="stepTitle">Fixing Upgrade Problems</p><p>Step 2 of 2</p>
\end{verbatim}

Liferay goes to great lengths to maintain backwards compatibility.
Sometimes, breaking changes are necessary to improve Liferay DXP. There
may be cases where breaking changes affect your code upgrade process and
must be resolved. A breaking change can include

\begin{itemize}
\tightlist
\item
  Functionality that is removed or replaced
\item
  API incompatibilities: Changes to public Java or JavaScript APIs
\item
  Changes to context variables available to templates
\item
  Changes in CSS classes available to Liferay themes and portlets
\item
  Configuration changes: Changes in configuration files, like
  \texttt{portal.properties}, \texttt{system.properties}, etc.
\item
  Execution requirements: Java version, J2EE Version, browser versions,
  etc.
\item
  Deprecations or end of support: For example, warning that a certain
  feature or API will be dropped in an upcoming version.
\item
  Recommendations: For example, recommending using a newly introduced
  API that replaces an old API, in spite of the old API being kept in
  Liferay Portal for backwards compatibility.
\end{itemize}

Liferay provides a list of breaking changes for every major release to
ensure you can easily adapt your code during the upgrade process.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.0 Breaking Changes}
\item
  \href{/docs/7-1/reference/-/knowledge_base/r/breaking-changes}{Liferay
  DXP 7.1 Breaking Changes}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/breaking-changes}{7.0
  Breaking Changes}
\end{itemize}

The easiest way to resolve breaking changes is by using the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-upgrade-planner}{Liferay
Upgrade Planner}. It automatically finds all documented breaking changes
and can automatically resolve some of them on its own.

If you're resolving breaking changes manually, make sure to investigate
each breaking change document if you're upgrading code across multiple
versions. For example, if you're upgrading from Liferay Portal 6.2 to
7.0, you must resolve all the breaking changes listed in the three
documents listed above.

Now that you've resolved your breaking changes, you'll learn how to
upgrade service builder services next.

\chapter{Upgrading Service Builder
Services}\label{upgrading-service-builder-services}

To properly upgrade app's leveraging service builder, you must complete
the following steps:

\begin{itemize}
\tightlist
\item
  Remove Legacy Files
\item
  Migrate from Spring DI to OSGi Declarative Services
\item
  Rebuild Services
\end{itemize}

You'll start by removing legacy files.

Let's Go!{}

\chapter{Removing Legacy Files}\label{removing-legacy-files}

\begin{verbatim}
<p id="stepTitle">Upgrading Service Builder Services</p><p>Step 1 of 3</p>
\end{verbatim}

The first step in upgrading your Service Builder services is to delete
legacy files. These legacy files include

\begin{itemize}
\tightlist
\item
  \texttt{portlet-spring.xml}
\item
  \texttt{shard-data-source-spring.xml}
\item
  \texttt{/src/main/resources/META-INF/} (folder)
\end{itemize}

When initiating this step, these files/folders are automatically removed
from your Service Builder project.

If you're manually upgrading your code, delete the listed files/folders
above.

Next, you'll convert your Service Builder Module from Spring DI to OSGi
DS.

\chapter{Converting a Service Builder Module from Spring DI to OSGi
DS}\label{converting-a-service-builder-module-from-spring-di-to-osgi-ds}

\begin{verbatim}
<p id="stepTitle">Upgrading Service Builder Services</p><p>Step 2 of 3</p>
\end{verbatim}

Prior to 7.0, Service Builder modules could only use Spring for
dependency injection (DI). Now
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Declarative Services} (DS) is the default DI mechanism for new Service
Builder modules. Although OSGi DS is the default DI mechanism, Spring is
still supported. Therefore, this is an optional migration step.

To learn more about the decision to convert your Service Builder
modules' DI mechanism and how to complete the conversion process, see
the
\href{/docs/7-2/appdev/-/knowledge_base/a/migrating-a-service-builder-module-from-spring-di-to-osgi-ds}{Migrating
a Service Builder Module from Spring DI to OSGi DS} article.

\chapter{Rebuilding Services}\label{rebuilding-services}

\begin{verbatim}
<p id="stepTitle">Upgrading Service Builder Services</p><p>Step 3 of 3</p>
\end{verbatim}

To properly upgrade Service Builder projects, you must rebuild all
service classes so your changes are persisted across your project.
Initiate this step to rebuild your services and finalize your Service
Builder upgrade.

Great! Your Service Builder services are upgraded!

\chapter{Upgrading Customization
Plugins}\label{upgrading-customization-plugins}

Liferay DXP has more extension points than ever, and connecting existing
hook plugins to them takes very few steps. In most cases, after you
upgrade your hook using the Liferay Upgrade Planner, it's ready to run
on Liferay DXP. The following tutorials show you how to upgrade each
type of hook plugin.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-customization-modules}{Override/Extension
  Modules}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Core
  JSP Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portlet-jsp-hooks}{Portlet
  JSP Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-wrapper-hooks}{Service
  Wrapper Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Core
  Language Key Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portlet-language-key-hooks}{Portlet
  Language Key Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Model
  Listener Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-event-action-hooks}{Event
  Actions Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-servlet-filter-hooks}{Servlet
  Filter Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-portal-property-hooks}{Portal
  Properties Hooks}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-struts-action-hooks}{Struts
  Action Hooks}
\end{itemize}

Continue on to get started!

Let's Go!{}

\chapter{Upgrading Customization
Modules}\label{upgrading-customization-modules}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 1 of 11</p>
\end{verbatim}

Customization modules include any module extension or override used to
customize another module. For examples of these types of modules, visit
the
\href{https://github.com/liferay/liferay-blade-samples/tree/master/liferay-workspace/extensions}{\texttt{extensions}}
and
\href{https://github.com/liferay/liferay-blade-samples/tree/master/liferay-workspace/overrides}{\texttt{overrides}}
sample projects.

Getting a customization module running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected or flagged. For any remaining
  errors, consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your module.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} A fragment was a common customization module in past
versions of Liferay DXP. Fragments are no longer recommended; you should
upgrade a fragment to a dynamic include or portlet filter. For more
information on recommended ways of customizing JSPs in 7.0, see the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{Customizing
JSPs} section.

\noindent\hrulefill

Great! Your customization module is upgraded for 7.0!

\chapter{Upgrading Core JSP Hooks}\label{upgrading-core-jsp-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 2 of 11</p>
\end{verbatim}

Getting a core JSP hook running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Although you can upgrade your core JSP hook to 7.0, there are better
ways to override a core JSP. The two recommended approaches are

\begin{itemize}
\tightlist
\item
  Dynamic includes
\item
  Portlet filters
\end{itemize}

For more information on recommended ways of customizing JSPs in 7.0, see
the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{Customizing
JSPs} section.

\chapter{Upgrading Portlet JSP Hooks}\label{upgrading-portlet-jsp-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 3 of 11</p>
\end{verbatim}

Getting a portlet JSP hook running on 7.0 takes two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Although you can upgrade your portlet JSP hook to 7.0, there are better
ways to override a portlet JSP. The two recommended approaches are

\begin{itemize}
\tightlist
\item
  Dynamic includes
\item
  Portlet filters
\end{itemize}

For more information on recommended ways of customizing JSPs in 7.0, see
the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{Customizing
JSPs} section.

\chapter{Upgrading Service Wrapper
Hooks}\label{upgrading-service-wrapper-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 4 of 11</p> 
\end{verbatim}

Upgrading traditional
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-a-portal-service-using-a-hook}{service
wrapper hook plugins} to 7.0 is quick and easy.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy the plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your service wrapper hook is now available in Liferay DXP.

\chapter{Upgrading Core Language Key
Hooks}\label{upgrading-core-language-key-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 5 of 11</p>
\end{verbatim}

Here are the steps for upgrading a core language key hook to 7.0.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  project
  (\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/master/maven/extensions/resource-bundle}{Maven}).

  Here are the main parts of the module folder structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} → Custom
    resource bundle class goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy all your plugin's language properties files into the module
  folder \texttt{src/main/resources/content/}.
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-global-language-keys\#create-a-resource-bundle-service-component}{Create
  a resource bundle loader}.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module}.
\end{enumerate}

Your core language key customizations are deployed to 7.0.

\chapter{Upgrading Portlet Language Key
Hooks}\label{upgrading-portlet-language-key-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 6 of 11</p>
\end{verbatim}

You can upgrade your portlet language key hooks to 7.0 by following
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module based on the Blade sample \texttt{resource-bundle}
  project
  (\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/extensions/resource-bundle}{Gradle}
  or
  \href{https://github.com/liferay/liferay-blade-samples/tree/master/maven/extensions/resource-bundle}{Maven}).

  Here are the module folder structure's main files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{src/main/java/{[}resource\ bundle\ path{]}} →
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/}{\texttt{ResourceBundleLoader}
    extension} goes here
  \item
    \texttt{src/main/resources/content}

    \begin{itemize}
    \tightlist
    \item
      \texttt{Language.properties}
    \item
      \texttt{Language\_xx.properties}
    \item
      \ldots{}
    \end{itemize}
  \end{itemize}
\item
  Copy your language properties files into module folder
  \texttt{src/main/resources/content/}.
\item
  In your \texttt{bnd.bnd} file,
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-a-modules-language-keys}{specify
  OSGi manifest headers} that target the portlet module's resource
  bundle, but prioritize yours.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module}.
\end{enumerate}

Your portlet language key customizations are deployed in your new module
on 7.0.

\chapter{Upgrading Model Listener
Hooks}\label{upgrading-model-listener-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 7 of 11</p>
\end{verbatim}

Developers have been creating model listeners for several Liferay DXP
versions. Upgrading model listener Hooks from previous portal versions
has never been easier.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your model listener hook is now available in Liferay DXP.

\chapter{Upgrading Event Action
Hooks}\label{upgrading-event-action-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 8 of 11</p>
\end{verbatim}

Event action hooks can be upgraded by completing these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your event action hook is now available in Liferay DXP.

\chapter{Upgrading Servlet Filter
Hooks}\label{upgrading-servlet-filter-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 9 of 11</p>
\end{verbatim}

If you have servlet filter hooks ready to be upgraded, this tutorial's
for you. The process is simple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your Servlet Filter is running on 7.0!

\chapter{Upgrading Portal Property
Hooks}\label{upgrading-portal-property-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 10 of 11</p>
\end{verbatim}

All portal properties in previous Liferay DXP versions that are also
used in 7.0 can be overridden using portal property hooks. To upgrade
portal property hooks, do this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt your code to 7.0's API using the Liferay Upgrade Planner. When
  you ran the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues were autocorrected/flagged. For any remaining errors,
  consult the
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
  a Project's Dependencies} article.
\item
  Deploy your hook plugin.
\end{enumerate}

Liferay DXP's Plugin Compatibility Layer converts the plugin WAR to a
Web Application Bundle (WAB) and installs it to Liferay's OSGi Runtime.

Your custom property values are live!

\chapter{Upgrading Struts Action
Hooks}\label{upgrading-struts-action-hooks}

\begin{verbatim}
<p id="stepTitle">Upgrading Customization Plugins</p><p>Step 11 of 11</p>
\end{verbatim}

In Liferay Portal 6.1 and 6.2, developers could customize the Portal and
Portlet Struts Actions using a Hook and \texttt{StrutsAction} wrapper.
For example, the \texttt{liferay-hook.xml} file for a hook that overrode
the login portlet's login action had this entry:

\begin{verbatim}
<struts-action>
    <struts-action-path>/login/login</struts-action-path>
    <struts-action-impl>
        com.liferay.sample.hook.action.ExampleStrutsPortletAction
    </struts-action-impl>
</struts-action>
\end{verbatim}

The \texttt{liferay-hook.xml} contains the Struts mapping and the new
class that overrides the default login action.

The wrapper could extend either \texttt{BaseStrutsAction} or
\texttt{BaseStrutsPortletAction}, depending on whether the Struts Action
was a portal or portlet action, respectively.

Since Liferay DXP 7.0, this mechanism no longer applies for most
portlets because they no longer use Struts Actions, but instead use
Liferay \texttt{MVCCommand}s.

This tutorial demonstrates how to convert your existing
\texttt{StrutsAction} wrappers to \texttt{MVCCommand}s.

\section{\texorpdfstring{Converting Your Old Wrapper to
\texttt{MVCCommand}s}{Converting Your Old Wrapper to MVCCommands}}\label{converting-your-old-wrapper-to-mvccommands}

Converting \texttt{StrutsAction} wrappers to \texttt{MVCCommand}s is
easier than you may think.

As a review, legacy \texttt{StrutsAction} wrappers implemented all
methods, such as \texttt{processAction}, \texttt{render}, and
\texttt{serveResource}, even if only one method was being customized.
Each of these methods can now be customized independently using
different classes, making the logic simpler and easier to maintain.
Depending on the method you customized in your \texttt{StrutsAction}
wrapper, you need to use the matching
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCCommand.html}{\texttt{MVCCommand}
interface} shown below:

\begin{itemize}
\tightlist
\item
  \texttt{processAction} →
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}
\item
  \texttt{render} →
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
\item
  \texttt{serveResource} →
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}
\end{itemize}

Look at the
\href{/docs/6-2/tutorials/-/knowledge_base/t/overriding-and-adding-struts-actions}{\texttt{ExampleStrutsPortletAction}
class} for a \texttt{StrutsAction} wrapper example. Depending on the
actions overridden, the user must use different \texttt{MVCCommand}s. In
this example, the action and render were overridden, so to migrate to
the new pattern, you would create two classes: an
\texttt{MVCActionCommand} and \texttt{MVCRenderCommand}.

Next you'll determine the mapping the \texttt{MVCCommand} uses.

\section{\texorpdfstring{Mapping Your \texttt{MVCCommand}
URLs}{Mapping Your MVCCommand URLs}}\label{mapping-your-mvccommand-urls}

For most cases, the \texttt{MVCCommand} mapping is the same mapping
defined in the legacy Struts Action.

Using the beginning login example once again, the
\texttt{struts-action-path} mapping, \texttt{/login/login}, remains the
same for the \texttt{MVCCommand} mapping in 7.0, but some of the
mappings may have changed. It's best to check Liferay DXP's source code
to determine the correct mapping.

Map to your \texttt{MVCCommand} URLs using portlet URL tags:

\begin{itemize}
\item
  \texttt{MVCRenderCommand} URLs go in \texttt{mvcRenderCommandName}
  parameters. For example,

\begin{verbatim}
<portlet:renderURL var="editEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/hello/edit_entry" />
    <portlet:param name="entryId" value="<%= String.valueOf(entry.getEntryId()) %>" />
</portlet:renderURL>
\end{verbatim}
\item
  \texttt{MVCActionCommand} URLs go in \texttt{actionURL} tag
  \texttt{name} attributes or in a parameter
  \texttt{ActionRequest.ACTION\_NAME}. For example,

\begin{verbatim}
<portlet:actionURL name="/blogs/edit_entry" var="editEntryURL" />
\end{verbatim}
\item
  \texttt{MVCResourceCommand} URLs go in \texttt{resourceURL} tag
  \texttt{id} attributes. For example,

\begin{verbatim}
<portlet:resourceURL id="/login/captcha" var="captchaURL" />
\end{verbatim}
\end{itemize}

Once you have this information, you can override the \texttt{MVCCommand}
by following the instructions found in these \texttt{MVCCommand}
articles:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{Adding
  Logic to MVCCommands}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcrendercommand}{Overriding
  MVCRenderCommands}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcactioncommand}{Overriding
  MVCActionCommands}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcresourcecommand}{Overriding
  MVCResourceCommands}
\end{itemize}

Now you know how to convert your \texttt{StrutsActionWrapper}s to
\texttt{MVCCommand}s!

\chapter{Upgrading a Theme to 7.2}\label{upgrading-a-theme-to-7.2}

In these tutorials, you'll learn how to upgrade your themes from earlier
versions of Liferay DXP to 7.0. As you go through this process, you'll
learn how to upgrade your theme's metadata, styling, templates, UI, and
more using all the best practices and standards. By the end of the
tutorial, you'll have a theme that runs on 7.0.

To upgrade your theme, select the tutorial below that corresponds to the
current version of your theme:

Let's Go 6.2!{}

Let's Go 7.0!{}

Let's Go 7.1!{}

\chapter{Upgrading Your Theme from Liferay Portal 6.2 to
7.2}\label{upgrading-your-theme-from-liferay-portal-6.2-to-7.2}

In this tutorial, you'll upgrade the Lunar Resort theme developed in the
Liferay Portal 6.2
\href{/docs/6-2/tutorials/-/knowledge_base/t/developing-a-liferay-theme}{Developing
a Liferay Theme} Learning Path to 7.0 using the
\href{https://github.com/liferay/liferay-js-themes-toolkit/tree/master/packages}{Liferay
JS Theme Toolkit}. The Lunar Resort theme is similar to many Liferay
Portal 6.2 themes, as it extends the
\href{https://github.com/liferay/liferay-portal/tree/6.2.x/portal-web/docroot/html/themes/_styled}{\texttt{\_styled}
theme}, adds configurable settings, and incorporates a responsive design
that leverages Font Awesome icons and Bootstrap. The theme
\href{https://github.com/liferay/liferay-docs/blob/7.0.x/develop/tutorials/code/upgrading-themes/lunar-resort-theme-migration-6.2.zip}{ZIP
file} contains its original source code.

\begin{figure}
\centering
\includegraphics{./images/finished-7-2-theme.png}
\caption{The Lunar Resort example theme upgraded in this tutorial uses a
clean, minimal design.}
\end{figure}

As you upgrade this theme, you'll learn how to update metadata, theme
templates, UI, and more using all the best practices and standards.
Completing this tutorial prepares you for upgrading your own theme.

Let's Go!{}

\chapter{Setting up the Development
Environment}\label{setting-up-the-development-environment}

In this section, you'll set up your development environment to use the
\href{https://github.com/liferay/liferay-js-themes-toolkit/tree/master/packages}{Liferay
JS Theme Toolkit}. Setting up your development environment involves
these steps:

\begin{itemize}
\item
  Install NodeJS with npm.
\item
  Install Yeoman.
\item
  Install the Liferay Theme Generator.
\item
  Import the 6.2 theme to use the Liferay JS Theme Toolkit
\end{itemize}

Let's Go{}

\chapter{Installing the Liferay Theme Generator to Import a 6.2
Theme}\label{installing-the-liferay-theme-generator-to-import-a-6.2-theme}

\begin{verbatim}
<p id="stepTitle">Setting up the Development Environment</p><p>Step 1 of 2</p>
\end{verbatim}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \href{http://nodejs.org/}{NodeJS} (along with Node Package
  Manager(npm)) if it's not already installed. We recommend installing
  the Long Term Support (LTS) version. Once NodeJS is installed,
  \href{/docs/7-2/reference/-/knowledge_base/r/setting-up-your-npm-environment}{set
  up your npm environment}.
\item
  Use npm to install the \href{http://yeoman.io/}{Yeoman} dependency:

\begin{verbatim}
npm install -g yo
\end{verbatim}
\item
  Install the Liferay Theme Generator v8.x.x with the command below:

\begin{verbatim}
npm install -g generator-liferay-theme@8.x.x
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Liferay Theme Generator v8.x.x supports importing 6.2 themes to use 
 the Liferay JS Theme Toolkit. Later on, you will install the latest version of 
 the Liferay Theme Generator to complete the upgrade process.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
If you're on Windows, follow the instructions in step 4 to install Sass, 
otherwise you can skip that step.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  The generator uses node-sass. If you're on Windows, you must also
  install
  \href{https://github.com/nodejs/node-gyp\#installation}{node-gyp and
  Python}.
\end{enumerate}

Nice job! Your npm environment is set up and the Liferay Theme Generator
and dependencies are installed. Next, you can import the Liferay DXP 6.2
theme to use the Liferay JS Theme Toolkit.

\chapter{Importing the Theme into the Liferay JS Theme
Toolkit}\label{importing-the-theme-into-the-liferay-js-theme-toolkit}

\begin{verbatim}
<p id="stepTitle">Setting up the Development Environment</p><p>Step 2 of 2</p>
\end{verbatim}

Now you'll import your theme to use the Liferay JS Theme Toolkit. The
Liferay JS Theme Toolkit provides several useful Gulp tasks for
automating theme development and maintenance, including upgrading parts
of the theme.

Follow these steps to import your theme to use the Liferay JS Theme
Toolkit:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Run the command below to import your 6.2 theme to use the Liferay JS
  Theme Toolkit:

\begin{verbatim}
yo liferay-theme:import
\end{verbatim}
\item
  Provide the path (relative or absolute) to the 6.2 theme project's
  root folder and press the \emph{Enter} key to import the theme.
\item
  Answer the prompts to configure the location to your 7.0 app server.
\end{enumerate}

Congratulations! Your development environment is set up to use the
Liferay JS Theme Toolkit. Next, you'll start upgrading the theme.

\chapter{Running the Upgrade Task for 6.2
Themes}\label{running-the-upgrade-task-for-6.2-themes}

You can upgrade a Liferay Portal 6.2 theme to 7.0, regardless of the
development environment you use. This tutorial uses the Liferay JS Theme
Toolkit's Gulp \texttt{upgrade} task to automate much of the steps.
Because the theme was built on Liferay DXP 6.2, the Gulp
\texttt{upgrade} task must be run three times to bring it up to 7.0.

The Liferay Theme Generator is available in a few different versions. To
update the Liferay DXP 6.2 theme to Liferay DXP 7.0, you must install
v8.x.x of the \texttt{liferay-theme-tasks} dependency. After the theme
is updated to 7.1, you must then install v9.x.x of the
\texttt{liferay-theme-tasks} dependency to complete the upgrade process.

Here's what the Upgrade Task does:

\begin{itemize}
\tightlist
\item
  Updates the theme's Liferay version
\item
  Updates the theme's Bootstrap version
\item
  Updates the theme's Lexicon version
\item
  Updates CSS file names
\item
  Updates theme dependencies
\item
  Suggests specific code updates
\end{itemize}

Follow these steps to take the theme through the upgrade process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the theme's root directory and run the command below to
  update the theme's \texttt{liferay-theme-tasks} dependency to version
  \texttt{8.x.x}:

\begin{verbatim}
npm install --save-dev liferay-theme-tasks@8.x.x
\end{verbatim}
\item
  Run the command below to initially upgrade it from 6.2 to 7.0.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: The Upgrade task overwrites the theme's files. We recommend that 
 you backup your files before proceeding with the upgrade process.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
```bash
gulp upgrade
```

Here's what the 6.2 to 7.0 upgrade task does:

- Updates the theme's Liferay version
- Renames CSS files
- Suggests specific code updates

The task continues upgrading CSS files, prompting you to update CSS file 
names. For 7.0, Sass files should use the `.scss` extension, and 
file names for Sass partials should start with an underscore (e.g., 
`_custom.scss`). The `upgrade` task prompts you for each CSS file to rename. 

The upgrade task automatically upgrades CSS code that it can identify. For 
everything else, it suggests upgrades. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Run the \texttt{gulp\ upgrade} command again to upgrade the 7.0 theme
  to 7.1.

  Here's what it does:

  \begin{itemize}
  \tightlist
  \item
    Creates core code for generating theme base files
  \item
    Collects removed Bootstrap and Lexicon variables
  \item
    Updates Bootstrap version references
  \item
    Updates Lexicon version references
  \item
    Updates Liferay version references
  \end{itemize}
\item
  You must update the theme's \texttt{liferay-theme-tasks} dependency to
  version \texttt{9.x.x} to complete the upgrade process. Install the
  latest version of the Liferay Theme Generator as well while you're at
  it, so future uses of the tool will be compatible with the 7.0 theme.
  Both commands are shown below. Run them separately:

\begin{verbatim}
npm install --save-dev liferay-theme-tasks@9.x.x

npm install -g generator-liferay-theme@9.x.x
\end{verbatim}
\item
  With the \texttt{9.x.x} versions of the \texttt{liferay-theme-tasks}
  and Liferay Theme Generator installed, run the \texttt{gulp\ upgrade}
  command for the final time to upgrade the 7.1 theme to 7.2:

  Here's what it does:

  \begin{itemize}
  \tightlist
  \item
    Updates Liferay version references
  \item
    Updates theme dependencies
  \end{itemize}
\end{enumerate}

The Gulp \texttt{upgrade} task lists any deprecated or removed
variables. For other areas of the code it suspects might need updates,
it logs suggestions. The task also reports changes that may affect theme
templates.

The Gulp \texttt{upgrade} task jump-starts the upgrade process, but it
doesn't complete it. Manual updates are required. The remaining portion
of this tutorial covers these manual steps.

\chapter{Updating 6.2 CSS Code}\label{updating-6.2-css-code}

7.0's UI improvements require these CSS-related changes:

\begin{itemize}
\tightlist
\item
  Updating rules and imports
\item
  Modifying responsiveness tokens
\end{itemize}

The theme upgrade process involves conforming to these changes.

Let's Go{}

\chapter{Updating 6.2 CSS Rules and
Imports}\label{updating-6.2-css-rules-and-imports}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 CSS Code<p><p>Step 1 of 2</p>
\end{verbatim}

7.0 uses Bootstrap 4.3's CSS rule syntax. Font Awesome icons have been
removed from base themes, so you should remove those stale imports if
you have them. The Gulp \texttt{upgrade} task reports automatic CSS
updates and suggests manual updates. For example, here is part of the
task log for the Lunar Resort theme upgrade from 6.2 to 7.0. For each
update performed and suggested, the task reports a file name and line
number range:

\begin{verbatim}
 Bootstrap Upgrade (2 to 3)

Because Liferay Portal 7.0 uses Bootstrap 3, the default box model has been 
changed to box-sizing: border-box. So if you were using width or height, and 
padding together on an element, you may need to make changes, or those elements 
may have unexpected sizes.

File: src/css/_aui_variables.scss
    Line 5: "$white" has been removed
    Line 31: "$white" has been removed
File: src/css/_custom.scss
    Line 201: Padding no longer affects width or height, you may need to change 
    your rule (lines 201-227)
    Line 207: Padding no longer affects width or height, you may need to change 
    your rule (lines 207-226)
    Line 212: You would change height from "62px" to "82px"
    Line 305: Padding no longer affects width or height, you may need to change 
    your rule (lines 305-314)
    Line 308: You would change height from "39px" to "46px"
    Line 409: Padding no longer affects width or height, you may need to change 
    your rule (lines 409-418)
\end{verbatim}

Follow these steps to update your theme's Bootstrap rules and Font
Awesome imports:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Since Bootstrap 3 adopted the \texttt{box-sizing:\ border-box}
  property for all elements and pseudo-elements (e.g., \texttt{:before}
  and \texttt{:after}), padding no longer affects dimensions.
  \href{https://getbootstrap.com/docs/3.3/css/\#less-mixins-box-sizing}{Bootstrap's
  documentation} describes the box sizing changes. Update the width and
  height for all CSS rules that use padding. For example, examine the
  \texttt{height} value change in this CSS rule for the Lunar Resort
  theme's \texttt{\_custom.scss} file:

  Original:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 62px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}

  Updated:

\begin{verbatim}
#reserveBtn {
    background-color: #00C4FB;
    border-radius: 10px;
    color: #FFF;
    font-size: 1.5em;
    height: 82px;
    margin: 30px;
    padding: 10px 0;
    ...
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** For individual elements, you can overwrite the 
 `box-sizing:border-box` rule with `box-sizing:content-box`. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  The following variables are removed in Bootstrap 4. Remove these
  variables where they are used in the theme:

\begin{verbatim}
$line-height-computed
$padding-base-horizontal
$padding-base-vertical
$padding-large-horizontal
$padding-large-vertical
$padding-small-horizontal
$padding-small-vertical
$padding-xs-horizontal
$padding-xs-vertical
$gray-base
$gray-darker
$gray-dark
$gray
$gray-light
$gray-lighter
$brand-primary
$brand-success
$brand-info
$brand-warning
$brand-danger
$state-success-text
$state-success-bg
$state-success-border
$state-info-text
$state-info-bg
$state-info-border
$state-warning-text
$state-warning-bg
$state-warning-border
$state-danger-text
$state-danger-bg
$state-danger-border
\end{verbatim}

  See the
  \href{http://getbootstrap.com/migration/\#migrating-from-2x-to-30}{Migrating
  from 2.x to 3.0 guide} for CSS rules that changed in Bootstrap 3.
  Likewise, you can refer to the
  \href{https://getbootstrap.com/docs/4.3/migration/}{Migrating to v4
  guide} for updating CSS rules to Bootstrap 4.
\item
  Font Awesome icons were removed from the theme and Font are now
  included as a package dependency if you answer yes (y) to include Font
  Awesome during the upgrade task. If you included the old imports in
  \texttt{\_custom.scss}, they must be removed:

\begin{verbatim}
@import "aui/alloy-font-awesome/scss/mixins-alloy";
@import "aui/alloy-font-awesome/scss/variables";
\end{verbatim}
\end{enumerate}

Great! The rules and imports are updated. You can update the
responsiveness next.

\chapter{Updating the Responsiveness}\label{updating-the-responsiveness}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 CSS Code</p><p>Step 2 of 2</p>
\end{verbatim}

Bootstrap 4 explicit media queries replaced the Bootstrap 2
\texttt{respond-to} mixins for CSS responsiveness. Follow these steps to
update the theme's responsiveness:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{\_custom.scss}.
\item
  Replace all \texttt{respond-to} mixins with corresponding media
  queries shown below. Note that some of the dimensions have slightly
  changed:

  \textbf{Media Query Replacements}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Liferay Portal 6.2 Mixin                            |  &nbsp;7.0 Media Query                                     |
\end{verbatim}

\noindent\hrulefill --------------------------------------
\textbar:----------------------------------------------------------
\textbar{} \texttt{@include\ respond-to(phone)} (max-width: 767px)
\textbar{} \texttt{@include\ media-breakpoint-down(sm)} (max-width:
767px) \textbar{} \texttt{@include\ respond-to(tablet)} (min-width:
768px, max-width: 979px) \textbar{}
\texttt{@include\ media-breakpoint-only(md)} (min-width: 768px,
max-width: 991px) \textbar{}
\texttt{@include\ respond-to(phone,\ tablet)} (max-width: 979px)
\textbar{} \texttt{@include\ media-breakpoint-down(md)} (max-width:
991px) \textbar{} \texttt{@include\ respond-to(desktop,\ tablet)}
(min-width: 768px) \textbar{} \texttt{@include\ media-breakpoint-up(md)}
(min-width: 768px) \textbar{} \texttt{@include\ respond-to(desktop)}
(min-width: 980px) \textbar{} \texttt{@include\ media-breakpoint-up(lg)}
(min-width: 992px) \textbar{}

\begin{verbatim}
The Lunar Resort theme's original and updated syntax is shown below:

Original:

```scss
@include respond-to(phone, tablet) {
    html #wrapper #banner #navigation {
    ...
    }
}
```

Updated:

```scss
@include media-breakpoint-down(md) {
    html #wrapper #banner #navigation {
    ...
    }
}
```
\end{verbatim}

The CSS code is updated! Next you'll update the theme's templates.

\chapter{Updating 6.2 Theme
Templates}\label{updating-6.2-theme-templates}

Liferay DXP 6.2 theme templates and 7.0 theme templates are essentially
the same. Here are the main changes:

\begin{itemize}
\item
  Velocity templates were deprecated in Liferay Portal CE 7.0 and are
  now removed in favor of FreeMarker templates in Liferay DXP. Below are
  the key reasons for this move:

  \begin{itemize}
  \item
    FreeMarker is developed and maintained regularly, while Velocity is
    no longer actively being developed.
  \item
    FreeMarker is faster and supports more sophisticated macros.
  \item
    FreeMarker supports using taglibs directly rather than requiring a
    method to represent them. You can pass body content to them,
    parameters, etc.
  \end{itemize}
\item
  The Dockbar has been replaced and reorganized into a set of three
  distinct menus:

  \begin{itemize}
  \item
    \emph{The Product Menu}: Manage Site and page navigation, content,
    settings and pages for the current Site, and navigate to user
    account settings, etc.
  \item
    \emph{The Control Menu}: Configure and add content to the page and
    view the page in a simulation window.
  \item
    \emph{The User Personal Bar}: Display notifications and the user's
    avatar and name.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/upgrading-themes-dockbar.png}
  \caption{The Dockbar was removed and must be replaced with the new
  Control Menu.}
  \end{figure}
\end{itemize}

Start by converting your Velocity theme templates to FreeMarker. You can
refer to Apache's
\href{https://freemarker.apache.org/docs/ref.html}{FreeMarker
documentation} for help. Common Liferay DXP FreeMarker variables and
macros can be found in
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_liferay.ftl}}

The \href{running-the-upgrade-task-for-6.2-themes}{Gulp \texttt{upgrade}
task} reports the required theme template changes in the log. For
example, here are the 6.2 to 7.0 upgrade log and 7.0 to 7.1 upgrade logs
for the Lunar Resort theme:

\begin{verbatim}
 Liferay Upgrade (6.2 to 7)

File: portal_normal.ftl
    Warning: <@liferay.dockbar /> is deprecated, replace with 
    <@liferay.control_menu /> for new admin controls.
    Warning: not all admin controls will be visible without 
    <@liferay.control_menu />
    Warning: ${theme} variable is no longer available in Freemarker 
    templates, see https://goo.gl/9fXzYt for more information.
[18:57:23] Finished 'upgrade:log-changes' after 5.61 ms
[18:57:23] Finished 'upgrade' after 19 s

 Liferay Upgrade (7.0 to 7.1)

Renamed aui.scss to clay.scss
[19:16:54] Finished 'upgrade:log-changes' after 2.53 ms
[19:16:54] Finished 'upgrade' after 16 min
\end{verbatim}

The log warns about removed and deprecated code and suggests
replacements when applicable.

In this section you'll learn how to update various theme templates to
7.0.

Let's Go{}

\chapter{Updating 6.2 Portal Normal Theme
Template}\label{updating-6.2-portal-normal-theme-template}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Theme Templates</p><p>Step 1 of 3</p>
\end{verbatim}

Follow these steps to update \texttt{portal\_normal.ftl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{portal\_normal.ftl} and replace the following 6.2
  directives with the updated syntax. This change is described in the
  \href{/docs/7-0/reference/-/knowledge_base/r/breaking-changes\#taglibs-are-no-longer-accessible-via-the-theme-variable-in-freemarker}{7.0
  Breaking Changes} reference document:

  \begin{longtable}[]{@{}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2209}}
    >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7791}}@{}}
  \toprule\noalign{}
  \begin{minipage}[b]{\linewidth}\raggedright
  6.2
  \end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
  ~Updated
  \end{minipage} \\
  \midrule\noalign{}
  \endhead
  \bottomrule\noalign{}
  \endlastfoot
  \texttt{\$\{theme.include(top\_head\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=top\_head\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(body\_top\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_top\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(content\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.wrapPortlet("portlet.ftl",\ content\_include)\}} &
  \texttt{\textless{}@liferay\_theme{[}"wrap-portlet"{]}\ page="portlet.ftl"\textgreater{}\ \textless{}@liferay\_util{[}"include"{]}\ page=content\_include\ /\textgreater{}\ \textless{}/@\textgreater{}} \\
  \texttt{\$\{theme.include(body\_bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=body\_bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme.include(bottom\_include)\}} &
  \texttt{\textless{}@liferay\_util{[}"include"{]}\ page=bottom\_include\ /\textgreater{}} \\
  \texttt{\$\{theme\_settings{[}"my-theme-setting"{]}\}} &
  \texttt{\$\{themeDisplay.getThemeSetting("my-theme-setting")\}} \\
  \texttt{\$\{theme.runtime("56",\ "articleId="\ +\ my\_article\_id)\}}
  &
  \texttt{\textless{}@liferay\_portlet{[}"runtime"{]}\ portletName=}\texttt{"com\_liferay\_journal\_content\_web\_portlet\_JournalContentPortlet"}
  \texttt{queryString="articleId="\ +\ my\_article\_id\ /\textgreater{}} \\
  \end{longtable}
\item
  Remove the breadcrumbs and page title code:

\begin{verbatim}
<nav id="breadcrumbs">      
    <@liferay.breadcrumbs />        
</nav>
...
<h2 class="page-title">
    <span>${the_title}</span>
</h2>
\end{verbatim}
\item
  Remove \texttt{dockbar-split} from the \texttt{body} element's
  \texttt{class} value so it matches the markup below:

\begin{verbatim}
<body class="${css_class}">
\end{verbatim}
\item
  Find the
  \texttt{\textless{}a\ href="\#main-content"\ id="skip-to-content"\textgreater{}\textless{}@liferay.language\ key="skip-to-content"\ /\textgreater{}\textless{}/a\textgreater{}}
  element and replace it with the updated Liferay UI quick access macro
  shown below:

\begin{verbatim}
<@liferay_ui["quick-access"] contentId="#main-content" />
\end{verbatim}
\item
  Replace the \texttt{\textless{}@liferay.dockbar\ /\textgreater{}}
  macro with the updated Control menu macro:

\begin{verbatim}
<@liferay.control_menu />
\end{verbatim}
\item
  Replace the \texttt{\textbar{}\textbar{}\ is\_signed\_in} condition
  for the \texttt{navigation.ftl} theme template include with
  \texttt{\&\&\ is\_setup\_complete}:

\begin{verbatim}
<#if has_navigation && is_setup_complete>
    <#include "${full_templates_path}/navigation.ftl" />
</#if>
\end{verbatim}
\item
  Replace the \texttt{content} \texttt{\textless{}div\textgreater{}}
  with an HTML 5 \texttt{section} element. The \texttt{section} element
  is more accurate and provides better accessibility for screen readers:

\begin{verbatim}
<section id="content">
\end{verbatim}
\item
  Add the
  \texttt{\textless{}h1\ class="hide-accessible"\textgreater{}\$\{the\_title\}\textless{}/h1\textgreater{}}
  header element just inside the \texttt{content}
  \texttt{\textless{}section\textgreater{}} to support accessibility,
  and remove the breadcrumbs \texttt{\textless{}nav\textgreater{}}
  element from inside it.
\end{enumerate}

\texttt{portal\_normal.ftl} is updated! Next you can update the
navigation template.

\chapter{Updating 6.2 Navigation Theme
Template}\label{updating-6.2-navigation-theme-template}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Theme Templates</p><p>Step 2 of 3</p>
\end{verbatim}

Follow these steps to update \texttt{navigation.ftl}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Below the
  \texttt{\textless{}nav\ class="\$\{nav\_css\_class\}"\ id="navigation"\ role="navigation"\textgreater{}}
  element, add the heading below to improve accessibility for screen
  readers:

\begin{verbatim}
<h1 class="hide-accessible">
    <@liferay.language key="navigation" />
</h1>
\end{verbatim}
\item
  Remove the \texttt{nav\_item\_attr\_selected} variable declaration at
  the top, and add the layout declaration shown below instead, to access
  the layout. Don't forget to remove all uses of
  \texttt{nav\_item\_attr\_selected} throughout the rest of the
  template:

\begin{verbatim}
<#assign nav_item_layout = nav_item.getLayout() />
\end{verbatim}
\item
  Replace the \texttt{\$\{nav\_item.icon()\}}variable in the
  \texttt{\textless{}a\ aria-labelledby="layout\_\$\{nav\_item.getLayoutId()\}"...\textless{}/a\textgreater{}}
  anchor with the element below:

\begin{verbatim}
<@liferay_theme["layout-icon"] layout=nav_item_layout />
\end{verbatim}
\item
  Remove the \texttt{nav\_child\_attr\_selected} variable from the
  bottom of the template, including all uses throughout the rest of the
  template.
\end{enumerate}

The navigation template is updated. You can update \texttt{portlet.ftl}
next.

\chapter{Updating 6.2 Init Custom Theme
Template}\label{updating-6.2-init-custom-theme-template}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Theme Templates</p><p>Step 3 of 3</p>
\end{verbatim}

The Lunar Resort theme has a couple theme settings defined in
\texttt{init\_custom.ftl}. The syntax has changed slightly in 7.0.
Follow these steps to update the theme setting syntax:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace the \texttt{getterUtil.getBoolean(theme\_settings} method with
  \texttt{getterUtil.getBoolean(themeDisplay.getThemeSetting}:

  Original:

\begin{verbatim}
<#assign show_breadcrumbs = 
getterUtil.getBoolean(theme_settings["show-breadcrumbs"])/>

<#assign show_page_title = 
getterUtil.getBoolean(theme_settings["show-page-title"])/>
\end{verbatim}

  Updated:

\begin{verbatim}
<#assign show_breadcrumbs = 
getterUtil.getBoolean(themeDisplay.getThemeSetting("show-breadcrumbs"))/>

<#assign show_page_title = 
getterUtil.getBoolean(themeDisplay.getThemeSetting("show-page-title"))/>
\end{verbatim}
\item
  Although the Lunar Resort theme doesn't have any String variables, you
  would replace the \texttt{getterUtil.getString(theme\_settings} method
  with \texttt{themeDisplay.getThemeSetting}:

  Original:

\begin{verbatim}
<#assign string_setting = 
getterUtil.getString(theme_settings["my-string-key"])/>
\end{verbatim}

  Updated:

\begin{verbatim}
<#assign string_setting = 
themeDisplay.getThemeSetting("my-string-key")/>
\end{verbatim}
\end{enumerate}

Awesome! The theme templates are updated. You can always compare theme
templates with the updated ones found in the
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates}{\texttt{\_unstyled}
theme}, if you're unsure if something has changed. Refer to the
suggested changes that the Gulp \texttt{upgrade} task reports for the
theme.

\chapter{Updating the Resources
Importer}\label{updating-the-resources-importer}

The Resources Importer is now an OSGi module bundled with Liferay DXP,
so you don't have to download the Resources Importer separately. The
following components have been updated and are the focus of this
section:

\begin{itemize}
\tightlist
\item
  Plugin properties
\item
  Web content article files and folder structure
\item
  Sitemap
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Due to the page and article import order, articles that
link to pages in the Site's layout cause a null pointer exception
\href{https://issues.liferay.com/browse/LPS-64859}{issue}. These links
have been removed from the Lunar Resort theme's web content articles to
avoid this issue.

\noindent\hrulefill

Let's Go{}

\chapter{Updating 6.2 Liferay Plugin Package
Properties}\label{updating-6.2-liferay-plugin-package-properties}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Resources Importer</p><p>Step 1 of 3</p>
\end{verbatim}

Since the Lunar Resort theme was developed in the Plugins SDK, it
requires the updates covered in this section. Themes developed outside
of the Plugins SDK do not require these changes.

Follow these steps to update the Lunar Resort Theme's
\texttt{liferay-plugin-package.properties} file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the
  \texttt{src\textbackslash{}WEB-INF\textbackslash{}liferay-plugin-package.properties}
  file and remove the \texttt{required-deployment-contexts} property.
  This is no longer needed since the Resources Importer is bundled with
  Liferay DXP.
\item
  The group model class's fully-qualified class name has changed.
  Replace the \texttt{resources-importer-target-class-name} property's
  value with the updated one below:
\end{enumerate}

\begin{verbatim}
com.liferay.portal.kernel.model.Group
\end{verbatim}

Now that the \texttt{liferay-plugin-package.properties} is updated, you
can update the theme's web content.

\chapter{Updating 6.2 Web Content}\label{updating-6.2-web-content}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Resources Importer</p><p>Step 2 of 3</p>
\end{verbatim}

All web content articles must be written in XML and have a structure for
article creation and a template for rendering.

\noindent\hrulefill

\textbf{Note:} The example Lunar Resort theme's updated XML articles are
in the ZIP file's
\texttt{/resources-importer/journal/articles/Basic\ Web\ Content/}
folder for reference.

\noindent\hrulefill

Follow these steps to update the theme's web content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a subfolder called \texttt{BASIC\_WEB\_CONTENT} in the
  \texttt{/resources-importer/journal/articles/} folder, and move all
  the basic HTML articles (articles that did not require a structure or
  template previously) into it.
\item
  Create a subfolder in the
  \texttt{/resources-importer/journal/templates/} folder with the same
  name as the folder you just created (\texttt{BASIC\_WEB\_CONTENT}).
  The articles and template folder names \textbf{must match} for the web
  content to import properly.
\item
  XML article structures are now written in JSON. Open the
  \texttt{/resources-importer/journal/structures/} folder and create a
  new file inside called \texttt{BASIC\_WEB\_CONTENT.json}. The
  structure name \textbf{must match} the folder names created in the
  previous steps. To ensure the syntax is correct for web content
  articles that used a structure and template before, we recommend that
  you recreate the structure and template in Liferay DXP.
\item
  Add the JSON structure below to the \texttt{BASIC\_WEB\_CONTENT.json}
  file. This provides the required metadata to render standard web
  content articles (i.e.~the language, fields, etc.):

\begin{verbatim}
{
    "availableLanguageIds": [
        "en_US"
    ],
    "defaultLanguageId": "en_US",
    "fields": [
        {
            "label": {
                "en_US": "Content"
            },
            "predefinedValue": {
                "en_US": ""
            },
            "style": {
                "en_US": ""
            },
            "tip": {
                "en_US": ""
            },
            "dataType": "html",
            "fieldNamespace": "ddm",
            "indexType": "keyword",
            "localizable": true,
            "name": "content",
            "readOnly": false,
            "repeatable": false,
            "required": false,
            "showLabel": true,
            "type": "ddm-text-html"
        }
    ]
}
\end{verbatim}
\item
  Create a new FreeMarker template file for basic web content inside the
  \texttt{/resources-importer/journal/templates/BASIC\_WEB\_CONTENT}
  folder called \texttt{BASIC\_WEB\_CONTENT.ftl}, and add the method
  below to retrieve the article's data:

\begin{verbatim}
${content.getData()}
\end{verbatim}
\item
  Convert the basic web content articles from HTML to XML to conform to
  the new format. Replace the \texttt{.html} file extensions with
  \texttt{.xml}. wrap each basic web content article's content with the
  XML shown below:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
        <dynamic-element name="content" type="text_area"
        index-type="keyword" index="0">
                <dynamic-content language-id="en_US">
                        <![CDATA[
                        ORIGINAL HTML CONTENT GOES HERE
                        ]]>
                </dynamic-content>
        </dynamic-element>
</root>
\end{verbatim}
\item
  7.0's updated Bootstrap requires that you replace all
  \texttt{span{[}number{]}} classes with the updated
  \texttt{col-{[}device-size{]}-{[}number{]}} syntax.
  \texttt{{[}device-size{]}} can be \texttt{xs}, \texttt{sm},
  \texttt{md}, or \texttt{lg}. See Bootstrap's
  \href{https://getbootstrap.com/docs/4.0/layout/grid/}{documentation}
  for more information. The original and updated classes for the Lunar
  Resort's \texttt{2\ column\ description.xml} article are shown below:

  Original:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
                    <div class="span4" id="columnLeft">
                        Out of This World
                    </div>
                    <div class="span8" id="columnRight">
                        Come to the Lunar Resort...
                    </div>
                </div>
            ]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}

  Updated:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
    <dynamic-element name="content" type="text_area"
    index-type="keyword" index="0">
        <dynamic-content language-id="en_US">
            <![CDATA[
                <div class="container-fluid">
                    <div class="col-md-4" id="columnLeft">
                        Out of This World
                    </div>
                    <div class="col-md-8" id="columnRight">
                        Come to the Lunar Resort...
                    </div>
                </div>
            ]]>
        </dynamic-content>
    </dynamic-element>
</root>
\end{verbatim}
\end{enumerate}

The web content is updated! Next, you must update the theme's sitemap
file.

\chapter{Updating the 6.2 Sitemap}\label{updating-the-6.2-sitemap}

\begin{verbatim}
<p id="stepTitle">Updating 6.2 Resources Importer</p><p>Step 3 of 3</p>
\end{verbatim}

In Liferay DXP 6.2, portlet IDs were incremental numbers. In 7.0,
they're explicit class names. Update the \texttt{sitemap.json} file with
the new portlet IDs. Follow these steps to update the sitemap:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace the portlet IDs with the updated class names. The
  \href{/docs/7-2/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Portlet
  ID Quick Reference Guide} list the default portlet IDs. Check
  \texttt{liferay-portlet.xml} for the portlet ID number in 6.2 and
  replace it with the updated ID in the quick reference Guide.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** you can also retrieve a portlet's ID from the UI. Open the 
 portlet's *Options* menu, select *Look and Feel Configuration*. 
 
 ![ You can find the portlet ID in the *Look and Feel Configuration* menu.](./images/upgrading-themes-look-and-feel-menu.png)
 
 Select the *Advanced Styling* tab. The `Portlet ID` value appears in the 
 blue box. 
 
 ![ The portlet ID appears within the blue box in the *Advanced Styling* tab.](./images/upgrading-themes-portlet-id.png)
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The original and updated versions of the Lunar Resort theme's `sitemap.json` 
are shown below:

Original:

```json
{
    "name": "Collaboration",
    "title": "Collaboration",
    "friendlyURL": "/collaboration",
    "layoutTemplateId": "2_columns",
    "columns": [
        [
            {
            "portletId": "36"
            }
        ],
        [
            {
            "portletId": "115"
            }
        ]
    
    ]
}
```

Updated:

```json
{
  "name": "Collaboration",
  "title": "Collaboration",
  "friendlyURL": "/collaboration",
  "layoutTemplateId": "2_columns",
  "columns": [
    [
      {
      "portletId": "com_liferay_wiki_web_portlet_WikiPortlet"
      }
    ],
    [
      {
      "portletId": "com_liferay_blogs_web_portlet_BlogsAgreggatorPortlet"
      }
    ]
  
  ]
},
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Update references to the web content articles in the
  \texttt{sitemap.json} to use the XML file extensions.
\end{enumerate}

Great! The Resources Importer updates are complete. Next you'll apply
Clay markup patterns to the theme's custom UI.

\chapter{Applying Clay Design
Patterns}\label{applying-clay-design-patterns}

7.0 uses \href{https://clayui.com/}{Clay}, a web implementation of
Liferay's \href{https://lexicondesign.io/}{Lexicon Experience Language}.
The Lexicon Experience Language provides styling guidelines and best
practices for application UIs. Clay's CSS, HTML, and JavaScript
components enable developers to build fully-realized UIs quickly and
effectively. Liferay DXP's
\href{/docs/7-2/tutorials/-/knowledge_base/t/using-the-bootstrap-3-lexicon-css-compatibility-layer}{compatibility
layer} let's you use \href{https://lexiconcss.wedeploy.io/}{Lexicon CSS}
markup alongside \href{https://clayui.com/}{Clay CSS}.

\noindent\hrulefill

\textbf{Note:} The compatibility layer is meant as a short-term solution
to ensure that your Bootstrap 3 and Lexicon CSS components aren't broken
while you update your theme to use
\href{https://getbootstrap.com/docs/4.3/migration/}{Bootstrap 4} and
\href{https://clayui.com/docs/css-framework/scss.html}{Clay CSS}. It
will be disabled in a future release. Migrate your theme to use
Bootstrap 4 and Clay CSS as soon as you're able to.

\noindent\hrulefill

This section demonstrates how to apply Clay to the Lunar Resort's form.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace the \texttt{control-group} classes with \texttt{form-group}
  classes:
\item
  Remove the \texttt{control-label} classes from the \texttt{label}
  elements:
\item
  Remove \texttt{\textless{}div\ class="controls"\textgreater{}}
  elements.
\item
  Add the \texttt{form-control} class to each \texttt{input} element.
\item
  Add the \texttt{btn-primary} class to your submit buttons to emphasize
  them.
\end{enumerate}

The Lunar Resort's original form and updated form are shown below:

Original form markup:

\begin{verbatim}
<form class="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="control-group">
              <label class="control-label" for="inputName">Name</label>
              <div class="controls">
                      <input type="text" id="inputName"
                      placeholder="Enter your Name here" required="required">
                  </div>
          </div>
          <div class="control-group">
              <label class="control-label" for="inputEmail">Email</label>
              <div class="controls">
                  <input type="email" id="inputEmail"
                  placeholder="Enter your E-Mail here" required="required">
              </div>
          </div>
          <div class="control-group">
              <div class="controls">
                  <button type="submit" class="btn">Submit</button>
              </div>
          </div>
        </fieldset>
</form>
\end{verbatim}

Updated form markup:

\begin{verbatim}
<form role="form-horizontal">
        <fieldset>
          <legend>Reservation Form</legend>
          <div class="form-group">
              <label for="inputName">Name</label>
              <input type="text" id="inputName" class="form-control"
              placeholder="Enter your Name here" required="required">
          </div>
          <div class="form-group">
              <label for="inputEmail">Email</label>
              <input type="email" id="inputEmail" class="form-control"
              placeholder="Enter your E-Mail here" required="required">
          </div>
          <div class="form-group">
                  <button type="submit" class="btn btn-primary">Submit
                  </button>
          </div>
        </fieldset>
</form>
\end{verbatim}

The Lunar Resort theme is updated for 7.0!

\chapter{Upgrading Your Theme from Liferay Portal 7.0 to
7.2}\label{upgrading-your-theme-from-liferay-portal-7.0-to-7.2}

In this tutorial, you'll learn how to use the
\href{https://github.com/liferay/liferay-js-themes-toolkit/tree/master/packages}{Liferay
JS Theme Toolkit} to upgrade a Liferay DXP 7.0 theme to 7.0. As you
upgrade this theme, you'll learn how to update metadata, theme
templates, UI (including support for Bootstrap 4 and Lexicon 2.0.), and
more using all the best practices and standards. Completing this
tutorial prepares you for upgrading your own theme.

Theme upgrades involve these steps:

\begin{itemize}
\tightlist
\item
  Updating project metadata
\item
  Updating CSS
\item
  Updating theme templates
\end{itemize}

Let's Go!{}

\chapter{Running the Upgrade Task for 7.0
Themes}\label{running-the-upgrade-task-for-7.0-themes}

You can upgrade a Liferay DXP 7.0 theme to 7.0, regardless of the
development environment you use. This tutorial uses the Liferay JS Theme
Toolkit's Gulp \texttt{upgrade} task to automate much of the steps. The
Gulp \texttt{upgrade} task must be run twice to bring a Liferay DXP 7.0
theme up to 7.0.

The Liferay Theme Generator is available in a few different versions. To
update the Liferay DXP 7.0 theme to Liferay DXP 7.1, you must install
v8.x.x of the \texttt{liferay-theme-tasks} dependency. After the theme
is updated to 7.1, you must then install v9.x.x of the
\texttt{liferay-theme-tasks} dependency to complete the upgrade process.

Here's what the Upgrade Task does:

\begin{itemize}
\tightlist
\item
  Updates the theme's Liferay version
\item
  Updates the theme's Bootstrap version
\item
  Updates the theme's Lexicon version
\item
  Suggests specific code updates
\end{itemize}

Follow these steps to take the theme through the upgrade process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the theme's root directory and run the command below to
  update the theme's \texttt{liferay-theme-tasks} dependency to version
  \texttt{8.x.x}:

\begin{verbatim}
npm install --save-dev liferay-theme-tasks@8.x.x
\end{verbatim}
\item
  Run the \texttt{gulp\ upgrade} command to upgrade the Liferay DXP 7.0
  theme to 7.1.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: The Upgrade task overwrites the theme's files. We recommend that 
 you backup your files before proceeding with the upgrade process.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Here's what it does:

- Creates core code for generating theme base files
- Collects removed Bootstrap and Lexicon variables
- Updates Bootstrap version references
- Updates Lexicon version references
- Updates Liferay version references
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  You must update the theme's \texttt{liferay-theme-tasks} dependency to
  version \texttt{9.x.x} to complete the upgrade process. Install the
  latest version of the Liferay Theme Generator as well while you're at
  it, so future uses of the tool will be compatible with the 7.0 theme.
  Both commands are shown below. Run them separately:

\begin{verbatim}
npm install --save-dev liferay-theme-tasks@9.x.x

npm install -g generator-liferay-theme@9.x.x
\end{verbatim}
\item
  With the \texttt{9.x.x} versions of the \texttt{liferay-theme-tasks}
  and Liferay Theme Generator installed, run the \texttt{gulp\ upgrade}
  command for the final time to upgrade the 7.1 theme to 7.2:

  Here's what it does:

  \begin{itemize}
  \tightlist
  \item
    Updates Liferay version references
  \item
    Updates theme dependencies
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Since Liferay DXP Fix Pack 2 and Liferay Portal 7.2 CE GA2, Font 
 Awesome is available globally as a system setting, which is enabled by 
 default. If you're using Font Awesome icons in your theme, answer yes (y) 
 to the Font Awesome question during the Upgrade task to include Font 
 Awesome imports in your theme. This ensures that your icons won't break if 
 a Site Administrator disables the global setting. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Run \texttt{gulp\ init} from your theme's root directory to update the
  path of your Liferay DXP server to point to your 7.2 Liferay DXP
  server.
\end{enumerate}

The Gulp \texttt{upgrade} task lists any deprecated or removed
variables. For other areas of the code it suspects might need updates,
it logs suggestions. The task also reports changes that may affect theme
templates. This jump-starts the upgrade process, but it doesn't complete
it. Manual updates are required. The remaining portion of this tutorial
covers these manual steps.

\chapter{Updating 7.0 CSS Code}\label{updating-7.0-css-code}

7.0's UI improvements requires these CSS-related changes:

\begin{itemize}
\tightlist
\item
  Renaming CSS files
\item
  Class variable changes
\item
  Updating core imports
\end{itemize}

The theme upgrade process involves conforming to these changes. Now
you'll update the theme's CSS files to reflect these changes. Start with
updating CSS file names.

Let's Go{}

\chapter{Updating 7.0 CSS File Names for
Clay}\label{updating-7.0-css-file-names-for-clay}

\begin{verbatim}
<p id="stepTitle">Updating 7.0 CSS Code</p><p>Step 1 of 3</p>
\end{verbatim}

Some of the CSS filenames have changed to reflect the introduction of
Clay (previously Lexicon CSS). The file name changes for the Unstyled
theme are listed below. Refer to the
\href{/docs/7-2/reference/-/knowledge_base/r/theme-reference-guide}{Theme
Reference Guide} for a complete list of expected theme CSS files.

Orignal AUI file names:

\begin{itemize}
\tightlist
\item
  \texttt{css/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_aui\_custom.scss}
  \item
    \texttt{\_aui\_variables.scss}
  \item
    \texttt{aui.scss}
  \end{itemize}
\end{itemize}

Updated Clay file names:

\begin{itemize}
\tightlist
\item
  \texttt{css/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_clay\_custom.scss}
  \item
    \texttt{\_clay\_variables.scss}
  \item
    \texttt{clay.scss}
  \end{itemize}
\end{itemize}

Next, you can update the theme's CSS variables.

\chapter{Updating 7.0 Class
Variables}\label{updating-7.0-class-variables}

\begin{verbatim}
<p id="stepTitle">Updating 7.0 CSS Code</p><p>Step 2 of 3</p>
\end{verbatim}

7.0 uses Bootstrap 4's CSS rule syntax. The new syntax lets developers
leverage Bootstrap 4 features and improvements. The
\href{https://getbootstrap.com/docs/4.0/migration/}{Migrating to v4
guide} provides complete instructions for updating CSS rules to
Bootstrap 4.

Follow these steps to upgrade the theme's CSS variables:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Consult the upgrade log produced by the \texttt{gulp\ upgrade} task.
  It suggests the manual Lexicon updates required for the theme.
\item
  Make the required changes in the log. The log lists removed and/or
  deprecated variables and suggests possible changes. For each update
  performed or suggested, the task reports a file name. For example,
  here is part of the task log for the 7.0 Westeros Bank theme:
\end{enumerate}

\begin{verbatim}
 Lexicon Upgrade (1.0 to 2.0)

File: _variables_custom.scss
    $brand-default was deprecated in Lexicon CSS 1.x.x and has been removed 
        in the new Clay 2.x.x version
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If the \texttt{gulp\ upgrade} task detects any variables
in the theme that are removed in Clay from the previous LexiconCSS
version, it adds a \texttt{\_variables\_deprecated.scss} file to the
theme containing the removed variables, to make sure the theme compiles
and to decouple it from future upgrades.

\noindent\hrulefill

After updating your theme's CSS variables and mixins, you should update
the imports next.

\chapter{Updating 7.0 Imports}\label{updating-7.0-imports}

\begin{verbatim}
<p id="stepTitle">Updating 7.0 CSS Code</p><p>Step 3 of 3</p>
\end{verbatim}

Font Awesome imports and core imports have changed. Follow these steps
to update the theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Originally in Liferay Portal CE 7.0 and Liferay DXP, Font Awesome
  icons were imported in \texttt{\_aui\_variables.scss} (now renamed
  \texttt{\_clay\_variables.scss}). Font Awesome icons are now included
  as a package dependency if you answer yes (y) to include Font Awesome
  during the upgrade task. If a 7.0 theme was made prior to this move
  and \texttt{\_aui\_variables.scss} was modified, the Font Awesome
  imports shown below must be removed from
  \texttt{\_clay\_variables.scss}:

\begin{verbatim}
// Icon paths
$FontAwesomePath: "aui/lexicon/fonts/alloy-font-awesome/font";
$font-awesome-path: "aui/lexicon/fonts/alloy-font-awesome/font";
$icon-font-path: "aui/lexicon/fonts/";
\end{verbatim}
\item
  Update the old AUI lexicon paths to use the new Clay paths instead, as
  shown in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
Pattern|Replacement|
---|---|
`@import "/aui/lexicon/bootstrap/mixins/";`|removed|
`@import "/aui/lexicon/lexicon-base/mixins/";`|removed|
`@import "/aui/lexicon/atlas-theme/mixins/";`|removed|
`@import "aui/lexicon/atlas-variables";`|`@import "clay/atlas-variables";`|
`@import "aui/lexicon/atlas";`|`@import "clay/atlas";`|
\end{verbatim}

\noindent\hrulefill

Great! Your imports are updated, and your CSS upgrade is complete. Next
you can upgrade the theme templates.

\chapter{Updating 7.0 Theme Templates to
7.2}\label{updating-7.0-theme-templates-to-7.2}

Liferay DXP 7.0 theme templates and 7.0 theme templates are essentially
the same. Here are the main changes:

\begin{itemize}
\tightlist
\item
  Velocity templates were deprecated in Liferay Portal CE 7.0 and are
  now removed in favor of FreeMarker templates in 7.0.
\end{itemize}

Key reasons for using FreeMarker templates and removing Velocity
templates are these:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

If you haven't converted your Velocity theme templates to FreeMarker,
\textbf{you must convert your Velocity theme templates to FreeMarker
now}.

The \texttt{gulp\ upgrade} command reports the required theme template
changes in the log. For example, here is the \texttt{gulp\ upgrade} log
for the Westeros Bank theme:

\begin{verbatim}
 Liferay Upgrade (7.0 to 7.1)

Renamed aui.scss to clay.scss
File: footer.ftl
    Warning: .container-fluid-1280 has been deprecated. Please use 
    .container-fluid.container-fluid-max-xl instead.
File: portal_normal.ftl
    Warning: .navbar-header has been removed. This container should be 
    removed in most cases. Please, use your own container if necessary.
\end{verbatim}

The log warns about removed and deprecated code and suggests
replacements when applicable. For reference, the main changes between
Liferay DXP 7.0 themes and 7.0 themes appear below:

\begin{itemize}
\item
  List items inside a container with the \texttt{list-inline} class
  \href{https://getbootstrap.com/docs/4.3/migration/\#typography}{now
  require} the \texttt{list-inline-item} class.
\item
  The \texttt{container-fluid-1280} class has been deprecated. Please
  use \texttt{container-fluid\ container-fluid-max-xl} instead.
\item
  Responsive navbar behaviors
  \href{https://getbootstrap.com/docs/4.3/migration/\#navbar}{are now
  applied} to the \texttt{navbar} class via the required
  \texttt{navbar-expand-\{breakpoint\}} class.
\item
  The \texttt{navbar-toggle} class is now \texttt{navbar-toggler} and
  \href{https://getbootstrap.com/docs/4.3/migration/\#navbar}{has
  different inner markup}.
\item
  The \texttt{navbar-header} class has been removed. This container
  should be removed in most cases. Please, use your own container if
  necessary.
\end{itemize}

In this section you'll learn how to update various theme templates to
7.0.

Let's Go{}

\chapter{Updating 7.0 Theme
Templates}\label{updating-7.0-theme-templates}

Follow these steps to update the theme's templates. Note these changes
are only required if the templates are modified in the theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{portal\_normal.ftl} and remove the breadcrumbs:

\begin{verbatim}
<nav id="breadcrumbs">      
    <@liferay.breadcrumbs />        
</nav>
\end{verbatim}
\item
  Still inside \texttt{portal\_normal.ftl}, remove
  \texttt{id="main-surface"} from the \texttt{body} tag so it looks like
  the one below. This is not needed for SPA to work properly:

\begin{verbatim}
<body class="${css_class}">
\end{verbatim}
\item
  Open \texttt{navigation.ftl} and remove the
  \texttt{nav\_item\_attr\_selected} variable declaration at the top.
  Don't forget to remove all uses of the
  \texttt{nav\_item\_attr\_selected} throughout the rest of the
  template.
\item
  Also inside \texttt{navigation.ftl}, remove the
  \texttt{nav\_child\_attr\_selected} variable from the bottom of the
  template, including all uses throughout the rest of the template.
\item
  Open \texttt{portlet.ftl} and find the code snippet below:

\begin{verbatim}
<a 
  class="icon-monospaced portlet-icon-back text-default" 
  href="${portlet_back_url}" 
  title="<@liferay.language key="return-to-full-page" />"
>
\end{verbatim}

  Add the \texttt{list-unstyled} class to it:

\begin{verbatim}
<a 
  class="icon-monospaced list-unstyled portlet-icon-back text-default" 
  href="${portlet_back_url}" 
  title="<@liferay.language key="return-to-full-page" />"
>
\end{verbatim}
\item
  Still inside \texttt{portlet.ftl}, find the
  \texttt{\textless{}div\ class="autofit-float\ autofit-row"\textgreater{}}
  element and add the \texttt{portlet-header} class to it:

\begin{verbatim}
<div class="autofit-float autofit-row portlet-header">
\end{verbatim}
\end{enumerate}

The theme templates are updated! If you modified any other FreeMarker
theme templates, you can compare them with templates in the
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-unstyled/src/main/resources/META-INF/resources/_unstyled/templates}{\texttt{\_unstyled}
theme}. Next you can learn how to use Liferay DXP's compatibility layer
to help ease the transition to Bootstrap 4 and Clay CSS.

\chapter{Using the Bootstrap 3 Lexicon CSS Compatibility
Layer}\label{using-the-bootstrap-3-lexicon-css-compatibility-layer}

By default, 7.0 includes Bootstrap 4 out-of-the-box. Bootstrap 4 has
been completely rewritten and therefore includes some
\href{https://getbootstrap.com/docs/4.3/migration/}{notable changes} and
\href{https://getbootstrap.com/docs/4.3/getting-started/introduction/}{compatibility
updates} that may be cause for concern if your theme uses Bootstrap 3 or
Lexicon CSS. Not to worry though. To ensure that your upgrade runs
smoothly, Liferay DXP includes a compatibility layer so you can use
Bootstrap 3 markup and Lexicon CSS markup alongside the new Bootstrap 4
and Clay CSS. If your theme extends the
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-styled}{Styled
base theme}, this compatibility layer is included by default.

\noindent\hrulefill

\textbf{Note:} The compatibility layer is meant as a short-term solution
to ensure that your Bootstrap 3 and Lexicon CSS components aren't broken
while you update your theme to use
\href{https://getbootstrap.com/docs/4.3/migration/}{Bootstrap 4} and
\href{https://clayui.com/docs/css-framework/scss.html}{Clay CSS}. It
will be disabled in a future release. Migrate your theme to use
Bootstrap 4 and Clay CSS as soon as you're able to.

\noindent\hrulefill

Follow these guidelines to update your markup:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inspect your themes UI with the compatibility layer enabled (it's
  enabled by default), and note any issues.
\item
  Individually disable the component(s) in the compatibility layer that
  you don't need. These are listed in the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/compat/_variables.scss}{\texttt{css/compat/\_variables.scss}}
  file. For convenience, these components are listed below:

\begin{verbatim}
// Compatibility layer components config

$compat-alerts: true !default;
$compat-basic_search: true !default;
$compat-breadcrumbs: true !default;
$compat-button_groups: true !default;
$compat-buttons: true !default;
$compat-cards: true !default;
$compat-component_animations: true !default;
$compat-dropdowns: true !default;
$compat-figures: true !default;
$compat-form_validation: true !default;
$compat-forms: true !default;
$compat-grid: true !default;
$compat-icons: true !default;
$compat-labels: true !default;
$compat-liferay: true !default;
$compat-list_groups: true !default;
$compat-management_bar: true !default;
$compat-modals: true !default;
$compat-nav_tabs: true !default;
$compat-navbar: true !default;
$compat-navs: true !default;
$compat-pager: true !default;
$compat-pagination: true !default;
$compat-panels: true !default;
$compat-progress_bars: true !default;
$compat-responsive_utilities: true !default;
$compat\noindent\hrulefill: true !default;
$compat-simple_flexbox_grid: true !default;
$compat-stickers: true !default;
$compat-tables: true !default;
$compat-toggle_card: true !default;
$compat-toggle_switch: true !default;
$compat-toolbar: true !default;
$compat-user_icons: true !default;
$compat-utilities: true !default;
\end{verbatim}

  To disable a component, add the component you want to remove
  compatibility for to \texttt{/src/css/\_clay\_custom.scss} (create
  this file if it doesn't exist) and set its value to \texttt{false}.
  The example below removes compatibility for alerts and cards:

\begin{verbatim}
$compat-alerts: false !default;
$compat-cards: false !default;
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Some Liferay DXP components haven't been migrated to Bootstrap 4.
 Disabling certain components might cause portions of the UI to break.
 Therefore, after upgrading your markup, we recommend that you re-enable any
 components you disable. Proceed with caution.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Update your markup to Bootstrap 4 and Clay CSS until you're satisfied
  with the result.
\item
  Re-enable any components you disabled in the compatibility layer by
  removing any components you set to false in
  \texttt{/src/css/\_clay\_custom.scss}. This prevents Liferay DXP's UI
  from breaking.
\end{enumerate}

Now you know how to use the Bootstrap 3 and Lexicon CSS compatibility
layer to provide a smooth transition during your theme upgrade.

\chapter{Upgrading 7.1 Themes to 7.2}\label{upgrading-7.1-themes-to-7.2}

You can upgrade a Liferay Portal 7.1 theme to 7.0, regardless of the
development environment you use. This tutorial uses the Liferay JS Theme
Toolkit's Gulp \texttt{upgrade} task to automate much of the steps. This
requires v9.x.x of the Liferay Theme Generator and liferay theme tasks.

Here's what the Upgrade Task does:

\begin{itemize}
\tightlist
\item
  Updates Liferay version references
\item
  Updates theme dependencies
\end{itemize}

Follow these steps to upgrade the theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install the Liferay Theme Generator v9.x.x with the command below:

\begin{verbatim}
npm install -g generator-liferay-theme@9.x.x
\end{verbatim}
\item
  You must update the theme's \texttt{liferay-theme-tasks} dependency to
  version \texttt{9.x.x} as well to run the upgrade process:

\begin{verbatim}
npm install --save-dev liferay-theme-tasks@9.x.x
\end{verbatim}
\item
  With the \texttt{9.x.x} versions of the \texttt{liferay-theme-tasks}
  and Liferay Theme Generator installed, run the \texttt{gulp\ upgrade}
  command to upgrade the 7.1 theme to 7.2.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: The Upgrade task overwrites the theme's files. We recommend that 
 you backup your files before proceeding with the upgrade process.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  In 7.1, Font Awesome \& Glyphicons were included in the
  \href{/docs/7-1/tutorials/-/knowledge_base/t/using-the-bootstrap-3-lexicon-css-compatibility-layer}{compatibility
  layer}. Since Liferay DXP Fix Pack 2 and Liferay Portal 7.2 CE GA2,
  Font Awesome is available globally as a system setting, which is
  enabled by default. If you're using Font Awesome icons in your theme,
  answer yes (y) to the Font Awesome question during the Upgrade task to
  include the Font Awesome dependency in your theme. This ensures that
  your icons won't break if a Site Administrator disables the global
  setting.
\item
  Run \texttt{gulp\ init} from the theme's root directory to update the
  path of the app server to point to the new 7.2 app server.
\end{enumerate}

There you have it! The theme is ready to run on 7.0.

\chapter{Upgrading a Layout Template to
7.2}\label{upgrading-a-layout-template-to-7.2}

In these tutorials, you'll learn how to upgrade your layout templates
from earlier versions of Liferay DXP to 7.0. By the end of the tutorial,
you'll have a layout template that runs on 7.0.

Select the tutorial below that corresponds to the current version of
your layout template:

Let's Go 6.2!{}

Let's Go 7.0 and 7.1!{}

\chapter{Upgrading 6.2 Layout Templates to
7.2}\label{upgrading-6.2-layout-templates-to-7.2}

Upgrading your Liferay DXP 6.2 layout template to 7.0 requires a few
updates:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your layout template's \texttt{liferay-plugin-package.properties}
  file and update the \texttt{liferay-versions} property to
  \texttt{7.2.0+}:

\begin{verbatim}
liferay-versions=7.2.0+
\end{verbatim}
\item
  Velocity layout templates are supported, but deprecated as of Liferay
  DXP 7.1. We recommend that you convert your Velocity layout templates
  to FreeMarker now. Wrap the
  \texttt{processor.processColumn("column-1",\ "portlet-column-content\ portlet-column-content-first")}
  methods with braces (\texttt{\{...\}}) and change the template's file
  extension to \texttt{.ftl}.
\item
  Update the Bootstrap \texttt{span{[}number{]}} classes to use the
  newer \texttt{col-{[}size{]}-{[}number{]}} classes. See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/layout-templates-intro}{Layout
  Templates} for more information on the updated syntax.
\item
  Save the changes.

  Below is an example configuration:

  Original:

\begin{verbatim}
<div class="span4 span6 portlet-column portlet-column-first" 
id="column-1">
        $processor.processColumn("column-1", 
        "portlet-column-content portlet-column-content-first")
</div>
<div class="span8 span6 portlet-column portlet-column-last" 
id="column-2">
        $processor.processColumn("column-2", 
        "portlet-column-content portlet-column-content-last")
</div>
</div>
\end{verbatim}

  Updated:

\begin{verbatim}
<div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
id="column-1">
        ${processor.processColumn("column-1", 
        "portlet-column-content portlet-column-content-first")}
</div>
<div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
id="column-2">
        ${processor.processColumn("column-2", 
        "portlet-column-content portlet-column-content-last")}
</div>
</div>
\end{verbatim}
\end{enumerate}

Awesome! Your layout template is upgraded.

\chapter{Upgrading 7.0 and 7.1 Layout Templates to
7.2}\label{upgrading-7.0-and-7.1-layout-templates-to-7.2}

If you're upgrading your Liferay DXP 7.0 or Liferay DXP 7.1 layout
template to 7.0, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your layout template's \texttt{liferay-plugin-package.properties}
  file and update the \texttt{liferay-versions} property to
  \texttt{7.2.0+}:

\begin{verbatim}
liferay-versions=7.2.0+
\end{verbatim}
\item
  Velocity layout templates are supported, but deprecated as of Liferay
  DXP 7.1. We recommend that you convert your Velocity layout templates
  to FreeMarker now. Wrap the
  \texttt{processor.processColumn("column-1",\ "portlet-column-content\ portlet-column-content-first")}
  methods with braces (\texttt{\{...\}}) and change the template's file
  extension to \texttt{.ftl}.
\item
  Save the changes.

  Below is an example configuration:

  Original (\texttt{my\_layout\_template.tpl}):

\begin{verbatim}
<div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
id="column-1">
        $processor.processColumn("column-1", 
        "portlet-column-content portlet-column-content-first")
</div>
<div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
id="column-2">
        $processor.processColumn("column-2", 
        "portlet-column-content portlet-column-content-last")
</div>
</div>
\end{verbatim}

  Updated (\texttt{my\_layout\_template.ftl}):

\begin{verbatim}
<div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
id="column-1">
        ${processor.processColumn("column-1", 
        "portlet-column-content portlet-column-content-first")}
</div>
<div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
id="column-2">
        ${processor.processColumn("column-2", 
        "portlet-column-content portlet-column-content-last")}
</div>
</div>
\end{verbatim}
\end{enumerate}

Awesome! Your layout template is upgraded.

\chapter{Upgrading Frameworks and
Features}\label{upgrading-frameworks-and-features}

Your upgrade process not only relies on portlet technology, themes, and
customization plugins, but also the frameworks your project leverages.
The following frameworks and their upgrade processes are discussed in
this section:

\begin{itemize}
\tightlist
\item
  JNDI data source usage
\item
  Service Builder service invocation
\item
  Service Builder
\item
  Velocity templates
\end{itemize}

Continue on to learn more about upgrading these frameworks.

Let's Go!{}

\chapter{Upgrading JNDI Data Source
Usage}\label{upgrading-jndi-data-source-usage}

\begin{verbatim}
<p id="stepTitle">Upgrading Frameworks and Features</p><p>Step 1 of 4</p>
\end{verbatim}

In Liferay DXP's OSGi environment, you must use the portal's class
loader to load the application server's JNDI classes. An OSGi bundle's
attempt to connect to a JNDI data source without using Liferay DXP's
class loader results in a \texttt{java.lang.ClassNotFoundException}.

For more information on how to do this, see the
\href{/docs/7-2/appdev/-/knowledge_base/a/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources} article.

\chapter{Upgrading Service Builder Service
Invocation}\label{upgrading-service-builder-service-invocation}

\begin{verbatim}
<p id="stepTitle">Upgrading Frameworks and Features</p><p>Step 2 of 4</p>
\end{verbatim}

When upgrading a portlet leveraging
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}, you must first decide if you're building your Service Builder
logic as a WAR or modularizing it.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically have its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

If you prefer keeping your Service Builder logic as a WAR, you must
implement a service tracker to call services. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{Service
Trackers} article for more information.

\chapter{Upgrading Service Builder}\label{upgrading-service-builder}

\begin{verbatim}
<p id="stepTitle">Upgrading Frameworks and Features</p><p>Step 3 of 4</p>
\end{verbatim}

7.0 continues to use
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}, so you can focus on your application's business logic instead
of its persistence details. It still generates model classes, local and
remote services, and persistence.

Upgrading most Service Builder portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[step-1-adapt-the-code-to-product-vers-api]{Adapt the code to
  7.0's API}
\item
  \hyperref[step-2-resolve-dependencies]{Resolve dependencies}
\item
  \hyperref[step-3-build-the-services]{Build the services}
\end{enumerate}

Start by adapting the code.

\section{Step 1: Adapt the Code to 7.0's
API}\label{step-1-adapt-the-code-to-7.0s-api}

Adapt the portlet to 7.0's API using the Upgrade Planner. When running
the planner's \emph{Fix Upgrade Problems} step, many of the existing
issues are autocorrected. For remaining issues, the planner identifies
code affected by the new API and ways to adapt it.

For example, consider an example portlet with the following compilation
error:

\begin{verbatim}
/html/guestbook/view.jsp(58,1) PWC6131: Attribute total invalid for tag search-container-results according to TLD
\end{verbatim}

The \texttt{view.jsp} file specifies a tag library attribute
\texttt{total} that doesn't exist in 7.0's \texttt{liferay-ui} tag
library. Notice the second attribute \texttt{total}.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>"
    total="<%=EntryLocalServiceUtil.getEntriesCount(scopeGroupId,
                    guestbookId)%>" />
\end{verbatim}

Remove the \texttt{total} attribute assignment to make the tag like
this:

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%=EntryLocalServiceUtil.getEntries(scopeGroupId,
                    guestbookId, searchContainer.getStart(),
                    searchContainer.getEnd())%>" />
\end{verbatim}

Resolve these error types and others until your code is adapted to the
new API.

\section{Step 2: Resolve
Dependencies}\label{step-2-resolve-dependencies}

To adapt your app's dependencies, refer to the
\href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolving
a Project's Dependencies} tutorial. Once your dependencies are upgraded,
rebuild your services!

\section{Step 3: Build the Services}\label{step-3-build-the-services}

An example change where upgrading legacy Service Builder code can
produce differing results is explained below.

A Liferay Portal 6.2 portlet's \texttt{service.xml} file specifies
exception class names in \texttt{exception} elements like this:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
    <exceptions>
        <exception>GuestbookName</exception>
        <exception>EntryName</exception>
        <exception>EntryMessage</exception>
        <exception>EntryEmail</exception>
    </exceptions>
</service-builder>
\end{verbatim}

In Liferay Portal 6.2, Service Builder generates exception classes to
the path attribute \texttt{package-path} specifies. In 7.0, Service
Builder generates them to \texttt{{[}package-path{]}/exception}.

Old path:

\begin{verbatim}
[package-path]
\end{verbatim}

New path:

\begin{verbatim}
[package-path]/exception 
\end{verbatim}

For example, the example portlet's package path is
\texttt{com.liferay.docs.guestbook}. Its exception class for
\texttt{exception} element \texttt{GuestbookName} is generated to
\texttt{docroot/WEB-INF/service/com/liferay/docs/guestbook/exception}.
Classes that use the exception must import
\texttt{com.liferay.docs.guestbook.exception.GuestbookNameException}. If
this upgrade is required in your Service Builder project, you must
update the references to your portlet's exception classes.

Once your Service Builder portlet is upgraded,
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy
it}.

\noindent\hrulefill

\textbf{Note:} Service Builder portlets automatically migrated to
Liferay Workspace using the Upgrade Planner or Blade CLI's
\texttt{convert} command automatically has its Service Builder logic
converted to API and implementation modules. This is a best practice for
7.0.

\noindent\hrulefill

The portlet is now available on Liferay DXP. Congratulations on
upgrading a portlet that uses Service Builder!

\chapter{Migrating Off of Velocity
Templates}\label{migrating-off-of-velocity-templates}

\begin{verbatim}
<p id="stepTitle">Upgrading Frameworks and Features</p><p>Step 4 of 4</p>
\end{verbatim}

Velocity templates were deprecated in Liferay Portal 7.0 and are now
removed in favor of FreeMarker templates in 7.0. Below are the key
reasons for this move:

\begin{itemize}
\item
  FreeMarker is developed and maintained regularly, while Velocity is no
  longer actively being developed.
\item
  FreeMarker is faster and supports more sophisticated macros.
\item
  FreeMarker supports using taglibs directly rather than requiring a
  method to represent them. You can pass body content to them,
  parameters, etc.
\end{itemize}

Although Velocity templates still work in 7.0, we highly recommend
migrating to FreeMarker templates. For more information on this topic,
see the
\href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-layout-template-to-7-2}{Upgrading
Layout Templates} section.

\chapter{Upgrading Portlets}\label{upgrading-portlets}

All portlet types developed for Liferay Portal 6.x, 7.0, and 7.1 can be
upgraded and deployed to 7.0.

Upgrading most portlets involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Adapt the code to 7.0's API
\item
  Resolve dependencies
\end{enumerate}

Liferay's Upgrade Planner helps you adapt your code to 7.0's API. This
makes resolving a portlet's dependencies straightforward. In most cases,
after you finish the above steps, you can deploy your portlet to Liferay
DXP.

The portlet upgrade tutorials show you how to upgrade the following
common portlets:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-genericportlet}{GenericPortlet}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-liferay-mvc-portlet}{Liferay
  MVC Portlet}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-liferay-jsf-portlet}{Liferay
  JSF Portlet}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-servlet-based-portlet}{Servlet-based
  portlet}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-spring-portlet-mvc-portlet}{Spring
  Portlet MVC}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-struts-1-portlet}{Struts
  Portlet}
\end{itemize}

Let's get your portlet running on 7.0!

Let's Go!{}

\chapter{Upgrading a GenericPortlet}\label{upgrading-a-genericportlet}

\begin{verbatim}
<p id="stepTitle">Upgrading Portlets</p><p>Step 1 of 6</p>
\end{verbatim}

It's common to create portlets that extend
\texttt{javax.portlet.GenericPortlet}. After all,
\texttt{GenericPortlet} provides a default
\texttt{javax.portlet.Portlet} interface implementation. Upgrading a
\texttt{GenericPortlet} is straightforward and takes only two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  it}
\end{enumerate}

When the portlet WAR file is deployed, Liferay DXP's Plugin
Compatibility Layer converts the WAR to a Web Application Bundle (WAB)
and installs the portlet as a WAB to Liferay DXP's OSGi runtime.

On deploying an upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying a portlet produces messages like these:

\begin{verbatim}
2018-03-21 17:44:59.179 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:262] Processing sample-dao-portlet-7.1.0.1.war
...
2018-03-21 17:45:09.959 INFO  [Refresh Thread: Equinox Container: 0012cbb0-7e2c-0018-146e-95a4d71cdf95][PortletHotDeployListener:298] 1 portlet for sample-dao-portlet is available for use 
...
2018-03-21 17:45:10.151 INFO  [Refresh Thread: Equinox Container: 0012cbb0-7e2c-0018-146e-95a4d71cdf95][BundleStartStopLogger:35] STARTED sample-dao-portlet_7.1.0.1 [655]
\end{verbatim}

The portlet is now available on Liferay DXP.

You've learned how to upgrade and deploy a portlet that extends
\texttt{GenericPortlet}. You adapt the code, resolve dependencies, and
deploy the portlet as you always have. It's just that easy!

\chapter{Upgrading a Liferay MVC
Portlet}\label{upgrading-a-liferay-mvc-portlet}

\begin{verbatim}
<p id="stepTitle">Upgrading Portlets</p><p>Step 2 of 6</p>
\end{verbatim}

Liferay's MVC Portlet framework is used extensively in Liferay DXP's
portlets and is a popular choice for portlet developers. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}}
class is a lightweight extension of
\texttt{javax.portlet.GenericPortlet}. Its \texttt{init} method saves
you from writing a lot of boilerplate code. MVC portlets can be upgraded
to 7.0 without a hitch.

Upgrading a Liferay MVC Portlet involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  it}
\end{enumerate}

After deploying the upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay MVC Portlet on your 7.0
instance. Have fun showing off your upgraded portlet!

\chapter{Upgrading a Liferay JSF
Portlet}\label{upgrading-a-liferay-jsf-portlet}

\begin{verbatim}
<p id="stepTitle">Upgrading Portlets</p><p>Step 3 of 6</p>
\end{verbatim}

Liferay JSF portlets are easy to upgrade and require few changes. They
interface with the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-faces}{Liferay
Faces} project, which encapsulates Liferay DXP's Java API and JavaScript
code. Because of this, upgrading JSF portlets to 7.0 requires only
updating dependencies.

There are two ways to find a JSF portlet's dependencies for 7.0:

\begin{itemize}
\tightlist
\item
  The \url{http://liferayfaces.org/} home page lets you look up the
  dependencies (Gradle or Maven) by Liferay DXP version, JSF version,
  and component suites.
\item
  The
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-faces-version-scheme}{Liferay
  Faces Version Scheme} article's tables list artifacts by Liferay DXP
  version, JSF version, portlet version, and AlloyUI and Metal component
  suite version.
\end{itemize}

In this article, you'll upgrade a Liferay DXP JSF portlet's (JSF 2.2)
dependencies to 7.0.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your Liferay JSF portlet's build file (e.g., \texttt{pom.xml},
  \texttt{build.gradle}) to where the dependencies are configured.
\item
  Navigate to the \url{http://liferayfaces.org/} site and generate a
  dependency list by choosing the environment to which you want to
  upgrade your portlet.

  \begin{figure}
  \centering
  \includegraphics{./images/jsf-dependency-generation.png}
  \caption{The Liferay Faces site gives you options to generate
  dependencies for many environments.}
  \end{figure}
\item
  Compare the generated dependencies with your portlet's dependencies
  and make any necessary updates. For example, in the sample
  dependencies listed below, the Mojarra dependency and two Liferay
  Faces dependencies require updating:

\begin{verbatim}
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.faces</artifactId>
    <version>2.2.13</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>3.0.0</version>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.impl</artifactId>
    <version>4.0.0</version>
</dependency>
\end{verbatim}

  Using the \url{http://liferayfaces.org/} dependency list as a guide,
  these dependencies would be updated to

\begin{verbatim}
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>javax.faces</artifactId>
    <version>2.2.19</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.ext</artifactId>
    <version>5.0.4</version>
</dependency>
<dependency>
    <groupId>com.liferay.faces</groupId>
    <artifactId>com.liferay.faces.bridge.impl</artifactId>
    <version>4.1.3</version>
</dependency>
\end{verbatim}
\end{enumerate}

Once your Liferay JSF portlet's dependencies are updated, it's
deployable to 7.0! Follow the
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploying
a Project} article for deployment help.

When the portlet WAR is deployed, Liferay DXP's Plugin Compatibility
Layer converts the WAR to a Web Application Bundle (WAB) and installs
the portlet as a WAB to Liferay DXP's OSGi runtime. The server prints
messages that indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

Deploying a Liferay JSF portlet produces messages like these:

\begin{verbatim}
13:41:43,690 INFO ... [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:252] Processing com.liferay.faces.demo.jsf.applicant.portlet-1.0.war
...
13:42:03,522 INFO  [fileinstall-C:/liferay-ce-portal-7.2-ga1/osgi/war][BundleStartStopLogger:35] STARTED com.liferay.faces.demo.jsf.applicant.portlet-1.0_4.1.0 [503]
...
13:42:05,169 INFO  [fileinstall-C:/liferay-ce-portal-7.2-ga1/osgi/war][PortletHotDeployListener:293] 1 portlet for com.liferay.faces.demo.jsf.applicant.portlet-1.0 is available for use
\end{verbatim}

After the portlet deployment is complete, it's available on Liferay DXP.

You've learned how to upgrade and deploy a Liferay JSF portlet. You
resolved dependencies and deployed the portlet as you always have. It's
just that easy!

\chapter{Upgrading a Servlet-based
Portlet}\label{upgrading-a-servlet-based-portlet}

\begin{verbatim}
<p id="stepTitle">Upgrading Portlets</p><p>Step 4 of 6</p>
\end{verbatim}

This tutorial shows you how to upgrade servlet-based portlets. It refers
to code from before and after upgrading a sample servlet-based portlet
called \emph{Sample JSON} (project \texttt{sample-json-portlet}). The
portlet shows a \emph{Click me} link. When users click the link, the
Liferay logo appears.

Follow these steps to upgrade a servlet-based portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  it}
\end{enumerate}

For an example upgrade scenario, consider this:

Some servlet-based portlets relied on Liferay Portal to provide several
dependency JAR files. Here's the \texttt{portal-dependency-jars}
property from a sample portlet's
\texttt{liferay-plugin-package.properties} file:

\begin{verbatim}
portal-dependency-jars=\
    dom4j.jar,\
    jabsorb.jar,\
    json-java.jar
\end{verbatim}

This property is deprecated in 7.0 because importing and exporting Java
packages has replaced wholesale use of JARs. This means modules and WABs
can import packages without concerning themselves with JARs. Liferay DXP
exports many third party packages for plugins to use. Best practices for
using packages that Liferay DXP exports are found
\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{here}.

Once you've deployed your portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

The portlet is installed to Liferay's OSGi runtime and is available to
users.

Congratulations! You've upgraded and deployed your servlet-based portlet
to 7.0.

\chapter{Upgrading a Spring Portlet MVC
Portlet}\label{upgrading-a-spring-portlet-mvc-portlet}

\begin{verbatim}
<p>Upgrading Portlets<br>Step 5 of 6</p>
\end{verbatim}

Upgraded portlets that use Spring Portlet MVC should be migrated to use
PortletMVC4Spring. The main reason is that PortletMVC4Spring is
maintained for compatibility with the latest versions of the Spring
Framework.

\noindent\hrulefill

\textbf{Note:} The PortletMVC4Spring project began as Spring Portlet MVC
and was part of the
\href{https://spring.io/projects/spring-framework}{Spring Framework}.
When the project was pruned from version 5.0.x of the Spring Framework
under
\href{https://github.com/spring-projects/spring-framework/issues/18701}{SPR-14129},
it became necessary to fork and rename the project. This made it
possible to improve and maintain the project for compatibility with the
latest versions of the Spring Framework and the Portlet API.

\noindent\hrulefill

\noindent\hrulefill

\href{http://www.liferay.com/}{Liferay} adopted Spring Portlet MVC in
March of 2019 and the project was renamed to PortletMVC4Spring.

\noindent\hrulefill

For more information on PortletMVC4Spring, see its dedicated
\href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{section of
articles}. For specific information on migrating a portlet using Spring
Portlet MVC to PortletMVC4Spring, see the
\href{/docs/7-2/appdev/-/knowledge_base/a/migrating-to-portletmvc4spring}{Migrating
to PortletMVC4Spring} article.

Once you've migrated your portlet to leverage the PortletMVC4Spring
framework, you must also adapt your Liferay-specific APIs and
dependencies. To do this, complete the following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  it}
\end{enumerate}

After deploying the upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've migrated your Spring Portlet MVC portlet to the updated
PortletMVC4Spring framework, updated any additional APIs and
dependencies, and deployed it to your 7.0 instance. Your portlet's
upgrade process is complete!

\chapter{Upgrading a Struts 1
Portlet}\label{upgrading-a-struts-1-portlet}

\begin{verbatim}
<p id="stepTitle">Upgrading Portlets</p><p>Step 6 of 6</p>
\end{verbatim}

Struts is a stable, widely adopted framework that implements the Model
View Controller (MVC) design pattern. If you have a Struts portlet for
previous versions of Liferay Portal, you can upgrade it to 7.0.

Upgrading Struts portlets to 7.0 is easier than you might think. Liferay
DXP lets you continue working with Struts portlets as Java EE web
applications.

This tutorial demonstrates how to upgrade a portlet that uses the Struts
1 Framework.

Here's a sample Struts portlet's folder structure with file/folder
descriptions:

\begin{itemize}
\tightlist
\item
  \texttt{sample-struts-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{docroot/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{html/portlet/sample\_struts\_portlet/} → JSPs
    \item
      \texttt{WEB-INF/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{lib/} → Required third-party libraries unavailable in
        the Liferay DXP system
      \item
        \texttt{src/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/samplestruts/model/} → Model classes
        \item
          \texttt{com/liferay/samplestruts/servlet/} → Test servlet and
          servlet context listener
        \item
          \texttt{com/liferay/samplestruts/struts/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{action/} → \texttt{Action} classes that return View
            pages to the client
          \item
            \texttt{form/} → \texttt{ActionForm} classes for model
            interaction
          \item
            \texttt{render/} → \texttt{Action} classes that present
            additional pages and handle input
          \item
            \texttt{SampleException.java} → Exception class
          \end{itemize}
        \item
          \texttt{content/test/} → Resource bundles
        \item
          \texttt{META-INF/} → Javadoc
        \end{itemize}
      \item
        \texttt{tld/} → Tag library definitions
      \item
        \texttt{liferay-display.xml} → Sets the application category
      \item
        \texttt{liferay-plugin-package.properties} → Sets metadata and
        portal dependencies
      \item
        \texttt{liferay-portlet.xml} → Maps descriptive role names to
        roles
      \item
        \texttt{liferay-releng.properties} → (internal) Release
        properties
      \item
        \texttt{portlet.xml} → Defines the portlet and its
        initialization parameters and security roles
      \item
        \texttt{struts-config.xml} → Struts configuration
      \item
        \texttt{tiles-defs.xml} → Struts Tile definitions
      \item
        \texttt{validation.xml} → Defines form inputs for validation
      \item
        \texttt{validation-rules.xml} → Struts validation rules
      \item
        \texttt{web.xml} → Web application descriptor
      \end{itemize}
    \end{itemize}
  \item
    \texttt{build.xml} → Apache Ant build file
  \end{itemize}
\end{itemize}

Upgrading a Struts 1 portlet involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the portlet to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\end{enumerate}

You've resolved the Sample Struts portlet's dependencies. It's ready to
deploy.

\noindent\hrulefill

\textbf{Important}: Setting Portal property
\texttt{jsp.page.context.force.get.attribute} (described in the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#JSP}{JSP
section}) to \texttt{true} (default) forces calls to
\texttt{com.liferay.taglib.servlet.PageContextWrapper\#findAttribute(String)}
to use \texttt{getAttribute(String)}. Although this improves performance
by avoiding unnecessary fall-backs, it can cause attribute lookup
problems in Struts portlets. To use Struts portlets in your sites, makes
sure to set the Portal property
\texttt{jsp.page.context.force.get.attribute} to \texttt{false} in a
file \texttt{{[}Liferay-Home{]}/portal-ext.properties}.

\begin{verbatim}
jsp.page.context.force.get.attribute=false
\end{verbatim}

\noindent\hrulefill

On
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploying}
a Struts portlet Web Application aRchive (WAR), Liferay DXP's Web
Application Bundle (WAB) Generator creates an OSGi module (bundle) for
the portlet and installs it to Liferay's OSGi framework. The server
prints messages indicating the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

The Struts portlet is now available on your Liferay DXP instance. The
Struts portlet behaves just as it did on previous versions on your 7.0
site.

Congratulations on upgrading your Struts portlet to 7.0!

\chapter{Upgrading Web Plugins}\label{upgrading-web-plugins}

\begin{verbatim}
<p id="stepTitle">Upgrading Web Plugins</p><p>Step 1 of 1</p>
\end{verbatim}

Web plugins are regular
\href{https://docs.oracle.com/cd/E19226-01/820-7627/bnadx/index.html}{Java
EE web modules} designed to work with Liferay DXP. These plugins were
stored in the \texttt{webs} folder of the legacy Plugins SDK.

Upgrading a Liferay web plugin involves these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Adapt the plugin to 7.0's API using the Liferay Upgrade Planner. When
  running the planner's \emph{Fix Upgrade Problems} step, many of the
  existing issues are autocorrected. For remaining issues, the planner
  identifies code affected by the new API and ways to adapt it.
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/resolving-a-projects-dependencies}{Resolve
  its dependencies}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  it}
\end{enumerate}

After deploying the upgraded portlet, the server prints messages that
indicate the following portlet status:

\begin{itemize}
\tightlist
\item
  WAR processing
\item
  WAB startup
\item
  Availability to users
\end{itemize}

You've upgraded and deployed your Liferay web plugin on your 7.0
instance. Great job!

\chapter{Upgrading Ext Plugins}\label{upgrading-ext-plugins}

Ext plugins let you use internal APIs and even let you overwrite Liferay
DXP core files. This puts your deployment at risk of being incompatible
with security, performance, or feature updates released by Liferay. When
upgrading to a new version of Liferay DXP, you must review all changes
and manually modify your Ext projects to merge your changes with Liferay
DXP's.

During your upgrade to 7.0, it's highly recommended to leverage an
extension point to customize Liferay DXP instead of using you existing
Ext plugin, if possible. 7.0 provides many extension points that let you
customize almost every detail of Liferay DXP. If there's a way to
customize what you want with an extension point, do it that way instead.
See
\href{/docs/7-2/customization/-/knowledge_base/c/finding-extension-points}{Finding
Extension Points} for more details.

For more information on Ext projects, how to decide if you need one, and
how to manage them, see the
\href{/docs/7-2/customization/-/knowledge_base/c/customization-with-ext}{Customization
with Ext} section.

\chapter{Creating a Theme}\label{creating-a-theme}

This tutorial takes you step-by-step through the process of creating a
theme. You'll create a responsive theme for Liferay's Lunar Resort that
demonstrates best practices and uses Liferay DXP's theme tools,
extensions, and mechanisms. Several example files are referenced
throughout this tutorial. You can download the
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code}{\texttt{lunar-resort-theme.zip}}
if you want to follow along locally. The Lunar Resort theme's files are
also included in the
\href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme}{\texttt{lunar-resort-theme}}
folder of the Liferay Docs repo, if you would rather view them there.

This tutorial covers these topics:

\begin{itemize}
\tightlist
\item
  Generating the theme and configuring it to extend the Atlas base theme
\item
  Customizing the Header and logo
\item
  Customizing the Header navigation
\item
  Customizing the Footer and embedding footer navigation
\item
  Creating a color scheme variant
\end{itemize}

By the end of this tutorial, you'll be able to create the theme below:

\begin{figure}
\centering
\includegraphics{./images/theme-tutorial-finished-theme.png}
\caption{The finished Lunar Resort Theme uses Liferay DXP's tools to
produce a user-friendly UI that is maintainable.}
\end{figure}

\chapter{Setting up the Theme}\label{setting-up-the-theme}

In this section, you'll use the Liferay JS Theme Toolkit's Liferay Theme
Generator to generate the theme's files. You'll complete these tasks:

\begin{itemize}
\tightlist
\item
  Install the Liferay Theme Generator and its dependencies
\item
  Generate a theme
\item
  Configure the theme to extend the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-atlas-and-clay-base-themes}{Atlas
  base theme}.
\end{itemize}

Atlas provides the look of the Classic theme. It builds on the default
Clay Base theme and provides additional styles.

Follow these steps to generate and configure the theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install the Theme Generator. Since you're developing a theme for 7.0,
  install v9.x.x if it's not installed already. Run the command below:

\begin{verbatim}
npm install -g generator-liferay-theme@9.x.x
\end{verbatim}
\item
  Install the Yeoman and gulp dependencies:

\begin{verbatim}
npm install -g yo gulp
\end{verbatim}
\item
  Generate the starting theme with the Theme Generator. Enter
  \emph{Lunar Resort Theme} for the name and \emph{lunar-resort} for the
  ID, and answer no for the Font Awesome prompt. This theme uses Clay
  icons instead:

\begin{verbatim}
yo liferay-theme
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/theme-tutorial-yeoman-prompt.png}
  \caption{Answer no for the Font Awesome Prompt}
  \end{figure}
\item
  To develop the theme you must copy the default files from the theme's
  build and modify them. The \texttt{/src/css/} folder and
  \texttt{\_custom.scss} file are included by default. Run the command
  below from the theme's root folder to build the files:

\begin{verbatim}
gulp build
\end{verbatim}
\item
  Create a new \texttt{/src/templates/} folder and copy
  \texttt{portal\_normal.ftl} from the \texttt{build/templates/} folder
  into it.
\item
  Configure the theme to extend the Atlas theme. Add a
  \texttt{clay.scss} file to the theme's \texttt{/src/css/} folder and
  add the import shown below:

\begin{verbatim}
@import "clay/atlas";
\end{verbatim}
\item
  Create an \texttt{\_imports.scss} file in the \texttt{/src/css/}
  folder and add the imports shown below to it. This includes the
  default imports and replaces the \texttt{clay/base-variables} with the
  Atlas base variables:

\begin{verbatim}
@import "bourbon";

@import "mixins";

@import "compat/mixins";

@import "clay/atlas-variables";
\end{verbatim}
\end{enumerate}

You've generated the theme, prepared it for development, and configured
it to extend the Atlas theme. Continue to the next section to build the
Lunar Resort's Header and customize the logo.

\chapter{Customizing the Lunar Resort's Header and
Logo}\label{customizing-the-lunar-resorts-header-and-logo}

The Header contains the navigation and logo for the site. In this
section you'll customize the look and feel of the Header and add a
custom logo.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open \texttt{portal\_normal.ftl} and replace the
  \texttt{\textless{}header\textgreater{}...\textless{}/header\textgreater{}}
  element and contents with the updated code snippet below. This updates
  the structure slightly, making the banner expand the full width of the
  Header, and adds a new \texttt{header\_css\_class} variable to the
  \texttt{class} attribute. This variable is defined in a later step.

\begin{verbatim}
<header class="${header_css_class}">
    <div class="container-fluid" id="banner" role="banner">
        <a class="${logo_css_class}" href="${site_default_url}" title="<@liferay.language_format arguments="${site_name}" key="go-to-x" />">
            <img alt="${logo_description}" height="${site_logo_height}" src="${site_logo}" width="${site_logo_width}" />
            <#if show_site_name>
                ${site_name}
            </#if>
        </a>

        <#if has_navigation>
            <#include "${full_templates_path}/navigation.ftl" />
        </#if>
    </div>
</header>
\end{verbatim}
\item
  Replace the
  \texttt{\textless{}div\ class="container-fluid"\ id="wrapper"\textgreater{}}
  element with the updated code below to remove some margins and
  padding:

\begin{verbatim}
<div class="container-fluid mt-0 pt-0 px-0" id="wrapper">
\end{verbatim}

  And move the wrapper down, and place it directly above the
  \texttt{\textless{}section\ id="content"\textgreater{}} element:

\begin{verbatim}
<div class="container-fluid mt-0 pt-0 px-0" id="wrapper">
  <section id="content">
  ...
  </section>
  <footer...>
  ...
  </footer>
</div>
\end{verbatim}
\item
  The logo's height is retrieved with the
  \texttt{\$\{site\_logo\_height\}} variable. The height of the logo is
  a bit too large for the Lunar Resort theme, so you must adjust it.
  Remove the \texttt{width} attribute from the logo's image so it
  defaults to \texttt{auto}:

\begin{verbatim}
<img alt="${logo_description}" height="${site_logo_height}" src="${site_logo}" />
\end{verbatim}
\item
  Create \texttt{init\_custom.ftl} in your theme's
  \texttt{/src/templates/} folder and assign the logo's
  \texttt{site\_logo\_height} variable to the value below:

\begin{verbatim}
<#assign site_logo_height = 56 />
\end{verbatim}
\item
  Assign the new \texttt{header\_css\_class} variable you added in step
  one to the value below:

\begin{verbatim}
<
#assign header_css_class = 
"navbar navbar-expand-md navbar-dark flex-column flex-md-row bd-navbar" 
/>
\end{verbatim}

  This applies Bootstrap and Clay utility classes to provide the overall
  look and feel of the Header. Assigning the classes to a variable keeps
  \texttt{portal\_normal} clean and makes the code easy to maintain. If
  you want to update the classes, you just have to modify the variable
  (e.g.~\texttt{header\_css\_class\ =\ header\_css\_class\ +\ "\ my-new-class"}).
\item
  Add the code snippet below to update the \texttt{logo\_css\_class}
  variable to use Bootstrap's \texttt{navbar-brand} class:

\begin{verbatim}
<#assign logo_css_class = logo_css_class + " navbar-brand" />
\end{verbatim}
\item
  Before you upload the theme to see what it looks like so far, you must
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-thumbnail-preview-for-your-theme}{create
  a theme thumbnail} so you can identify it. To save time, copy the
  \texttt{thumbnail.png} asset from the
  {[}\texttt{lunar-resort-build/assets{]}(./images/}{]}(https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets
  folder to a new \texttt{/src{]}(./images/} folder. Note that its
  dimensions are 480px by 270px. These dimensions are required to
  display the theme thumbnail properly.
\item
  The theme isn't complete yet, but you'll deploy what you have so you
  can replace the default logo with the Lunar Resort logo. Enable
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Developer
  Mode} before deploying your theme, so the theme's files are not cached
  for future deployments. Start the server, if it's not already started,
  and deploy the theme with the command below:

\begin{verbatim}
gulp deploy
\end{verbatim}
\item
  Before you configure the pages, you must import the Lunar Resort's
  pages. Open the Control Menu and navigate to \emph{Publishing} →
  \emph{Import}. Click the Plus button to create a new import process.
  Click \emph{Select File} and import the
  \texttt{lunar\_resort\_pages.lar} from the
  \href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets}{\texttt{lunar-resort-build/assets/}}
  folder. Keep the default settings and click \emph{Import}.
\item
  Open the Control Menu and navigate to \emph{Site Builder} →
  \emph{Pages}. Click the Gear icon next to \emph{Public Pages} to open
  the configuration menu. Under the \emph{Look and Feel} tab, scroll
  down and click the \emph{Change Current Theme} button and select the
  Lunar Resort Theme. Scroll to the Logo heading, click the
  \emph{Change} button, upload the \texttt{lunar-resort-logo.png} asset
  from the
  {[}\texttt{lunar-resort-build/assets{]}(./images/}{]}(https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets
  folder, and click the \emph{Save} button to apply the theme and logo.
\end{enumerate}

Great! You've customized the Lunar Resort's Header and applied a custom
logo. Next, you'll configure and customize the theme's navigation.

\chapter{Customizing the Navigation}\label{customizing-the-navigation}

Navigation items (pages) are defined and configured in Liferay DXP. The
Navigation template iterates through the existing navigation items
(pages) and assigns the template's markup for each of them. Page updates
therefore require no updates to the theme directly and can be made by a
Site Administrator, thus reducing the maintenance costs.

To customize the navigation, you can either use the default navigation
provided in \texttt{navigation.ftl} and customize the markup template,
or you can embed the navigation portlet in the theme and customize its
preferences. Both approaches use the same overall markup. This section
takes the former approach and customizes the default configuration in
\texttt{navigation.ftl}. in the next section, you'll embed the
navigation portlet in the Footer and configure its preferences to only
display the top level (parent) navigation items.

Follow these steps to configure the Header's navigation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy the default \texttt{navigation.ftl} file from the
  \texttt{/src/build/templates/} folder into the theme's
  \texttt{/src/templates/} folder. The \texttt{build} folder was
  generated when you built the theme and again when you initially
  deployed the theme in the last section.
\item
  By default, the User Personal Bar is hidden from the theme. You can
  either enable this via System Settings outside the scope of the theme,
  or you can include it in your theme. In this case, you'll include it
  in the theme. Open the \texttt{navigation.ftl} template you just
  copied and add this User Personal Bar markup to the top:

\begin{verbatim}
<div class="mx-1 mx-sm-3 order-md-1 lunar-user">
    <@liferay.user_personal_bar />
</div>
\end{verbatim}

  along with some utility classes to position and order the User
  Personal Bar, this also adds a custom \texttt{lunar-user} class, which
  you'll use later for styling.
\item
  Modify the default template to use Bootstrap's \texttt{navbar} format.
  Wrap the
  \texttt{\textless{}nav\textgreater{}...\textless{}/nav\textgreater{}}
  element with the \texttt{\textless{}div\textgreater{}} shown below:

\begin{verbatim}
<div class="collapse navbar-collapse" id="lunarNav">
  <nav ... >
  </nav>
</div>
\end{verbatim}
\item
  Open the \texttt{portal\_normal.ftl} template and find this
  conditional wrapper:

\begin{verbatim}
<#if has_navigation>
  <#include "${full_templates_path}/navigation.ftl" />
</#if>
\end{verbatim}

  Update the conditional to include the menu toggler for the mobile
  navigation. This targets the \texttt{\#lunarNav} wrapper that you
  added in the previous step:

\begin{verbatim}
<#if has_navigation>
  <button 
    aria-controls="navigation" 
    aria-expanded="false" 
    class="btn-monospaced ml-auto navbar-toggler" 
    data-target="#lunarNav" 
    data-toggle="collapse" 
    type="button">
    <span class="navbar-toggler-icon"></span>
  </button>
  <#include "${full_templates_path}/navigation.ftl" />
</#if>
\end{verbatim}
\item
  Open \texttt{navigation.ftl} and add the \texttt{navbar-nav} and
  \texttt{mr-auto} classes to the \texttt{\textless{}ul\textgreater{}}
  element at the top:

\begin{verbatim}
<ul aria-label="<@liferay.language key="site-pages" />" class="navbar-nav mr-auto" role="menubar">
\end{verbatim}
\item
  Open \texttt{navigation.ftl} and replace the first
  \texttt{\textless{}\#assign...\ /\textgreater{}} declaration with the
  one below. This adds the \texttt{nav-item} class to the
  \texttt{nav\_item\_css\_class} variable declaration in
  \texttt{navigation.ftl} and declares a new \texttt{nav\_item\_caret}
  variable:

\begin{verbatim}
<#assign
  nav_item_attr_has_popup = ""
  nav_item_css_class = "nav-item"
  nav_item_layout = nav_item.getLayout()
  nav_item_caret = ""
/>
\end{verbatim}
\item
  Replace the \texttt{nav\_item.isSelected} conditional block with the
  one shown below. This adds the \texttt{selected} class to the existing
  \texttt{nav\_item\_css\_class} classes:

\begin{verbatim}
<#if nav_item.isSelected()>
  <#assign
    nav_item_attr_has_popup = "aria-haspopup='true'"
    nav_item_css_class = "${nav_item_css_class} selected"
  />
</#if>
\end{verbatim}
\item
  The Lunar Resort contains nested pages (child navigation items). By
  default, child navigation items are displayed at the block level.
  Instead, the Administrator wants to display these items in a dropdown
  list that is only displayed on hover of the parent navigation item.
  Add this conditional block directly below the
  \texttt{nav\_item.isSelected} block you just modified. This adds the
  \texttt{dropdown} class to the parent navigation item and updates the
  \texttt{nav\_item\_caret} variable to hold Clay caret icon markup to
  indicate the parent navigation has nested child items:

\begin{verbatim}
<#if nav_item.hasChildren()>
  <#assign
    nav_item_css_class = "${nav_item_css_class} dropdown"
    nav_item_caret = '<svg class="lexicon-icon">
    <use xlink:href="${images_folder}/lexicon/icons.svg#caret-bottom" />
    </svg>'
  />
</#if>
\end{verbatim}
\item
  Locate the anchor's markup below:

\begin{verbatim}
<a aria-labelledby="layout_${nav_item.getLayoutId()}" 
${nav_item_attr_has_popup} 
href="${nav_item.getURL()}" 
${nav_item.getTarget()} 
role="menuitem"
>
  <span>
    <@liferay_theme["layout-icon"] layout=nav_item_layout /> 
    ${nav_item.getName()}
  </span>
</a>
\end{verbatim}

  Replace it with the updated markup shown below to include the
  \texttt{\$\{nav\_item\_caret\}} variable:

\begin{verbatim}
<a 
  aria-labelledby="layout_${nav_item.getLayoutId()}" 
  class="nav-link" ${nav_item_attr_has_popup} 
  href="${nav_item.getURL()}" 
  ${nav_item.getTarget()} 
  role="menuitem"
>
  <span>
    <@liferay_theme["layout-icon"] layout=nav_item_layout /> 
    ${nav_item.getName()}
  </span> 
  ${nav_item_caret}
</a>
\end{verbatim}
\item
  Add the \texttt{dropdown-menu} class to the
  \texttt{\textless{}ul\ class="child-menu"\ role="menu"\textgreater{}}
  element and replace the \texttt{nav\_child\_css\_class} variable
  declarations with the ones below to add the \texttt{nav-item} class to
  them:

\begin{verbatim}
<#assign
  nav_child_css_class = "nav-item"
/>

<#if nav_item.isSelected()>
  <#assign
    nav_child_css_class = "nav-item selected"
  />
</#if>
\end{verbatim}
\item
  Find the \texttt{\textless{}a\textgreater{}} element with the
  \texttt{aria-labelledby="layout\_\$\{nav\_child.getLayoutId()\}"}
  attribute and add the \texttt{class="nav-link"} attribute to it:
\end{enumerate}

\begin{verbatim}
```markup
<a aria-labelledby="layout_${nav_child.getLayoutId()}" class="nav-link"...></a>
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{11}
\tightlist
\item
  Add a call to action for the visitors to the Lunar Resort site so they
  can book their flight. Add the book now button's code below the
  closing \texttt{\textless{}/nav\textgreater{}} element. This uses some
  utility classes for the basic look and feel and ordering, as well as a
  custom \texttt{btn-orange} class that you'll provide styling for
  later:
\end{enumerate}

\begin{verbatim}
```html
<a aria-controls="book-now" class="btn text-white btn-orange order-md-2">
    <p class="book-now-text mb-0">Book Now</p>
</a>
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{12}
\item
  The Lunar Resort's color scheme is comprised of three colors: orange,
  white, and blue. Since these colors are used throughout the theme,
  you'll store them in SASS variables in a separate file. Create a new
  file called \texttt{\_colors.scss} inside the theme's
  \texttt{/src/css/} folder and add these variables to it. Note that
  White is already defined as the global variable \texttt{\$white} by
  the Atlas theme.

\begin{verbatim}
$lunar-resort-orange: #dfa356;
$lunar-resort-blue: #415fa7;
$lunar-resort-link-teal: #00ccFF;
\end{verbatim}
\item
  Now that the main colors are defined, open
  \texttt{/src/css/\_custom.scss} and add the code snippet below. This
  imports the \texttt{\_colors.scss} file so you can use the variables
  you just created. It adds some basic styling for the Header and
  navigation, including a style to highlight the page that is currently
  active via the \texttt{selected} class. It also displays the child
  menu items at the block level on smaller devices with the
  \texttt{@include\ media-breakpoint-down} breakpoint:

\begin{verbatim}
@import 'colors';

body {

  a.btn-orange {
    background-color: $lunar-resort-orange;
    margin-right: 5px;

    &:hover {
      border-color: $white;
    }

    @include media-breakpoint-down(sm){
      width: 100%;
    }
  }

  header {
    background-color: $lunar-resort-blue;

    .lunar-user a {
        color: $lunar-resort-link-teal;
    }

    .user-avatar-link .lexicon-icon {
      color: $lunar-resort-blue;
    }

    li.nav-item {
      & a.nav-link span {
        font-size: 1.5em;
      }

      &:hover ul.child-menu {
        background-color: $lunar-resort-blue;
        display: block;
        margin-top: -10px;
      }

      &.selected {
        background-color: $white;
        height: 73px;
        & a.nav-link {
          color: $lunar-resort-blue;
          font-weight: bold;
          &:hover {
            color: $lunar-resort-blue;
            font-weight: normal;
            padding-left: 9.619px;
            padding-right: 9.619px;
          }
        }
      }

      @include media-breakpoint-down(sm){
        ul.child-menu {
          display: block;
        }
      }    
    }
  }
}
\end{verbatim}
\item
  The Control Menu is displayed on top of everything when the user is
  signed in, which covers the Header. You must update the
  \texttt{navigation.ftl} template to account for the Control Menu.
  Liferay DXP provides a unique class that is added to the \texttt{body}
  of the page when each product navigation (which includes the Control
  Menu) is visible. Use the \texttt{has-control-menu} class is added to
  the body when the Control Menu is visible. Open \texttt{\_custom.scss}
  and add this code snippet just above the closing bracket for the
  \texttt{body} to add a top margin to the Header that's equal to the
  height of the Control Menu:

\begin{verbatim}
&.has-control-menu {
  header {
    margin-top: 56px;  
  }
}
\end{verbatim}
\item
  The Control Menu's height is slightly smaller on mobile devices, so
  you must account for that responsiveness in your styling. Update the
  code snippet you just added to match the one below:

\begin{verbatim}
&.has-control-menu {
  header {
    margin-top: 56px;
    @include media-breakpoint-down(sm){
      margin-top: 48px;
    }  
  }
}
\end{verbatim}
\end{enumerate}

Great! The Header's navigation is customized. The updated Header and
logo should look like the figure below:

\begin{figure}
\centering
\includegraphics{./images/theme-tutorial-updated-navigation.png}
\caption{The updated Header and navigation are much more user-friendly
now.}
\end{figure}

Next, you'll define the Footer and embed a navigation portlet to display
navigation.

\chapter{Defining the Lunar Resort's Footer and Footer
Navigation}\label{defining-the-lunar-resorts-footer-and-footer-navigation}

You've configured the Header and its navigation, but at the moment the
Footer is a bit bare bones. In this section, you'll update the Footer to
include contact information for the Lunar Resort and include navigation
with an embedded navigation portlet.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  To keep the Portal Normal template uncluttered, create a separate
  template to hold the Footer's markup. Create a new file called
  \texttt{footer.ftl} in the theme's \texttt{/src/templates/} folder.
\item
  Copy the Footer markup (shown below) from \texttt{portal\_normal.ftl}
  into \texttt{footer.ftl}:

\begin{verbatim}
<footer id="footer" role="contentinfo">
    <p class="powered-by">
        <@liferay.language key="powered-by" /> <a href="http://www.liferay.com" rel="external">Liferay</a>
    </p>
</footer>
\end{verbatim}

  And update the \texttt{\textless{}p\textgreater{}} element in
  \texttt{footer.ftl} to include the classes shown below:

\begin{verbatim}
<footer id="footer" role="contentinfo">
    <p class="powered-by text-center text-white py-3 mb-0">
        <@liferay.language key="powered-by" /> <a href="http://www.liferay.com" rel="external">Liferay</a>
    </p>
</footer>
\end{verbatim}
\item
  Add this \texttt{@liferay.navigation\_menu} macro snippet above the
  \texttt{powered-by} paragraph to embed the navigation portlet. This
  configuration stores the portlet preferences in a
  \texttt{preferencesMap} variable. The \texttt{displayDepth} of
  \texttt{1} specifies that the portlet must only render the top-level
  parent navigation, and \texttt{portletSetupPortletDecoratorId} sets
  the portlet decorator to \texttt{barebone}, which removes the
  portlet's wrapper and only renders the portlet's content:

\begin{verbatim}
<nav id="navbarFooter">
    <div class="text-center mx-auto">
        <div class="nav text-uppercase" role="menubar">
            <#assign preferencesMap = {"displayDepth": "1", "portletSetupPortletDecoratorId": "barebone"} />

            <@liferay.navigation_menu
                default_preferences=freeMarkerPortletPreferences.getPreferences(preferencesMap)
                instance_id="footer_navigation_menu"
            />
        </div>
    </div>
</nav>
\end{verbatim}
\item
  The visitors need some social media links so they can keep tabs on the
  latest and greatest news from the Lunar Resort. Replace the snippet
  you just added with the one below. This uses
  \href{https://clayui.com/docs/components/icons.html}{Clay icons} and
  adds a wrapper to prepare for the next step.

\begin{verbatim}
<div id="navbarContactWrapper" class="row mx-0">
  <nav id="navbarFooter" class="col-12 col-md-6 pt-5">
    <div id="socialMediaWrapper" class="col-12 col-md-4 text-center mx-auto mb-4">
      <h2 class="nav-heading">
          Follow Us
      </h2>
        <div id="socialMediaLinks">
          <ul class="nav flex-row mx-auto">
              <li class="mx-2">
                  <div id="facebook"><a class="text-white"
                  href="http://www.facebook.com/pages/Liferay/45119213107" 
                  target="_blank"><span class="hide">Facebook</span>
                  <@clay["icon"] symbol="social-facebook" />
                  </a></div>
              </li>
              <li class="mx-2">
                  <div id="twitter"><a class="text-white" 
                  href="http://www.twitter.com/liferay" 
                  target="_blank"><span class="hide">Twitter</span>
                  <@clay["icon"] symbol="twitter" />
                  </a></div>
              </li>
              <li class="mx-2">
                  <div id="linked-in"><a class="text-white"
                  href="http://www.linkedin.com/company/83609" 
                  target="_blank"><span class="hide">LinkedIn</span>
                  <@clay["icon"] symbol="social-linkedin" />
                  </a></div>
              </li>
              <li class="mx-2">
                  <div id="youtube"><a class="text-white"
                  href="http://www.youtube.com/user/liferayinc" 
                  target="_blank"><span class="hide">YouTube</span>
                  <@clay["icon"] symbol="video" />
                  </a></div>
              </li>
          </ul>
        </div>
    </div>
    <div class="text-center mx-auto">
      <div class="nav text-uppercase" role="menubar">
        <#assign preferencesMap = {"displayDepth": "1", "portletSetupPortletDecoratorId": "barebone"} />

        <@liferay.navigation_menu
          default_preferences=freeMarkerPortletPreferences.getPreferences(preferencesMap)
          instance_id="footer_navigation_menu"
        />
      </div>
    </div>
  </nav>
</div>
\end{verbatim}
\item
  Add this snippet below the closing
  \texttt{\textless{}/nav\textgreater{}} tag to add the Lunar Resort's
  contact information. Also, copy the
  \texttt{lunar-resort-logo-vertical.png} asset from the
  {[}\texttt{lunar-resort-build/assets{]}(./images/}{]}(https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets
  folder to the \texttt{/src{]}(./images/} folder so you can use it in
  the Footer:

\begin{verbatim}
<div class="contact-info-container text-center pt-5 pb-2 col-12 col-md-4 mx-auto mb-4">
  <img alt="lunar-resort-logo" height="90" class="mb-2" src="${images_folder}/lunar-resort-logo-vertical.png" />
  <div id="contactTextWrapper" class="row mx-0">
    <p class="col-12 col-md-6">
      123 Mare Nectaris Lane<br>
      Mare Nectaris, Moon Colony 10010<br>
    </p>
    <p class="col-12 col-md-6">
      Tel: 4-919-843-6666<br>
      Fax: 4-919-843-6667<br>
      <a href="mailto:info@lunarresort.com">info@thelunarresort.com</a>
    </p>
  </div>
</div>
\end{verbatim}
\item
  The Administrator doesn't want to display the Footer on every page, so
  she would like the option to hide it. To do that, create a
  \href{/docs/7-2/frameworks/-/knowledge_base/f/making-configurable-theme-settings}{theme
  setting} to optionally show the Footer. Open your theme's
  \texttt{/src/WEB-INF/liferay-look-and-feel.xml} file and add this
  snippet just below the
  \texttt{\textless{}template-extension\textgreater{}ftl\textless{}/template-extension\textgreater{}}
  entry. This renders a togglable \emph{Show Footer} option in the
  \emph{Look and Feel} section for the theme's configuration.

\begin{verbatim}
<settings>
  <setting configurable="true" key="show-footer" type="checkbox" value="true" />
</settings>
\end{verbatim}
\item
  Now you must define a FreeMarker variable to store the value of the
  \texttt{show-footer} theme setting so you can check for it in
  \texttt{portal\_normal.ftl}. Open \texttt{init\_custom.ftl} and add
  the variable declaration below to set the \texttt{show\_footer}
  variable to the value (true or false) of the \texttt{show-footer}
  theme setting:

\begin{verbatim}
<#assign
  show_footer = getterUtil.getBoolean(themeDisplay.getThemeSetting("show-footer"))
/>
\end{verbatim}
\item
  Open \texttt{portal\_normal.ftl} and replace the Footer markup with
  the code snippet below to include the Footer template when the
  \texttt{show-footer} theme setting is \texttt{true}:

\begin{verbatim}
<#if show_footer>
    <#include "${full_templates_path}/footer.ftl" />
</#if>
\end{verbatim}
\item
  Open \texttt{\_custom.scss} and add this snippet above the
  \texttt{\&.has-control-menu} styling to style the Footer:

\begin{verbatim}
#footer {
  background-color: $lunar-resort-blue;
  color: $white;
  ul {
    margin-left: auto;
    margin-right: auto;

    &.navbar-nav {
      width: 410px;
      .nav-item.hover:after {
        width: auto;
      }

      a {
        color: $white;
        @include media-breakpoint-down(sm) {
          padding-left: 6px;
          padding-right: 6px;
        }
      }
    }
  }

  #socialMediaWrapper ul {
    width: 192px;

    li a {
      font-size: 2rem;
    }
  }

  p.powered-by a, .contact-info-container a {
      color: $lunar-resort-link-teal;
  }

}
\end{verbatim}
\item
  The majority of the Lunar Resort's content is provided with
  \href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{Fragments}.
  Since Fragments are out of the scope of this tutorial, you'll upload
  the completed fragments. Open the Control Menu and navigate to
  \emph{Site Builder} → \emph{Page Fragments}, and select the
  \emph{Import} option from the New dropdown menu. Import the
  \texttt{collections-lunar-resort.zip} asset from the
  \href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets}{\texttt{lunar-resort-build/assets/}}
  folder.
\item
  Re-deploy the updated theme with the command below:

\begin{verbatim}
gulp deploy
\end{verbatim}
\end{enumerate}

The updated Footer and navigation should look like the figure below:

\begin{figure}
\centering
\includegraphics{./images/theme-tutorial-updated-footer.png}
\caption{The updated Footer provides everything visitors need to follow
and contact the Lunar Resort.}
\end{figure}

In the next section you'll learn how to create a color scheme for the
Lunar Resort.

\chapter{Adding a Color Scheme Variant for the Lunar Resort
Theme}\label{adding-a-color-scheme-variant-for-the-lunar-resort-theme}

In this section, you'll create a color scheme variant for the Lunar
Resort Theme to apply during the Lunar Eclipse, when special discounts
are available. You'll create a color scheme that reflects the reds and
yellows present during a lunar eclipse. Since the majority of the Lunar
Resort Site's content is created with page fragments, you must account
for the color scheme styles in the page fragments as well. Follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the theme's \texttt{WEB-INF/liferay-look-and-feel.xml} file and
  add these color-scheme entries above the
  \texttt{\textless{}portlet-decorator\textgreater{}..\textless{}/portlet-decorator\textgreater{}}
  ones:

\begin{verbatim}
<theme id="my-theme-id" name="My Theme Name">
  <template-extension>ftl</template-extension>
  <color-scheme id="01" name="Default">
        <default-cs>true</default-cs>
        <css-class>default</css-class>
        <color-scheme-images-path>
                ${images-path}/color_schemes/${css-class}
        </color-scheme-images-path>
  </color-scheme>
  <color-scheme id="02" name="Eclipse">
    <css-class>eclipse</css-class>
  </color-scheme>
  ...
</theme>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Color schemes are sorted alphabetically by `name` rather than 
 `id`. For example, a color scheme named `Clouds` and `id` `02` would be 
 selected by default over a color scheme named `Day` with `id` `01`. The 
 `<default-cs>` element overrides the alphabetical sorting and sets the 
 color scheme that is selected by default when the theme is chosen.  
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Open \texttt{/src/css/\_colors.scss} and update the colors to include
  the two new ones (eclipse yellow and eclipse red) for the color
  scheme:

\begin{verbatim}
$lunar-resort-orange: #dfa356;
$lunar-resort-blue: #415fa7;
$lunar-resort-link-teal: #00ccFF;
$lunar-resort-eclipse-yellow: #dfd456;
$lunar-resort-eclipse-red: #a75441;
\end{verbatim}
\item
  Create a \texttt{/src/css/color\_schemes/} folder for the color
  scheme, and add a \texttt{eclipse.scss} file to it for the Eclipse
  color scheme. The default color scheme's styles are included in
  \texttt{\_custom.scss}, so you don't need to create anything for them.
\item
  The color scheme's class is added to the
  \texttt{\textless{}body\textgreater{}} element when the theme's color
  scheme is applied, so you must prefix the body styles with the
  \texttt{eclipse} class to target the proper color scheme. Open
  \texttt{/src/css/color\_schemes/eclipse.scss} and add this import and
  styles to it to use the new colors you defined:

\begin{verbatim}
@import '../colors';

body.eclipse {

  a.btn-orange {
    background-color: $lunar-resort-eclipse-yellow;
  }

  header {
    background-color: $lunar-resort-eclipse-red;

    .user-avatar-link .lexicon-icon {
      color: $lunar-resort-eclipse-red;
    }

    li.nav-item {

      ul.child-menu {
        background-color: $lunar-resort-eclipse-red;
      }

      &:hover ul.child-menu {
        background-color: $lunar-resort-eclipse-red;
      }

      &.selected {
        & a.nav-link {
          color: $lunar-resort-eclipse-red;
          &:hover {
            color: $lunar-resort-eclipse-red;
          }
        }
      }
    }
  }

  #footer {
    background-color: $lunar-resort-eclipse-red;
  }

}
\end{verbatim}
\item
  Import the eclipse color scheme's CSS file into \texttt{\_custom.scss}
  so it's loaded with the rest of the custom styles:

\begin{verbatim}
@import "color_schemes/eclipse";
\end{verbatim}
\item
  You must create thumbnails for each color scheme, just like you did
  the theme. To save time, copy the
  {[}\texttt{lunar-resort-build/assets{]}(./images/color\_schemes/}{]}(https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets
  folder to the theme's \texttt{/src{]}(./images/} folder. Note that the
  color scheme folder names match the color scheme CSS class names
  defined in \texttt{liferay-look-and-feel.xml}.
\item
  Now that the color scheme is created, you must update the page
  fragments to use the eclipse color scheme class so they have the same
  look as the color scheme when it's applied to the page. The fragments
  don't have access to the SASS color variables, so you must use the
  hexadecimal color codes. To save time, import the updated page
  fragments from the \texttt{lunar-resort-build/assets/} folder. Open
  the Control Menu and navigate to \emph{Site Builder} → \emph{Page
  Fragments}, click the Actions menu next to COLLECTIONS, and select the
  \emph{Import} option. Import the
  \texttt{collections-lunar-resort-color-scheme.zip} asset from the
  \href{https://github.com/liferay/liferay-docs/tree/master/en/developer/tutorials/code/lunar-resort-theme/lunar-resort-build/assets}{\texttt{lunar-resort-build/assets/}}
  folder. Note that each fragment style that requires a color change is
  duplicated and prefixed with \texttt{body.eclipse}. A couple example
  configurations are shown below:

\begin{verbatim}
.fragment_35201 h3.text-center {
  background-color: #dfa356;
  color: #FFF;
}

body.eclipse .fragment_35201 h3.text-center {
  background-color: #dfd456;
}
\end{verbatim}

\begin{verbatim}
.fragment_35201 a.btn {
  background-color: #415fa7;
}

body.eclipse .fragment_35201 a.btn {
  background-color: #a75441;
}
\end{verbatim}
\item
  Deploy the theme. Open the Control Menu, navigate to \emph{Site
  Builder} → \emph{Pages}, and click the Gear icon next to \emph{Public
  Pages}. Select the Eclipse color scheme under the \emph{LOOK AND FEEL}
  tab and save to apply the changes.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-tutorial-color-schemes.png}
  \caption{Color schemes are a good way to subtly change the look and
  feel of your site.}
  \end{figure}

  The theme should look like the figure below with the Eclipse color
  scheme applied:

  \begin{figure}
  \centering
  \includegraphics{./images/theme-tutorial-eclipse-color-scheme.png}
  \caption{The finished color scheme gives the Lunar Resort site a fiery
  glow.}
  \end{figure}
\end{enumerate}

Great! You've seen how you can quickly change the look and feel of the
Lunar Resort with just a simple color scheme. Now you know how to
develop a theme to customize the overall look and feel of your site!

See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes
section} for information on developing themes.
