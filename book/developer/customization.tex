\chapter{Liferay Customization}\label{liferay-customization}

Liferay DXP is highly customizable. Its modular architecture contains
components you can extend and override dynamically. This section
explains Liferay DXP's architecture and customization fundamentals and
demonstrates overriding and extending Liferay DXP components and
applications using APIs.

\begin{itemize}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/fundamentals}{Fundamentals}
  include understanding and configuring dependencies, packaging, and
  deployment. Here you'll work with module JARs, plugin WARs,
  components, and Java packages in Liferay DXP.
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/architecture}{Architecture}
  dives deep into how Liferay DXP uses modularity and OSGi to provide
  the core, application modules, component services, and extension
  points. Learning the architecture helps you develop better
  customizations fast, and it empowers you to build extension points
  into your own applications.
\item
  Built-in customization features, including
  \href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Widget
  Templates} and
  \href{/docs/7-2/user/-/knowledge_base/u/web-experience-management}{Web
  Experience Management} help you customize content and pages faster.
  All this is done from within the Liferay DXP UI.
\item
  Application customization articles (listed after the Architecture
  articles) demonstrate modifying Liferay applications via their APIs
  and extension points.
\end{itemize}

Start with
\href{/docs/7-2/customization/-/knowledge_base/c/fundamentals}{Fundamentals}.

\chapter{Fundamentals}\label{fundamentals}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

The fundamentals of developing on Liferay DXP and customizing it are
perhaps best learned in the context of projects. It's in projects that
you configure access to Liferay DXP's API, extend and override Liferay
DXP features, and package your software for deployment. Projects are
developed as WARs or OSGi JARs, but are all installed to Liferay's OSGi
framework as OSGi bundles. These bundles can depend on external Java
packages, share Java packages, and be manipulated at run time via Apache
Gogo Shell. The fundamentals are explained in the context of projects so
that you understand them in a practical sense and can apply them right
away. Here are the fundamental topics:

\begin{itemize}
\item
  \textbf{WARs Versus OSGi JAR} explains fundamental differences between
  the WAR and OSGi JAR structures and how they're deployed in Liferay
  DXP.
\item
  \textbf{Configuring Dependencies} demonstrates how to identify and
  configure Liferay artifacts and third-party artifacts to use their
  Java packages in your projects.
\item
  \textbf{Importing and Exporting Packages} shows how to import the
  packages your projects need and export packages your projects provide.
  Liferay's tooling detects package use and specifies package imports
  automatically.
\item
  \textbf{Semantic Versioning} shows how Liferay DXP uses a standard for
  ascribing meaning to major, minor, and micro versions of modules and
  Java packages.
\item
  \textbf{Deploying WARs (WAB Generator)} explains how Liferay's WAB
  Generator deploys WAR applications as OSGi Web Application Bundles
  (WABs).
\item
  \textbf{Gogo Shell} enables you to examine components, debug issues,
  and manage deployments.
\end{itemize}

Start with understanding how WAR and OSGi JAR project structures are
used in development.

\chapter{Configuring Dependencies}\label{configuring-dependencies}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Liferay DXP's modular environment lets modules provide and consume
capabilities via Java packages. To leverage packages from other modules
or traditional libraries in your project, you must configure them as
dependencies. Here you'll learn how to find artifacts (modules or
libraries) and configure dependencies on them.

\begin{itemize}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{Finding
  Artifacts} explains how to use the Application Manager, Gogo Shell,
  and Liferay DXP reference documentation to find artifacts deployed on
  Liferay DXP and available in repositories.
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/specifying-dependencies}{Specifying
  Dependencies} demonstrates specifying artifacts to Maven and Gradle
  build frameworks. It shows you how to determine whether Liferay DXP
  already exports packages from an artifact and how to configure such
  artifacts as compile-time dependencies.
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Resolving
  Third-Party Library Package Dependencies} provides a workflow for
  using packages that are only available in traditional library JARs
  (JARs that aren't OSGi modules). It involves minimizing transitive
  dependencies so you can resolve dependencies quicker and prevent
  bloating your project with unnecessary JARs.
\end{itemize}

Your first step is to find the artifacts you need.

\chapter{Finding Artifacts}\label{finding-artifacts}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Using external artifacts in your project requires configuring their
dependencies. To do this, look up the artifact's attributes and plug
them into dependency entries for your build system (either
\href{https://gradle.org/}{Gradle} or
\href{https://maven.apache.org/}{Maven}). Your build system downloads
the dependency artifacts your project needs to compile successfully.

Before specifying an artifact as a dependency, you must first find its
attributes. Artifacts have these attributes:

\begin{itemize}
\tightlist
\item
  \emph{Group ID}: Authoring organization
\item
  \emph{Artifact ID}: Name/identifier
\item
  \emph{Version}: Release number
\end{itemize}

Here you'll learn how to find artifact attributes to specify artifact
dependencies.

\section{Finding Core Artifact
Attributes}\label{finding-core-artifact-attributes}

Each Liferay artifact is a JAR file whose \texttt{META-INF/MANIFEST.MF}
file specifies OSGi bundle metadata the artifact's attributes. For
example, these two OSGi headers specify the artifact ID and version:

\begin{verbatim}
Bundle-SymbolicName:  [artifact ID]
Bundle-Version: [version]
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} Artifacts in Liferay DXP fix packs override Liferay
DXP installation artifacts. Subfolders of a fix pack ZIP file's
\texttt{binaries} folder hold the artifacts. If an installed fix pack
provides an artifact you depend \textbar{} on, specify the version of
that fix pack artifact in your dependency.

\noindent\hrulefill

This table lists each core Liferay DXP artifact's group ID and artifact
ID and where to find the artifact's manifest, which lists the artifact
version:

\emph{Core Liferay DXP Artifacts}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2364}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.2909}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1636}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1818}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 8\tabcolsep) * \real{0.1273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
File
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Group ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Version
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Origin
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portal-kernel.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
portal.kernel} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP, Liferay DXP installation, or Liferay DXP dependencies
ZIP \\
\texttt{portal-impl.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
portal.impl} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-bridges.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
util.bridges} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-java.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
util.java} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-slf4j.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
util.slf4j} & (see JAR's \texttt{MANIFEST.MF}) & fix
pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{util-taglibs.jar} & \texttt{com.liferay.portal} &
\texttt{com.liferay.\ 
util.taglib} & (see JAR's \texttt{MANIFEST.MF}) &
fix pack ZIP or Liferay DXP \texttt{.war} \\
\texttt{com.liferay.*} JAR files & \texttt{com.liferay} & (see JAR's
\texttt{MANIFEST.MF}) & (see JAR's \texttt{MANIFEST.MF}) & fix pack ZIP,
Liferay DXP installation, Liferay DXP dependencies ZIP, or the OSGi
ZIP \\
\end{longtable}

Next, you'll learn how to find Liferay DXP app and independent module
artifact attributes.

\section{Finding Liferay App and Independent
Artifacts}\label{finding-liferay-app-and-independent-artifacts}

Independent modules and Liferay DXP app modules aren't part of the
Liferay DXP core. You must still, however, find their artifact
attributes if you depend on them. The resources below provide the
artifact details for Liferay DXP's apps and independent modules:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.6250}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Resource
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Artifact Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\hyperref[app-manager]{App Manager} & Deployed modules \\
\hyperref[reference-docs]{Reference Docs} & Liferay DXP modules (per
release) \\
\hyperref[maven-central]{Maven Central} & All artifact types: Liferay
DXP and third party, module and non-module \\
\end{longtable}

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important}: \texttt{com.liferay} is the group ID for all of
Liferay's apps and independent modules.

\noindent\hrulefill

The App Manager is the best source for information on deployed modules.
You'll learn about it next.

\section{App Manager}\label{app-manager}

\href{/docs/7-2/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{The
App Manager} knows what's deployed on your Liferay instance. Use it to
find deployed module attributes.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Liferay DXP, navigate to \emph{Control Panel} → \emph{Apps} →
  \emph{App Manager}.
\item
  Search for the module by its display name, symbolic name, or related
  keywords. You can also browse for the module in its app. Whether
  browsing or searching, the App Manager shows the module's artifact ID
  and version number.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/configuring-dependencies-search-app-manager-for-module.png}
\caption{You can inspect deployed module artifact IDs and version
numbers.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/configuring-dependencies-indep-modules-in-app-manager.png}
\caption{The App Manager aggregates Liferay and independent modules.}
\end{figure}

If you don't know a deployed module's group ID, use the
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell} to find it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the Gogo Shell portlet in the Control Panel →
  \emph{Configuration} → \emph{Gogo Shell}. Enter commands in the Felix
  Gogo Shell command prompt.
\item
  Search for the module by its display name (e.g.,
  \texttt{Liferay\ Blogs\ API}) or a keyword. In the results, note the
  module's number. You can use it in the next step. For example, Gogo
  command results in the figure below show the Liferay Blogs API module
  number.

  \begin{figure}
  \centering
  \includegraphics{./images/configuring-deps-gogo-grep-for-module.png}
  \caption{Results from this Gogo command show that the module's number
  is \texttt{1173}.}
  \end{figure}
\item
  List the module's manifest headers by passing the module number to the
  \texttt{headers} command. In the results, note the
  \texttt{Bundle-Vendor} value: you'll match it with an artifact group
  in a later step:

  \begin{figure}
  \centering
  \includegraphics{./images/configuring-deps-gogo-module-info.png}
  \caption{Results from running the \texttt{headers} command show the
  module's bundle vendor and bundle version.}
  \end{figure}
\item
  On \href{https://search.maven.org/}{Maven Central} or
  \href{https://mvnrepository.com}{MVNRepository}, search for the module
  by its artifact ID.
\item
  Determine the group ID by matching the \texttt{Bundle-Vendor} value
  from step 3 with a group listed that provides the artifact.
\end{enumerate}

Next, Liferay DXP's reference documentation provides Liferay DXP app
artifact attributes.

\section{Reference Docs}\label{reference-docs}

Liferay DXP's app Javadoc lists each app module's artifact ID, version
number, and display name. This is the best place to look up Liferay DXP
app modules that aren't yet deployed to your Liferay DXP instance.

\noindent\hrulefill

\textbf{Note:} To find artifact information on a Core Liferay DXP
artifact, refer to the previous section \emph{Finding Core Liferay DXP
Artifact Attributes}.

\noindent\hrulefill

Follow these steps to find a Liferay DXP app module's attributes in the
Javadoc:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to Javadoc for an app module class. If you don't have a link
  to the class's Javadoc, find it by browsing
  {[}https://docs.liferay.com/dxp/apps{]}(
\item
  Copy the class's package name.
\item
  Navigate to the \emph{Overview} page.
\item
  On the \emph{Overview} page, search for the package name you copied in
  step 2.
\end{enumerate}

The heading above the package name shows the module's artifact ID,
version number, and display name. Remember, the group ID for all app
modules is \texttt{com.liferay}.

\begin{figure}
\centering
\includegraphics{./images/intro-configuring-dependencies-module-info-in-javadoc-overview.png}
\caption{Liferay DXP app Javadoc overviews list each app module's
display name, followed by its group ID, artifact ID, and version number
in a colon-separated string. It's a Gradle artifact syntax.}
\end{figure}

\noindent\hrulefill

\textbf{Note}: Module version numbers aren't currently included in any
tag library reference docs.

\noindent\hrulefill

Next, you'll learn how to look up artifacts on MVNRepository and Maven
Central.

\section{Maven Central}\label{maven-central}

Most artifacts, regardless of type or origin, are on
\href{https://mvnrepository.com/}{MVNRepository} and
\href{https://search.maven.org/}{Maven Central}. These sites can help
you find artifacts based on class packages. It's common to include an
artifact's ID in the start of an artifact's package names. For example,
if you depend on the class
\texttt{org.osgi.service.component.annotations.Component}, search for
the package name \texttt{org.osgi.service.component.annotations} on one
of the Maven sites.

\noindent\hrulefill

\textbf{Note:} Make sure to follow the instructions listed earlier to
determine the version of Liferay artifacts you need.

\noindent\hrulefill

Now that you know the artifact's attributes, you can configure a
dependency on it.

\section{Related Topics}\label{related-topics}

\href{/docs/7-2/customization/-/knowledge_base/c/specifying-dependencies}{Specifying
Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{Importing
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/exporting-packages}{Exporting
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Deploying
WARs (WAB Generator)}

\chapter{Specifying Dependencies}\label{specifying-dependencies}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Compiling your project and deploying it to Liferay DXP requires
satisfying its dependencies on external artifacts. After
\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{finding
the attributes of an artifact}, set a dependency for it in your build
file. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Determine whether Liferay DXP provides the Java packages you use from
  the artifact. These files list the packages Liferay DXP exports:

  \begin{itemize}
  \item
    \texttt{modules/core/portal-bootstrap/system.packages.extra.bnd}
    file in the
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/core/portal-bootstrap/system.packages.extra.bnd}{GitHub
    repository}. It lists exported packages on separate lines, making
    them easy to read.
  \item
    \texttt{META-INF/system.packages.extra.mf} file in
    \texttt{{[}LIFERAY\_HOME{]}/osgi/core/com.liferay.portal.bootstrap.jar}.
    The file is available in Liferay DXP bundles. It lists exported
    packages in a paragraph wrapped at 70 columns--they're harder to
    read here than in the \texttt{system.packages.extra.bnd} file.
  \end{itemize}
\item
  If Liferay DXP exports all the packages you use from the artifact,
  specify the artifact as a compile-only dependency. This prevents your
  build framework from bundling the artifact with your project. Here's
  how to make the dependency compile-only:

  \textbf{Gradle:} Add the \texttt{compileOnly} directive to the
  dependency

  \textbf{Maven:} Add the
  \texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}
  element to the dependency.
\item
  Add a dependency entry for the artifact. Here's the artifact
  terminology for the Gradle and Maven build frameworks:
\end{enumerate}

\emph{Artifact Terminology}

\noindent\hrulefill

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Framework & Group ID & Artifact ID & Version \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Gradle & \texttt{group} & \texttt{name} & \texttt{version} \\
Maven & \texttt{groupId} & \texttt{artifactId} & \texttt{version} \\
\end{longtable}

\noindent\hrulefill

Here is an example dependency on Liferay's Journal API module for
Gradle, and Maven:

\emph{Gradle (\texttt{build.gradle} entry):}

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.journal.api", version: "1.0.1"
    ...
}
\end{verbatim}

\emph{Maven (\texttt{pom.xml} entry):}

\begin{verbatim}
<dependency>
    <groupId>com.liferay</groupId>
    <artifactId>com.liferay.journal.api</artifactId>
    <version>1.0.1</version>
    <scope>provided</scope>
</dependency>
\end{verbatim}

\noindent\hrulefill

\textbf{Important:}
\href{/docs/7-2/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP exports many third-party packages}. Deploy your module to check if
Liferay DXP or another module in your Liferay instance's OSGi runtime
framework provides the package you need. If it's provided already,
specify the corresponding dependency as being ``provided''. Here's how
to specify a provided dependency:

Maven:
\texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}

Gradle: \texttt{providedCompile}

Don't deploy a provided package's JAR again or embed the JAR in your
project. Exporting the same package from different JARs leads to ``split
package'' issues, whose side affects differ from case to case. If the
package is in a third-party library (not an OSGi module), refer to
{[}Resolving Third

\noindent\hrulefill Party Library
Dependencies{]}(/docs/7-2/customization/-/knowledge\_base/c/adding-third-party-libraries-to-a-module).

\noindent\hrulefill

If you're developing a WAR that requires a different version of a
third-party package that
\href{/docs/7-2/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, follow the instructions
for
\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{adding
a third-party library (not an OSGi module)}.

\noindent\hrulefill

Nice! You know how to specify artifact dependencies. Now that's a skill
you can depend on!

\section{Related Topics}\label{related-topics-1}

\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{Finding
Artifacts}

\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{Importing
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/exporting-packages}{Exporting
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Deploying
WARs (WAB Generator)}

\chapter{Resolving Third Party Library Package
Dependencies}\label{resolving-third-party-library-package-dependencies}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Liferay's OSGi framework lets you build applications composed of
multiple OSGi bundles (modules). For the framework to assemble the
modules into a working system, the modules must resolve their Java
package dependencies. In a perfect world, every Java library would be an
OSGi module, but many libraries aren't. So how do you resolve the
packages your project needs from non-OSGi third party libraries?

Here is the main workflow for resolving third party Java library
packages:

\textbf{Option 1 - Find an OSGi module of the library}: Projects, such
as \href{https://www.eclipse.org/orbit/}{Eclipse Orbit} and
\href{https://servicemix.apache.org/developers/source/bundles-source.html}{ServiceMix
Bundles}, convert hundreds of traditional Java libraries to OSGi
modules. Their artifacts are available at these locations:

\begin{itemize}
\tightlist
\item
  \href{https://download.eclipse.org/tools/orbit/downloads/}{Eclipse
  Orbit downloads (select a build)}
\item
  \href{https://mvnrepository.com/artifact/org.apache.servicemix.bundles}{ServiceMix
  Bundles}
\end{itemize}

Deploying the module to Liferay's OSGi framework lets you share it on
the system. If you find a module for the library you need,
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy}
it. Then
\href{/docs/7-2/customization/-/knowledge_base/c/specifying-dependencies}{add
a compile-only dependency} for it in your project. When you deploy your
project, the OSGi framework wires the dependency module to your
project's module or web application bundle (WAB). If you don't find an
OSGi module based on the Java library, follow Option 2.

\noindent\hrulefill

\textbf{Tip:} Refrain from embedding library JARs that provide the same
\href{/docs/7-2/reference/-/knowledge_base/r/third-party-packages-portal-exports}{packages
that Liferay DXP or existing modules provide already}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} If you're developing a WAR that requires a different
version of a third-party package that
\href{/docs/7-2/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Liferay
DXP or another module exports}, specify that package in your
\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{\texttt{Import-Package:}
list}. If the package provider is an OSGi module, publish its exported
packages by deploying that module. Otherwise, rename the third-party
library (not an OSGi module) differently from the
\href{/docs/7-2/customization/-/knowledge_base/c/understanding-excluded-jars}{JAR
that the WAB generator excludes} and embed the JAR in your project.

\noindent\hrulefill

\textbf{Option 2 - Resolve the Java packages privately in your project}:
Copy \emph{required packages} only from libraries into your project, if
you can or embed \emph{libraries} wholesale, if you must. The rest of
this article shows you how to do these things.

\noindent\hrulefill

\textbf{Note:} Features for manipulating library packages are only
available to module projects that use bnd and the
\texttt{com.liferay.plugin} plugin, such as
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} modules. WAR projects must embed libraries wholesale into
their classpath.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: Liferay's Gradle plugin \texttt{com.liferay.plugin}
automates several third party library configuration steps. The plugin is
automatically applied to
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} Gradle module projects created using
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP} or
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Liferay Blade
CLI}.

To leverage the \texttt{com.liferay.plugin} plugin outside of Liferay
Workspace, add code like the listing below to your Gradle project and
update the version of the \texttt{com.liferay.gradle.plugins} artifact
to the latest version found in the repository:

\begin{verbatim}
 buildscript {
     dependencies {
         classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "4.0.4"
     }

     repositories {
         maven {
             url "https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/"
         }
     }
 }

 apply plugin: "com.liferay.plugin"
\end{verbatim}

If you use Gradle without the \texttt{com.liferay.plugin} plugin, you
must \hyperref[embedding-libraries-using-gradle]{embed the third party
libraries wholesale}.

\noindent\hrulefill

The recommended package resolution workflow is next.

\section{Library Package Resolution
Workflow}\label{library-package-resolution-workflow}

When you depend on a library JAR, much of the time you only need parts
of it. Explicitly specifying only the Java packages you need makes your
module more modular. This also keeps other modules that depend on your
module from incorporating unneeded packages.

Here's a configuration workflow for module projects that minimizes
dependencies and Java package imports:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the library as a compile-only dependency (e.g.,
  \texttt{compileOnly} in Gradle,
  \texttt{\textless{}scope\textgreater{}provided\textless{}/scope\textgreater{}}
  in Maven).
\item
  Copy only the library packages you need by specifying them in a
  conditional package instruction (\texttt{Conditional-Package}) in your
  \texttt{bnd.bnd} file. Here are some examples:

  \texttt{Conditional-Package:\ foo.common*} adds packages your module
  uses such as \texttt{foo.common}, \texttt{foo.common-messages},
  \texttt{foo.common-web} to your module's class path.

  \texttt{Conditional-Package:\ foo.bar.*} adds packages your module
  uses such as \texttt{foo.bar} and all its sub-packages (e.g.,
  \texttt{foo.bar.baz}, \texttt{foo.bar.biz}, etc.) to your module's
  class path.

  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your project}. If a class your module needs or class its dependencies
  need isn't found, go back to main workflow \textbf{Step 1 - Find an
  OSGi module version of the library} to resolve it.

  \textbf{Important}: Resolving packages by using compile-only
  dependencies and conditional package instructions assures you use only
  the packages you need and avoids unnecessary transitive dependencies.
  It's recommended to use the steps up to this point, as much as
  possible, to resolve required packages.
\item
  If a library package you depend on requires non-class files (e.g.,
  DLLs, descriptors) from the library, then you might need to
  \hyperref[embedding-libraries-in-a-project]{embed the library
  wholesale in your module}. This adds the entire library to your
  module's classpath.
\end{enumerate}

Next you'll learn how to embed libraries in your module project.

\section{Embedding Libraries in a
Project}\label{embedding-libraries-in-a-project}

You can use Gradle or Maven to embed libraries in your project. Below
are examples for adding \href{https://shiro.apache.org}{Apache Shiro}
using both build utilities.

\section{Embedding Libraries Using
Gradle}\label{embedding-libraries-using-gradle}

Open your module's \texttt{build.gradle} file and add the library as a
dependency in the \texttt{compileInclude} configuration:

\begin{verbatim}
dependencies {
    compileInclude group: 'org.apache.shiro', name: 'shiro-core', version: '1.1.0'
}
\end{verbatim}

The \texttt{com.liferay.plugin} plugin's \texttt{compileInclude}
configuration is transitive. The \texttt{compileInclude} configuration
embeds the artifact and all its dependencies in a \texttt{lib} folder in
the module's JAR. Also, it adds the artifact JARs to the module's
\texttt{Bundle-ClassPath} manifest header.

\textbf{Note}: The \texttt{compileInclude} configuration does not
download transitive
\href{https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html}{optional
dependencies}. If your module requires such artifacts, add them as you
would another third party library.

\textbf{Note:} If the library you've added as a dependency in your
\texttt{build.gradle} file has transitive dependencies, you can
reference them by name in an \texttt{-includeresource:} instruction
without having to add them explicitly to the dependency list. See how
it's used in the Maven section next.

\section{Embedding a Library Using
Maven}\label{embedding-a-library-using-maven}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your project's \texttt{pom.xml} file and add the library as a
  dependency in the \texttt{provided} scope:

\begin{verbatim}
<dependency>
  <groupId>org.apache.shiro</groupId>
  <artifactId>shiro-core</artifactId>
  <version>1.1.0</version>
  <scope>provided</scope>
</dependency>
\end{verbatim}
\item
  Open your module's \texttt{bnd.bnd} file and add the library to an
  \texttt{-includeresource} instruction:

\begin{verbatim}
-includeresource: META-INF/lib/shiro-core.jar=shiro-core-[0-9]*.jar;lib:=true
\end{verbatim}

  This instruction adds the \texttt{shiro-core-{[}version{]}.jar} file
  as an included resource in the module's \texttt{META-INF/lib} folder.
  The \texttt{META-INF/lib/shiro-core.jar} is your module's embedded
  library. The expression \texttt{{[}0-9{]}*} helps the build tool match
  the library version to make available on the module's class path. The
  \texttt{lib:=true} directive adds the embedded JAR to the module's
  class path via the \texttt{Bundle-Classpath} manifest header.
\end{enumerate}

Lastly, if after embedding a library you get unresolved imports when
trying to deploy to Liferay, you might need to blacklist some imports:

\begin{verbatim}
Import-Package:\
    !foo.bar.baz,\
    *
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Congratulations! Resolving all of your module's package dependencies,
especially those from traditional Java libraries, is a quite an
accomplishment.

\section{Related Topics}\label{related-topics-2}

\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{Importing
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/exporting-packages}{Exporting
Packages}

\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Creating
a Project}

\chapter{Understanding Excluded JARs}\label{understanding-excluded-jars}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{Portal
property \texttt{module.framework.web.generator.excluded.paths}}
declares JARs that are stripped from all Liferay DXP
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{generated
WABs}. These JARs are excluded from web application bundles (WABs)
because Liferay DXP provides them already. All JARs listed for this
property are excluded from a WAB, even if the WAB lists the JAR in a
\texttt{portal-dependency-jars} property in its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/liferay-plugin-package_7_2_0.properties.html}{\texttt{liferay-plugin-package.properties}}
file.

If your WAR requires different versions of the packages Liferay DXP
exports, you must include them in JARs named differently from the ones
\texttt{module.framework.web.generator.excluded.paths} excludes.

For example, Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/core/portal-bootstrap/system.packages.extra.bnd}{\texttt{system.packages.extra}}
module exports Spring Framework version 4.1.9 packages:

\begin{verbatim}
Export-Package:\
    ...
    org.springframework.*;version='4.1.9',\
    ...
\end{verbatim}

Liferay DXP uses the
\texttt{module.framework.web.generator.excluded.paths} portal property
to exclude their JARs.

\begin{verbatim}
module.framework.web.generator.excluded.paths=\
    ...
    WEB-INF/lib/spring-aop.jar,\
    WEB-INF/lib/spring-aspects.jar,\
    WEB-INF/lib/spring-beans.jar,\
    WEB-INF/lib/spring-context.jar,\
    WEB-INF/lib/spring-context-support.jar,\
    WEB-INF/lib/spring-core.jar,\
    WEB-INF/lib/spring-expression.jar,\
    WEB-INF/lib/spring-jdbc.jar,\
    WEB-INF/lib/spring-jms.jar,\
    WEB-INF/lib/spring-orm.jar,\
    WEB-INF/lib/spring-oxm.jar,\
    WEB-INF/lib/spring-tx.jar,\
    WEB-INF/lib/spring-web.jar,\
    WEB-INF/lib/spring-webmvc.jar,\
    WEB-INF/lib/spring-webmvc-portlet.jar,\
    ...
\end{verbatim}

To use a different Spring Framework version in your WAR, you must name
the corresponding Spring Framework JARs differently from the
glob-patterned JARs
\texttt{module.framework.web.generator.excluded.paths} lists.

For example, to use Spring Framework version 3.0.7's Spring AOP JAR,
include it in your plugin's \texttt{WEB-INF/lib} but name it something
other than \texttt{spring-aop.jar}. Adding the version to the JAR name
(i.e., \texttt{spring-aop-3.0.7.RELEASE.jar}) differentiates it from the
excluded JAR and prevents it from being stripped from the WAB (the
bundled WAR).

\section{Related Topics}\label{related-topics-3}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Deploying
WARs (WAB Generator)}

\chapter{Using the Felix Gogo Shell}\label{using-the-felix-gogo-shell}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

The Gogo shell provides a way to interact with Liferay DXP's module
framework. You can

\begin{itemize}
\tightlist
\item
  dynamically install/uninstall bundles
\item
  examine package dependencies
\item
  examine extension points
\item
  list service references
\item
  etc.
\end{itemize}

There are two ways you can access the Gogo shell.

The recommended way to access the Gogo shell for a production
environment is through the Control Panel. Accessing it there is the most
secure way to use the Gogo shell. You can set permissions in your
Liferay DXP instance to only give certain people access to it. The Gogo
shell is extremely powerful and should only be given to trusted admins,
as you can manipulate the platform's core functionality. You can access
the Gogo shell in the Control Panel by navigating to
\emph{Configuration} → \emph{Gogo Shell}.

You can also interact with Liferay DXP's module framework via a local
telnet session. This is only recommended when you're developing your
Liferay DXP instance. This is not recommended for production
environments.

To open the Gogo shell via telnet, execute the following command:

\begin{verbatim}
telnet localhost 11311
\end{verbatim}

Running this command requires a local running instance of Liferay DXP
and your machine's telnet command line utilities enabled. You must also
have
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes\#enabling-developer-mode-manually}{Developer
Mode enabled}.

To disconnect the session, execute the \texttt{disconnect} command.
Avoid using the following commands, which stop the OSGi framework:

\begin{itemize}
\tightlist
\item
  \texttt{close}
\item
  \texttt{exit}
\item
  \texttt{shutdown}
\end{itemize}

If you have
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}
installed and the telnet capability enabled, you can run the Gogo shell
via Blade command too:

\begin{verbatim}
blade sh <gogoShellCommand>
\end{verbatim}

Here are some useful Gogo shell commands:

\texttt{b\ {[}BUNDLE\_ID{]}}: lists information about a specific bundle
including the bundle's symbolic name, bundle ID, data root, registered
(provided) and used services, imported and exported packages, and more

\texttt{diag\ {[}BUNDLE\_ID{]}}: lists information about why the
specified bundle is not working (e.g., unresolved dependencies, etc.)

\texttt{headers\ {[}BUNDLE\_ID{]}}: lists metadata about the bundle from
the bundle's \texttt{MANIFEST.MF} file

\texttt{help}: lists all the available Gogo shell commands. Notice that
each command has two parts to its name, separated by a colon. For
example, the full name of the \texttt{help} command is
\texttt{felix:help}. The first part is the command scope while the
second part is the command function. The scope allows commands with the
same name to be disambiguated. E.g., scope allows the
\texttt{felix:refresh} command to be distinguished from the
\texttt{equinox:refresh} command.

\texttt{help\ {[}COMMAND\_NAME{]}}: lists information about a specific
command including a description of the command, the scope of the
command, and information about any flags or parameters that can be
supplied when invoking the command.

\texttt{inspect\ capability\ service\ {[}BUNDLE\_ID{]}}: lists services
exposed by a bundle

\texttt{install\ {[}PATH\_TO\_JAR\_FILE{]}}: installs the specified
bundle into Liferay's module framework

\texttt{lb}: lists all of the bundles installed in Liferay's module
framework. Use the \texttt{-s} flag to list the bundles using the
bundles' symbolic names.

\texttt{packages\ {[}PACKAGE\_NAME{]}}: lists all of the named package's
dependencies

\texttt{scr:list}: lists all of the components registered in the module
framework (\emph{scr} stands for service component runtime)

\texttt{scr:info\ {[}COMPONENT\_NAME{]}}: lists information about a
specific component including the component's description, services,
properties, configuration, references, and more.

\texttt{services}: lists all of the services that have been registered
in Liferay's module framework

\texttt{start\ {[}BUNDLE\_ID{]}}: starts the specified bundle

\texttt{stop\ {[}BUNDLE\_ID{]}}: stops the specified bundle

\texttt{uninstall\ {[}BUNDLE\_ID{]}}: uninstalls the specified bundle
from Liferay's module framework. This does not remove the specified
bundle from Liferay's module framework; it's hidden from Gogo's
\texttt{lb} command, but is still present. Adding a new version of the
uninstalled bundle, therefore, will not reinstall it; it will update the
currently hidden uninstalled version. To remove a bundle from Liferay's
module framework permanently, manually delete it from the
\texttt{LIFERAY\_HOME/osgi} folder. For more information on the
\texttt{uninstall} command, see OSGi's
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Bundle.html\#uninstall()}{uninstall}
documentation.

For more information about the Gogo shell, visit
\href{http://felix.apache.org/documentation/subprojects/apache-felix-gogo.html}{Apache's
official documentation}.

\chapter{Importing Packages}\label{importing-packages}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Plugins often must use Java classes from packages outside of themselves.
Another OSGi bundle (a module or an OSGi Web Application Bundle) in the
OSGi framework must
\href{/docs/7-2/customization/-/knowledge_base/c/exporting-packages}{export}
a package for your plugin to import it.

When an OSGi bundle (bundle) is set up to import packages, the OSGi
framework finds other registered bundles that export the needed packages
and wires them to the importing bundle. At run time, the importing
bundle gets the class from the wired bundle that exports the class's
package.

For this to happen, a bundle's \texttt{META-INF/MANIFEST.MF} file must
specify the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
OSGi manifest header with a comma-separated list of the Java packages it
needs. For example, if a bundle needs classes from the
\texttt{javax.portlet} and \texttt{com.liferay.portal.kernel.util}
packages, it must specify them like so:

\begin{verbatim}
Import-Package: javax.portlet,com.liferay.portal.kernel.util,*
\end{verbatim}

The \texttt{*} character represents all packages that the module refers
to explicitly. Bnd detects the referenced packages.

Import packages must sometimes be specified manually, but not always.
Conveniently, Liferay DXP
\href{/docs/7-2/reference/-/knowledge_base/r/project-templates}{project
templates} and
\href{/docs/7-2/reference/-/knowledge_base/r/tooling}{tools}
automatically detect the packages a bundle uses and add them to the
package imports in the bundle's manifest. Here are the different package
import scenarios:

\begin{itemize}
\item
  \hyperref[automatic-package-import-generation]{Automatic Package
  Import Generation}
\item
  \hyperref[manually-adding-package-imports]{Manually Adding Package
  Imports}
\end{itemize}

Let's explore how package imports are specified in these scenarios.

\section{Automatic Package Import
Generation}\label{automatic-package-import-generation}

\href{/docs/7-2/reference/-/knowledge_base/r/project-templates}{Gradle
and Maven module projects} created using
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI},
\href{/docs/7-2/reference/-/knowledge_base/r/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP} use \href{http://bnd.bndtools.org/}{bnd}. On building
such a project's module JAR, bnd detects the packages the module uses
and generates a \texttt{META-INF/MANIFEST.MF} file whose
\texttt{Import-Package} header specifies the packages.

\noindent\hrulefill

\textbf{Note:} Liferay's Maven module archetypes use the
\texttt{bnd-maven-plugin}. Liferay's Gradle module project templates use
\href{https://github.com/TomDmitriev/gradle-bundle-plugin}{a third-party
Gradle plugin} to invoke bnd.

\noindent\hrulefill

For example, suppose you're developing a Liferay module using Maven or
Gradle. In most cases, you specify your module's dependencies in your
\texttt{pom.xml} or \texttt{build.gradle} file. At build time, the Maven
or Gradle module plugin reads your \texttt{pom.xml} or
\texttt{build.gradle} file and bnd adds the required
\texttt{Import-Package} headers to your module JAR's
\texttt{META-INF/MANIFEST.MF}.

Here's an example dependencies section from a module's
\texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

And here's the \texttt{Import-Package} header that's generated in the
module JAR's \texttt{META-INF/MANIFEST.MF} file:

\begin{verbatim}
Import-Package: com.liferay.portal.kernel.portlet.bridges.mvc;version=
"[1.0,2)",com.liferay.portal.kernel.util;version="[7.0,8)",javax.nami
ng,javax.portlet;version="[2.0,3)",javax.servlet,javax.servlet.http,j
avax.sql
\end{verbatim}

Note that your build file need only specify artifact dependencies. bnd
examines your module's class path to determine which packages from those
artifacts contain classes your application uses and imports the
packages. The examination includes all classes found in the class
path--even those from embedded
\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{third
party library JARs}.

Regarding classes used by a plugin WAR,
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Liferay's
WAB Generator} detects their use in the WAR's JSPs, descriptor files,
and classes (in \texttt{WEB-INF/classes} and embedded JARs). The WAB
Generator searches the \texttt{web.xml}, \texttt{liferay-web.xml},
\texttt{portlet.xml}, \texttt{liferay-portlet.xml}, and
\texttt{liferay-hook.xml} descriptor files. It adds package imports for
classes that are neither found in the plugin's \texttt{WEB-INF/classes}
folder nor in its embedded JARs.

\noindent\hrulefill

\textbf{Note:} Packages for Java APIs, such as Java Portlet, aren't
semantically versioned but have Portable Java Contracts. Each API's
contract specifies the JSR it satisfies. Bundles that use these APIs
must specify requirements on the API contracts. The contract requirement
specifies your bundle's relationship with the imported API packages. If
the system you're running does \emph{not} provide the exact contract,
your bundle does not resolve. Resolving the missing package is better
than handling an incompatibility failure during execution.

\begin{itemize}
\item
  \textbf{Blade CLI and Liferay Dev Studio DXP module projects} specify
  Portable Java Contracts automatically! For example, if your Blade CLI
  or Liferay Dev Studio DXP module uses the Java Portlet API and you
  compile against the Java Portlet 2.0 artifact, a contract requirement
  for the package is added to your module's manifest.
\item
  \textbf{Module projects that use bnd but are not created using Blade
  CLI or Liferay Dev Studio DXP} must specify contracts in their
  \texttt{bnd.bnd} file. For example, here are contract instructions for
  Java Portlet and Java Servlet APIs:

\begin{verbatim}
-contract: JavaPortlet,JavaServlet
\end{verbatim}

  At build time, bnd adds the contract instructions to your module's
  manifest. It adds a requirement for the first version of the API found
  in your classpath and \emph{removes} version range information from
  \texttt{Import-Package} entries for corresponding API packages---the
  package version information isn't needed.
\item
  \textbf{Projects that don't use bnd} must specify contracts in their
  OSGi bundle manifest. For example, here's the specified contract for
  \texttt{JavaPortlet} 2.0, which goes in your
  \texttt{META-INF/MANIFEST.MF} file:

\begin{verbatim}
Import-Package: javax.portlet
Require-Capability: osgi.contract;filter:=(&(osgi.contract=JavaPortlet)(version=2.0))
\end{verbatim}
\end{itemize}

For Portable Java Contract details, see
\href{https://www.osgi.org/portable-java-contract-definitions/}{Portable
Java Contract Definitions}.

\noindent\hrulefill

\section{Manually Adding Package
Imports}\label{manually-adding-package-imports}

The WAB Generator and bnd don't add package imports for classes
referenced in these places:

\begin{itemize}
\tightlist
\item
  Unrecognized descriptor file
\item
  Custom or unrecognized descriptor element or attribute
\item
  Reflection code
\item
  Class loader code
\end{itemize}

In such cases, you must manually determine these packages and specify an
\texttt{Import-Package} OSGi header that includes these packages and the
packages that Bnd detects automatically. The \texttt{Import-Package}
header belongs in the location appropriate to your project type:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7273}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Project type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{Import-Package} header location
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Traditional Liferay plugin WAR &
\texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

\noindent\hrulefill

Here's an example of adding a package called
\texttt{com.liferay.docs.foo} to the list of referenced packages that
Bnd detects automatically:

\begin{verbatim}
Import-Package:\
    com.liferay.docs.foo,\
    *
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{WAB
Generator} refrains from adding WAR project embedded third-party JARs to
a WAB if
\href{/docs/7-2/customization/-/knowledge_base/c/understanding-excluded-jars}{Liferay
DXP already exports the JAR's packages}.

If your WAR requires a different version of a third-party package that
Liferay DXP exports, specify that package in your
\texttt{Import-Package:} list. Then if the package provider is an OSGi
module, publish its exported packages by deploying the module. If the
package provider is not an OSGi module, follow the instructions for
\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{adding
third-party libraries}.

\noindent\hrulefill

Please see the
\href{https://bnd.bndtools.org/heads/import_package.html}{\texttt{Import-Package}}
header documentation for more information.

Congratulations! Now you can import all kinds of packages for your
modules and plugins to use.

\section{Related Topics}\label{related-topics-4}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Deploying
WARs (WAB Generator)}

\href{/docs/7-2/reference/-/knowledge_base/r/project-templates}{Project
Templates}

\href{/docs/7-2/reference/-/knowledge_base/r/maven}{Liferay's Maven
Archetypes}

\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP}

\chapter{Exporting Packages}\label{exporting-packages}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

An OSGi bundle's Java packages are private by default. To expose a
package, you must explicitly export it. This way you share only the
classes you want to share. Exporting a package in your OSGi bundle
(bundle) manifest makes all the package's classes available for other
bundles to
\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{import}.

To export a package, add it to your module's or plugin's
\texttt{Export-Package} OSGi header. A header exporting
\texttt{com.liferay.petra.io} and \texttt{com.liferay.petra.io.unsync}
would look like this:

\begin{verbatim}
Export-Package:\
com.liferay.petra.io,\
com.liferay.petra.io.unsync
\end{verbatim}

The correct location for the header depends on your project's type:

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Project Type & \texttt{Export-Package} header location \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Module JAR (uses bnd) & \texttt{{[}project{]}/bnd.bnd} \\
Module JAR (doesn't use bnd) &
\texttt{{[}module\ JAR{]}/META-INF/MANIFEST.MF} \\
Plugin WAR & \texttt{WEB-INF/liferay-plugin-package.properties} \\
\end{longtable}

\noindent\hrulefill

Module projects created using
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI},
\href{/docs/7-2/reference/-/knowledge_base/r/maven}{Liferay's Maven
archetypes}, or
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP} use \href{http://bnd.bndtools.org/}{bnd}. On building
such a project's module JAR, bnd propagates the OSGi headers from the
project's \texttt{bnd.bnd} file to the JAR's
\texttt{META-INF/MANIFEST.MF}.

In module projects that don't use bnd, you must manually add package
exports to an \texttt{Export-Package} header in the module JAR's
\texttt{META-INF/MANIFEST.MF}.

In plugin WAR projects, you must add package exports to an
\texttt{Export-Package} header in the project's
\texttt{WEB-INF/liferay-plugin-package.properties}. On copying the WAR
into the \texttt{{[}Liferay\ Home{]}/deploy} folder, the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{WAB
Generator} propagates the OSGi headers from the WAR's
\texttt{liferay-plugin-package.properties} file to the
\texttt{META-INF/MANIFEST.MF} file in the generated Web Application
Bundle (WAB).

\noindent\hrulefill

\textbf{Note:} bnd makes a module's exported packages
\emph{substitutable}. That is, the OSGi framework can substitute your
module's exported package with a compatible package of the same name,
but potentially different version, that's exported from a different OSGi
bundle. bnd enables this for your module by automatically making your
module import every package it exports. In this way, your module can
work on its own, but can also work in conjunction with bundles that
provide a different (compatible) version, or even the same version, of
the package. A package from another bundle might provide better
``wiring'' opportunities with other bundles.
\href{http://blog.osgi.org/2007/04/importance-of-exporting-nd-importing.html}{Peter
Kriens' blog post} provides more details on how substitutable exports
works.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important:} Don't export the same package from different JARs.
Multiple exports of the same package leads to ``split package'' issues,
whose side affects differ from case to case.

\noindent\hrulefill

Now you can share your module's or plugin's terrific {[}EDITOR: or
terrible!{]} packages with other OSGi bundles!

\section{Related Topics}\label{related-topics-5}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Deploying
WARs (WAB Generator)}

\href{/docs/7-2/reference/-/knowledge_base/r/project-templates}{Project
Templates}

\href{/docs/7-2/reference/-/knowledge_base/r/maven}{Liferay's Maven
Archetypes}

\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP}

\href{/docs/7-2/customization/-/knowledge_base/c/semantic-versioning}{Semantic
Versioning}

\chapter{Semantic Versioning}\label{semantic-versioning}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

\href{https://semver.org}{Semantic Versioning} is a three tiered
versioning system that increments version numbers based on the type of
API change introduced to a releasable software component. It's a
standard way of communicating programmatic compatibility of a package or
module for dependent consumers and API implementations. If a package is
programmatically (i.e., semantically) incompatible with a project,
\href{http://bnd.bndtools.org}{bnd} (used when building
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Liferay
generated module projects}) fails that project's build immediately.

The semantic version format looks like this:

\begin{verbatim}
MAJOR.MINOR.MICRO
\end{verbatim}

Certain events force each tier to increment:

\begin{itemize}
\tightlist
\item
  \emph{MAJOR:} an incompatible, API-breaking change is made
\item
  \emph{MINOR:} a change that affects only providers of the API, or new
  backwards- compatible functionality is added
\item
  \emph{MICRO:} a backwards-compatible bug fix is made
\end{itemize}

For more details on semantic versioning, see the official
\href{https://semver.org/}{Semantic Versioning} site and
\href{http://www.osgi.org/wp-content/uploads/SemanticVersioning1.pdf}{OSGi
Alliance's Semantic Versioning} technical whitepaper.

All of Liferay DXP's modules use Semantic Versioning.

Following Semantic Versioning is especially important because Liferay
DXP is a modular platform containing hundreds of independent OSGi
modules. With many independent modules containing a slew of
dependencies, releasing new package versions can quickly become
terrifying. With this complex intertwined system of dependencies, you
must meticulously manage your own project's API versions to ensure
compatibility for those who leverage it. With Semantic Versioning's
straightforward system and the help of
\href{/docs/7-2/reference/-/knowledge_base/r/tooling}{Liferay tooling},
managing your module project's versions is easy.

\section{Baselining Your Project}\label{baselining-your-project}

Following Semantic Versioning manually seems deceptively easy. There's a
sad history of good-intentioned developers updating their projects'
semantic versions manually, only to find out later they made a mistake.
The truth is, it's hard to anticipate the ramifications of a simple
update. To avoid this, you can \emph{baseline} your project after it has
been updated. Baselining verifies that the Semantic Versioning rules are
obeyed by your project. This can catch many obvious API changes that are
not so obvious to humans. Care must always be taken, however, when
making any kind of code change because this tool is not smart enough to
identify compatibility changes not represented in the signatures of Java
classes or interfaces, or in API \emph{use} changes (e.g., assumptions
about method call order, or changes to input and/or output encoding).
Baseline, as the name implies, does give you a certain measure of
\emph{baseline} comfort that a large class of compatibility issues won't
sneak past you.

You can use Liferay's Baseline Gradle plugin to provide baselining
capabilities. Add it to your Gradle build configuration and execute the
following command:

\begin{verbatim}
./gradlew baseline
\end{verbatim}

See the
\href{/docs/7-2/reference/-/knowledge_base/r/baseline-gradle-plugin}{Baseline
Gradle Plugin} article for configuration details. This plugin is not
provided in
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} by default.

When you run the \texttt{baseline} command, the plugin baselines your
new module against the latest released non-snapshot module (i.e., the
baseline). That is, it compares the public exported API of your new
module with the baseline. If there are any changes, it uses the OSGi
Semantic Versioning rules to calculate the minimum new version. If your
new module has a lower version, errors are thrown.

With baselining, your project's Semantic Versioning is as accurate as
its API expresses.

\section{Managing Artifact and Dependency
Versions}\label{managing-artifact-and-dependency-versions}

There are two ways to track your project's artifact and dependency
versions with Semantic Versioning:

\begin{itemize}
\tightlist
\item
  Range of versions
\item
  Exact version (one-to-one)
\end{itemize}

You should track a range of versions if you intend to build your project
for multiple versions of Liferay DXP and maintain maximum compatibility.
In other words, if several versions of a package work for an app, you
can configure the app to use any of them. What's more, bnd automatically
determines the semantically compatible range of each package a module
depends on and records the range to the module's manifest.

For help with version range syntax, see the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{OSGi
Specifications}.

A version range for imported packages in an OSGi bundle's
\texttt{bnd.bnd} looks like this:

\begin{verbatim}
Import-Package: com.liferay.docs.test; version="[1.0.0,2.0.0)"
\end{verbatim}

Popular build tools also follow this syntax. In Gradle, a version range
for a dependency looks like this:

\begin{verbatim}
compile group: "com.liferay.portal", name: "com.liferay.portal.test", version: "[1.0.0,2.0.0)"
\end{verbatim}

In Maven, it looks like this:

\begin{verbatim}
<groupId>com.liferay.portal</groupId>
<artifactId>com.liferay.portal.test</artifactId>
<version>[1.0.0,2.0.0)</version>
\end{verbatim}

Specifying the latest release version can also be considered a range of
versions with no upper limit. For example, in Gradle, it's specified as
\texttt{version:\ "latest.release"}. This can be done in Maven 2.x with
the usage of the version marker \texttt{RELEASE}. This is not possible
if you're using Maven 3.x. See \href{https://gradle.org/docs}{Gradle}
and \href{http://maven.apache.org/guides/}{Maven}'s respective docs for
more information.

Tracking a range of versions comes with a price. It's hard to reproduce
old builds when you're debugging an issue. It also comes with the risk
of differing behaviors depending on the version used. Also, relying on
the latest release could break compatibility with your project if a
major change is introduced. You should proceed with caution when
specifying a range of versions and ensure your project is tested on all
included versions.

Tracking a dependency's exact version is much safer, but is less
flexible. This might limit you to a specific version of Liferay DXP. You
would also be locked in to APIs that only exist for that specific
version. This means your module is much easier to test and has less
chance for unexpected failures.

\noindent\hrulefill

\textbf{Note:} When specifying package versions in your \texttt{bnd.bnd}
file, exact versions are typically specified like this:
\texttt{version="1.1.2"}. However, this syntax is technically a range;
it is interpreted as {[}1.1.2, ∞). Therefore, if a higher version of the
package is available, it's used instead of the version you specified.
For these cases, it may be better to specify a version range for
compatible versions that have been tested. If you want to specify a true
exact match, the syntax is like this: \texttt{{[}1.1.2{]}}. See the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i3189032}{Version
Range} section in the OSGi specifications for more info.

Gradle and Maven use exact versions when only one version is specified.

\noindent\hrulefill

You now know the pros and cons for tracking dependencies as a range and
as an exact match.

\section{Related Topics}\label{related-topics-6}

\href{/docs/7-2/customization/-/knowledge_base/c/importing-packages}{Importing
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/exporting-packages}{Exporting
Packages}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\chapter{Deploying WARs (WAB
Generator)}\label{deploying-wars-wab-generator}

You can create applications for Liferay DXP as Java EE-style Web
Application ARchive (WAR) artifacts or as Java ARchive (JAR) OSGi bundle
artifacts. Bean Portlets, PortletMVC4Spring Portlets, and JSF Portlets
must be packaged as WAR artifacts because their frameworks are designed
for Java EE. Therefore, they expect a WAR layout and require Java EE
resources such as the \texttt{WEB-INF/web.xml} descriptor.

Liferay provides a way for these WAR-styled plugins to be deployed and
treated like OSGi modules by Liferay's OSGi runtime. They can be
converted to \emph{WABs}.

Liferay DXP supports the OSGi Web Application Bundle (WAB) standard for
deployment of Java EE style WARs. Simply put, a WAB is an archive that
has a WAR layout and contains a \texttt{META-INF/MANIFEST.MF} file with
the \texttt{Bundle-SymbolicName} OSGi directive. A WAB is an OSGi
bundle. Although the project source has a WAR layout, the artifact
filename may end with either the \texttt{.jar} or \texttt{.war}
extension.

Liferay only supports the use of WABs that have been auto-generated by
the WAB Generator. The WAB Generator transforms a traditional WAR-style
plugin into a WAB during deployment. So what exactly does the WAB
Generator do to a WAR file to transform it into a WAB?

The WAB Generator detects packages referenced in the plugin WAR's JSPs,
descriptor files, and classes (in \texttt{WEB-INF/classes} and embedded
JARs). The descriptor files include \texttt{web.xml},
\texttt{liferay-web.xml}, \texttt{portlet.xml},
\texttt{liferay-portlet.xml}, and \texttt{liferay-hook.xml}. The WAB
Generator verifies whether the detected packages are in the plugin's
\texttt{WEB-INF/classes} folder or in an embedded JAR in the
\texttt{WEB-INF/lib} folder. Packages that aren't found in either
location are added to an \texttt{Import-Package} OSGi header in the
WAB's \texttt{META-INF/MANIFEST.MF} file.

To import a package that is only referenced in the following types of
locations, you must add an \texttt{Import-Package} OSGi header to the
plugin's \texttt{WEB-INF/liferay-plugin-package.properties} file and add
the package to that header's list of values.

\begin{itemize}
\tightlist
\item
  Unrecognized descriptor file
\item
  Custom or unrecognized descriptor element or attribute
\item
  Reflection code
\item
  Class loader code
\end{itemize}

\section{WAR versus WAB Structure}\label{war-versus-wab-structure}

The WAB folder structure and WAR folder structure differ. Consider the
following folder structure of a WAR-style portlet.

\textbf{WAR}

\begin{itemize}
\tightlist
\item
  \texttt{my-war-portlet}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}
      \item
        \texttt{webapp}

        \begin{itemize}
        \tightlist
        \item
          \texttt{WEB-INF}

          \begin{itemize}
          \tightlist
          \item
            \texttt{classes}
          \item
            \texttt{lib}
          \item
            \texttt{resources}
          \item
            \texttt{views}
          \item
            \texttt{liferay-display.xml}
          \item
            \texttt{liferay-plugin-package.properties}
          \item
            \texttt{liferay-portlet.xml}
          \item
            \texttt{portlet.xml}
          \item
            \texttt{web.xml}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

When a WAR-style portlet is deployed to Liferay DXP and processed by the
WAB Generator, the portlet's folder structure is transformed.

\textbf{WAB}

\begin{itemize}
\tightlist
\item
  \texttt{my-war-portlet-that-is-now-a-wab}

  \begin{itemize}
  \tightlist
  \item
    \texttt{META-INF}

    \begin{itemize}
    \tightlist
    \item
      \texttt{MANIFEST.MF}
    \end{itemize}
  \item
    \texttt{WEB-INF}

    \begin{itemize}
    \tightlist
    \item
      \texttt{classes}
    \item
      \texttt{lib}
    \item
      \texttt{resources}
    \item
      \texttt{views}
    \item
      \texttt{liferay-display.xml}
    \item
      \texttt{liferay-plugin-package.properties}
    \item
      \texttt{liferay-portlet.xml}
    \item
      \texttt{portlet.xml}
    \item
      \texttt{web.xml}
    \end{itemize}
  \end{itemize}
\end{itemize}

The major difference is the addition of the
\texttt{META-INF/MANIFEST.MF} file. The WAB Generator automatically
generates an OSGi-ready manifest file. If you want to affect the content
of the manifest file, you can place bnd directives and OSGi headers
directly into your plugin's \texttt{liferay-plugin-package.properties}
file.

\noindent\hrulefill

\textbf{Note:} Adding a \texttt{bnd.bnd} file or a build-time plugin
(e.g., \texttt{bnd-maven-plugin}) to your WAR plugin is pointless,
because the generated WAB cannot use them.

\noindent\hrulefill

\section{Deploying a WAR}\label{deploying-a-war}

To deploy a WAB based on your WAR plugin, copy your WAR plugin to your
Liferay DXP instance's \texttt{deploy/} folder in your
\href{/docs/7-2/deploy/-/knowledge_base/d/liferay-home}{\texttt{{[}Liferay\ Home{]}}}.

\section{Saving a Copy of the WAB}\label{saving-a-copy-of-the-wab}

Optionally, save the WAB to a local folder. This gives you the
opportunity to inspect the generated WAB. To store generated WABs, add
the following portal properties to a
\texttt{{[}Liferay\ Home{]}/portal-ext.properties} file. Then restart
Liferay DXP:

\begin{verbatim}
module.framework.web.generator.generated.wabs.store=true
module.framework.web.generator.generated.wabs.store.dir=${module.framework.base.dir}/wabs
\end{verbatim}

These properties instruct the WAB generator to store generated WABs in
your Liferay instance's \texttt{osgi/wabs/} folder. The generated WABs
have the same structure as the example WAB structure listed above. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Module\%20Framework\%20Web\%20Application\%20Bundles}{Module
Framework Web Application Bundles} properties section explains more
details.

Awesome! You have deployed your WAR plugin as a WAB and you know how to
save a copy of the WAB to examine it!

\section{Related Topics}\label{related-topics-7}

\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Creating
a Project}

\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploying
a Project}

\href{/docs/7-2/appdev/-/knowledge_base/a/web-front-ends}{Developing Web
Front-Ends}

\chapter{Architecture}\label{architecture}

Liferay DXP architecture comprises these parts:

\textbf{Core:} Bootstraps Liferay DXP and its frameworks. The Core
provides a runtime environment for managing services, UI components, and
customizations.

\textbf{Services:} Liferay and custom functionality is exposed via Java
APIs and web APIs.

\textbf{UI:} The optional web application UI for adding portals, sites,
pages, widgets, and content.

You can use the Liferay DXP UI and services together or focus solely on
using services via
\href{/docs/7-2/frameworks/-/knowledge_base/f/headless-rest-apis}{REST
web APIs}.

\begin{figure}
\centering
\includegraphics{./images/architecture-options.png}
\caption{Liferay DXP portals and Sites contain content and widgets.
Liferay DXP can also be used ``headless''---without the UI.}
\end{figure}

The architecture satisfies these requirements:

\begin{itemize}
\item
  Supports using common development technologies
\item
  Leverages development standards
\item
  Facilitates swapping components
\item
  Starts fast and performs well
\item
  Its runtime is easy to configure and inspect
\end{itemize}

The Core supports UI and service deployments and orchestrates wiring
them together.

\section{Core}\label{core}

Liferay DXP is a web application that runs on your application server.
The Core bootstraps the application and
\href{/docs/7-2/frameworks/-/knowledge_base/f/frameworks}{Liferay's
built-in frameworks}.

There are frameworks for these things and more:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media}{Adaptive
  Media}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configurable-applications}{Application
  Configuration}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/application-security}{Application
  Security}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
  Framework}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{File
  Management}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/search}{Search}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/segmentation-personalization}{Segmentation
  and Personalization}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes}{Upgrade
  Processes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{Web
  Fragments}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/the-workflow-framework}{Workflow}
\end{itemize}

The Core provides the component runtime environment for the frameworks,
services, and UI. Here are some component examples:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Services}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{Service
  customizations}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}
  (templates, controllers, and resources)
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/web-front-ends}{JavaScript
  applications} (templates, routers, and resources)
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
  customization via Portlet Filters}
\item
  \href{(/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction)}{Theme}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-language-module}{Shared
  Language Keys}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/screen-navigation-framework}{Navigation
  components}
\end{itemize}

The following figure shows these component types in the runtime
environment.

\begin{figure}
\centering
\includegraphics{./images/component-runtime-environment.png}
\caption{The Core provides a runtime environment for components, such as
the ones here. New component implementations can extend or replace
existing implementations dynamically.}
\end{figure}

The runtime environment supports adding, replacing, and customizing
components on-the-fly. This makes the following scenarios possible:

\textbf{Replacement:} If the \texttt{ServiceC\ Impl\ 2} component has a
higher ranking than existing component \texttt{ServiceC\ Impl\ 1},
\texttt{ServiceC\ Impl\ 2} is used in its place.

\textbf{Customization:} The \texttt{PortletA\ Filter} intercepts and
modifies requests to and responses from \texttt{PortletA}, affecting the
content \texttt{PortletA} displays.

Component WAR and module JAR projects install as
\href{https://www.osgi.org/}{OSGi bundles} (modules). Liferay DXP's OSGi
framework defines the module lifecycle, enforces dependencies, defines
the class loading structure, and provides an API and CLI
(\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell}) for managing modules and components. The Core is configured
via \href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{portal
properties files} and
\href{/docs/7-2/user/-/knowledge_base/u/server-administration}{Server
Administration panels}.

The service components provide business functionality.

\section{Services}\label{services}

Business logic is implemented in services deployed to the component
runtime environment. Built-in Core services and framework services
operate on Liferay models such as Users, Roles, Web Content, Documents
and Media, and more. You can write and deploy custom services to
introduce new models and functionality. Service components can access
each other in Liferay DXP via
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{dependency
injection}.

Front-end applications invoke the services to do work. You can deploy
Java-based applications that call services directly using the
\href{/docs/7-2/reference/-/knowledge_base/r/java-apis}{Java APIs}, and
any web-based (Java and non-Java) application, whether deployed on
Liferay DXP or not, can use the web APIs, which include
\href{/docs/7-2/appdev/-/knowledge_base/a/generating-apis-with-rest-builder}{headless
REST APIs} that conform to the
\href{https://swagger.io/docs/specification/about/}{OpenAPI} standard
and include
\href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{plain
web/REST services}. The following figure shows Liferay DXP applications
and external clients invoking Liferay services.

\begin{figure}
\centering
\includegraphics{./images/apps-invoking-services.png}
\caption{Remote and Liferay DXP applications can invoke services via
REST web APIs. Liferay DXP Java-based portlets can also invoke services
via Java APIs.}
\end{figure}

Liferay services are built using
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} and made REST-ful using
\href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder}.
The services are easy to
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-osgi-services}{override
and extend} too.

Liferay DXP also provides a web-based UI, which makes content and
service functionality available in browsers.

\section{UI}\label{ui}

\href{/docs/7-2/user/-/knowledge_base/u/the-liferay-distinction}{Liferay
DXP's UI} helps people do work,
\href{/docs/7-2/user/-/knowledge_base/u/collaboration}{collaborate}, and
\href{/docs/7-2/user/-/knowledge_base/u/web-experience-management}{enjoy
content}. The UI consists of

\begin{itemize}
\item
  \href{/docs/7-2/user/-/knowledge_base/u/the-liferay-distinction}{Liferay
  DXP application}: The web application for managing Portals, Sites,
  Users, Pages, Widgets, and more.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/application-development}{Applications}:
  Widgets that provide a user interface for services already deployed.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes}:
  Plugins for styling Sites with a unique look and feel.
\end{itemize}

The UI concepts article digs deeper into developing and customizing UI
components.

As you can see, the Liferay DXP architecture supports developing
services, UI components, and customizations. The architecture section
covers Core, service, and UI topics. Next, we dive into the Core to
describe class loading, modularity, and more. But you can jump ahead to
any service or UI architecture topics, if you like. Enjoy exploring the
Liferay DXP architecture!

\chapter{Liferay Portal Classloader
Hierarchy}\label{liferay-portal-classloader-hierarchy}

All Liferay DXP applications live in its OSGi container. Portal is a web
application deployed on your application server. Portal's Module
Framework bundles (modules) live in the OSGi container and have
classloaders. All the classloaders from Java's Bootstrap classloader to
classloaders for bundle classes and JSPs are part of a hierarchy.

This article explains Liferay's classloader hierarchy and describes how
it works in the following contexts:

\begin{itemize}
\tightlist
\item
  Web application, such as Liferay Portal, deployed on the app server
\item
  OSGi bundle deployed in the Module Framework
\end{itemize}

The following diagram shows Liferay DXP's classloader hierarchy.

\begin{figure}
\centering
\includegraphics{./images/portal-classloader-hierarchy.png}
\caption{0: Here is Liferay's classloader hierarchy.}
\end{figure}

Here are the classloader descriptions:

\begin{itemize}
\item
  \textbf{Bootstrap}: The JRE's classes (from packages \texttt{java.*})
  and Java extension classes (from \texttt{\$JAVA\_HOME/lib/ext}). No
  matter the context, loading all \texttt{java.*} classes is delegated
  to the Bootstrap classloader.
\item
  \textbf{System}: Classes configured on the \texttt{CLASSPATH} and or
  passed in via the application server's Java classpath (\texttt{-cp} or
  \texttt{-classpath}) parameter.
\item
  \textbf{Common}: Classes accessible globally to web applications on
  the application server.
\item
  \textbf{Web Application}: Classes in the application's
  \texttt{WEB-INF/classes} folder and \texttt{WEB-INF/lib/*.jar}.
\item
  \textbf{Module Framework}: Liferay's OSGi module framework classloader
  which is used to provide controlled isolation for the module framework
  bundles.
\item
  \textbf{bundle}: Classes from a bundle's packages or from packages
  other bundles export.
\item
  \textbf{JSP}: A classloader that aggregates the following bundle and
  classloaders:

  \begin{itemize}
  \tightlist
  \item
    Bundle that contains the JSPs' classloader
  \item
    JSP servlet bundle's classloader
  \item
    Javax Expression Language (EL) implementation bundle's classloader
  \item
    Javax JSTL implementation bundle's classloader
  \end{itemize}
\item
  \textbf{Service Builder}: Service Builder classes
\end{itemize}

The classloader used depends on context. Classloading rules vary between
application servers. Classloading in web applications and OSGi bundles
differs too. In all contexts, however, the Bootstrap classloader loads
classes from \texttt{java.*} packages.

Classloading from a web application perspective is up next.

\section{Web Application Classloading
Perspective}\label{web-application-classloading-perspective}

Application servers dictate where and in what order web applications,
such as Liferay DXP, search for classes and resources. Application
servers such as
\href{https://tomcat.apache.org/tomcat-9.0-doc/class-loader-howto.html}{Apache
Tomcat} enforce the following default search order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Bootstrap classes
\item
  Web app's \texttt{WEB-INF/classes}
\item
  web app's \texttt{WEB-INF/lib/*.jar}
\item
  System classloader
\item
  Common classloader
\end{enumerate}

First, the web application searches Bootstrap. If the class/resource
isn't there, the web application searches its own classes and JARs. If
the class/resource still isn't found, it checks the System classloader
and then Common classloader. Except for the web application checking its
own classes and JARs, it searches the hierarchy in parent-first order.

Application servers such as
\href{https://docs.oracle.com/cd/E19501-01/819-3659/beadf/index.html}{Oracle
WebLogic} and IBM WebSphere have additional classloaders. They may also
have a different classloader hierarchy and search order. Consult your
application server's documentation for classloading details.

\section{Other Classloading
Perspectives}\label{other-classloading-perspectives}

\href{/docs/7-2/customization/-/knowledge_base/c/bundle-classloading-flow}{Bundle
Classloading Flow} explains classloading from an OSGi bundle
perspective.

Classloading for JSPs and Service Builder classes is similar to that of
web applications and OSGi bundle classes.

You now know Liferay DXP's classloading hierarchy, understand it in
context of web applications, and have references to information on other
classloading perspectives.

\section{Related Topics}\label{related-topics-8}

\href{/docs/7-2/customization/-/knowledge_base/c/bundle-classloading-flow}{Bundle
Classloading Flow}

\chapter{Liferay DXP Startup Phases}\label{liferay-dxp-startup-phases}

Knowing Liferay's startup phases helps you troubleshoot startup
failures. By learning the phase triggered events, you can listen for
phases and act on them. This article describes the startup phases and
identifies how to \hyperref[acting-on-events]{implement actions for
phase events}.

Startup consists of these main phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Portal Context Initialization Phase:} focuses on low level
  tasks without a web context.
\item
  \textbf{Main Servlet Initialization Phase:} focuses on the portlet
  container and the Liferay DXP web application's UI features such as
  Struts, Themes, and more.
\end{enumerate}

The Portal Context Initialization Phase sets the stage for the Main
Servlet Initialization Phase.

\section{Portal Context Initialization
Phase}\label{portal-context-initialization-phase}

The Portal Context Initialization phase runs first with these tasks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set up low level utilities such as logging and those in
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/PortalUtil.html}{\texttt{PortalUtil}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/util/InitUtil.html}{\texttt{InitUtil}}.
\item
  OSGi framework is initialized.
\item
  Spring Phase 1: INFRASTRUCTURE beans specified by the Spring context
  files listed in Portal property
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Spring}{\texttt{spring.infrastructure.configs}}
  are loaded.
\item
  INFRASTRUCTURE beans are published as
  \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
  services}.
\item
  OSGi framework starts.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Static bundles are installed and started.
  \item
    Dynamic bundles are started.
  \end{enumerate}
\item
  OSGi framework starts the runtime.
\item
  Spring Phase 2: MAIN

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Load Spring beans specified by the Spring context files listed in
    Portal property
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Spring}{\texttt{spring.configs}}.
  \item
    A
    \hyperref[moduleservicelifecycle-events]{\texttt{ModuleServiceLifecycle}
    event service} with a service property
    \texttt{module.service.lifecycle} value \texttt{spring.initialized}
    (i.e.,
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.SPRING_INITIALIZED}{\texttt{SPRING\_INITIALIZED}})
    registers.
  \end{enumerate}
\item
  MAIN Spring beans are published as
  \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
  services}.
\end{enumerate}

\section{Main Servlet Initialization
Phase}\label{main-servlet-initialization-phase}

Here's the phase's activity sequence:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The
  \hyperref[moduleservicelifecycle-events]{\texttt{ModuleServiceLifecycle}
  event service} is updated with the service property
  \texttt{module.service.lifecycle} value \texttt{database.initialized}
  (i.e.,
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.DATABASE_INITIALIZED}{\texttt{DATABASE\_INITIALIZED}}).
\item
  The \hyperref[portal-startup-events]{Global Startup event} fires.
\item
  For each portal instance, the
  \hyperref[portal-startup-events]{Application Startup events} fire.
\item
  The
  \hyperref[moduleservicelifecycle-events]{\texttt{ModuleServiceLifecycle}
  event service} is updated with the service property
  \texttt{module.service.lifecycle} value \texttt{portal.initialized}
  (i.e.,
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.PORTAL_INITIALIZED}{\texttt{PORTAL\_INITIALIZED}}).
\end{enumerate}

Now that you're acquainted with the startup phases, you can concentrate
on the events they fire.

\section{Acting on Events}\label{acting-on-events}

The ways to act on events depends on the event type. These subsections
describe the event types.

\section{ModuleServiceLifecycle
Events}\label{moduleservicelifecycle-events}

\href{/docs/7-2/customization/-/knowledge_base/c/waiting-on-lifecycle-events}{You
can wait for and act on \texttt{ModuleServiceLifecycle} event services.}

\section{Portal Startup Events}\label{portal-startup-events}

In your \texttt{liferay-portal-ext.properties} file, you can override
the following properties and add your own
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/events/LifecycleAction.html}{\texttt{LifecycleAction}}
classes to the list of action classes to invoke on the events.

\textbf{Global Startup Event} runs once when Liferay DXP initializes.
The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Startup\%20Events}{\texttt{global.startup.events}
property} defines the event's default actions.

\textbf{Application Startup Events} runs once for each Site instance
Liferay DXP initializes. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Startup\%20Events}{\texttt{application.startup.events}
property} defines the event's default actions.

\section{Related Topics}\label{related-topics-9}

\href{/docs/7-2/customization/-/knowledge_base/c/waiting-on-lifecycle-events}{Waiting
on Lifecycle Events}

\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\chapter{The Benefits of Modularity}\label{the-benefits-of-modularity}

Dictionary.com defines
\href{http://www.dictionary.com/browse/modularity}{modularity} as
\emph{the use of individually distinct functional units, as in
assembling an electronic or mechanical system.} The distinct functional
units are called \emph{modules}.

NASA's Apollo spacecraft, for example, comprised three modules, each
with a distinct function:

\begin{itemize}
\tightlist
\item
  \emph{Lunar Module}: Carried astronauts from the Apollo spacecraft to
  the moon's surface and back.
\item
  \emph{Service Module}: Provided fuel for propulsion, air conditioning,
  and water.
\item
  \emph{Command Module}: Housed the astronauts and communication and
  navigation controls.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/modularity_apollo_spacecraft_diagram.png}
\caption{The Apollo spacecraft's modules collectively took astronauts to
the moon's surface and back to Earth.}
\end{figure}

The spacecraft and its modules exemplified these modularity
characteristics:

\begin{itemize}
\item
  \textbf{Distinct functionality}: Each module provides a distinct
  function (purpose); modules can be combined to provide an entirely new
  collective function.

  The Apollo spacecraft's modules were grouped together for a distinct
  collective function: take astronauts from the Earth's atmospheric rim,
  to the moon's surface, and back to Earth. The previous list identifies
  each module's distinct function.
\item
  \textbf{Dependencies}: Modules can require capabilities other modules
  satisfy.

  The Apollo modules had these dependencies:

  \begin{itemize}
  \item
    Lunar Module depended on the Service Module to get near the moon.
  \item
    Command Module depended on the Service Module for power and oxygen.
  \item
    Service Module depended on the Command Module for instruction.
  \end{itemize}
\item
  \textbf{Encapsulation}: Modules hide their implementation details but
  publicly define their capabilities and interfaces.

  Each Apollo module was commissioned with a contract defining its
  capabilities and interface, while each module's details were
  encapsulated (hidden) from other modules. NASA integrated the modules
  based on their interfaces.
\item
  \textbf{Reusability}: A module can be applied to different scenarios.

  The Command Module's structure and design were reusable. NASA used
  different versions of the Command Module, for example, throughout the
  Apollo program, and in the Gemini Program, which focused on Earth
  orbit.
\end{itemize}

NASA used modularity to successfully complete over a dozen missions to
the moon. Can modularity benefit software too? Yes! The following
sections show you how:

\begin{itemize}
\tightlist
\item
  \hyperref[modularity-benefits-for-software]{Modularity benefits for
  software}
\item
  \hyperref[example-designing-a-modular-application]{Example: How to
  design a modular application}
\end{itemize}

\section{Modularity Benefits for
Software}\label{modularity-benefits-for-software}

Java applications have predominantly been monolithic: they're developed
in large code bases. In a monolith, it's difficult to avoid tight
coupling of classes. Modular application design, conversely, facilitates
loose coupling, making the code easier to maintain. It's much easier and
more fun to develop small amounts of cohesive code in modules. Here are
some key benefits of developing modular software.

\section{Distinct Functionality}\label{distinct-functionality}

It's natural to focus on developing one piece of software at a time. In
a module, you work on a small set of classes to define and implement the
module's function. Keeping scope small facilitates writing high quality,
elegant code. The more cohesive the code, the easier it is to test,
debug, and maintain. Modules can be combined to provide a new function,
distinguishable from each module's function.

\section{Encapsulation}\label{encapsulation}

A module encapsulates a function (capability). Module implementations
are hidden from consumers, so you can create and modify them as you
like. Throughout a module's lifetime, you can fix and improve the
implementation or swap in an entirely new one. You make the changes
behind the scenes, transparent to consumers. A module's contract defines
its capability and interface, making the module easy to understand and
use.

\section{Dependencies}\label{dependencies}

Modules have requirements and capabilities. The interaction between
modules is a function of the capability of one satisfying the
requirement of another and so on. Modules are published to artifact
repositories, such as Maven Central. Module versioning schemes let you
specify dependencies on particular module versions or version ranges.

\section{Reusability}\label{reusability}

Modules that do their job well are hot commodities. They're reusable
across projects, for different purposes. As you discover helpful
reliable modules, you'll use them again and again.

It's time to design a modular application.

\section{Example: Designing a Modular
Application}\label{example-designing-a-modular-application}

Application design often starts out simple but gets more complex as you
determine capabilities the application requires. If a third party
library already provides the capability, you can
\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{deploy
it with your app}. You can otherwise implement the capability yourself.

As you design various aspects of your app to support its function, you
must decide how those aspects fit into the code base. Putting them in a
single monolithic code base often leads to tight coupling, while
designating separate modules for each aspect fosters loose coupling.
Adopting a modular approach to application design lets you reap the
modularity benefits.

For example, you can apply modular design to a speech recognition app.
Here are the app's function and required capabilities:

\emph{Function}: interface with users to translate their speech into
text for the computer to understand.

\emph{Required capabilities}:

\begin{itemize}
\tightlist
\item
  Translates user words to text
\item
  Uses a selected computer voice to speak to users.
\item
  Interacts with users based on a script of instructions that include
  questions, commands, requests, and confirmations.
\end{itemize}

You could create modules to provide the required capabilities:

\begin{itemize}
\tightlist
\item
  \emph{Speech to text}: Translates spoken words to text the computer
  understands.
\item
  \emph{Voice UI}: Interacts with users based on stored questions,
  commands, and confirmations.
\item
  \emph{Instruction manager}: Stores and provides the application's
  questions, commands, and confirmations.
\item
  \emph{Computer voice}: Stores and provides computer voices for users
  to choose from.
\end{itemize}

The following diagram contrasts a monolithic design for the speech
recognition application with a modular design.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-application-design-example.png}
\caption{The speech recognition application can be implemented in a
single monolithic code base or in modules, each focused on a particular
function.}
\end{figure}

Designing the app as a monolith lumps everything together. There are no
initial boundaries between the application aspects, whereas the modular
design distinguishes the aspects.

Developers can create the modules in parallel, each one with its own
particular capability. Designing applications that comprise modules
fosters writing cohesive pieces of code that represent capabilities.
Each module's capability can potentially be \emph{reused} in other
scenarios too.

For example, the \emph{Instruction manager} and \emph{Computer voice}
modules can be \emph{reused} by a navigation app.

\begin{figure}
\centering
\includegraphics{./images/modularity-benefits-module-reuse.png}
\caption{The \emph{Instruction manager} and \emph{Computer voice}
modules designed for the speech recognition app can be used (or
\emph{reused}) by a navigation app.}
\end{figure}

Here are the benefits of designing the speech recognition app as
modules:

\begin{itemize}
\tightlist
\item
  Each module represents a capability that contributes to the app's
  overall function.
\item
  The app depends on modules, that are easy to develop, test, and
  maintain.
\item
  The modules can be reused in different applications.
\end{itemize}

In conclusion, modularity has literally taken us to the moon and back.
It benefits software development too. The example speech recognition
application demonstrated how to design an app that comprises modules.

Next you'll learn how OSGi facilitates creating modules that provide and
consume services.

\chapter{OSGi and Modularity}\label{osgi-and-modularity}

Modularity makes writing software, especially as a team, fun! Here are
some benefits to modular development on DXP:

\begin{itemize}
\tightlist
\item
  Liferay DXP's runtime framework is lightweight, fast, and secure.
\item
  The framework uses the OSGi standard. If you have experience using
  OSGi with other projects, you can apply your existing knowledge to
  developing on DXP.
\item
  Modules publish services to and consume services from a service
  registry. Service contracts are loosely coupled from service providers
  and consumers, and the registry manages the contracts automatically.
\item
  Modules' dependencies are managed automatically by the container,
  dynamically (no restart required).
\item
  The container manages module life cycles dynamically. Modules can be
  installed, started, updated, stopped, and uninstalled while Liferay is
  running, making deployment a snap.
\item
  Only a module's classes whose packages are explicitly exported are
  publicly visible; OSGi hides all other classes by default.
\item
  Modules and packages are semantically versioned and declare
  dependencies on specific versions of other packages. This allows two
  applications that depend on different versions of the same packages to
  each depend on their own versions of the packages.
\item
  Team members can develop, test, and improve modules in parallel.
\item
  You can use your existing developer tools and environment to develop
  modules.
\end{itemize}

There are many benefits to modular software development with OSGi, and
we can only scratch the surface here. Once you start developing modules,
you might find it hard to go back to developing any other way.

\section{Modules}\label{modules}

It's time to see what module projects look like and see Liferay DXP's
modular development features in action. To keep things simple, only
project code and structure are shown: you can
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{create
modules} like these anytime.

These modules collectively provide a command that takes a String and
uses it in a greeting. Consider it ``Hello World'' for modules.

\section{API}\label{api}

The API module is first. It defines the contract that a provider
implements and a consumer uses. Here is its structure:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-api}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/api}

          \begin{itemize}
          \tightlist
          \item
            \texttt{Greeting.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Very simple, right? Beyond the Java source file, there are only two
other files: a Gradle build script (though you can use any build system
you want), and a configuration file called \texttt{bnd.bnd}. The
\texttt{bnd.bnd} file describes and configures the module:

\begin{verbatim}
Bundle-Name: Greeting API
Bundle-SymbolicName: com.liferay.docs.greeting.api
Bundle-Version: 1.0.0
Export-Package: com.liferay.docs.greeting.api
\end{verbatim}

The module's name is \emph{Greeting API}. Its symbolic name--a name that
ensures uniqueness--is \texttt{com.liferay.docs.greeting.api}. Its
semantic version is declared next, and its package is \emph{exported},
which means it's made available to other modules. This module's package
is just an API other modules can implement.

Finally, there's the Java class, which in this case is an interface:

\begin{verbatim}
package com.liferay.docs.greeting.api;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface Greeting {

        public void greet(String name);

}
\end{verbatim}

The interface's \texttt{@ProviderType} annotation tells the service
registry that anything implementing the interface is a provider. The
interface's one method asks for a \texttt{String} and doesn't return
anything.

That's it! As you can see, creating modules is not very different from
creating other Java projects.

\section{Provider}\label{provider}

An interface only defines an API; to do something, it must be
implemented. This is what the provider module is for. Here's what a
provider module for the Greeting API looks like:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-impl}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/impl}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingImpl.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

It has the same structure as the API module: a build script, a
\texttt{bnd.bnd} configuration file, and an implementation class. The
only differences are the file contents. The \texttt{bnd.bnd} file is a
little different:

\begin{verbatim}
Bundle-Name: Greeting Impl
Bundle-SymbolicName: com.liferay.docs.greeting.impl
Bundle-Version: 1.0.0
\end{verbatim}

The bundle name, symbolic name, and version are all set similarly to the
API.

Finally, there's no \texttt{Export-Package} declaration. A client (which
is the third module you'll create) just wants to use the API: it doesn't
care how its implementation works as long as the API returns what it's
supposed to return. The client, then, only needs to declare a dependency
on the API; the service registry injects the appropriate implementation
at runtime.

Pretty cool, eh?

All that's left, then, is the class that provides the implementation:

\begin{verbatim}
package com.liferay.docs.greeting.impl;

import com.liferay.docs.greeting.api.Greeting;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = Greeting.class
)
public class GreetingImpl implements Greeting {

    @Override
    public void greet(String name) {
        System.out.println("Hello " + name + "!");
    }

}
\end{verbatim}

The implementation is simple. It uses the \texttt{String} as a name and
prints a hello message. A better implementation might be to use
Liferay's API to collect all the names of all the users in the system
and send each user a greeting notification, but the point here is to
keep things simple. You should understand, though, that there's nothing
stopping you from replacing this implementation by deploying another
module whose Greeting implementation's \texttt{@Component} annotation
specifies a higher service ranking property (e.g.,
\texttt{"service.ranking:Integer=100"}).

This \texttt{@Component} annotation defines three options:
\texttt{immediate\ =\ true}, an empty property list, and the service
class that it implements. The \texttt{immediate\ =\ true} setting means
that this module should not be lazy-loaded; the service registry loads
it as soon as it's deployed, instead of when it's first used. Using the
\texttt{@Component} annotation declares the class as a Declarative
Services component, which is the most straightforward way to create
components for OSGi modules. A component is a POJO that the runtime
creates automatically when the module starts.

To compile this module, the API it's implementing must be on the
classpath. If you're using Gradle, you'd add the \texttt{greetings-api}
project to your \texttt{dependencies\ \{\ ...\ \}} block. In a
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace} module, the dependency looks like this:

\begin{verbatim}
compileOnly project (':modules:greeting-api')
\end{verbatim}

That's all there is to a provider module.

\section{Consumer}\label{consumer}

The consumer or client uses the API that the API module defines and the
provider module implements. DXP has many different kinds of consumer
modules.
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets} are
the most common consumer module type, but since they are a topic all by
themselves, this example stays simple by creating an command for the
Apache Felix Gogo shell. Note that consumers can, of course, consume
many different APIs to provide functionality.

A consumer module has the same structure as the other module types:

\begin{itemize}
\tightlist
\item
  \texttt{greeting-command}

  \begin{itemize}
  \tightlist
  \item
    \texttt{src}

    \begin{itemize}
    \tightlist
    \item
      \texttt{main}

      \begin{itemize}
      \tightlist
      \item
        \texttt{java}

        \begin{itemize}
        \tightlist
        \item
          \texttt{com/liferay/docs/greeting/command}

          \begin{itemize}
          \tightlist
          \item
            \texttt{GreetingCommand.java}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \end{itemize}
  \item
    \texttt{bnd.bnd}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Again, you have a build script, a \texttt{bnd.bnd} file, and a Java
class. This module's \texttt{bnd.bnd} file is almost the same as the
provider's:

\begin{verbatim}
Bundle-Name: Greeting Command
Bundle-SymbolicName: com.liferay.docs.greeting.command
Bundle-Version: 1.0.0
\end{verbatim}

There's nothing new here: you declare the same things you declared for
the provider.

Your Java class has a little bit more going on:

\begin{verbatim}
package com.liferay.docs.greeting.command;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.docs.greeting.api.Greeting;

@Component(
    immediate = true,
    property = {
        "osgi.command.scope=greet",
        "osgi.command.function=greet"
    },
    service = Object.class
)
public class GreetingCommand {

    public void greet(String name) {
        Greeting greeting = _greeting;

        greeting.greet(name);
    }

    @Reference
    private Greeting _greeting;

}
\end{verbatim}

The \texttt{@Component} annotation declares the same attributes, but
specifies different properties and a different service. As in Java,
where every class is a subclass of \texttt{java.lang.Object} (even
though you don't need to specify it by default), in Declarative
Services, the runtime needs to know the type of class to register.
Because you're not implementing any particular type, your parent class
is \texttt{java.lang.Object}, so you must specify that class as the
service. While Java doesn't require you to specify \texttt{Object} as
the parent when you're creating a class that doesn't inherit anything,
Declarative Services does.

The two properties define a command scope and a command function. All
commands have a scope to define their context, as it's common for
multiple APIs to have similar functions, such as \texttt{copy} or
\texttt{delete}. These properties specify you're creating a command
called \texttt{greet} in a scope called \texttt{greet}. While you get no
points for imagination, this sufficiently defines the command.

Since you specified \texttt{osgi.command.function=greet} in the
\texttt{@Component} annotation, your class must have a method named
\texttt{greet}, and you do. But how does this \texttt{greet} method
work? It obtains an instance of the \texttt{Greeting} OSGi service and
invokes its \texttt{greet} method, passing in the \texttt{name}
parameter. How is an instance of the \texttt{Greeting} OSGi service
obtained? The \texttt{GreetingCommand} class declares a private service
bean, \texttt{\_greeting} of type \texttt{Greeting}. This is the OSGi
service type that the provider module registers. The \texttt{@Reference}
annotation tells the OSGi runtime to instantiate the service bean with a
service from the service registry. The runtime binds the
\texttt{Greeting} object of type \texttt{GreetingImpl} to the private
field \texttt{\_greeting}. The \texttt{greet} method uses the
\texttt{\_greeting} field value.

Just like the provider, the consumer needs to have the API on its
classpath in order to compile, but at runtime, since you've declared all
the dependencies appropriately, the container knows about these
dependencies, and provides them automatically.

If you were to
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy
these modules to a DXP instance}, you'd be able to attach to the
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
Shell} and execute a command like this:

\begin{verbatim}
greet:greet "Captain\ Kirk"
\end{verbatim}

The shell would then return your greeting:

\begin{verbatim}
Hello Captain Kirk!
\end{verbatim}

This most basic of examples should make it clear that module-based
development is easy and straightforward. The API-Provider-Consumer
contract fosters loose coupling, making your software easy to manage,
enhance, and support.

\section{A Typical Liferay
Application}\label{a-typical-liferay-application}

If you look at a typical application from Liferay's source, you'll
generally find at least four modules:

\begin{itemize}
\tightlist
\item
  An API module
\item
  A Service (provider) module
\item
  A Test module
\item
  A Web (consumer) module
\end{itemize}

This is exactly what you'll find for some smaller applications, like the
Mentions application that lets users mention other users with the
\texttt{@username} nomenclature in comments, blogs, or other
applications. Larger applications like the Documents and Media library
have more modules. In the case of the Documents and Media library, there
are separate modules for different document storage back-ends. In the
case of the Wiki, there are separate modules for different Wiki engines.

Encapsulating capability variations as modules facilitates
extensibility. If you have a document storage back-end that Liferay
doesn't yet support, you can implement Liferay's document storage API
for your solution by developing a module for it and thus extend
Liferay's Documents and Media library. If there's a Wiki dialect that
you like better than what Liferay's wiki provides, you can write a
module for it and extend Liferay's wiki.

Are you excited yet? Are you ready to start developing? Here are some
resources for you to learn more.

\section{Related Topics}\label{related-topics-10}

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio}

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}

\href{/docs/7-2/reference/-/knowledge_base/r/maven}{Maven}

\href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-code-to-product-ver}{Upgrading
Code to 7.2}

\chapter{Module Lifecycle}\label{module-lifecycle}

In OSGi, all components, Java classes, resources, and descriptors are
deployed via modules. The \texttt{MANIFEST.MF} file describes the
module's physical characteristics, such as the packages it exports and
imports. The module's component description files specify its functional
characteristics (i.e., the services its components offer and consume).
Also modules and their components have their own lifecycles and
administrative APIs. Declarative Services and shell tools give you
fine-grained control over module and component deployment.

Since a module's contents depend on its activation, consider the
activation steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \emph{Installation}: Copying the module JAR into Liferay DXP's
  \texttt{{[}Liferay\ Home{]}/deploy} folder installs the module to the
  OSGi framework, marking the module \texttt{INSTALLED}.
\item
  \emph{Resolution}: Once all the module's requirements are met (e.g.,
  all packages it imports are available), the framework publishes the
  module's exported packages and marks the module \texttt{RESOLVED}.
\item
  \emph{Activation}: Modules are activated \emph{eagerly} by default.
  That is, they're started in the framework and marked \texttt{ACTIVE}
  on resolution. An active module's components are enabled. If a module
  specifies a \texttt{lazy} activation policy, as shown in the manifest
  header below, it's activated only after another module requests one of
  its classes.

\begin{verbatim}
Bundle-ActivationPolicy: lazy
\end{verbatim}
\end{enumerate}

The figure below illustrates the module lifecycle.

\begin{figure}
\centering
\includegraphics{./images/module-state-diagram.png}
\caption{This state diagram illustrates the module lifecycle.}
\end{figure}

The
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Apache
Felix Gogo Shell} lets you manage the module lifecycle. You can
install/uninstall modules and start/stop them. You can update a module
and notify dependent modules to use the update. Liferay's tools,
including
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP},
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace}, and
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} offer
similar shell commands that use the OSGi Admin API.

On activating a module, its components are enabled. But only
\emph{activated} components can be used. Component activation requires
all its referenced services be satisfied. That is, all services it
references must be registered. The highest ranked service that matches a
reference is bound to the component. When the container finds and binds
all the services the component references, it registers the component.
It's now ready for activation.

Components can use \emph{delayed} (default) or \emph{immediate}
activation policies. To specify immediate activation, the developer adds
the attribute \texttt{immediate=true} to the \texttt{@Component}
annotation.

\begin{verbatim}
@Component(
    immediate = true,
    ...
)
\end{verbatim}

Unless immediate activation is specified, the component's activation is
delayed. That is, the component's object is created and its classes are
loaded once the component is requested. In this way, delayed activation
can improve startup times and conserve resources.

Gogo Shell's
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html\#shell-command}{Service
Component Runtime commands} let you manage components:

\begin{itemize}
\item
  \texttt{scr:list\ {[}bundleID{]}}: Lists the module's (bundle's)
  components.
\item
  \texttt{scr:info\ {[}componentID\textbar{}fullClassName{]}}: Describes
  the component, including its status and the services it provides.
\item
  \texttt{scr:enable\ {[}componentID\textbar{}fullClassName{]}}: Enables
  the component.
\item
  \texttt{scr:disable\ {[}componentID\textbar{}fullClassName{]}}:
  Disables the component. It's disabled on the server (or current server
  node in a cluster) until the server is restarted.
\end{itemize}

Service references are static and reluctant by default. That is, an
injected service remains bound to the referencing component until the
service is disabled. Alternatively, you can specify \emph{greedy}
service policies for references. Every time a higher ranked matching
service is registered, the framework unbinds the lower ranked service
from the component (whose service policy is greedy) and binds the new
service in its place automatically. Here's a \texttt{@Reference}
annotation that uses a greedy policy:

\begin{verbatim}
@Reference(policyOption = ReferencePolicyOption.GREEDY)
\end{verbatim}

Declarative Services annotations let you specify component activation
and service policies. Gogo Shell commands let you control modules and
components.

\section{Related Topics}\label{related-topics-11}

\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Creating
a Project}

\href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-code-to-product-ver}{Upgrading
Code to 7.2}

\chapter{UI Architecture}\label{ui-architecture}

\href{/docs/7-2/user/-/knowledge_base/u/the-liferay-distinction}{Liferay
DXP's UI} is a portal for adding sites, pages, widgets, and content. It
helps people do work,
\href{/docs/7-2/user/-/knowledge_base/u/collaboration}{collaborate}, and
\href{/docs/7-2/user/-/knowledge_base/u/web-experience-management}{share
content}.

The UI comprises the following parts:

\begin{itemize}
\item
  Content: images, videos, and text.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/application-development}{Applications}:
  Widgets and portlets that expose functionality for accomplishing
  tasks.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes}:
  Plugins that use CSS, FreeMarker templates, HTML, and JavaScript to
  provide a site's overall look and feel.
\item
  Product navigation sidebars and panels: Use these for administering
  sites.
\end{itemize}

\section{Content}\label{content}

Liferay DXP's built-in applications help you publish images, video,
forms, markup text, and more to site pages.
\href{/docs/7-2/user/-/knowledge_base/u/managing-documents-and-media}{Documents
and Media} stores images, videos, and documents to use throughout your
site. The
\href{/docs/7-2/user/-/knowledge_base/u/web-experience-management}{Web
Experience Management} suite helps you create, maintain, and organize
content. \href{/docs/7-2/user/-/knowledge_base/u/forms}{Liferay Forms}
gives you robust form building capability.
\href{/docs/7-2/user/-/knowledge_base/u/creating-forums-with-message-boards}{Message
Boards} facilitate lively discussions and
\href{/docs/7-2/user/-/knowledge_base/u/publishing-blogs}{Blogs} let
users express themselves with markup text and images. These are just a
few of the built-in applications for adding site content.

\section{Applications}\label{applications}

Liferay DXP applications provide content and help users accomplish
tasks. They're
\href{/7-2/appdev/-/knowledge_base/a/web-front-ends}{developed the same
way} as other web applications, and Liferay DXP can combine multiple
applications on one page.

Liferay DXP supports developing JavaScript-based applications using
popular front-end frameworks:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-an-angular-application}{Angular}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-react-application}{React}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-vue-application}{Vue}
\end{itemize}

Java-based portlet applications use the latest portlet standards and
frameworks, including ones familiar to experienced Liferay portlet
developers:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
  MVC Portlet}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{PortletMVC4Spring}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/jsf-portlet}{JSF Portlet}
\end{itemize}

In the UI, applications are referred to as Widgets and categorized for
users to add to pages. Administrative applications are available in the
product menu panels.

\begin{figure}
\centering
\includegraphics{./images/architecture-ui-widgets.png}
\caption{Widget pages offer users functionality. Widgets are organized
into a page template's rows and columns. This template has two columns:
a smaller left column and larger right column. On this page, users
select tags in the Tag Cloud widget and the matching tagged images show
the Asset Publisher widget.}
\end{figure}

\section{Themes}\label{themes}

A
\href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{theme}
styles a site with a unique look and feel. It's developed as a WAR
project that includes CSS, JavaScript, and markup content. You can
develop themes using whatever tools you prefer, but Liferay DXP offers
\href{https://getbootstrap.com/}{Bootstrap}-based components and
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-themes}{theme
tooling} to create and deploy themes in no time.

\begin{figure}
\centering
\includegraphics{./images/architecture-ui-themes.png}
\caption{You can select an attractive theme and apply it to your site.}
\end{figure}

Here's a quick demonstration of developing a theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a theme using the
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{Theme
  Generator}. The theme extends the base theme you specified to the
  Theme Generator---Liferay's
  \href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-styled}{Styled
  theme} is the default.
\item
  Run
  \href{https://portal.liferay.dev/docs/7-2/frameworks/-/knowledge_base/f/building-your-themes-files}{\texttt{gulp\ build}}
  to generate the base theme files to the \texttt{build} folder
  subfolders:

  \begin{itemize}
  \item
    \texttt{templates}: FreeMarker templates specify site page markup.
    \texttt{portal\_normal.ftl} is the central file; it includes
    templates that define the page parts (e.g., header, navigation,
    footer). The \texttt{init.ftl} file defines default variables
    available to the templates.
  \item
    \texttt{css}: SCCS files that provide styling.
  \item
    \texttt{font}: Font Awesome and Glyphicons fonts.
  \item
    \texttt{js}: JavaScript files; \texttt{main.js} is the Styled
    theme's JavaScript.
  \item
    \texttt{images}: Image files.
  \end{itemize}
\item
  Override aspects of the base theme by copying relevant files from the
  \texttt{build} subfolders to folders of the same name in your
  \texttt{src} folder. The
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-reference-guide}{Theme
  Anatomy Guide} describes all the files. Here's an example of a
  customized \texttt{portal\_normal.ftl}:
\end{enumerate}

\begin{verbatim}
<html class="${root_css_class}">
<head></head>
  <body class="${body_class}">
    <header class="${header_css_class}">
      <a class="${logo_css_class} href="${site_url}"><img src="${site_logo}"/></a>
      <#include "${full_templates_path}/navigation.ftl" />
    </header>
    <section>
      ${portlets}
    </section>
      <#include "${full_templates_path}/footer.ftl" />
  </body>
</html>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Add custom styling using your theme's \texttt{\_custom.scss} file
  (i.e., \texttt{src/css/\_custom.scss}). Liferay DXP supports
  \href{https://getbootstrap.com/}{Bootstrap}, as well as
  \href{https://sass-lang.com/}{Sass}, so you can use Bootstrap
  utilities in your markup and Sass nesting, variables, and more in your
  CSS files. This snippet styles the logo:
\end{enumerate}

\begin{verbatim}
.logo {
  margin-left: 15px;

  img {
    height: auto;
  }

  @include media-breakpoint-down(md) {
    text-align: center;
    width: 100%;
  }
}
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/architecture-ui-portal-dev-logo.png}
\caption{You can provide custom styling using the theme's
\texttt{\_custom.sccs} file.}
\end{figure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Deploy your theme by executing \texttt{gulp\ deploy}.
\end{enumerate}

The theme is available to
\href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{apply}
to your site.

For details,
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components}{Theme
Components} breaks down a theme's parts, and the
\href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes
section} provides theme development details.

\section{Product Navigation Sidebars and
Panels}\label{product-navigation\noindent\hrulefills-and-panels}

The product navigation sidebars and panels enable administrators to
build sites, add pages, apply themes, and configure the portal. It's
also where you can provide administrative functionality for your custom
applications. The navigation sidebars and panels are customizable.

\begin{figure}
\centering
\includegraphics{./images/architecture-ui-menus-and-panel-app.png}
\caption{Liferay facilitates integrating custom administrative
functionality through navigation menus and administrative applications.}
\end{figure}

As you can see, Liferay DXP's UI is highly flexible and customizable.
Here's where to learn more:

\begin{itemize}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/theme-components}{Theme
  Components}: Explains available mechanisms and extensions for
  customizing and theming pages, content, and applications.
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/understanding-the-page-structure}{Understanding
  the Page Structure}: Describes how the page's UI is organized and
  introduces tools for populating and developing each section.
\end{itemize}

\chapter{Theme Components}\label{theme-components}

This guide provides an overview of the following theme development and
customization topics:

\begin{itemize}
\tightlist
\item
  \hyperref[theme-templates]{Theme Templates}
\item
  \hyperref[css-frameworks-and-extensions]{CSS Frameworks and
  Extensions}
\item
  \hyperref[theme-customizations-and-extensions]{Theme Customizations
  and Extensions}
\item
  \hyperref[portlet-customizations-and-extensions]{Portlet
  Customizations and Extensions}
\end{itemize}

\section{Theme Templates and
Utilities}\label{theme-templates-and-utilities}

The default FreeMarker templates provide helpful utilities and handle
key pieces of page layout (page) functionality:

\begin{itemize}
\tightlist
\item
  \texttt{portal\_normal.ftl}: Similar to a static site's
  \texttt{index.html}, this file is the hub for all the theme templates
  and provides the overall markup for the page.
\item
  \texttt{init.ftl}: Contains variables commonly used throughout the
  theme templates. Refer to it to look up theme objects. For
  convenience, the
  \href{/docs/7-2/reference/-/knowledge_base/r/freemarker-variable-reference-guide}{FreeMarker
  Variable Reference Guide} lists the objects. \textbf{DO NOT override
  this file}.
\item
  \texttt{init\_custom.ftl}: Used to override FreeMarker variables in
  \texttt{init.ftl} and to define new variables, such as
  \href{/docs/7-2/frameworks/-/knowledge_base/f/making-configurable-theme-settings}{theme
  settings}.
\item
  \texttt{portlet.ftl}: Controls the theme's portlets. If your theme
  uses
  \href{/docs/7-2/frameworks/-/knowledge_base/f/theming-portlets\#portlet-decorators}{Portlet
  Decorators}, modify this file to create application decorator-specific
  theme settings.
\item
  \texttt{navigation.ftl}: Contains the navigation markup. To customize
  pages in the navigation, you must use the
  \texttt{liferay.navigation\_menu} macro. Then you can leverage
  \href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/site-navigation/site-navigation-menu-web/src/main/resources/com/liferay/site/navigation/menu/web/portlet/template/dependencies}{widget
  templates} for the navigation menu. Note that \texttt{navigation.ftl}
  also defines the hamburger icon and \texttt{navbar-collapse} class
  that provides the simplified navigation toggle for mobile viewports,
  as shown in the snippet below for the Classic theme:
\end{itemize}

\begin{verbatim}
<#if has_navigation && is_setup_complete>
  <button aria-controls="navigationCollapse" aria-expanded="false" 
  aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" 
  data-target="#navigationCollapse" data-toggle="collapse" type="button">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div aria-expanded="false" class="collapse navbar-collapse" id="navigationCollapse">
    <@liferay.navigation_menu default_preferences="${preferences}" />
  </div>
</#if>
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-mobile-nav.png}
\caption{The collapsed navbar provides simplified user-friendly
navigation for mobile devices.}
\end{figure}

\begin{itemize}
\tightlist
\item
  \texttt{portal\_pop\_up.ftl}: Controls pop up dialogs for the theme's
  portlets. Similar to \texttt{portal\_normal.ftl},
  \texttt{portal\_pop\_up.ftl} provides the markup template for all
  pop-up dialogs, such as a portlet's Configuration menu. It also has
  access to the FreeMarker variables defined in \texttt{init.ftl} and
  \texttt{init\_custom.ftl}.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-theme-templates.png}
\caption{Each theme template provides a portion of the page's markup and
functionality.}
\end{figure}

\begin{itemize}
\item
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-template/portal-template-freemarker/src/main/resources/FTL_liferay.ftl}{\texttt{FTL\_Liferay.ftl}}:
  Provides
  \href{/docs/7-2/reference/-/knowledge_base/r/product-freemarker-macros}{macros}
  for commonly used portlets and theme resources.
\item
  \texttt{taglib-mappings.properties}: Maps the portal taglibs to
  FreeMarker macros. Taglibs can quickly create common UI components.
  This properties file is provided separately for each app taglib. For
  convenience, these FreeMarker macros appear in the
  \href{/docs/7-2/reference/-/knowledge_base/r/freemarker-taglib-macros}{FreeMarker
  Taglib Mappings reference guide}. See the
  \href{/docs/7-2/reference/-/knowledge_base/r/front-end-taglibs}{Taglib
  reference} for more information on using each taglib in your theme
  templates.
\end{itemize}

\section{CSS Frameworks and
Extensions}\label{css-frameworks-and-extensions}

Themes are integrated with \href{https://sass-lang.com/}{SASS}, so you
can take full advantage of Sass mixins, nesting, partials, and variables
in your CSS.

Also important to note is \href{https://clayui.com/}{Clay CSS}, the web
implementation of Liferay's \href{https://lexicondesign.io/}{Lexicon
design language}. An extension of Bootstrap, Clay CSS fills the gaps
between Bootstrap and the needs of Liferay DXP, providing additional
components and CSS patterns that you can use in your themes. Clay base,
Liferay's Bootstrap API extension, along with Atlas, a custom Bootstrap
theme, creates Liferay DXP's Classic theme. See
\href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-atlas-and-clay-base-themes}{Customizing
Atlas and Clay Base Themes} for more information.

\section{Theme Customizations and
Extensions}\label{theme-customizations-and-extensions}

The theme templates, along with the CSS, provide much of the overall
look and feel for the page, but additional extension
points/customizations are available. The following extensions and
mechanisms are available for themes:

\begin{itemize}
\tightlist
\item
  \textbf{Color Schemes:} Specifies configurable color scheme settings
  Administrators can configure via the Look and Feel menu. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-color-schemes-for-your-theme}{color
  scheme tutorial} for more information.
\item
  \textbf{Configurable Theme Settings:} Administrators can configure
  theme aspects that change frequently, such as the visibility of
  certain elements, changing a daily quote, etc. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/making-configurable-theme-settings}{Configurable
  Theme Settings tutorial} for more information.
\item
  \textbf{Context Contributor:} Exposes Java variables and functionality
  for use in FreeMarker templates. This allows non-JSP templating
  languages in themes, widget templates, and any other templates. See
  the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/injecting-additional-context-variables-and-functionality-into-your-theme-templates}{Context
  Contributors tutorial} or more information.
\item
  \textbf{Theme Contributor:} A package containing UI resources, not
  attached to a theme, that you want to include on every page. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/packaging-independent-ui-resources-for-your-site}{Theme
  Contributors tutorial} for more information.
\item
  \textbf{Themelet:} Small, extendable, and reusable pieces of code
  containing CSS and JavaScript. They can be shared with other
  developers to provide common components for themes. See
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
  Themelets} for more information.
\end{itemize}

\section{Portlet Customizations and
Extensions}\label{portlet-customizations-and-extensions}

You can customize portlets with these mechanisms and extensions:

\begin{itemize}
\tightlist
\item
  \textbf{Portlet FTL Customizations:} Customize the base template
  markup for all portlets. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/theming-portlets}{Theming
  Portlets} for more information.
\item
  \textbf{Widget Templates:} Provides an alternate display style for a
  portlet. Note that not all portlets support widget templates. See the
  \href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Widget
  Templates User Guide} for more information.
\item
  \textbf{Portlet Decorator:} Customizes the exterior decoration for a
  portlet. See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/theming-portlets\#portlet-decorators}{Portlet
  Decorators} for more information.
\item
  \textbf{Web Content Template:} Defines how structures are displayed
  for web content. See the
  \href{/docs/7-2/user/-/knowledge_base/u/designing-web-content-with-templates}{Web
  Content Templates User Guide articles} for more information.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-portlet-customizations.png}
\caption{There are several extension points for customizing portlets}
\end{figure}

\section{Related Topics}\label{related-topics-12}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/understanding-the-page-structure}{Understanding
  the Page Structure}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Installing
  the Theme Generator and Creating a Theme}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-themes}{Developing
  Themes}
\end{itemize}

\chapter{Understanding the Page
Structure}\label{understanding-the-page-structure}

Understanding the page's structure is crucial to targeting the correct
markup for styling, organizing your content, and creating your site.
Your page layout is unique to the requirements and design for your site.
The Unstyled theme's default page layout is organized into three key
sections in its \texttt{portal\_normal.ftl} template:

\begin{itemize}
\tightlist
\item
  \textbf{Header:} Contains the navigation, site logo and title (if
  shown), and sign-in link when the user isn't logged in.
\item
  \textbf{Main Content:} Contains the portlets or fragments for the
  page.
\item
  \textbf{Footer:} contains additional information, such as the
  copyright or author.
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-sections.png}
\caption{The page layout is broken into three key sections.}
\end{figure}

\section{Portlets or Fragments}\label{portlets-or-fragments}

The \texttt{\#content} \texttt{Section} makes up the majority of the
page. Portlets or fragments are contained inside the
\texttt{\#main-content} \texttt{div}. Liferay DXP ships with a default
set of applications that provide common functionality, such as forums
and Wikis, documents and media, blogs, and more. For more information on
using Liferay DXP and its native portlets, see the
\href{/documentation/user}{User \& Admin documentation}. You can also
create custom portlets for your site. Portlets can be added via the Add
Menu (referred to as widget), included in a sitemap through the
\href{/docs/7-2/frameworks/-/knowledge_base/f/importing-resources-with-a-theme}{Resources
Importer}, or they can be
\href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes}{embedded
in the page's theme}. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{portlet
tutorials section} for more information on creating and developing
portlets.

You can target the elements and IDs shown in the table below to style
the page:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Element
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{div} & \texttt{\#wrapper} & The container div for the page
contents \\
\texttt{header} & \texttt{\#banner} & The page's header \\
\texttt{section} & \texttt{\#content} \textgreater{}
\texttt{\#main-content} & The main contents of the page (portlets or
fragments) \\
\texttt{footer} & \texttt{\#footer} & The page's footer \\
\end{longtable}

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/portal-layout-elements.png}
\caption{Each section of the page has elements and IDs that you can
target for styling.}
\end{figure}

As shown in the diagram above, you can also add
\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{fragments}
to a page. Fragments are components---composed of CSS, JavaScript, and
HTML---that provide key pieces of functionality for the page (i.e.~a
carousel or banner). Liferay DXP provides an editor for creating
collections of fragments that you can then add to the page. These
fragments can be edited on the page to suit your vision.

\section{Layout Templates, Page Templates, and Site
Templates}\label{layout-templates-page-templates-and-site-templates}

The page layout within the \texttt{\#content} Section is determined by
the
\href{/docs/7-2/frameworks/-/knowledge_base/f/layout-templates-intro}{Layout
Template}. Several layout templates are included out-of-the-box. You can
also
\href{/docs/7-2/frameworks/-/knowledge_base/f/layout-templates-intro}{create
custom layout templates manually} or with the
\href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Liferay
Theme Generator's layout sub-generator}.

Layout templates can be pre-configured depending on the
\href{/docs/7-2/user/-/knowledge_base/u/creating-pages}{page type} you
choose when the page is created. Along with setting the types of
portlets to include on the page, the page template may also define the
default layout template for the page. Climbing further up the scope
chain, you can create
\href{/docs/7-2/user/-/knowledge_base/u/building-sites-from-templates}{Site
Templates}, which can define the pages, page templates, layout
templates, and theme(s) to use for site pages.

\section{Product Navigation Sidebars and
Panels}\label{product-navigation-sidebars-and-panels-1}

The main page layout also contains a few notable sidebars an
administrative user can trigger through the Control Menu. These are
listed below:

\begin{itemize}
\tightlist
\item
  \textbf{Add Menu:} For adding portlets (widgets) and fragments (if
  applicable) to the page
\item
  \textbf{Control Menu:} Provides the main navigation for accessing the
  Add Menu, Product Menu, and Simulation Panel
\item
  \textbf{Product Menu:} Contains administrative apps, configuration
  settings, and user account settings, profile, and dashboard page
\item
  \textbf{Simulation Panel:} Simulates how the page appears on different
  devices
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-nav-control-menu.png}
\caption{Remember to account for the product navigation sidebars and
panels when styling your site.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-nav-add-menu.png}
\caption{The Add Menu pushes the main contents to the left.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-nav-product-menu.png}
\caption{The Product Menu pushes the main contents to the right.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/portal-layout-nav-simulation-panel.png}
\caption{The Simulation Panel pushes the main contents to the left.}
\end{figure}

When styling the page, you must keep the navigation menus in mind,
especially for absolutely positioned elements, such as a fixed navbar.
If the user is logged in and can view the Control Menu, the fixed navbar
must have a top margin equal to the Control Menu's height.

See the
\href{/docs/7-2/customization/-/knowledge_base/c/product-navigation}{Product
Navigation articles} for more information on customizing these menus.

\section{Related Topics}\label{related-topics-13}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Creating
  Layout Templates with the Layouts Sub-generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/including-layout-templates-with-a-theme}{Bundling
  Layout Templates with a Theme}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Installing
  the Liferay Theme Generator and Creating a Theme}
\end{itemize}

\chapter{Bundle Classloading Flow}\label{bundle-classloading-flow}

The OSGi container searches several places for imported classes. It's
important to know where it looks and in what order. Liferay DXP's
classloading flow for OSGi bundles follows the OSGi Core specification.
It's straightforward, but complex. The figure below illustrates the flow
and this article walks you through it.

\begin{figure}
\centering
\includegraphics{./images/bundle-classloading-flow-chart.png}
\caption{This flow chart illustrates classloading in a bundle.}
\end{figure}

Here is the algorithm for classloading in a bundle:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If the class is in a \texttt{java.*} package, delegate loading to the
  parent classloader. Otherwise, continue.
\item
  If the class is in the OSGi Framework's boot delegation list, delegate
  loading to the parent classloader. Otherwise, continue.
\item
  If the class is in one of the packages the bundle imports from a wired
  exporter, the exporting bundle's classloader loads it. A \emph{wired
  exporter} is another bundle's classloader that previously loaded the
  package. If the class isn't found, continue.
\item
  If the class is imported by one of the bundle's required bundles, the
  required bundle's classloader loads it.
\item
  If the class is in the bundle's classpath (manifest header
  \texttt{Bundle-ClassPath}), the bundle's classloader loads it.
  Otherwise, continue.
\item
  If the class is in the bundle's fragments classpath, the bundle's
  classloader loads it.
\item
  If the class is in a package that's dynamically imported using
  \texttt{DynamicImport-Package} and a wire is established with the
  exporting bundle, the exporting bundle's classloader loads it.
  Otherwise, the class isn't found.
\end{enumerate}

Congratulations! Now you know how Liferay DXP finds and loads classes
for OSGi bundles.

\chapter{Finding Extension Points}\label{finding-extension-points}

Liferay DXP provides many features that help users accomplish their
tasks. Sometimes, however, you may find it necessary to
\href{/docs/7-2/customization/-/knowledge_base/c/liferay-customization}{customize
a built-in feature}. It's easy to \textbf{find} an area you want to
customize, but it may seem like a daunting task to figure out
\textbf{how} to customize it. Liferay DXP was developed for easy
customization, meaning it has many extension points you can use to add
your own flavor.

There's a process you can follow that makes finding an extension point a
breeze.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Locate the bundle (module) that provides the functionality you want to
  change.
\item
  Find the components available in the module.
\item
  Discover the extension points for the components you want to
  customize.
\end{enumerate}

This article demonstrates finding an extension point. It steps through a
simple example that locates an extension point for importing LDAP users.
The example includes using Liferay DXP's
\href{/docs/7-2/user/-/knowledge_base/u/managing-and-configuring-apps\#using-the-app-manager}{Application
Manager} and
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell}.

\section{Locate the Related Module and
Component}\label{locate-the-related-module-and-component}

First think of words that describe the application behavior you want to
change. The right keywords can help you easily track down the desired
module and its component. Consider the example for importing LDAP users.
Some candidate keywords for finding the component are \emph{import},
\emph{user}, \emph{security, }and \emph{LDAP}.

The easiest way to discover the module responsible for a particular
Liferay feature is to use the Application Manager. The Application
Manager lists apps and their included modules/components in an
easy-to-use interface. It even lists third party apps! You'll use your
keywords to target the applicable component.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the App Manager by navigating to \emph{Control Panel} →
  \emph{Apps} → \emph{App Manager}. The top level lists independent apps
  and independent modules.
\item
  Navigate the apps and modules to find components that might provide
  your desired extension point. Remember to check for your keywords in
  element names. The keyword \emph{security} is found in the Liferay CE
  Portal Security app. Select it.
\item
  The Security application has several modules to inspect. Select the
  \emph{Liferay Portal Security LDAP Implementation} module.

  \begin{figure}
  \centering
  \includegraphics{./images/ldapimplementation-module.png}
  \caption{The module name can be found using the App Manager.}
  \end{figure}
\item
  Search through the components, applying your keywords as a guide. Copy
  the component name you think best fits the functionality you want to
  customize; you'll inspect it later using the Gogo shell.

  \begin{figure}
  \centering
  \includegraphics{./images/usermodellistener-component.png}
  \caption{The component name can be found using the App Manager.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** When using the Gogo shell later, understand that it can take 
 several tries to find the component you're looking for; Liferay's naming 
 conventions facilitate finding extension points in a manageable time frame. 
\end{verbatim}

\noindent\hrulefill

Next, you'll use the Gogo shell to inspect the component for extension
points.

\section{Finding Extension Points in a
Component}\label{finding-extension-points-in-a-component}

Once you have the component that relates to the functionality you want
to extend, you can use the Gogo shell's Service Component Runtime (SCR)
commands to inspect it. You can execute SCR commands using
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Liferay Blade
CLI} or in
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell}. This article assumes you're using the Gogo shell.

Execute the following command:

\begin{verbatim}
scr:info [COMPONENT_NAME]
\end{verbatim}

For the LDAP example component you copied previously, the command would
look like this:

\begin{verbatim}
scr:info com.liferay.portal.security.ldap.internal.messaging.UserImportMessageListener
\end{verbatim}

The output includes a lot of information. For this exercise, you're
interested in services the component references. They are extension
points. For example, here's the reference for the service that imports
LDAP users:

\begin{verbatim}
- _ldapUserImporter: 
  com.liferay.portal.security.ldap.exportimport.LDAPUserImporter 
  SATISFIED 
  1..1 
  dynamic+greedy
    target=(*) scope=bundle (1 binding):
    * Bound to [7764] from bundle 1754 (com.liferay.portal.security.ldap.impl:2.0.4)
\end{verbatim}

The \texttt{LDAPUserImporter} is the extension point for customizing the
LDAP user import process! If none of the references satisfy what you're
looking for, search other components from the App Manager.

If you plan on overriding the referenced service, you'll need to
understand the reference's policy and policy option. In the example, the
policy is \texttt{dynamic} and the policy option is \texttt{greedy}. If
the policy is \texttt{static} and the policy option is
\texttt{reluctant}, binding a new higher ranking service in place of a
bound service requires reactivating the component or changing the
target. For information on the other policies and policy options, visit
the \href{https://osgi.org/download/r6/osgi.enterprise-6.0.0.pdf}{OSGi
specification}, in particular, sections 112.3.5 and 112.3.6. See
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-osgi-services}{Overriding
OSGi Services} to learn how to override a component's service reference.

\textbf{Important} Not all Liferay extension points are available as
referenced services. Service references are common in Declarative
Services (DS) components, but extension points can be exposed in other
ways too. Here's a brief list of other potential extension points in
Liferay DXP:

\begin{itemize}
\tightlist
\item
  Instances of
  \texttt{org.osgi.util.tracker.ServiceTracker\textless{}S,\ T\textgreater{}}
\item
  Uses of Liferay's \texttt{Registry.getServiceTracker}
\item
  Uses of Liferay's \texttt{ServiceTrackerMap} or
  \texttt{ServiceTrackerCollection}
\item
  Any other component framework or whiteboard implementation (e.g.,
  HTTP, JAX-RS) that supports tracking services; Blueprint, Apache
  Dependency Manager, etc. could also introduce extension points.
\end{itemize}

There you have it! In the App Manager, you used keywords to find the
module component whose behavior you wanted to change. Then you used Gogo
shell to find the component extension point for implementing your
customization.

\chapter{Troubleshooting
Customizations}\label{troubleshooting-customizations}

When coding on any platform, you can sometimes run into issues that have
no clear resolution. This can be particularly frustrating. If you have
issues building, deploying, or running apps and modules, you want to
resolve them fast. These frequently asked questions and answers help you
troubleshoot and correct problems.

Click a question to view the answer.

{Why aren't my fragment's JSP overrides showing?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/customization/-/knowledge_base/c/why-arent-jsp-overrides-i-made-using-fragments-showing">Make sure your <code>Fragment-Host</code>'s bundle version is compatible with the host's bundle version</a>. </p>
\end{verbatim}

{Why doesn't the package I use from the fragment host resolve?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/customization/-/knowledge_base/c/why-is-a-package-i-use-from-the-fragment-host-unresolved">Refrain from importing (<code>Import-Package: ...</code>) host packages that the host doesn't export</a>. </p>
\end{verbatim}

\phantomsection\label{cacheable-web-content-taglibs}
{Why does my web content break when I refresh the page?~{}}

\begin{verbatim}
<p>Some taglibs, such as the <code>liferay-map</code> taglib, have limitations when used in a cacheable template (e.g., FreeMarker and Velocity). For instance, when the <code>liferay-map</code> taglib is used in a cacheable template and the user refreshes the page, the map does not show. </p>
<p>One possible workaround is to disable cache for the template by editing it and unchecking the cacheable option. Alternatively, you can disable cache for all templates by navigating to <code>System Settings</code>&rarr;<code>Template Engines</code> and setting <code>Resource Modification Check</code> to <code>0</code>. </p>
<p>As best practice, however, we recommend that you don't use taglibs in cacheable web content. </p>
\end{verbatim}

\chapter{Why doesn't the package I use from the fragment host
resolve?}\label{why-doesnt-the-package-i-use-from-the-fragment-host-resolve}

An OSGi fragment can access all of the fragment host's packages---it
doesn't need to import them from another bundle. bnd adds external
packages the fragment uses (even ones in the fragment host) to the
fragment's \texttt{Import-Package:\ {[}package{]},...} OSGi manifest
header. That's fine for packages exported to the OSGi runtime. The
problem is, however, when bnd tries to import a host's internal package
(a package the host doesn't export). The OSGi runtime can't activate the
fragment because the internal package remains an
\texttt{Unresolved\ requirement}---a fragment shouldn't import a
fragment host's packages.

Resolve the issue by explicitly excluding host packages that the host
doesn't export.

For example, this fragment bundle's JSP uses classes from the fragment
host bundle's internal package
\texttt{com.liferay.portal.search.web.internal.custom.facet.display.context}:

\begin{verbatim}
<%@
page import="com.liferay.portal.search.web.internal.custom.facet.display.context.CustomFacetDisplayContext" %><%@
page import="com.liferay.portal.search.web.internal.custom.facet.display.context.CustomFacetTermDisplayContext" %>
\end{verbatim}

Since the example host bundle doesn't export the package, the fragment
bundle can avoid importing the package by using an OSGi manifest header,
like the one below, to explicitly exclude the package from package
imports:

\begin{verbatim}
Import-Package: !com.liferay.portal.search.web.internal.*,*
\end{verbatim}

\chapter{Why Aren't JSP overrides I Made Using Fragments
Showing?}\label{why-arent-jsp-overrides-i-made-using-fragments-showing}

\noindent\hrulefill

\textbf{Important:} It's strongly recommended to
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{customize
JSPs using Liferay DXP's API}. Since overriding a JSP using an OSGi
fragment is not based on APIs there's no way to guarantee that it will
fail gracefully. Instead, if your customization is buggy (because of
your code or because of a change in Liferay), you are most likely to
find out at runtime, where functionality breaks and nasty log errors
greet you. Overriding a JSP using a fragment should only be used as a
last resort.

\noindent\hrulefill

The fragment module must specify the exact version of the host module. A
Liferay DXP upgrade might have changed some JSPs in the host module,
prompting a version update. If this occurs, check that your JSP
customizations are compatible with the updated host JSPs and then update
your fragment module's targeted version to match the host module.

For example, this \texttt{bnd.bnd} file from a fragment module uses
\texttt{Fragment-Host} to specify the host module and host module
version:

\begin{verbatim}
Bundle-Name: custom-login-jsp
Bundle-SymbolicName: custom.login.jsp
Bundle-Version: 1.0.0
Fragment-Host: com.liferay.login.web;bundle-version="1.1.18"
\end{verbatim}

\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{Finding
versions of deployed modules} is straightforward.

\section{Related Topics}\label{related-topics-14}

\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
Overrides using Portlet Filters}

\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{Customizing
JSPs}

\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{Finding
Artifacts}

\chapter{Using OSGi Services from EXT
Plugins}\label{using-osgi-services-from-ext-plugins}

\href{/docs/7-2/frameworks/-/knowledge_base/f/service-trackers-for-osgi-services}{\texttt{ServiceTrackers}}
are the best way for Ext plugins to access OSGi services. They account
for the possibility of OSGi services coming and going.

\section{Related Topics}\label{related-topics-15}

\href{/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\chapter{Contributing to Liferay
Portal}\label{contributing-to-liferay-portal}

Liferay Portal is developed by its community consisting of users,
enthusiasts, employees, customers, partners, and others. We strongly
encourage you to contribute to Liferay's open source projects by
implementing new features, enhancing existing features, and fixing bugs.
We also welcome your participation in our forums, chat, writing
documentation, and translating existing documentation.

Liferay Portal is known for its innovative top quality features. To
maintain this reputation, all code changes are reviewed by a core set of
project maintainers. We encourage you to join our
\href{https://liferay-community.slack.com}{Slack Chat} and introduce
yourself to the core maintainer(s) and engage them as you contribute to
the areas they maintain.

Developing features and fixes requires cloning the source tree and
building Liferay Portal.

\section{Building Liferay Portal from
source}\label{building-liferay-portal-from-source}

The first step to contributing to Liferay Portal is to clone the
\texttt{liferay-portal} repo from GitHub and build the platform from
source code.

Please follow the instructions for
\href{https://portal.liferay.dev/participate/fix-a-bug/building-liferay-source}{building
Liferay Portal from source code}.

To better understand the code structure, please also read
\href{https://portal.liferay.dev/participate/fix-a-bug/how-the-source-is-organized}{How
the source is organized}.

\section{Tooling}\label{tooling}

\href{/docs/7-2/reference/-/knowledge_base/r/tooling}{Liferay tooling}
facilitates creating customizations and debugging code. Consider using
these Liferay development tools:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}: a
  command line interface used to build and manage Liferay Workspaces and
  Liferay Portal projects. This CLI is intended for Gradle or Maven
  development.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
  Workspace}: a generated Gradle/Maven environment built to hold and
  manage Liferay Portal projects.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
  Dev Studio}: an Eclipse-based IDE supporting development for Liferay
  Portal.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/intellij}{Liferay
  IntelliJ Plugin}: a plugin providing support for Liferay Portal
  development with IntelliJ IDEA.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{Liferay
  Theme Generator}: a generator that creates themes, layouts templates,
  and themelets for Liferay Portal development.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/js-generator}{Liferay JS
  Generator}: a generator that creates JavaScript portlets with
  JavaScript tooling.
\end{itemize}

The
\href{https://portal.liferay.dev/participate/fix-a-bug/ide-support}{Configure
an IDE for use with the Liferay Source} page, explains how to set up the
project in your favorite IDE.

\section{Additional Resources}\label{additional-resources}

\href{https://liferay.dev}{Liferay Community Site}

\href{https://liferay-community.slack.com/}{Liferay Community Slack
Chat}

\href{https://liferay.dev/chat}{Liferay Community Slack Chat Self
Invite}

\href{https://www.liferay.com/legal/contributors-agreement}{Contributor
License Agreement}

\href{http://help.github.com/}{General GitHub documentation}

\href{http://help.github.com/send-pull-requests/}{GitHub pull request
documentation}

\chapter{Model Listeners}\label{model-listeners}

Model Listeners implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/ModelListener.html}{\texttt{ModelListener}
interface}. They are used to listen for persistence events on models and
do something in response (either before or after the event).

Model listeners are designed to perform lightweight actions in response
to a \texttt{create}, \texttt{remove}, or \texttt{update} attempt on an
entity's database table or a mapping table (for example,
\texttt{users\_roles}). Here are some supported use cases:

\begin{itemize}
\tightlist
\item
  Audit Listener: In a separate database, record information about
  updates to an entity's database table.
\item
  Cache Clearing Listener: Clear caches that you've added to improve the
  performance of custom code.
\item
  Validation Listener: Perform additional validation on a model's
  attribute values before they are persisted to the database.
\item
  Entity Update Listener: Do some additional processing when an entity
  table is updated. For example, notify users when changes are made to
  their account.
\end{itemize}

There are also use cases that are not recommended, since they're likely
to break unpredictably and give you headaches:

\begin{itemize}
\tightlist
\item
  Setting a model's attributes in an \texttt{onBeforeUpdate} call. If
  some other database table has already been updated with the values
  before your model listener is invoked, your database gets out of sync.
  To change how an entity's attributes are set, consider using a
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{service
  wrapper} instead.
\item
  Wrapping a model. Model listeners are not called when fetching records
  from the database.
\item
  Creating worker threads to do parallel processing and querying data
  you updated via your listener. Model listeners are called
  \emph{before} the database transaction is complete (even the
  \texttt{onAfter...} methods), so the queries could be executed before
  the database transaction completes.
\end{itemize}

If there is no existing listener on the model, your model listener is
the only one that runs. However, there can be multiple listeners on a
single model, and the order in which the listeners run cannot be
controlled.

You can create a model listener in a module by doing two simple things:

\begin{itemize}
\tightlist
\item
  Implement \texttt{ModelListener}
\item
  Register the service in Liferay's OSGi runtime
\end{itemize}

\section{Creating a Model Listener
Class}\label{creating-a-model-listener-class}

Create a \texttt{-ModelListener} class that extends the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/BaseModelListener.html}{\texttt{BaseModelListener}
class}.

\begin{verbatim}
package ...;

import ...;

public class CustomEntityListener extends BaseModelListener<CustomEntity> {

    // Override one or more methods from the ModelListener interface.
    
}
\end{verbatim}

In the body of the class, override any methods from the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/ModelListener.html}{\texttt{ModelListener}
interface}. The available methods are listed and described at the end of
this article.

In your model listener class, the parameterized type (for example,
\texttt{CustomEntity} in the snippet above) tells the listener's
\texttt{ServiceTrackerCustomizer} which model class to register the
listener against.

\section{Register the Model Listener
Service}\label{register-the-model-listener-service}

Register the service with Liferay's OSGi runtime for immediate
activation. If using Declarative Services, set
\texttt{service=\ ModelListener.class} and \texttt{immediate=true} in
the Component:

\begin{verbatim}
@Component(
    immediate = true,
    service = ModelListener.class
)
\end{verbatim}

That's all there is to preparing a model listener. Now learn what model
events you can respond to.

\section{Listening For Persistence
Events}\label{listening-for-persistence-events}

The \texttt{ModelListener} interface provides lots of opportunity to
listen for model events:

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{onAfterAddAssociation}:} If there's an association
  between two models (if they have a mapping table), use this method to
  do something after an association record is added.
\item
  \textbf{\texttt{onAfterCreate}:} Use this method to do something after
  the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onAfterRemove}:} Use this method to do something after
  the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onAfterRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something after
  an association record is removed.
\item
  \textbf{\texttt{onAfterUpdate}:} Use this method to do something after
  the persistence layer's \texttt{update} method is called.
\item
  \textbf{\texttt{onBeforeAddAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  an addition to the mapping table.
\item
  \textbf{\texttt{onBeforeCreate}:} Use this method to do something
  before the persistence layer's \texttt{create} method is called.
\item
  \textbf{\texttt{onBeforeRemove}:} Use this method to do something
  before the persistence layer's \texttt{remove} method is called.
\item
  \textbf{\texttt{onBeforeRemoveAssociation}:} If there's an association
  between two models (if they have a mapping table), do something before
  a removal from the mapping table.
\item
  \textbf{\texttt{onBeforeUpdate}:} Use this method to do something
  before the persistence layer's \texttt{update} method is called.
\end{itemize}

Look in Liferay source file
\texttt{portal-kernel/src/com/liferay/portal/kernel/service/persistence/impl/BasePersistenceImpl.java},
particularly the \texttt{remove} and \texttt{update} methods, and you'll
see how model listeners are accounted for before (for the
\texttt{onBefore...} case) and after (for the \texttt{onAfter...} case)
the model persistence event.

Now that you know how to create model listeners, keep in mind that
they're useful as standalone projects or inside of your application. If
your application needs to do something (like add a custom entity) every
time a User is added in Liferay, you can include the model listener
inside your application.

\section{Related Topics}\label{related-topics-16}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-model-listener-hooks}{Upgrading
  Model Listener Hooks}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder Persistence}
\end{itemize}

\chapter{Customizing JSPs}\label{customizing-jsps}

There are several different ways to customize JSPs in portlets and the
core. Liferay DXP's API provides the safest ways to customize them. If
you customize a JSP by other means, new versions of the JSP can render
your customization invalid and leave you with runtime errors. It's
highly recommended to use one of the API-based ways.

\section{Using Liferay DXP's API to Override a
JSP}\label{using-liferay-dxps-api-to-override-a-jsp}

Here are API-based approaches to overriding JSPs in Liferay DXP:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps-with-dynamic-includes}{Dynamic
includes} & Adds content at dynamic include tags. & Limited to JSPs that
have \texttt{dynamic-include} tags (or tags whose classes inherit from
\texttt{IncludeTag}). Only inserts content in the JSPs at the dynamic
include tags. \\
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{Portlet
filters} & Modifies portlet requests and/or responses to simulate a JSP
customization. & Although this approach doesn't directly customize a
JSP, it achieves the effect of a JSP customization. \\
\end{longtable}

\section{Overriding a JSP Without Using Liferay DXP's
API}\label{overriding-a-jsp-without-using-liferay-dxps-api}

It's strongly recommended to customize JSPs using Liferay DXP's API, as
the previous section describes. Since overriding a JSP using an OSGi
fragment or a Custom JSP Bag is not based on APIs there's no way to
guarantee that they'll fail gracefully. Instead, if your customization
is buggy (because of your code or because of a change in Liferay), you
are most likely to find out at runtime, where functionality breaks and
nasty log errors greet you. These approaches should only be used as a
last resort.

If you're maintaining a JSP customization that uses one of these
approaches, you should know how they work. This section describes them
and links to their tutorials.

Here are ways to customize JSPs without using Liferay DXP's API:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Approach}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Cons/Limitations}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-osgi-fragments}{OSGi
fragment} & Completely overrides a module's JSP using an OSGi fragment &
Changes to the original JSP or module can cause runtime errors. \\
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-custom-jsp-bag}{Custom
JSP bag} & Completely override a Liferay DXP core JSP or one of its
corresponding \texttt{-ext.jsp} files. & For Liferay DXP core JSPs only.
Changes to the original JSP or module can cause runtime errors. \\
\end{longtable}

All the JSP customization approaches are available to you. It's time to
customize some JSPs!

\chapter{Customizing JSPs with Dynamic
Includes}\label{customizing-jsps-with-dynamic-includes}

The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/liferay-util/dynamic-include.html}{\texttt{liferay-util:dynamic-include}
tag} is placeholder into which you can inject content. Every JSP's
dynamic include tag is an extension point for inserting content (e.g.,
JavaScript code, HTML, and more). To do this, create a module that has
content you want to insert, register that content with the dynamic
include tag, and deploy your module.

\noindent\hrulefill

\textbf{Note}: If the JSP you want to customize has no
\texttt{liferay-util:dynamic-include} tags (or tags whose classes
inherit from \texttt{IncludeTag}), you must use a different
customization approach, such as
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{portlet
filters}.

\noindent\hrulefill

Blogs entries contain a good example of how dynamic includes work. For
reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-dynamic-include-blogs-master.zip}{example
module}.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Find the \texttt{liferay-util:dynamic-include} tag where you want to
  insert content and note the tag's key.

  The Blogs app's \texttt{view\_entry.jsp} has a dynamic include tag at
  the top and another at the very bottom.

\begin{verbatim}
<%@ include file="/blogs/init.jsp" %>

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#pre" />

    ... JSP content is here

<liferay-util:dynamic-include key="com.liferay.blogs.web#/blogs/view_entry.jsp#post" />
\end{verbatim}

  Here are the Blogs view entry dynamic include keys:

  \begin{itemize}
  \tightlist
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#pre"}
  \item
    \texttt{key="com.liferay.blogs.web\#/blogs/view\_entry.jsp\#post"}
  \end{itemize}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module} (e.g., \texttt{blade\ create\ my-dynamic-include}). The
  module will hold your dynamic include implementation.
\item
  Specify compile-only dependencies, like these Gradle dependencies, in
  your module build file:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "1.0.0"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}
\item
  Create an OSGi component class that implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.html}{\texttt{DynamicInclude}
  interface}.

  Here's an example dynamic include implementation for Blogs:

\begin{verbatim}
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.servlet.taglib.DynamicInclude;

@Component(
    immediate = true,
    service = DynamicInclude.class
)
public class BlogsDynamicInclude implements DynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        printWriter.println(
            "<h2>Added by Blogs Dynamic Include!</h2><br />");
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register(
            "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
    }

}
\end{verbatim}

  Giving the class an \texttt{@Component} annotation that has the
  service attribute \texttt{service\ =\ DynamicInclude.class} makes the
  class a \texttt{DynamicInclude} service component.

\begin{verbatim}
@Component(
    immediate = true,
    service = DynamicInclude.class
)
\end{verbatim}

  In the \texttt{include} method, add your content. The example
  \texttt{include} method writes a heading.

\begin{verbatim}
@Override
public void include(
        HttpServletRequest request, HttpServletResponse response,
        String key)
    throws IOException {

    PrintWriter printWriter = response.getWriter();

    printWriter.println(
    "<h2>Added by Blogs Dynamic Include!</h2><br />");
}
\end{verbatim}

  In the \texttt{register} method, specify the dynamic include tag to
  use. The example register method targets the dynamic include at the
  top of the Blogs \texttt{view\_entry.jsp}.

\begin{verbatim}
@Override
public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
    dynamicIncludeRegistry.register(
        "com.liferay.blogs.web#/blogs/view_entry.jsp#pre");
}
\end{verbatim}
\end{enumerate}

Once you've
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deployed
your module}, the JSP dynamically includes your content. Congratulations
on injecting dynamic content into a JSP!

\chapter{JSP Overrides Using Portlet
Filters}\label{jsp-overrides-using-portlet-filters}

Portlet filters let you intercept portlet requests before they're
processed and portlet responses after they're processed but before
they're sent back to the client. You can operate on the request and / or
response to modify the JSP content. Unlike dynamic includes, portlet
filters give you access to all the content sent back to the client.

This demonstration uses a portlet filter to modify content in Liferay's
Blogs portlet. For reference, you can download the
\href{https://portal.liferay.dev/documents/113763090/114000186/example-portlet-filter-customize-jsp-master.zip}{example
module}.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new module and make sure it specifies these compile-only
  dependencies, shown here in Gradle format:

\begin{verbatim}
dependencies {
    compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "osgi.cmpn", version: "6.0.0"
}
\end{verbatim}
\item
  Create an OSGi component class that implements the
  \texttt{javax.portlet.filter.RenderFilter} interface.

  Here's an example portlet filter implementation for Blogs:

\begin{verbatim}
import java.io.IOException;

import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;
import javax.portlet.filter.FilterChain;
import javax.portlet.filter.FilterConfig;
import javax.portlet.filter.PortletFilter;
import javax.portlet.filter.RenderFilter;
import javax.portlet.filter.RenderResponseWrapper;

import org.osgi.service.component.annotations.Component;

import com.liferay.portal.kernel.util.PortletKeys;

@Component(
    immediate = true,
    property = {
            "javax.portlet.name=" + PortletKeys.BLOGS
    },
    service = PortletFilter.class
)
public class BlogsRenderFilter implements RenderFilter {

    @Override
    public void init(FilterConfig config) throws PortletException {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
            throws IOException, PortletException {

        RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

        chain.doFilter(request, renderResponseWrapper);

        String text = renderResponseWrapper.toString();

        if (text != null) {
            String interestingText = "<input  class=\"field form-control\"";

            int index = text.lastIndexOf(interestingText);

            if (index >= 0) {
                String newText1 = text.substring(0, index);
                String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
                String newText3 = text.substring(index);

                String newText = newText1 + newText2 + newText3;

                response.getWriter().write(newText);
            }
        }
    }

}
\end{verbatim}
\item
  Make your class a \texttt{PortletFilter} service component by giving
  it the \texttt{@Component} annotation that has the service attribute
  \texttt{service\ \ \ \ \ \ =\ PortletFilter.class}. Target the portlet
  whose content you're overriding by assigning it a javax.portlet.name
  property that's the same as your portlet's key. Here's the example
  \texttt{@Component} annotation:

\begin{verbatim}
@Component(
   immediate = true,
   property = {
           "javax.portlet.name=" + PortletKeys.BLOGS
   },
   service = PortletFilter.class
)
\end{verbatim}
\item
  Override the \texttt{doFilterMethod} to operate on the request or
  response to produce the content you want. The example appends a
  paragraph stating \texttt{Added\ \ \ \ \ \ by\ Blogs\ Render\ Filter!}
  to the portlet content:

\begin{verbatim}
@Override
public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
        throws IOException, PortletException {

    RenderResponseWrapper renderResponseWrapper = new BufferedRenderResponseWrapper(response);

    chain.doFilter(request, renderResponseWrapper);

    String text = renderResponseWrapper.toString();

    if (text != null) {
        String interestingText = "<input  class=\"field form-control\"";

        int index = text.lastIndexOf(interestingText);

        if (index >= 0) {
            String newText1 = text.substring(0, index);
            String newText2 = "\n<p>Added by Blogs Render Filter!</p>\n";
            String newText3 = text.substring(index);

            String newText = newText1 + newText2 + newText3;

            response.getWriter().write(newText);
        }
    }
}
\end{verbatim}

  The example uses a \texttt{RenderResponseWrapper} extension class
  called \texttt{BufferedRenderResponseWrapper}.
  \texttt{BufferedRenderResponseWrapper} is a helper class whose
  \texttt{toString} method returns the current response text and whose
  \texttt{getWriter} method lets you write data to the response before
  it's sent back to the client.

\begin{verbatim}
import java.io.CharArrayWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;

import javax.portlet.RenderResponse;
import javax.portlet.filter.RenderResponseWrapper;

public class BufferedRenderResponseWrapper extends RenderResponseWrapper {

    public BufferedRenderResponseWrapper(RenderResponse response) {
        super(response);

        charWriter = new CharArrayWriter();
    }

    public OutputStream getOutputStream() throws IOException {
        if (getWriterCalled) {
            throw new IllegalStateException("getWriter already called");
        }

        getOutputStreamCalled = true;

        return super.getPortletOutputStream();
    }

    public PrintWriter getWriter() throws IOException {
        if (writer != null) {
            return writer;
        }

        if (getOutputStreamCalled) {
            throw new IllegalStateException("getOutputStream already called");
        }

        getWriterCalled = true;

        writer = new PrintWriter(charWriter);

        return writer;
    }

    public String toString() {
        String s = null;

        if (writer != null) {
            s = charWriter.toString();
        }

        return s;
    }

    protected CharArrayWriter charWriter;
    protected PrintWriter writer;
    protected boolean getOutputStreamCalled;
    protected boolean getWriterCalled;

}
\end{verbatim}
\end{enumerate}

Once you've
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deployed
your module}, the portlet's JSP shows your custom content.

Your portlet filter operates directly on portlet response content.
Unlike dynamic includes, portlet filters let you work with all of a
JSP's content.

\chapter{JSP Overrides Using OSGi
Fragments}\label{jsp-overrides-using-osgi-fragments}

You can completely override JSPs using OSGi fragments. This approach is
powerful but can make things unstable when the host module is upgraded:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  By overriding an entire JSP, you might not account for new content or
  new widgets essential to new host module versions.
\item
  Fragments are tied to a specific host module version. If the host
  module is upgraded, the fragment detaches from it. In this scenario,
  the original JSPs are still available and the module is functional
  (but lacks your JSP enhancements).
\item
  Liferay cannot guarantee that JSPs overridden by fragments can be
  upgraded.
\end{enumerate}

Using OSGi fragments to override JSPs is a bad practice, equivalent to
using Ext plugins to customize Liferay DXP. They should only be used as
a last resort. Liferay's API based approaches to overriding JSPs (i.e.,
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps-with-dynamic-includes}{Dynamic
Includes} and
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{Portlet
Filters}), on the other hand, provide more stability as they customize
specific parts of JSPs that are safe to override. Also, the API based
approaches don't limit your override to a specific host module version.
If you are maintaining existing JSP overrides that use OSGi fragments,
however, this tutorial explains how they work.

An OSGi fragment that overrides a JSP requires these two things:

\begin{itemize}
\item
  The host module's symbolic name and version in the OSGi header
  \texttt{Fragment-Host} declaration.
\item
  The original JSP with any modifications you need to make.
\end{itemize}

For more information about fragment modules, you can refer to section
3.14 of the
\href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html}{OSGi
Alliance's core specification document}.

\section{Declaring a Fragment Host}\label{declaring-a-fragment-host}

There are two players in this game: the fragment and the host. The
fragment is a parasitic module that attaches itself to a host. That
sounds harsh, so let's compare the fragment-host relationship to the
relationship between a pilot fish and a huge, scary shark. It's
symbiotic, really. Your fragment module benefits by not doing much work
(like the pilot fish who benefits from the shark's hunting prowess). In
return, the host module gets whatever benefits you've conjured up in
your fragment's JSPs (for the shark, it gets free dental cleanings!). To
the OSGi runtime, your fragment is part of the host module.

Your fragment must declare two things to the OSGi runtime regarding the
host module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Bundle Symbolic Name of the host module. This is the module
  containing the original JSP.
\item
  The exact version of the host module to which the fragment belongs.
\end{enumerate}

Both are declared using the OSGi manifest header \texttt{Fragment-Host}.

\begin{verbatim}
Fragment-Host: com.liferay.login.web;bundle-version="[1.0.0,1.0.1)"
\end{verbatim}

Supplying a specific host module version is important. If that version
of the module isn't present, your fragment won't attach itself to a
host, and that's a good thing. A new version of the host module might
have changed its JSPs, so if your now-incompatible version of the JSP is
applied to the host module, you'll break the functionality of the host.
It's better to detach your fragment and leave it lonely in the OSGi
runtime than it is to break the functionality of an entire application.

\section{Provide the Overridden JSP}\label{provide-the-overridden-jsp}

There are two possible naming conventions for targeting the host
original JSP: \texttt{portal} or \texttt{original}. For example, if the
original JSP is in the folder \texttt{/META-INF/resources/login.jsp},
then the fragment bundle should contain a JSP with the same path, using
the following pattern:

\begin{verbatim}
<liferay-util:include 
    page="/login.original.jsp" (or login.portal.jsp) 
    servletContext="<%= application %>" 
/>
\end{verbatim}

After that, make your modifications. Just make sure you mimic the host
module's folder structure when overriding its JAR. If you're overriding
Liferay's login application's \texttt{login.jsp} for example, you'd put
your own \texttt{login.jsp} in

\begin{verbatim}
my-jsp-fragment/src/main/resources/META-INF/resources/login.jsp
\end{verbatim}

If you must post-process the output, you can update the pattern to
include Liferay DXP's buffering mechanism. Below is an example that
overrides the original \texttt{create\_account.jsp}:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<liferay-util:buffer var="html">
    <liferay-util:include page="/create_account.portal.jsp" 
    servletContext="<%= application %>"/>
</liferay-util:buffer>

<liferay-util:buffer var="openIdFieldHtml"><aui:input name="openId" 
type="hidden" value="<%= ParamUtil.getString(request, "openId") %>" />
</liferay-util:buffer>

<liferay-util:buffer var="userNameFieldsHtml"><liferay-ui:user-name-fields />
</liferay-util:buffer>

<liferay-util:buffer var="errorMessageHtml">
    <liferay-ui:error 
    exception="<%= com.liferay.portal.kernel.exception.NoSuchOrganizationException.class %>" message="no-such-registration-code" />
</liferay-util:buffer>

<liferay-util:buffer var="registrationCodeFieldHtml">
            <aui:input name="registrationCode" type="text" value="">
                    <aui:validator name="required" />
            </aui:input>
</liferay-util:buffer>

<%
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      openIdFieldHtml, openIdFieldHtml + errorMessageHtml);
    html = com.liferay.portal.kernel.util.StringUtil.replace(html, 
      userNameFieldsHtml, userNameFieldsHtml + registrationCodeFieldHtml);
%>

<%=html %>
\end{verbatim}

\section{Using Fragment Host Internal
Packages}\label{using-fragment-host-internal-packages}

To use an internal (unexported) host package, the fragment must
explicitly exclude the package from its \texttt{Import-Package:}
manifest header. For example, this \texttt{Import-Package} header
excludes packages that match
\texttt{com.liferay.portal.search.web.internal.*}.

\begin{verbatim}
Import-Package: !com.liferay.portal.search.web.internal.*,*
\end{verbatim}

Unless you explicitly exclude the package, bnd adds the package to the
\texttt{Import-Package:} header. Attempting to start the fragment while
requiring an unexported package fails because the package is an
unresolved requirement. For this reason, make sure to exclude such
packages from your fragment's \texttt{Import-Package:} header.

Each fragment has full access to the host packages, including its
internal (unexported) packages already.

Now you can easily modify the JSPs of any application in Liferay.

\includegraphics{./images/sharks.jpg}

\section{Related Topics}\label{related-topics-17}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
  Overrides Using Portlet Filters}
\end{itemize}

\chapter{JSP Overrides Using Custom JSP
Bag}\label{jsp-overrides-using-custom-jsp-bag}

Liferay's API based approaches to overriding JSPs (i.e.,
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps-with-dynamic-includes}{Dynamic
Includes} and
\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{Portlet
Filters}) are the best way to override JSPs in apps and in the core. You
can also use Custom JSP Bags to override core JSPs. But the approach is
not as stable as the API based approaches. If your Custom JSP Bag's JSP
is buggy (because of your code or because of a change in Liferay), you
are most likely to find out at runtime, where functionality breaks and
nasty log errors greet you. Using Custom JSP Bags to override JSPs is a
bad practice, equivalent to using Ext plugins to customize Liferay DXP.
If you're maintaining existing Custom JSP Bags, however, this tutorial
explains how they work.

\noindent\hrulefill

\textbf{Important:} Liferay cannot guarantee that JSPs overridden using
Custom JSP Bag can be upgraded.

\noindent\hrulefill

A Custom JSP Bag module must satisfy these criteria:

\begin{itemize}
\item
  Provides and specifies a custom JSP for the JSP you're extending.
\item
  Includes a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}
  implementation for serving the custom JSPs.
\end{itemize}

The module provides transportation for this code into Liferay's OSGi
runtime. After you
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{create
your new module}, continue with providing your custom JSP.

\section{Providing a Custom JSP}\label{providing-a-custom-jsp}

Create your JSPs to override Liferay DXP core JSPs. If you're using the
Maven
\href{https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html}{Standard
Directory Layout}, place your JSPs under
\texttt{src/main/resources/META-INF/jsps}. For example, if you're
overriding

\begin{verbatim}
portal-web/docroot/html/common/themes/bottom-ext.jsp 
\end{verbatim}

place your custom JSP at

\begin{verbatim}
[your module]/src/main/resources/META-INF/jsps/html/common/themes/bottom-ext.jsp
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} If you place custom JSPs somewhere other than
\texttt{src/main/resources/META-INF/jsps} in your module, assign that
location to a \texttt{-includeresource:\ META-INF/jsps=} directive in
your module's \texttt{bnd.bnd} file. For example, if you place custom
JSPs in a folder \texttt{src/META-INF/custom\_jsps} in your module,
specify this in your \texttt{bnd.bnd}:

\begin{verbatim}
 -includeresource: META-INF/jsps=src/META-INF/custom_jsps
\end{verbatim}

\noindent\hrulefill

\section{Implement a Custom JSP Bag}\label{implement-a-custom-jsp-bag}

Liferay DXP (specifically the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBagRegistryUtil.html}{\texttt{CustomJspBagRegistryUtil}
class}) loads JSPs from
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}
services. Here are steps for implementing a custom JSP bag.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your module, create a class that implements
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/deploy/hot/CustomJspBag.html}{\texttt{CustomJspBag}}.
\item
  Register your class as an OSGi service by adding an
  \texttt{@Component} annotation to it, like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "context.id=BladeCustomJspBag",
      "context.name=Test Custom JSP Bag",
        "service.ranking:Integer=100"
    }
)
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \textbf{\texttt{immediate\ =\ true}:} Makes the service available on
    module activation.
  \item
    \textbf{\texttt{context.id}:} Your custom JSP bag class name.
    Replace \texttt{BladeCustomJspBag} with your class name.
  \item
    \textbf{\texttt{context.name}:} A more human readable name for your
    service. Replace it with a name of your own.
  \item
    \textbf{\texttt{service.ranking:Integer}:} A priority for your
    implementation. The container chooses the implementation with the
    highest priority.
  \end{itemize}
\item
  Implement the \texttt{getCustomJspDir} method to return the folder
  path in your module's JAR where the JSPs reside (for example,
  \texttt{META-INF/jsps}).

\begin{verbatim}
@Override
public String getCustomJspDir() {
    return "META-INF/jsps/";
}
\end{verbatim}
\item
  Create an \texttt{activate} method and the following fields. The
  method adds the URL paths of all your custom JSPs to a list when the
  module is activated.

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _bundle = bundleContext.getBundle();

    _customJsps = new ArrayList<>();

    Enumeration<URL> entries = _bundle.findEntries(
        getCustomJspDir(), "*.jsp", true);

    while (entries.hasMoreElements()) {
        URL url = entries.nextElement();

        _customJsps.add(url.getPath());
    }
}

private Bundle _bundle;
private List<String> _customJsps;
\end{verbatim}
\item
  Implement the \texttt{getCustomJsps} method to return the list of this
  module's custom JSP URL paths.

\begin{verbatim}
@Override
public List<String> getCustomJsps() {
    return _customJsps;
}
\end{verbatim}
\item
  Implement the \texttt{getURLContainer} method to return a new
  \texttt{com.liferay.portal.kernel.url.URLContainer}. Instantiate the
  URL container and override its \texttt{getResources} and
  \texttt{getResource} methods. The \texttt{getResources} method looks
  up all the paths to resources in the container by a given path. It
  returns a \texttt{HashSet} of \texttt{Strings} for the matching custom
  JSP paths. The \texttt{getResource} method returns one specific
  resource by its name (the path included).

\begin{verbatim}
@Override
public URLContainer getURLContainer() {
    return _urlContainer;
}

private final URLContainer _urlContainer = new URLContainer() {

    @Override
    public URL getResource(String name) {
        return _bundle.getEntry(name);
    }

    @Override
    public Set<String> getResources(String path) {
        Set<String> paths = new HashSet<>();

        for (String entry : _customJsps) {
            if (entry.startsWith(path)) {
               paths.add(entry);
            }
        }

        return paths;
    }

};
\end{verbatim}
\item
  Implement the \texttt{isCustomJspGlobal} method to return
  \texttt{true}.

\begin{verbatim}
@Override
public boolean isCustomJspGlobal() {
    return true;
}
\end{verbatim}
\end{enumerate}

Now your module provides custom JSPs and a custom JSP bag
implementation. When you deploy it, Liferay DXP uses its custom JSPs in
place of the core JSPs they override.

\section{Extend a JSP}\label{extend-a-jsp}

If you want to add something to a core JSP, see if it has an empty
\texttt{-ext.jsp} and override that instead of the whole JSP. It keeps
things simpler and more stable, since the full JSP might change
significantly, breaking your customization in the process. By overriding
the \texttt{-ext.jsp}, you're only relying on the original JSP including
the \texttt{-ext.jsp}. For an example, open
\texttt{portal-web/docroot/html/common/themes/bottom.jsp}, and scroll to
the end. You'll see this:

\begin{verbatim}
<liferay-util:include page="/html/common/themes/bottom-ext.jsp" />
\end{verbatim}

If you must add something to \texttt{bottom.jsp}, override
\texttt{bottom-ext.jsp}.

Since Liferay DXP 7.0, the content from the following JSP files formerly
in \texttt{html/common/themes} are inlined to improve performance.

\begin{itemize}
\tightlist
\item
  \texttt{body\_bottom-ext.jsp}
\item
  \texttt{body\_top-ext.jsp}
\item
  \texttt{bottom-ext.jsp}
\item
  \texttt{bottom-test.jsp}
\end{itemize}

They're no longer explicit files in the code base. But you can still
create them in your module to add functionality and content.

Remember, this type of customization is a last resort. Your override may
break due to the nature of this implementation, and core functionality
in Liferay can go down with it. If the JSP you want to override is in
another module, refer to the API based approaches to overriding JSPs
mentioned at the beginning of the article.

\section{Site Scoped JSP
Customization}\label{site-scoped-jsp-customization}

In Liferay Portal 6.2, you could use
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{Application
Adapters} to scope your core JSP customizations to a specific Site.
Since the majority of JSPs were moved into modules for Liferay DXP 7.0,
the use case for this has shrunk considerably. If you must scope a core
JSP customization to a Site, prepare an application adapter
\href{/docs/6-2/tutorials/-/knowledge_base/t/customizing-sites-and-site-templates-with-application-adapters}{as
you would have for Liferay Portal 6.2}, and deploy it to 7.0. It will
still work. However, note that this approach is deprecated in 7.0 and
won't be supported at all in Liferay 8.0.

\section{Related Topics}\label{related-topics-18}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/upgrading-core-jsp-hooks}{Upgrading
  Core JSP Hooks}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
  Overrides Using Portlet Filters}
\end{itemize}

\chapter{Overriding Inline Content Using
JSPs}\label{overriding-inline-content-using-jsps}

Some Liferay DXP core content, such as tag library tags, can only be
overridden using JSPs ending in \texttt{.readme}. The suffix
\texttt{.readme} facilitates finding them. The code from these JSPs is
now inlined (brought into Liferay DXP Java source files) to improve
performance. Liferay DXP ignores JSP files with the \texttt{.readme}
suffix. If you add code to a JSP \texttt{.readme} file and remove the
\texttt{.readme} suffix, Liferay DXP uses that JSP instead of the core
inline content. This tutorial shows you how to make these
customizations.

\noindent\hrulefill

\textbf{Important:} This type of customization is a last resort. Your
override may break due to the nature of this implementation, and core
functionality can go down with it. Liferay cannot guarantee that content
overridden using JSP \texttt{.readme} files can be upgraded.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Warning:} Modifying a Liferay DXP tag library tag affects all
uses of that tag in your Liferay DXP installation.

\noindent\hrulefill

Here's how to override inline content using JSPs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a
  \href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-custom-jsp-bag}{Custom
  JSP Bag} for deploying your JSP. Note the module folder you're storing
  the JSPs in: the default folder is
  \texttt{{[}your\ module{]}/src/main/resources/META-INF/jsps/}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** you can develop your JSP anywhere, but a Custom JSP Bag module 
 provides a straightforward way to build and deploy it.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Download the Liferay DXP source code or browse the source code on
  \href{https://github.com/liferay/liferay-portal/tree/7.2.x}{GitHub
  (Liferay Portal CE)}.
\item
  Search the source code for a \texttt{.jsp.readme} file that overrides
  the tag you're customizing.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Files ending in `-ext.jsp.readme` let you prepend or
 append new content to existing content. Examples include the
 `bottom-test.jsp.readme`, `bottom-ext.jsp.readme`,
 `body_top-ext.jsp.readme`, and `body_bottom-ext.jsp.readme` files in
 the Liferay DXP application's `portal-web/docroot/html/common/themes` folder.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Copy the \texttt{.jsp.readme} file into your project and drop the
  \texttt{.readme} suffix. Use the same relative file path Liferay DXP
  uses for the \texttt{.jsp.readme} file. For example, if the file in
  Liferay DXP is

\begin{verbatim}
portal-web/docroot/html/taglib/aui/fieldset/start.jsp.readme
\end{verbatim}

  use file path

\begin{verbatim}
[your module]/src/main/resources/META-INF/jsps/html/taglib/aui/fieldset/start.jsp
\end{verbatim}
\item
  Familiarize yourself with the current UI content and logic, so you can
  override it appropriately. Tag library tag content logic, for example,
  is in the respective \texttt{*Tag.java} file under
  \texttt{util-taglib/src/com/liferay/taglib/{[}tag\ library{]}/}.
\item
  Develop your new logic, keeping in mind the current inline logic
  you're replacing.
\item
  Deploy your JSP.
\end{enumerate}

Liferay DXP uses your JSP in place of the current inline logic. If you
want to walk through an example override, continue with this tutorial.
Otherwise, congratulations on a modified \texttt{.jsp.readme} file to
override core inline content!

\section{Example: Overriding the fieldset Taglib
Tag}\label{example-overriding-the-fieldset-taglib-tag}

This example demonstrates changing the \texttt{liferay:aui} tag
library's \texttt{fieldset} tag. Browsing the Liferay DXP web
application or the source code at
\texttt{portal-web/docroot/html/taglib/aui/fieldset} reveals these
files:

\begin{itemize}
\tightlist
\item
  \texttt{start.jsp.readme}
\item
  \texttt{end.jsp.readme}
\end{itemize}

They can override the logic that creates the start and end of the
\texttt{fieldset} tag. The \texttt{FieldsetTag.java} class's
\texttt{processStart} and \texttt{processEnd} methods implement the
current inline content. Here's the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/util-taglib/src/com/liferay/taglib/aui/FieldsetTag.java\#L86-L141}{\texttt{processStart}}
method:

\begin{verbatim}
@Override
protected int processStartTag() throws Exception {
  JspWriter jspWriter = pageContext.getOut();

  jspWriter.write("<fieldset class=\"fieldset ");
  jspWriter.write(GetterUtil.getString(getCssClass()));
  jspWriter.write("\" ");

  String id = getId();

  if (id != null) {
    jspWriter.write("id=\"");
    jspWriter.write(id);
    jspWriter.write("\" ");
  }

  jspWriter.write(
    InlineUtil.buildDynamicAttributes(getDynamicAttributes()));

  jspWriter.write(StringPool.GREATER_THAN);

  String lable = getLabel();

  if (lable != null) {
    jspWriter.write(
      "<legend class=\"fieldset-legend\"><span class=\"legend\">");

    MessageTag messageTag = new MessageTag();

    messageTag.setKey(lable);
    messageTag.setLocalizeKey(getLocalizeLabel());

    messageTag.doTag(pageContext);

    String helpMessage = getHelpMessage();

    if (helpMessage != null) {
      IconHelpTag iconHelpTag = new IconHelpTag();

      iconHelpTag.setMessage(helpMessage);

      iconHelpTag.doTag(pageContext);
    }

    jspWriter.write("</span></legend>");
  }

  if (getColumn()) {
    jspWriter.write("<div class=\"row\">");
  }
  else {
    jspWriter.write("<div class=\"\">");
  }

  return EVAL_BODY_INCLUDE;
}
\end{verbatim}

The code above does this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write
  \texttt{\textless{}fieldset\ class=\textbackslash{}"fieldset}starting
  tag.
\item
  Write the CSS class name attribute.
\item
  If the tag has an ID, add the \texttt{id} as an attribute.
\item
  Write the tag's dynamic attribute (map).
\item
  Close the starting \texttt{fieldset} tag.
\item
  Get the tag's \texttt{label} attribute.
\item
  Write the starting \texttt{legend} element.
\item
  Use \texttt{getLocalizeLabel()} to add the localized label in the
  \texttt{legend}.
\item
  If there's a help message (retrieved from \texttt{getHelpMessage()}),
  write it in an \texttt{icon-help-tag}.
\item
  Write the closing \texttt{legend} tag.
\item
  If there's a column attribute, write
  \texttt{\textless{}div\ class=\textbackslash{}"row\textbackslash{}"\textgreater{}};
  else write
  \texttt{\textless{}div\ class=\textbackslash{}"\textbackslash{}"\textgreater{}}.
\end{enumerate}

Replicating the current logic in your custom JSP helps you set up the
tag properly for customizing. The \texttt{init.jsp} for
\texttt{fieldset} initializes all the variables required to create the
starting tag. You can use the variables in the \texttt{start.jsp}. The
logic from \texttt{FieldsetTag}'s \texttt{processStart} method converted
to JSP code for \texttt{start.jsp} (renamed from
\texttt{start.jsp.readme}) would look like this:

\begin{verbatim}
<%@ include file="/html/taglib/aui/fieldset/init.jsp" %>

<fieldset class="fieldset <%= cssClass %>" <%= Validator.isNotNull(id) ? "id=\"" + id + "\"" : StringPool.BLANK %> <%= InlineUtil.buildDynamicAttributes(dynamicAttributes) %>>
    <c:if test="<%= Validator.isNotNull(label) %>">
        <legend class="fieldset-legend">
            <span class="legend">
                <liferay-ui:message key="<%= label %>" localizeKey="<%= localizeLabel %>" />

                <c:if test="<%= Validator.isNotNull(helpMessage) %>">
                    <liferay-ui:icon-help message="<%= helpMessage %>" />
                </c:if>
            </span>
        </legend>
    </c:if>

    <div class="<%= column ? "row" : StringPool.BLANK %>">
\end{verbatim}

\noindent\hrulefill

\textbf{Tip:} A \texttt{*Tag.java} file's history might reveal original
JSP code that was inlined. For example, the logic from \texttt{fieldset}
tag's
\href{https://github.com/liferay/liferay-portal/blob/df22ba66eff49b76404cfda908d3cd024efbebd9/portal-web/docroot/html/taglib/aui/fieldset/start.jsp}{\texttt{start.jsp}}
was inlined in
\href{https://github.com/liferay/liferay-portal/commit/7fba0775bcc1d1a0bc4d107cabfb41a90f15937c\#diff-2ad802b4c0d8f7a2da45b895e89d6e46}{this
commit}.

\noindent\hrulefill

On deploying the \texttt{start.jsp}, the \texttt{fieldset} tags render
the same as they did before. This is expected because it uses the same
logic as \texttt{FieldsetTag}'s \texttt{processStart} method.

\begin{figure}
\centering
\includegraphics{./images/jsp-readme-inline-fieldset.png}
\caption{Liferay DXP's home page's search and sign in components are in
a \texttt{fieldset}.}
\end{figure}

The \texttt{fieldset} starting logic is ready for customization. To test
that this works, you'll print the word \emph{test} surrounded by
asterisks before the end of the \texttt{fieldset} tag's starting logic.
Insert this line before the \texttt{start.jsp}'s last \texttt{div} tag:

\begin{verbatim}
<c:out value="**********test**********"/>
\end{verbatim}

Redeploy the JSP and refresh the page to see the text printed above the
\texttt{fieldset}'s fields.

\begin{figure}
\centering
\includegraphics{./images/jsp-readme-override-inline-fieldset.png}
\caption{Before the \texttt{fieldset}'s nested fields, it prints
\emph{test} surrounded by asterisks.}
\end{figure}

You know how to override specific Liferay DXP core inline content using
Liferay's \texttt{.jsp.readme} files.

\section{Related Topics}\label{related-topics-19}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps-with-dynamic-includes}{Customizing
  JSPs with Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
  Overrides Using Portlet Filters}
\end{itemize}

\chapter{Customizing Widgets}\label{customizing-widgets}

It would be nice to apply display changes to specific widget instances
without having to create a hook (e.g., HTML-related change) or change a
theme (e.g., CSS-related change). Ideally, you should be able to enable
authorized users to apply custom display interfaces to widgets.

Be of good cheer! That's precisely what
\href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Widget
Templates} provide. Now you can customize the way widgets appear on a
page, removing limitations to the way content is displayed. With Widget
Templates, you can define display templates to render asset-centric
widgets. Some default widgets already have templating capabilities
(e.g., \emph{Web Content} and \emph{Dynamic Data Lists}), in which you
can add as many display options (or templates) as you want. You can also
add them to your own applications.

Some portlets that already support Widget Templates are

\begin{itemize}
\tightlist
\item
  \emph{Asset Publisher}
\item
  \emph{Blogs}
\item
  \emph{Breadcrumb}
\item
  \emph{Categories Navigation}
\item
  \emph{Language Selector}
\item
  \emph{Media Gallery}
\item
  \emph{Navigation Menu}
\item
  \emph{RSS Publisher}
\item
  \emph{Site Map}
\item
  \emph{Tags Navigation}
\item
  \emph{Wiki}
\end{itemize}

To leverage the Widget Template API, follow these steps:

\begin{itemize}
\tightlist
\item
  register your portlet to use Widget Templates
\item
  define your display template definitions
\item
  define permissions
\item
  expose the Widget Template functionality to users
\end{itemize}

The detailed steps are in the
\href{/docs/7-2/customization/-/knowledge_base/c/implementing-widget-templates}{Implementing
Widget Templates} article. Here's a high level overview of what you'll
do.

\section{Implementing the TemplateHandler
Interface}\label{implementing-the-templatehandler-interface}

To register your portlet to use Widget Templates, you must implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateHandler.html}{\texttt{TemplateHandler}}
interface. Read the interface's Javadoc for more information on each
method provided by the interface.

Each of the methods in this class have a significant role in defining
and implementing Widget Templates for your custom portlet. The list
below highlights some of the methods defined specifically for Widget
Templates:

\texttt{getClassName()}: Defines the type of entry your portlet is
rendering.

\texttt{getName()}: Declares the name of your Widget Template type
(typically, the name of the portlet).

\texttt{getResourceName()}: Specifies which resource is using the Widget
Template (e.g., a portlet) for permission checking. This method must
return the portlet's fully qualified portlet ID (e.g.,
\texttt{com\_liferay\_wiki\_web\_portlet\_WikiPortlet}).

\texttt{getTemplateVariableGroups()}: Defines the variables exposed in
the template editor.

\texttt{getTemplatesConfigPath()}: Defines the configuration file
containing the display template definition.

Next, you must define your display template definition(s).

\section{Defining Display Template
Definitions}\label{defining-display-template-definitions}

Once you've registered your portlet to use Widget Templates, you should
create the display template definitions. These are used to style the
content displayed in the widget.

You must create a \texttt{portlet-display-templates.xml} configuration
file to define the definitions and point to their styled templated
(e.g., FreeMarker). Then you must create the templates. These template
definitions are available to apply from a widget's Configuration menu.

Next, you define permissions for your portlet's Widget Templates.

\section{Defining Permissions}\label{defining-permissions}

You must define permissions for your Widget Templates; without
permissions, anyone in the Site could access and change your widget's
display templates. Configuring permissions lets administrative users
grant permissions only to the Roles that should create and manage
display templates.

This is done by creating a \texttt{default.xml} file in your portlet
defining the permissions you want to enforce, wiring it up with your
portlet, and configuring them for use in Liferay DXP. You can visit
\href{/docs/7-2/customization/-/knowledge_base/c/implementing-widget-templates}{this
article} for step-by-step instructions on how to complete this.

Next, you'll learn how to expose Widget Template selection for users.

\section{Exposing the Widget Template
Selection}\label{exposing-the-widget-template-selection}

To expose the Widget Template option to your users, use the
\texttt{\textless{}liferay-ui:ddm-template-selector\textgreater{}} tag
in the JSP file that controls your portlet's configuration. This tag
requires the following parameters:

\texttt{className}: your entity's class name.

\texttt{contextObjects}: accepts a
\texttt{Map\textless{}String,\ Object\textgreater{}} with any object you
want to the template context.

\texttt{displayStyle}: your portlet's display style.

\texttt{displayStyleGroupId}: your portlet's display style group ID.

\texttt{entries}: accepts a list of your entities (e.g.,
\texttt{List\textless{}YourEntity\textgreater{}}).

The variables \texttt{displayStyle} and \texttt{displayStyleGroupId} are
preferences that your portlet stores when you use this taglib and your
portlet uses the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BaseJSPSettingsConfigurationAction.html}{\texttt{BaseJSPSettingsConfigurationAction}}
or
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultConfigurationAction.html}{\texttt{DefaultConfigurationAction}}.
Otherwise, you must obtain the value of those parameters and store them
manually in your configuration class.

\section{Recommendations for Using Widget
Templates}\label{recommendations-for-using-widget-templates}

You can harness a lot of power by leveraging the Widget Template API. Be
careful, for with great power, comes great responsibility! Here are some
practices you can use to optimize your portlet's performance and
security.

First let's talk about security. You may want to hide some classes or
packages from the template context to limit the operations that Widget
Templates can perform. Liferay DXP provides some system settings, which
can be accessed by navigating to \emph{Control Panel} →
\emph{Configuration} → \emph{System Settings} → \emph{Template Engines}
→ \emph{FreeMarker Engine}, to define the restricted classes, packages,
and variables. In particular, you may want to add
\texttt{serviceLocator} to the list of default values assigned to the
FreeMarker Engine Restricted variables.

Widget Templates introduce additional processing tasks when your portlet
is rendered. To minimize negative effects on performance, make your
templates as minimal as possible by focusing on their presentation,
while using the existing API for complex operations. The best way to
make Widget Templates efficient is to know your template context well,
and understand what you can use from it. Fortunately, you don't need to
memorize the context information, thanks to Liferay DXP's advanced
template editor!

To navigate to the template editor for Widget Templates, go to the Site
Admin menu and select \emph{Configuration} → \emph{Widget Templates} and
then click \emph{Add} and select the specific portlet on which you
decide to create a custom template.

The template editor provides fields, general variables, and utility
variables customized for the portlet you chose. These variable
references are on the left-side panel of the template editor. Place your
cursor where you want the variable placed and click the desired variable
to insert it. You can learn more about the template editor in
\href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Styling
Widgets with Widget Templates}.

Finally, don't forget to run performance tests and tune the template
cache options by modifying the \emph{Resource modification check} field
in \emph{System Settings} → \emph{Template Engines} → \emph{FreeMarker
Engine}.

Widget Templates provide power to your portlets by providing infinite
ways of editing your portlet to create new interfaces for your users. Be
sure to configure your FreeMarker templates appropriately for the most
efficient customization process.

Continue on to add support for Widget Templates in your portlet.

\chapter{Implementing Widget
Templates}\label{implementing-widget-templates}

\href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Widget
Templates} are ways to customize how a widget looks. You can create
templates for a widget's display and then choose which template is
active.

\begin{figure}
\centering
\includegraphics{./images/widget-template-dropdown.png}
\caption{By using a custom display template, your portlet's display can
be customized.}
\end{figure}

To add Widget Template support to your portlet, follow the steps below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create and register a custom \texttt{*PortletDisplayTemplateHandler}
  component. Liferay provides the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portletdisplaytemplate/BasePortletDisplayTemplateHandler.html}{\texttt{BasePortletDisplayTemplateHandler}}
  as a base implementation for you to extend. You can check the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateHandler.html}{\texttt{TemplateHandler}}
  interface Javadoc to learn about each template handler method.

  The \texttt{@Component} annotation ties your handler to a specific
  portlet by setting the property \texttt{javax.portlet.name} to your
  portlet's name. The same property should be found in your portlet
  class. For example,

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name="+ AssetCategoriesNavigationPortletKeys.ASSET_CATEGORIES_NAVIGATION
    },
    service = TemplateHandler.class
)
\end{verbatim}

  The Site Map widget sets the \texttt{@Component} annotation like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = "javax.portlet.name=" + SiteNavigationSiteMapPortletKeys.SITE_NAVIGATION_SITE_MAP,
    service = TemplateHandler.class
)
public class SiteNavigationSiteMapPortletDisplayTemplateHandler
    extends BasePortletDisplayTemplateHandler {
}
\end{verbatim}

  You'll continue stepping through the Site map widget's
  \texttt{TemplateHandler} implementation next.
\item
  Override the base class' \texttt{getClassName()},
  \texttt{getName(...)}, and \texttt{getResourceName()} methods:

\begin{verbatim}
@Override
public String getClassName() {
    return LayoutSet.class.getName();
}

@Override
public String getName(Locale locale) {
    String portletTitle = _portal.getPortletTitle(
        SiteNavigationSiteMapPortletKeys.SITE_NAVIGATION_SITE_MAP,
        ResourceBundleUtil.getBundle(locale, getClass()));

    return LanguageUtil.format(locale, "x-template", portletTitle, false);
}

@Override
public String getResourceName() {
    return SiteNavigationSiteMapPortletKeys.SITE_NAVIGATION_SITE_MAP;
}
\end{verbatim}

  These methods return the template handler's class name, the template
  handler's name (via
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{resource
  bundle}), and the resource name associated with the Widget Template,
  respectively.
\item
  Override the \texttt{getTemplateVariableGroups(...)} method to return
  your widget template's script variable groups. These are used to
  display hints in the template editor palette.

\begin{verbatim}
@Override
public Map<String, TemplateVariableGroup> getTemplateVariableGroups(
        long classPK, String language, Locale locale)
    throws Exception {

    Map<String, TemplateVariableGroup> templateVariableGroups =
        super.getTemplateVariableGroups(classPK, language, locale);

    TemplateVariableGroup templateVariableGroup =
        templateVariableGroups.get("fields");

    templateVariableGroup.empty();

    templateVariableGroup.addCollectionVariable(
        "pages", List.class, PortletDisplayTemplateConstants.ENTRIES,
        "page", Layout.class, "curPage", "getName(locale)");
    templateVariableGroup.addVariable(
        "site-map-display-context",
        SiteNavigationSiteMapDisplayContext.class, "siteMapDisplayContext");

    return templateVariableGroups;
}
\end{verbatim}

  For this example, the \emph{Pages} and \emph{Site Map Display Context}
  fields are added to the default variables in the template editor
  palette.

  \begin{figure}
  \centering
  \includegraphics{./images/widget-template-fields.png}
  \caption{You can click a variable to add it to the template editor.}
  \end{figure}
\item
  Set your display template configuration file path:

\begin{verbatim}
@Override
protected String getTemplatesConfigPath() {
    return "com/liferay/site/navigation/site/map/web/portlet/template" +
        "/dependencies/portlet-display-templates.xml";
}
\end{verbatim}

  This method returns the XML file containing the display template
  definitions available for your portlet. You'll create this file next.
\item
  Create your \texttt{portlet-display-templates.xml} file to define your
  display template definitions. For example,

\begin{verbatim}
<?xml version="1.0"?>

<root>
    <template>
        <template-key>site-map-multi-column-layout-ftl</template-key>
        <name>portlet-display-template-name-multi-column-layout</name>
        <description>portlet-display-template-description-multi-column-layout-sitemap</description>
        <language>ftl</language>
        <script-file>com/liferay/site/navigation/site/map/web/portlet/template/dependencies/portlet_display_template_multi_column_layout.ftl</script-file>
        <cacheable>false</cacheable>
    </template>
</root>
\end{verbatim}

  This defined template option is read and presented to the user through
  the widget's Configuration menu. Navigate to the Site Map widget's
  Configuration menu and you can confirm the \emph{Multi Column Layout}
  option is available.

  \begin{figure}
  \centering
  \includegraphics{./images/widget-config-display.png}
  \caption{You can choose the Widget Template you want to apply from the
  widget's Configuration menu.}
  \end{figure}

  This template is created using FreeMarker. You'll create this template
  option next.
\item
  Create your template script file that you specified in the previous
  step. For the Site Map widget, its Multi Column Layout option is
  configured in a FreeMarker template like this:

\begin{verbatim}
<#if entries?has_content>
    <@liferay_aui.row>
        <#list entries as entry>
            <#if layoutPermission.containsWithoutViewableGroup(permissionChecker, entry, "VIEW")>
                <@liferay_aui.col width=25>
                    <div class="results-header">
                        <h3>
                            <a

                            <#assign layoutType = entry.getLayoutType() />

                            <#if layoutType.isBrowsable()>
                                href="${portalUtil.getLayoutURL(entry, themeDisplay)}"
                            </#if>

                            >${entry.getName(locale)}</a>
                        </h3>
                    </div>

                    <@displayPages
                        depth=1
                        pages=entry.getChildren(permissionChecker)
                    />
                </@liferay_aui.col>
            </#if>
        </#list>
    </@liferay_aui.row>
</#if>

<#macro displayPages
    depth
    pages
>
    <#if pages?has_content && ((depth < displayDepth?number) || (displayDepth?number == 0))>
        <ul class="child-pages">
            <#list pages as page>
                <li>
                    <a

                    <#assign pageType = page.getLayoutType() />

                    <#if pageType.isBrowsable()>
                        href="${portalUtil.getLayoutURL(page, themeDisplay)}"
                    </#if>

                    >${page.getName(locale)}</a>

                    <@displayPages
                        depth=depth + 1
                        pages=page.getChildren(permissionChecker)
                    />
                </li>
            </#list>
        </ul>
    </#if>
</#macro>
\end{verbatim}

  This template definition enforces page permissions, formats how the
  pages are displayed (multi column), and provides clickable links for
  each page.
\item
  Your widget must define permissions for creating and managing display
  templates. Add the action key \texttt{ADD\_PORTLET\_DISPLAY\_TEMPLATE}
  to your portlet's
  \texttt{/src/main/resources/resource-actions/default.xml} file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.2.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_2_0.dtd">
<resource-action-mapping>
    ...
    <portlet-resource>
        <portlet-name>yourportlet</portlet-name>
        <permissions>
            <supports>
                <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
                <action-key>ADD_TO_PAGE</action-key>
                <action-key>CONFIGURATION</action-key>
                <action-key>VIEW</action-key>
            </supports>
            ...
        </permissions>
    </portlet-resource>
    ...
</resource-action-mapping>
\end{verbatim}
\item
  If your widget hasn't defined Liferay permissions before, create a
  file named \texttt{portlet.properties} in the \texttt{/resources}
  folder and add the following contents providing the path to your
  \texttt{default.xml}:

\begin{verbatim}
include-and-override=portlet-ext.properties
resource.actions.configs=resource-actions/default.xml
\end{verbatim}
\item
  Now expose the Widget Template selector to your users. Include the
  \texttt{\textless{}liferay-ddm:template-selector\textgreater{}} tag in
  the JSP file you're using to control your portlet's configuration.

  For example, it may be helpful for you to insert a
  \texttt{\textless{}liferay-frontend:fieldset\textgreater{}} in your
  configuration JSP file like this:

\begin{verbatim}
<liferay-frontend:fieldset
    collapsible="<%= true %>"
    label="templates"
>
    <div class="display-template">
        <liferay-ddm:template-selector
            classNameId="<%= YourEntity.class.getName() %>"
            displayStyle="<%= displayStyle %>"
            displayStyleGroupId="<%= displayStyleGroupId %>"
            refreshURL="<%= PortalUtil.getCurrentURL(request) %>"
            showEmptyOption="<%= true %>"
        />
    </div>
</liferay-frontend:fieldset>
\end{verbatim}

  In this JSP, the
  \texttt{\textless{}liferay-ddm:template-selector\textgreater{}} tag
  specifies the Display Template drop-down menu to be used in the
  widget's Configuration menu.
\item
  You must now extend your view code to render your portlet using the
  selected Widget Template.

  First, initialize the Java variables needed for the Widget Template:

\begin{verbatim}
<%
String displayStyle = GetterUtil.getString(portletPreferences.getValue("displayStyle", StringPool.BLANK));
long displayStyleGroupId = GetterUtil.getLong(portletPreferences.getValue("displayStyleGroupId", null), scopeGroupId);
%>
\end{verbatim}

  Next, you can test if the Widget Template is configured, grab the
  entities to be rendered, and render them using the Widget Template.
  The tag
  \texttt{\textless{}liferay-ddm:template-renderer\textgreater{}} aids
  with this process. It automatically uses the selected template or
  renders its body if no template is selected.

  Here's some example code that demonstrates implementing this:

\begin{verbatim}
<liferay-ddm:template-renderer
    className="<%= YourEntity.class.getName() %>"
    contextObjects="<%= contextObjects %>"
    displayStyle="<%= displayStyle %>"
    displayStyleGroupId="<%= displayStyleGroupId %>"
    entries="<%= yourEntities %>"
>

    <%-- The code that renders the default view should be inserted here. --%>

</liferay-ddm:template-renderer>
\end{verbatim}

  In this step, you initialized variables dealing with the display
  settings (\texttt{displayStyle} and \texttt{displayStyleGroupId}) and
  passed them to the tag along with other parameters.

  As an example, the Site Map widget implements the
  \texttt{\textless{}liferay-ddm:template-renderer\textgreater{}} tag in
  its \texttt{view.jsp} like this:

\begin{verbatim}
<liferay-ddm:template-renderer
    className="<%= LayoutSet.class.getName() %>"
    contextObjects="<%= contextObjects %>"
    displayStyle="<%= siteNavigationSiteMapPortletInstanceConfiguration.displayStyle() %>"
    displayStyleGroupId="<%= siteNavigationSiteMapDisplayContext.getDisplayStyleGroupId() %>"
    entries="<%= siteNavigationSiteMapDisplayContext.getRootLayouts() %>"
>
    <%= siteNavigationSiteMapDisplayContext.buildSiteMap() %>
</liferay-ddm:template-renderer>
\end{verbatim}

  This logic builds the site's navigation map when the widget is added
  to a page.
\end{enumerate}

Awesome! Your portlet now supports Widget Templates! Once your script is
uploaded and saved, Users with the specified Roles can select the
template when they're configuring the display settings of your portlet
on a page. You can visit the
\href{/docs/7-2/user/-/knowledge_base/u/styling-widgets-with-widget-templates}{Styling
Widgets with Widget Templates} section for more details on using Widget
Templates.

\chapter{Dynamic Includes}\label{dynamic-includes}

Dynamic includes expose extension points in JSPs for injecting
additional HTML, adding resources, modifying editors, and more. Several
dynamic includes are available. Once you know the dynamic include's key,
you can use it to
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps-with-dynamic-includes}{create
a module to inject your content}.

This section of tutorials lists the available dynamic include keys,
along with a description of their use cases and a code example.

The following extension points are covered in this section:

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4074}}
  >{\centering\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5926}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Extension Point
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{/docs/7-2/customization/-/knowledge_base/c/bottom-jsp-dynamic-includes}{bottom}
& Load additional HTML or scripts in the bottom of the theme's body \\
\href{/docs/7-2/customization/-/knowledge_base/c/top-head-jsp-dynamic-includes}{top\_head}
& Load additional links in the theme's head \\
\href{/docs/7-2/customization/-/knowledge_base/c/top-js-dynamic-include}{top\_js}
& Load additional JS files in the theme's head \\
\href{/docs/7-2/customization/-/knowledge_base/c/wysiwyg-editor-dynamic-includes}{WYSIWYG}
& Add resources to the editor, listen to events, update the
configuration, etc. \\
\end{longtable}

\chapter{WYSIWYG Editor Dynamic
Includes}\label{wysiwyg-editor-dynamic-includes}

All WYSIWYG editors share the same dynamic include extension points for
these things:

\begin{itemize}
\item
  Adding resources, plugins, etc. to the editor:

  com.liferay.frontend.editor.\texttt{editorType}.web\#\texttt{editorName}\#additionalResources
\item
  Accessing the editor instance to listen to events, configure it, etc:

  com.liferay.frontend.editor.\texttt{editorType}.web\#\texttt{editorName}\#onEditorCreate
\end{itemize}

The table below shows the \texttt{editorType}, variable, and
\texttt{editorName}s for each editor:

\begin{longtable}[]{@{}ccc@{}}
\toprule\noalign{}
editorType & variable & editorName \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
alloyeditor & alloyEditor & alloyeditor \\
~ & ~ & alloyeditor\_bbcode \\
~ & ~ & alloyeditor\_creole \\
ckeditor & ckEditor & ckeditor \\
~ & ~ & ckeditor\_bbcode \\
~ & ~ & ckeditor\_creole \\
tinymce & tinyMCEEditor & tinymce \\
~ & ~ & tinymce\_simple \\
\end{longtable}

The example below alerts the user when he/she pastes content into the
CKEditor.

\texttt{*DynamicInclude} Java Class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class CKEditorOnEditorCreateDynamicInclude implements DynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        Bundle bundle = _bundleContext.getBundle();

        URL entryURL = bundle.getEntry(
            "/META-INF/resources/ckeditor/extension/ckeditor_alert.js");

        StreamUtil.transfer(
            entryURL.openStream(), response.getOutputStream(), false);
    }

    @Override
    public void register(
        DynamicInclude.DynamicIncludeRegistry dynamicIncludeRegistry) {

        dynamicIncludeRegistry.register(
            "com.liferay.frontend.editor.ckeditor.web#ckeditor#onEditorCreate");
    }

    @Activate
    protected void activate(BundleContext bundleContext) {
        _bundleContext = bundleContext;
    }

    private BundleContext _bundleContext;

}
\end{verbatim}

Example JavaScript:

\begin{verbatim}
// ckEditor variable is already available in the execution context
ckEditor.on(
    'paste',
    function(event) {
        event.stop();

        alert('Please, do not paste code here!');
    }
);
\end{verbatim}

Now you know how to use the WYSIWYG editor dynamic includes.

\section{Related Topics}\label{related-topics-20}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/bottom-jsp-dynamic-includes}{Bottom
  JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-head-jsp-dynamic-includes}{Top
  Head JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-js-dynamic-include}{Top
  JS Dynamic Include}
\end{itemize}

\chapter{Top Head JSP Dynamic
Includes}\label{top-head-jsp-dynamic-includes}

The \texttt{top\_head.jsp} dynamic includes load additional links in the
theme's head. It uses the following keys:

Load additional links in the theme's head before the existing ones:

\begin{verbatim}
/html/common/themes/top_head.jsp#pre
\end{verbatim}

Alternatively, you can load additional links in the theme's head, after
the existing ones:

\begin{verbatim}
/html/common/themes/top_head.jsp#post
\end{verbatim}

The example below injects a link into the top of the
\texttt{top\_head.jsp}:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class CssTopHeadDynamicInclude extends BaseDynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        String content = 
    "<link href=\"http://localhost:8080/o/my-custom-dynamic-include/css/mentions.css\" 
    rel=\"stylesheet\" 
    type = \"text/css\" />";
    
        printWriter.println(content);
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register("/html/common/themes/top_head.jsp#pre");
    }
  
}
\end{verbatim}

Page Source:

\begin{verbatim}
<head>
  ...
  <link href="http://localhost:8080/o/my-custom-dynamic-include/css/mentions.css" rel="stylesheet" type="text/css">
  ...
</head>
\end{verbatim}

Note that the link's \texttt{href} attribute's value
\texttt{/o/my-custom-dynamic-include/} is provided by the OSGi module's
\texttt{Web-ContextPath} (\texttt{/my-custom-dynamic-include} in the
example).

Now you know how to use the \texttt{top\_head.jsp} dynamic includes.

\section{Related Topics}\label{related-topics-21}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/bottom-jsp-dynamic-includes}{Bottom
  JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-js-dynamic-include}{Top
  JS Dynamic Include}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/wysiwyg-editor-dynamic-includes}{WYSIWYG
  Editor Dynamic Includes}
\end{itemize}

\chapter{Top JS Dynamic Include}\label{top-js-dynamic-include}

The \texttt{top\_js.jspf} dynamic include adds additional JavaScript
files to the theme's head. For example, you can use this extension point
to include a JS library that you need present in the theme's head:

\begin{verbatim}
/html/common/themes/top_js.jspf#resources
\end{verbatim}

The example below injects a JavaScript file into the top of the
\texttt{top\_js.jspf}:

\texttt{*DynamicInclude} Java Class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class JSTopHeadDynamicInclude extends BaseDynamicInclude {

  @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

    PrintWriter printWriter = response.getWriter();

    String content = "<script charset=\"utf-8\" src=\"/o/my-custom-dynamic-include/my_example_javascript.js\" async />";

    printWriter.println(content);
    }

    @Override
    public void register(
        DynamicInclude.DynamicIncludeRegistry dynamicIncludeRegistry) {

        dynamicIncludeRegistry.register(
      "/html/common/themes/top_js.jspf#resources"
    );
    }
}
\end{verbatim}

Page Source:

\begin{verbatim}
<head>
  ...
  <script charset="utf-8" src="/o/my-custom-dynamic-include/my_example_javascript.js" async>...</script>
  ...
</head>
\end{verbatim}

Note that the JavaScript \texttt{src} attribute's value
\texttt{/o/my-custom-dynamic-include/...} is provided by the OSGi
module's \texttt{Web-ContextPath} (\texttt{/my-custom-dynamic-include}
in the example).

Now you know how to use the \texttt{top\_js.jspf} dynamic include.

\section{Related Topics}\label{related-topics-22}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/bottom-jsp-dynamic-includes}{Bottom
  JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-head-jsp-dynamic-includes}{Top
  Head JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/wysiwyg-editor-dynamic-includes}{WYSIWYG
  Editor Dynamic Includes}
\end{itemize}

\chapter{Bottom JSP Dynamic Includes}\label{bottom-jsp-dynamic-includes}

The \texttt{bottom.jsp} dynamic includes load additional HTML or scripts
in the bottom of the theme's body. The following keys are available:

Load additional HTML or scripts in the bottom of the theme's body,
before the existing ones:

\begin{verbatim}
/html/common/themes/bottom.jsp#pre
\end{verbatim}

Alternatively, load HTML or scripts in the bottom of the theme's body,
after the existing ones:

\begin{verbatim}
/html/common/themes/bottom.jsp#post 
\end{verbatim}

The example below includes an additional script for the Simulation panel
in the bottom of the theme's body, after the existing ones.

\texttt{SimulationDeviceDynamicInclude} Java class:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
public class SimulationDeviceDynamicInclude extends BaseDynamicInclude {

    @Override
    public void include(
            HttpServletRequest request, HttpServletResponse response,
            String key)
        throws IOException {

        PrintWriter printWriter = response.getWriter();

        printWriter.print(_TMPL_CONTENT);
    }

    @Override
    public void register(DynamicIncludeRegistry dynamicIncludeRegistry) {
        dynamicIncludeRegistry.register("/html/common/themes/bottom.jsp#post");
    }

    private static final String _TMPL_CONTENT = StringUtil.read(
        SimulationDeviceDynamicInclude.class,
        "/META-INF/resources/simulation_device_dynamic_include.tmpl");

}
\end{verbatim}

\texttt{simulation\_device\_dynamic\_include.tmpl}:

\begin{verbatim}
<script type="text/javascript">
    // <![CDATA[
        AUI().use(
            'aui-base',
            function(A) {
                var frameElement = window.frameElement;

                if (frameElement && frameElement.getAttribute('id') === 'simulationDeviceIframe') {
                    A.getBody().addClass('lfr-has-simulation-panel');
                }
            }
        );
    // ]]>
</script>
\end{verbatim}

When the Simulation panel is open, the script adds the
\texttt{lfr-has-simulation-panel} class to the theme's body.

Page Source:

\begin{verbatim}
<body class="controls-visible has-control-menu closed  yui3-skin-sam guest-site signed-in public-page site lfr-has-simulation-panel" id="senna_surface1">
\end{verbatim}

Now you know how to use the \texttt{bottom.jsp} dynamic includes.

\section{Related Topics}\label{related-topics-23}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-head-jsp-dynamic-includes}{Top
  Head JSP Dynamic Includes}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/top-js-dynamic-include}{Top
  JS Dynamic Include}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/wysiwyg-editor-dynamic-includes}{WYSIWYG
  Editor Dynamic Includes}
\end{itemize}

\chapter{Waiting on Lifecycle Events}\label{waiting-on-lifecycle-events}

Liferay registers lifecycle events like portal and database
initialization into the OSGi service registry. Your OSGi Component or
non-component class can listen for these events by way of their service
registrations. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
interface} defines these names for the lifecycle event services:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.DATABASE_INITIALIZED}{DATABASE\_INITIALIZED}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.PORTAL_INITIALIZED}{PORTAL\_INITIALIZED}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/constant-values.html\#com.liferay.portal.kernel.module.framework.ModuleServiceLifecycle.SPRING_INITIALIZED}{SPRING\_INITIALIZED}
\end{itemize}

Here you'll learn how to wait on lifecycle event services to act on them
from within a component or non-component class.

\section{Taking action from a
component}\label{taking-action-from-a-component}

\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} facilitates waiting for OSGi services and acting on them
once they're available.

Here's a component whose \texttt{doSomething} method is invoked once the
\texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED} lifecycle event
service and other services are available.

\begin{verbatim}
@Component
public class MyXyz implements XyzApi {

    // Plain old OSGi service
    @Reference
    private SomeOsgiService _someOsgiService;

    // Service Builder generated service
    @Reference
    private DDMStructureLocalService _ddmStructureLocalService;

    // Liferay lifecycle service
    @Reference(target = ModuleServiceLifecycle.PORTAL_INITIALIZED)
    private ModuleServiceLifecycle _portalInitialized;

    @Activate
    public void doSomething() {
        // `@Activate` method is only executed once all of
        // `_someOsgiService`,
        // `_ddmStructureLocalService` and
        // `_portalInitialized`
        // are set.
    }
}
\end{verbatim}

Here's how to act on services in your component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For each lifecycle event service and OSGi service your component uses,
  add a field of that service type and add an \texttt{@Reference}
  annotation to that field. The OSGi framework binds the services to
  your fields. This field, for example, binds to a standard OSGi
  service.

\begin{verbatim}
@Reference
SomeOsgiService _someOsgiService;
\end{verbatim}
\item
  To bind to a particular lifecycle event service, target its name as
  the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/module/framework/ModuleServiceLifecycle.html}{\texttt{ModuleServiceLifecycle}
  interface} defines. This field, for example, targets database
  initialization.

\begin{verbatim}
@Reference(target = ModuleServiceLifecycle.DATABASE_INITIALIZED)
ModuleServiceLifecycle _dataInitialized;
\end{verbatim}
\item
  Create a method that's triggered on the event(s) and add the
  \texttt{@Activate} annotation to that method. It's invoked when all
  the service objects are bound to the component's fields.
\end{enumerate}

Your component fires (via its \texttt{@Activate} method) after all its
service dependencies resolve. DS components are the easiest way to act
on lifecycle event services.

\section{Taking action from a non-component
class}\label{taking-action-from-a-non-component-class}

Classes that aren't DS components can use a
\texttt{org.osgi.util.tracker.ServiceTracker} or
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer} as a
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker\#creating-a-service-tracker-that-tracks-service-events-using-a-callback-handler}{service
callback handler} for the lifecycle event. If you depend on multiple
services, add logic to your \texttt{ServiceTracker} or
\texttt{ServiceTrackerCustomizer} to coordinate taking action when all
the services are available.

To target a lifecycle event service, create a service tracker that
filters on that service. Use \texttt{org.osgi.framework.FrameworkUtil}
to create an \texttt{org.osgi.framework.Filter} that specifies the
service. Then pass that filter as a parameter to the service tracker
constructor. For example, this service tracker filters on the lifecycle
service \texttt{ModuleServiceLifecycle.PORTAL\_INITIALIZED}.

\begin{verbatim}
import org.osgi.framework.Filter;
import org.osgi.framework.FrameworkUtil;

Filter filter = FrameworkUtil.createFilter(
    String.format(
        "(&(objectClass=%s)%s)",
        ModuleServiceLifecycle.class.getName(),
        ModuleServiceLifecycle.PORTAL_INITIALIZED));

new ServiceTracker<>(bundleContext, filter, null);
\end{verbatim}

Acting on lifecycle event services in this way requires service callback
handling and some boilerplate code. Using DS components is easier and
more elegant, but at least service trackers provide a way to work with
lifecycle events outside of DS components.

\section{Related Topics}\label{related-topics-24}

\href{/docs/7-1/tutorials/-/knowledge_base/t/service-trackers}{Service
Trackers}

\href{/docs/7-1/reference/-/knowledge_base/r/liferay-startup-phases}{Liferay
DXP Startup Phases}

\chapter{Liferay Forms}\label{liferay-forms}

The \href{/docs/7-2/user/-/knowledge_base/u/forms}{Liferay Forms}
application is a full-featured form building tool for collecting data.
There's lots of built-in functionality. For the pieces you're missing,
there are extension points.

This section of articles shows developers how to

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Store form entry data in an alternative format. The default storage
  type is JSON.
\item
  {[}Coming Soon{]} Create new form field types.
\end{enumerate}

\section{Liferay Forms Extension
Points}\label{liferay-forms-extension-points}

Here's a compilation of the Liferay Forms application's extension points
that are ready for your customization:

\begin{itemize}
\tightlist
\item
  Create a Form Storage Adapter by implementing a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/storage/StorageAdapter.java}{\texttt{StorageAdapter}}
  or by extending the Abstract implementation,
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/storage/BaseStorageAdapter.java}{\texttt{BaseStorageAdapter}}.
\item
  Create a Form Field Type by implementing a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/form/field/type/DDMFormFieldType.java}{\texttt{DDMFormFieldType}},
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/form/field/type/DDMFormFieldTypeSettings.java}{\texttt{DDMFormFieldTypeSettings}},
  and a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/form/field/type/DDMFormFieldTemplateContextContributor.java}{\texttt{DDMFormFieldTemplateContextContributor}}.
\item
  Create custom validation rules for form fields by implementing a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/form/field/type/DDMFormFieldValueValidator.java}{DDMFormFieldValueValidator}.
\end{itemize}

\chapter{Form Storage Adapters}\label{form-storage-adapters}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

When a User adds a form record, the Forms API routes the processing of
the request through the storage adapter API. The same is true for the
other \emph{CRUD} operations performed on form entries (read, update,
and delete operations). The default implementation of the storage
service is called \texttt{JSONStorageAdapter}, and as its name implies,
it implements the \texttt{StorageAdapter} interface to provide JSON
storage of form entry data.

The Dynamic Data Mapping (DDM) backend can \emph{adapt} to other data
storage formats for form records. Want to store your data in XML? YAML?
No problem. Because the storage API is separated from the regular
service calls used to populate the database table for form entries, a
developer can even choose to store form data outside the Liferay
database.

Define your own format to save form entries by writing your own
implementation of the \texttt{StorageAdapter} interface. The interface
follows the \emph{CRUD} approach, so implementing it requires that you
write methods to create, read, update and delete form values.

\noindent\hrulefill

\textbf{Note:} The \texttt{StorageAdapter} interface and it's abstract
implementation, \textbar{} \texttt{BaseStorageAdapter}, are deprecated
in 7.0. In the future your code should be migrated to implement the
\texttt{DDMStorageAdapter} interface. If you need a storage adapter, the
current extension of \texttt{BaseStorageAdapter} (demonstrated in this
documentation), is still the way to create one, but be aware that it
will not be available in a future version.

\noindent\hrulefill

A newly added storage adapter can only be used with new Forms. All
existing Forms continue to use the adapter selected (JSON by default) at
the time of their creation, and a different storage adapter cannot be
selected.

The example storage adapter in this tutorial serializes form data to be
stored in a simple file, stored on the file system.

\begin{figure}
\centering
\includegraphics{./images/forms-storage-type.png}
\caption{Choose a Storage Type for your form records.}
\end{figure}

\section{Storage Adapter Methods}\label{storage-adapter-methods}

Before handling the CRUD logic, write a \texttt{getStorageType} method.

\begin{description}
\tightlist
\item[\texttt{getStorageType}]
Return a human readable String, as \texttt{getStorageType} determines
what appears in the UI when the form creator is selecting a storage type
for their form. The String value you return here is added to the
\texttt{StorageAdapterRegistry}'s Map of storage adapters.
\end{description}

\section{The CRUD Methods}\label{the-crud-methods}

\texttt{doCreate}: Return a \texttt{long} that identifies each form
record with a unique file ID. Almost as important is to validate the
form values being sent through the storage adapter API. This is as
simple as calling
\texttt{DDMFormValuesValidator.validate(ddmFormValues)}. In addition,
you'll interact with at least two other DDM services to get the form the
values are associated with, and to make sure they're linked:
\texttt{DDMStructureVersionLocalService} and
\texttt{DDMStorageLinkLocalService}. Lastly, the form values in the
\texttt{DDMFormValues} object must be serialized (converted) into the
right storage format. If JSON works for your use case, feel free to use
the \texttt{DDMFormValuesJSONSerializer} service in the Liferay Forms
code, as demonstrated in the following article. Otherwise you'll need to
provide your own serialization service for the form values.

\begin{description}
\tightlist
\item[\texttt{doGetDDMFormValues}]
Return the form values (\texttt{DDMFormValues}) for a form. You'll call
the \texttt{deserialize} method after retrieving them, to take them from
the storage format (e.g., JSON) to a proper \texttt{DDMFormValues}
object. You can use the Liferay Forms
\texttt{DDMFormValuesJSONDeserializer} if you're retrieving JSON data.
\item[\texttt{doUpdate}]
A request to update the values comes from a User in the Liferay Forms
application, so call the validator again, serialize the values into the
proper format, and save them.
\item[\texttt{doDeleteByClass}]
When a delete request is made on a form record directly, delete the form
values in whatever format they're currently being stored in (this is
entirely dependent on your own application of the storage adapter). In
addition, retrieve and delete the DDM class storage link using
\texttt{DDMStorageLinkLocalService}.
\item[\texttt{doDeleteByDDMStrcuture}]
When a delete request is made on an entire form, delete all the form
records associated with it. In addition, take the form's
\texttt{ddmStructureId} and delete all the DDM structure storage links
that were created for it.
\end{description}

\section{Validating Form Entries}\label{validating-form-entries}

Because the Storage Adapter handles User entered data during the
\texttt{add} and \texttt{update} operations, it's important to validate
that the entries include only appropriate data. Add a \texttt{validate}
method to the \texttt{StorageAdapter}, calling the Liferay Forms'
\texttt{DDMFormValuesValidator} method to do the heavy lifting.

\begin{verbatim}
protected void validate(
      DDMFormValues ddmFormValues, ServiceContext serviceContext)
    throws Exception {

    boolean validateDDMFormValues = GetterUtil.getBoolean(
        serviceContext.getAttribute("validateDDMFormValues"), true);

    if (!validateDDMFormValues) {
        return;
    }

    _ddmFormValuesValidator.validate(ddmFormValues);
}
\end{verbatim}

Make sure to do three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve the value of the \texttt{boolean\ validateDDMFormValues}
  attribute from the service context.
\item
  If \texttt{validateDDMFormValues} is false, exit the validation
  without doing anything.

  When a User accesses a form at its dedicated link, there's a periodic
  auto-save process of in-progress form values. There's no need to
  validate this data until the User hits the \emph{Submit} button on the
  form, so the auto-save process sets the \texttt{validateDDMFormValues}
  attribute to \texttt{false}.
\item
  Otherwise, call the validate method from the
  \texttt{DDMFormValuesValidator} service.
\end{enumerate}

All the Java code for the logic discussed here is shown in the next
article,
\href{/docs/7-2/customization/-/knowledge_base/c/creating-a-form-storage-adapter}{Creating
Form Storage Adapters}.

\section{Enabling the Storage
Adapter}\label{enabling-the-storage-adapter}

The storage adapter is enabled at the individual form level. Create a
new form, and select the Storage Adapter \emph{before saving or
publishing the form}. If you wait until first Saving the Form, the
default Storage Adapter is already assigned to the Form, and this
setting is no longer editable.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the Site Menu → Content → Forms, and click the \emph{Add} button
  (\includegraphics{./images/icon-add.png}).
\item
  In the Form Builder view, click the \emph{Options} button
  (\includegraphics{./images/icon-options.png}) and open the
  \emph{Settings} window.
\item
  From the select list field called \emph{Select a Storage Type}, choose
  the desired type and click \emph{Done}.
\end{enumerate}

Now all the form's entries are stored in the desired format.

\chapter{Creating a Form Storage
Adapter}\label{creating-a-form-storage-adapter}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

There's only one class to create when implementing a Form Storage
Adapter, and it extends the base \texttt{StorageAdapter} implementation.

\begin{verbatim}
@Component(service = StorageAdapter.class)
public class FileSystemStorageAdapter extends BaseStorageAdapter {
\end{verbatim}

The only method without a base implementation in the abstract class is
\texttt{getStorageType}. For file system storage, it can return
\texttt{"File\ System"}.

\begin{verbatim}
@Override
public String getStorageType() {
    return "File System";
}
\end{verbatim}

\section{Storage Adapter CRUD
Operations}\label{storage-adapter-crud-operations}

The CRUD operations must be created to properly handle the Form Records.

\section{Create}\label{create}

Next override the \texttt{doCreateMethod} to return a \texttt{long} that
identifies each form record with a unique file ID:

\begin{verbatim}
@Override
protected long doCreate(
    long companyId, long ddmStructureId, DDMFormValues ddmFormValues, 
    ServiceContext serviceContext)
    throws Exception {

    validate(ddmFormValues, serviceContext);

    long fileId = _counterLocalService.increment();

    DDMStructureVersion ddmStructureVersion =
        _ddmStructureVersionLocalService.getLatestStructureVersion(
            ddmStructureId);

    long classNameId = PortalUtil.getClassNameId(
        FileSystemStorageAdapter.class.getName());

    _ddmStorageLinkLocalService.addStorageLink(
        classNameId, fileId, ddmStructureVersion.getStructureVersionId(),
        serviceContext);

    saveFile(
        ddmStructureVersion.getStructureVersionId(), fileId, ddmFormValues);

    return fileId;
}

@Reference
private CounterLocalService _counterLocalService;

@Reference
private DDMStorageLinkLocalService _ddmStorageLinkLocalService;

@Reference
private DDMStructureVersionLocalService _ddmStructureVersionLocalService;
\end{verbatim}

These are the utility methods invoked in the create method:

\begin{verbatim}
private File getFile(long structureId, long fileId) {
    return new File(
        getStructureFolder(structureId), String.valueOf(fileId));
}

private File getStructureFolder(long structureId) {
    return new File(String.valueOf(structureId));
}

private void saveFile(
        long structureVersionId, long fileId, DDMFormValues formValues)
    throws IOException {

    String serializedDDMFormValues = _ddmFormValuesJSONSerializer.serialize(
        formValues);

    File formEntryFile = getFile(structureVersionId, fileId);

    FileUtil.write(formEntryFile, serializedDDMFormValues);
}

@Reference
private DDMFormValuesJSONSerializer _ddmFormValuesJSONSerializer;
\end{verbatim}

\section{Read}\label{read}

To retrieve the form record's values from the \texttt{File} object where
they were written, override \texttt{doGetDDMFormValues}:

\begin{verbatim}
@Override
protected DDMFormValues doGetDDMFormValues(long classPK) throws Exception {
    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    DDMStructureVersion structureVersion =
        _ddmStructureVersionLocalService.getStructureVersion(
            storageLink.getStructureVersionId());

    String serializedDDMFormValues = FileUtil.read(
        getFile(structureVersion.getStructureVersionId(), classPK));

    return _ddmFormValuesJSONDeserializer.deserialize(
        structureVersion.getDDMForm(), serializedDDMFormValues);
}

@Reference
private DDMFormValuesJSONDeserializer _ddmFormValuesJSONDeserializer;
\end{verbatim}

\section{Update}\label{update}

Override the \texttt{doUpdate} method so the record's values can be
overwritten. This example calls the \texttt{saveFile} utility method
provided earlier:

\begin{verbatim}
@Override
protected void doUpdate(
        long classPK, DDMFormValues ddmFormValues,
        ServiceContext serviceContext)
    throws Exception {

    validate(ddmFormValues, serviceContext);

    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    saveFile(
        storageLink.getStructureVersionId(), storageLink.getClassPK(),
        ddmFormValues);
}
\end{verbatim}

\section{Delete}\label{delete}

Override the \texttt{doDeleteByClass} method to delete the \texttt{File}
representing the form record, using the \texttt{classPK}, and to delete
the class storage links:

\begin{verbatim}
@Override
protected void doDeleteByClass(long classPK) throws Exception {
    DDMStorageLink storageLink =
        _ddmStorageLinkLocalService.getClassStorageLink(classPK);

    FileUtil.delete(getFile(storageLink.getStructureId(), classPK));

    _ddmStorageLinkLocalService.deleteClassStorageLink(classPK);
}
\end{verbatim}

Provide form record deletion logic to be called when deleting all the
records and storage links associated with a form (using its
\texttt{ddmStructureId}):

\begin{verbatim}
@Override
protected void doDeleteByDDMStructure(long ddmStructureId)
    throws Exception {

    FileUtil.deltree(getStructureFolder(ddmStructureId));

    _ddmStorageLinkLocalService.deleteStructureStorageLinks(ddmStructureId);
}
\end{verbatim}

\section{Beyond CRUD: Validation}\label{beyond-crud-validation}

Add a \texttt{validate} method to the \texttt{StorageAdapter}:

\begin{verbatim}
protected void validate(
    DDMFormValues ddmFormValues, ServiceContext serviceContext)
    throws Exception {

    boolean validateDDMFormValues = GetterUtil.getBoolean(
        serviceContext.getAttribute("validateDDMFormValues"), true);

    if (!validateDDMFormValues) {
        return;
    }

    _ddmFormValuesValidator.validate(ddmFormValues);
}
\end{verbatim}

Deploy your storage adapter and it's ready to use.

\chapter{Overriding Language Keys}\label{overriding-language-keys}

Core and portlet module \texttt{Language*.properties} files implement
site internationalization. They're fully customizable, too. This section
demonstrates this in the following topics:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
  Liferay's Language Keys}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-a-modules-language-keys}{Overriding
  a Module's Language Keys}
\end{itemize}

\chapter{Overriding Global Language
Keys}\label{overriding-global-language-keys}

Language files contain
\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{translations
of your application's user interface messages}. But you can also
override the default language keys globally and in other applications
(including your own). Here are the steps for overriding language keys:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[determine-the-language-keys-to-override]{Determine the
  language keys to override}
\item
  \hyperref[override-the-keys-in-a-new-language-properties-file]{Override
  the keys in a new language properties file}
\item
  \hyperref[create-a-resource-bundle-service-component]{Create a
  Resource Bundle service component}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Many applications that were once part of Liferay Portal
6.2 are now modularized. Their language keys might have been moved out
of Liferay's language properties files and into one of the application's
modules. The process for
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-a-modules-language-keys}{overriding
a module's language keys} is different from the process for overriding
Liferay's language keys.

\noindent\hrulefill

\section{Determine the language keys to
override}\label{determine-the-language-keys-to-override}

So how do you find global language keys? They're in the
\texttt{Language{[}xx\_XX{]}.properties} files in the source code or
your bundle.

\begin{itemize}
\item
  From the source:

  \texttt{/portal-impl/src/content/Language{[}xx\_XX{]}.properties}
\item
  From a bundle:

  \texttt{portal-impl.jar}
\end{itemize}

All language properties files contain properties you can override, like
the language settings properties:

\begin{verbatim}
##
## Language settings
##

...
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
...
\end{verbatim}

There are also many simple keys you can override to update default
messages and labels.

\begin{verbatim}
##
## Category titles
##

category.admin=Admin
category.alfresco=Alfresco
category.christianity=Christianity
category.cms=Content Management
...
\end{verbatim}

For example, Figure 1 shows a button that uses Liferay's
\texttt{publish} default language key.

\begin{verbatim}
`publish=Publish`
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/standard-publish.png}
\caption{Messages displayed in Liferay's user interface can be
customized.}
\end{figure}

Next, you'll learn how to override this key.

\section{Override the keys in a new language properties
file}\label{override-the-keys-in-a-new-language-properties-file}

Once you know the keys to override, create a language properties file
for the locale you want (or the default \texttt{Language.properties}
file) in your module's \texttt{src/main/resources/content} folder. In
your file, define the keys your way. For example, you could override the
\texttt{publish} key.

\begin{verbatim}
publish=Publish Override
\end{verbatim}

To enable your change, you must create a resource bundle service
component to reference your language file.

\section{Create a Resource Bundle service
component}\label{create-a-resource-bundle-service-component}

In your module, create a class that extends
\texttt{java.util.ResourceBundle} for the locale you're overriding.
Here's an example resource bundle class for the \texttt{en\_US} locale:

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
public class MyEnUsResourceBundle extends ResourceBundle {

    @Override
    protected Object handleGetObject(String key) {
        return _resourceBundle.getObject(key);
    }

    @Override
    public Enumeration<String> getKeys() {
        return _resourceBundle.getKeys();
    }

    private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
        "content.Language_en_US", UTF8Control.INSTANCE);

}
\end{verbatim}

The class's \texttt{\_resourceBundle} field is assigned a
\texttt{ResourceBundle}. The call to \texttt{ResourceBundle.getBundle}
needs two parameters. The \texttt{content.Language\_en\_US} parameter is
the language file's qualified name with respect to the module's
\texttt{src/main/resources} folder. The second parameter is a
\texttt{control} that sets the language syntax of the resource bundle.
To use language syntax identical to Liferay's syntax, import Liferay's
\texttt{com.liferay.portal.kernel.language.UTF8Control} class and set
the second parameter to \texttt{UTF8Control.INSTANCE}.

The class's \texttt{@Component} annotation declares it an OSGi
\texttt{ResourceBundle} service component. It's \texttt{language.id}
property designates it for the \texttt{en\_US} locale.

\begin{verbatim}
@Component(
    property = { "language.id=en_US" }, 
    service = ResourceBundle.class
)
\end{verbatim}

The class overrides these methods:

\begin{itemize}
\item
  \textbf{\texttt{handleGetObject}:} Looks up the key in the module's
  resource bundle (which is based on the module's language properties
  file) and returns the key's value as an \texttt{Object}.
\item
  \textbf{\texttt{getKeys}:} Returns an \texttt{Enumeration} of the
  resource bundle's keys.
\end{itemize}

Your resource bundle service component redirects the default language
keys to your module's language key overrides.

\noindent\hrulefill

\textbf{Note}: Global language key overrides for multiple locales
require a separate module for each locale. Each module's
\texttt{ResourceBundle} extension class (like the
\texttt{MyEnUsResourceBundle} class above) must specify its locale in
the \texttt{language.id} component property definition and in the
language file qualified name parameter. For example, here is what they
look like for the Spanish locale.

Component definition:

\begin{verbatim}
@Component(
    property = { "language.id=es_ES" },
    service = ResourceBundle.class
)
\end{verbatim}

Resource bundle assignment:

\begin{verbatim}
private final ResourceBundle _resourceBundle = ResourceBundle.getBundle(
    "content.Language_es_ES", UTF8Control.INSTANCE);
\end{verbatim}

\noindent\hrulefill

\textbf{Important}: If your module
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{uses
language keys from another module} and
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{overrides
any of that other module's keys}, make sure to use OSGi headers to
specify the capabilities your module requires and provides. This lets
you prioritize resource bundles from the modules.

To see your Liferay language key overrides in action,
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy
your module} and visit the portlets and pages that use the keys.

\begin{figure}
\centering
\includegraphics{./images/localized-publish.png}
\caption{This button uses the overridden \texttt{publish} key.}
\end{figure}

That's all there is to overriding Liferay's language keys.

\section{Related Topics}\label{related-topics-25}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
  Core Language Key Hooks}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-a-modules-language-keys}{Overriding
  a Module's Language Keys}
\end{itemize}

\chapter{Overriding a Module's Language
Keys}\label{overriding-a-modules-language-keys}

What do you do if the language keys you want to modify are in one of
Liferay's applications or another module whose source code you don't
control? Since module language keys are in the respective module, the
process for overriding a module's language keys is different from
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-global-language-keys}{the
process of overriding Liferay's language keys}.

Here is the process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[find-the-module-and-its-metadata-and-language-keys]{Find the
  module and its metadata and language keys}
\item
  \hyperref[write-custom-language-key-values]{Write your custom language
  key values}
\item
  \hyperref[prioritize-your-modules-resource-bundle]{Prioritize your
  module's resource bundle}
\end{enumerate}

\section{Find the module and its metadata and language
keys}\label{find-the-module-and-its-metadata-and-language-keys}

In
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell}, list the bundles and grep for keyword(s) that match the
portlet's display name. Language keys are in the portlet's web module
(bundle). When you find the bundle, note its ID number.

To find the Blogs portlet, for example, your Gogo commands and output
might look like this:

\begin{verbatim}
g! lb | grep Blogs
  152|Active     |    1|Liferay Blogs Service (1.0.2)
  184|Active     |    1|Liferay Blogs Editor Config (2.0.1)
  202|Active     |    1|Liferay Blogs Layout Prototype (2.0.2)
  288|Active     |    1|Liferay Blogs Recent Bloggers Web (1.0.2)
  297|Active     |    1|Liferay Blogs Item Selector Web (1.0.2)
  374|Active     |    1|Liferay Blogs Item Selector API (2.0.1)
  448|Active     |    1|Liferay Blogs API (3.0.1)
  465|Active     |    1|Liferay Blogs Web (1.0.6)
true
\end{verbatim}

List the bundle's headers by passing its ID to the \texttt{headers}
command.

\begin{verbatim}
g! headers 465

Liferay Blogs Web (465)
-----------------------
Manifest-Version = 1.0
Bnd-LastModified = 1459866186018
Bundle-ManifestVersion = 2
Bundle-Name = Liferay Blogs Web
Bundle-SymbolicName = com.liferay.blogs.web
Bundle-Version: 1.0.6
... 
Web-ContextPath = /blogs-web
g! 
\end{verbatim}

Note the \texttt{Bundle-SymbolicName}, \texttt{Bundle-Version}, and
\texttt{Web-ContextPath}. The \texttt{Web-ContextPath} value, following
the \texttt{/}, is the servlet context name.

\textbf{Important}: Record the servlet context name, bundle symbolic
name and version, as you'll use them to create the resource bundle
loader later in the process.

For example, here are those values for Liferay Blogs Web module:

\begin{itemize}
\tightlist
\item
  Bundle symbolic name: \texttt{com.liferay.blogs.web}
\item
  Bundle version: \texttt{4.0.16}
\item
  Servlet context name: \texttt{blogs-web}
\end{itemize}

Next find the module's JAR file so you can examine its language keys.
Liferay follows this module JAR file naming convention:

\begin{verbatim}
[bundle symbolic name]-[version].jar
\end{verbatim}

For example, the Blogs Web version 4.0.16 module is in
\texttt{com.liferay.blogs.web-4.0.16.jar}.

Here's where to find the module JAR:

\begin{itemize}
\tightlist
\item
  Liferay's
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/}{Nexus
  repository}
\item
  \texttt{{[}Liferay\ Home{]}/osgi/modules}
\item
  Embedded in an application's or application suite's LPKG file in
  \texttt{{[}Liferay\ \ \ \ \ Home{]}/osgi/marketplace}.
\end{itemize}

The language property files are in the module's
\texttt{src/main/resources/content} folder. Identify the language keys
you want to override in the \texttt{Language{[}\_xx{]}.properties}
files.

Checkpoint: Make sure you have the required information for overriding
the module's language keys:

\begin{itemize}
\tightlist
\item
  Language keys
\item
  Bundle symbolic name
\item
  Servlet context name
\end{itemize}

Next you'll write new values for the language keys.

\section{Write custom language key
values}\label{write-custom-language-key-values}

Create a new module to hold a resource bundle loader and your custom
language keys.

In your module's \texttt{src/main/resources/content} folder, create
\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{language
properties files} for each locale whose keys you want to override. In
each language properties file, specify your language key overrides.

Next you'll prioritize your module's language keys as a resource bundle
for the target module.

\section{Prioritize Your Module's Resource
Bundle}\label{prioritize-your-modules-resource-bundle}

Now that your language keys are in place, use OSGi manifest headers to
specify the language keys are for the target module. To compliment the
target module's resource bundle, you'll aggregate your resource bundle
with the target module's resource bundle. You'll list your module first
to prioritize its resource bundle over the target module resource
bundle. Here's an example of module
\texttt{com.liferay.docs.l10n.myapp.lang} prioritizing its resource
bundle over target module \texttt{com.liferay.blogs.web}'s resource
bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)";bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language";service.ranking:Long="2";\
servlet.context.name=blogs-web
\end{verbatim}

The example \texttt{Provide-Capability} header has two parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle with the base name
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles with resource bundles to
  aggregate, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=com.liferay.docs.l10n.myapp.lang),(bundle.symbolic.name=com.liferay.blogs.web)"}:
    The service aggregates resource bundles from bundles
    \texttt{com.liferay.docs.l10n.myapp.lang} and
    \texttt{com.liferay.blogs.web}. Aggregate as many bundles as
    desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=com.liferay.blogs.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{com.liferay.blogs.web} bundle's resource bundle
    named \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="2"}: The resource bundle's service
    ranking is \texttt{2}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{com.liferay.blogs.web}'s \texttt{content.Language} resource
    bundle.
  \item
    \texttt{servlet.context.name=blogs-web}: The target resource bundle
    is in servlet context \texttt{blogs-web}.
  \end{itemize}
\end{enumerate}

\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
your module} to see the language keys you've overridden.

\noindent\hrulefill

\textbf{Tip:} If your override isn't showing, use
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
Shell} to check for competing resource bundle services. It may be that
another service outranks yours. To check for competing resource bundle
services whose aggregates include \texttt{com.liferay.blogs.web}'s
resource bundle, for example, execute this Gogo Shell command:

\begin{verbatim}
 services "(bundle.symbolic.name=com.liferay.login.web)"
\end{verbatim}

Search the results for resource bundle aggregate services whose ranking
is higher.

\noindent\hrulefill

Now you can modify the language keys of modules in Liferay's OSGi
runtime. Remember, language keys you want to override might actually be
in Liferay's core. You can
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{override
Liferay's language keys} too.

\section{Related Topics}\label{related-topics-26}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-core-language-key-hooks}{Upgrading
  Core Language Key Hooks}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-global-language-keys}{Overriding
  Global Language Keys}
\end{itemize}

\chapter{Overriding Liferay Services (Service
Wrappers)}\label{overriding-liferay-services-service-wrappers}

Why might you need to customize Liferay services? Perhaps you've added a
new field to Liferay's \texttt{User} object and you want its value to be
saved whenever the \texttt{addUser} or \texttt{updateUser} methods of
Liferay's API are called. Or maybe you want to add some additional
logging functionality to some Liferay APIs or other services built using
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}. Whatever your case may be, Liferay's service wrappers provide
easy-to-use extension points for customizing Liferay's services.

To create a module that overrides one of Liferay's services, use
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} to
create a \texttt{servicewrapper} project type with the command below
(replace the class and package names with your own):

\begin{verbatim}
blade create -t service-wrapper -p com.liferay.docs.serviceoverride 
-c UserLocalServiceOverride -s 
com.liferay.portal.kernel.service.UserLocalServiceWrapper service-override
\end{verbatim}

As an example, here's the \texttt{UserLocalServiceOverride} class that's
generated with the Service Wrapper Template:

\begin{verbatim}
package com.liferay.docs.serviceoverride;

import com.liferay.portal.kernel.service.UserLocalServiceWrapper;
import com.liferay.portal.kernel.service.ServiceWrapper;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
    },
    service = ServiceWrapper.class
)
public class UserLocalServiceOverride extends UserLocalServiceWrapper {

    public UserLocalServiceOverride() {
        super(null);
    }

}
\end{verbatim}

Notice that you must specify the fully qualified class name of the
service wrapper class that you want to extend. The \texttt{service}
argument was used in full in this import statement:

\begin{verbatim}
import com.liferay.portal.service.UserLocalServiceWrapper;
\end{verbatim}

This import statement, in turn, allowed the short form of the service
wrapper class name to be used in the class declaration of your component
class:

\begin{verbatim}
public class UserLocalServiceOverride extends UserLocalServiceWrapper {...}
\end{verbatim}

The bottom line is that when using \texttt{blade\ create} to create a
service wrapper project, you must specify a fully qualified class name
as the \texttt{service} argument. (This is also true when using
\texttt{blade\ create} to create a service project.) For information
about creating service projects, please see
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}.

The generated \texttt{UserLocalServiceOverride} class does not actually
customize any Liferay service. Before you can test that your service
wrapper module actually works, you need to override at least one service
method.

Open your \texttt{UserLocalServiceOverride} class and add the following
methods:

\begin{verbatim}
@Override
public int authenticateByEmailAddress(long companyId, String emailAddress,
        String password, Map<String, String[]> headerMap,
        Map<String, String[]> parameterMap, Map<String, Object> resultsMap)
    throws PortalException {

    System.out.println(
        "Authenticating user by email address " + emailAddress);
    return super.authenticateByEmailAddress(companyId, emailAddress, password,
        headerMap, parameterMap, resultsMap);
}

@Override
public User getUser(long userId) throws PortalException {
    System.out.println("Getting user by id " + userId);
    return super.getUser(userId);
}
\end{verbatim}

Each of these methods overrides a Liferay service method. These
implementations merely execute a few print statements that before
executing the original service implementations.

Lastly, you must add the following method to the bottom of your service
wrapper so it can find the appropriate service it's overriding on
deployment.

\begin{verbatim}
@Reference(unbind = "-")
private void serviceSetter(UserLocalService userLocalService) {
    setWrappedService(userLocalService);
}
\end{verbatim}

\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Build
and deploy your module}. Congratulations! You've created and deployed a
Liferay service wrapper!

\section{Related Topics}\label{related-topics-27}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-service-wrapper-hooks}{Upgrading
  Service Wrappers}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-blade-cli}{Installing
  Blade CLI}
\item
  \href{/docs/7-1/tutorials/-/knowledge_base/t/creating-projects-with-blade-cli}{Creating
  Projects with Blade CLI}
\end{itemize}

\chapter{Overriding lpkg Files}\label{overriding-lpkg-files}

Applications are delivered through Liferay Marketplace as \emph{lpkg}
files. This is a simple compressed file format that contains .jar files
for deploying to Liferay DXP. If you want to examine an application from
Marketplace, all you have to do is unzip its .lpkg file to reveal its
.jar files.

After examining an application, you may want to
\href{/docs/7-2/customization/-/knowledge_base/c/liferay-customization}{customize}
one of its .jars. Make your customization in a copy of the .jar, but
don't deploy it the way you'd normally deploy an application. By
overriding the .lpkg file, you can update application modules without
modifying the original .lpkg file. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Shut down Liferay DXP.
\item
  Create a folder called \texttt{override} in the
  \href{/docs/7-2/deploy/-/knowledge_base/d/liferay-home}{\texttt{Liferay\ Home{]}/osgi/marketplace}
  folder}.
\item
  Name your updated .jar the same as the .jar in the original .lpkg,
  minus the version information. For example, if you're overriding the
  \texttt{com.liferay.amazon.rankings.web-1.0.5.jar} from the
  \texttt{Liferay\ CE\ Amazon\ \ \ \ \ \ Rankings.lpkg}, you'd name your
  .jar \texttt{com.liferay.amazon.rankings.web.jar}.
\item
  Copy this .jar into the \texttt{override} folder you created in step
  one.
\end{enumerate}

This works for applications from Marketplace, but there's also the
static .lpkg that contains core Liferay technology and third-party
utilities (such as the servlet API, Apache utilities, etc.). To
customize or patch any of these .jar files, follow this process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make your customization and package it in a .jar file.
\item
  Name your .jar the same as the original .jar, minus the version
  information. For example, a customized
  \texttt{com.liferay.portal.profile-1.0.4.jar} should be
  \texttt{com.liferay.portal.profile.jar}.
\item
  Copy the .jar into the \texttt{{[}Liferay\ Home{]}/osgi/static}
  folder.
\end{enumerate}

Now start Liferay DXP. Note that any time you add and remove .jars this
way, Liferay DXP must be shut down and then restarted for the changes to
take effect.

If you must roll back your customizations, delete the overriding .jar
files: Liferay DXP uses the original .jar on its next startup.

\chapter{Overriding Liferay MVC
Commands}\label{overriding-liferay-mvc-commands}

MVC Commands are used to break up the controller layer of
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC applications} into smaller, more digestible code chunks.

Sometimes you'll want to override an MVC command, whether it's in a
Liferay application or another Liferay MVC application whose source code
you don't own. Since MVC commands are components registered in the OSGi
runtime, you can simply publish your own customization of the component,
give it a higher service ranking, and deploy it.

All existing components that reference the original MVC command service
component (using a greedy reference policy) switch to reference your new
one. Any existing
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-osgi-services}{reluctant
references to the original command must be configured to reference the
new one}. Once they're configured with the new service component, their
JSP's command URLs invoke the new custom MVC command.

Here are the customization options available for each Liferay MVC
Command type:

\begin{itemize}
\tightlist
\item
  MVCActionCommand:
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcactioncommand}{Add
  logic}
\item
  MVCRenderCommand:

  \begin{itemize}
  \tightlist
  \item
    \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcrendercommand\#adding-logic-to-an-existing-mvc-render-command}{Add
    logic}
  \item
    \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcrendercommand\#redirecting-to-a-new-jsp}{Redirect
    to a different JSP}
  \end{itemize}
\item
  MVCResourceCommand:
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcresourcecommand}{Add
  logic}
\end{itemize}

This section demonstrates each MVC command customization option. Since
the steps for adding logic are generally the same across MVC command
types, start with
\href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{adding
logic}.

\chapter{Adding Logic to MVC
Commands}\label{adding-logic-to-mvc-commands}

You can completely override MVC commands, or any OSGi service for that
matter, but \emph{adding logic} to the commands is the better option.
Discarding necessary logic is bad. Conversely any logic you copy from
the original might not work in new versions of the portlet. Adding
custom logic while continuing to invoke the original logic decouples the
custom class from the original implementation. Keeping the new logic
separate form the original logic keeps the code clean, maintainable, and
easy to understand.

Here are the steps for adding logic to MVC commands:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[step-1-implement-the-interface]{Implement the interface}
\item
  \hyperref[step-2-publish-as-a-component]{Publish as a component}
\item
  \hyperref[step-3-refer-to-the-original-implementation]{Refer to the
  original implementation}
\item
  \hyperref[step-4-add-the-logic]{Add the logic, and call the original}
\end{enumerate}

\section{Step 1: Implement the
interface}\label{step-1-implement-the-interface}

Implement the respective MVC Command interface either directly or by
extending an existing base class that implements it. Extending a base
class for the interface relieves you from implementing logic that should
typically be a part of most command implementations. For example, to add
logic to the Blogs portlet's \texttt{EditEntryMVCActionCommand}, you
would extend base class \texttt{BaseMVCActionCommand}.

\begin{verbatim}
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {...}
\end{verbatim}

Check the MVC command interfaces for existing base classes:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}
\end{itemize}

Next make your class a service component.

\section{Step 2: Publish as a
component}\label{step-2-publish-as-a-component}

The Declarative Services \texttt{@Component} annotation facilitates
customizing MVC commands. All the customization options require
publishing your MVC command class as a component. For example, this
\texttt{@Component} annotation declares an \texttt{MVCActionCommand}
service.

\begin{verbatim}
@Component(
    immediate = true,
    property = { 
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN, 
        "mvc.command.name=/blogs/edit_entry",
        "service.ranking:Integer=100" 
    }, 
    service = MVCActionCommand.class
)
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {
    ...
} 
\end{verbatim}

It publishes \texttt{CustomBlogsMVCActionCommand} as a service component
for the \texttt{MVCActionCommand} class. Upon resolving, it's activated
immediately because \texttt{immediate\ =\ true}. The component is
invoked in the Blogs Admin portlet by the command URL
\texttt{/blogs/edit\_entry}. Its service ranking of \texttt{100}
prioritizes it ahead of the original service component, whose ranking is
\texttt{0}.

Here's what you need to specify in an \texttt{@Component} annotation for
your custom MVC command:

\begin{itemize}
\item
  \texttt{javax.portlet.name}: for each portlet you want the
  customization to affect. JSPs in these portlets can invoke the MVC
  command via applicable command URL tags. You can specify the same
  portlets as the original MVC command or a subset of those portlets.
\item
  \texttt{mvc.command.name}: this property declares the command URL that
  maps to this custom MVC command component.
\item
  \texttt{service.ranking:Integer}: set this property to a higher
  integer than the original service implementation's ranking. The
  ranking tells the OSGi runtime which service to use, in cases where
  multiple components register the same service, with the same
  properties. The higher the integer you specify here, the more weight
  your component carries. Liferay's service implementations typically
  have a \texttt{0} ranking.
\item
  \texttt{service}: this attribute specifies the service (interface) to
  override.
\item
  \texttt{immediate}: set this attribute to \texttt{true} to activate
  your component immediately upon resolution.
\end{itemize}

You can refer back to this list as you add \texttt{@Component}
annotations to your custom MVC commands.

Next reference the original implementation.

\section{Step 3: Refer to the original
implementation}\label{step-3-refer-to-the-original-implementation}

Use a field annotated with \texttt{@Reference} to fetch a reference to
the original MVC command component. If there are no additional
customizations on the original component, this reference will be for the
original MVC command type. For example, this field references the
original MVC command component \texttt{EditEntryMVCActionCommand}.

\begin{verbatim}
@Reference(
    target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCActionCommand)")
protected MVCActionCommand mvcActionCommand;
\end{verbatim}

Here's how to add the reference:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the field as the MVC command interface type that it is. For
  example, the \texttt{mvcActionCommand} field is type
  \texttt{MVCActionCommand}.
\item
  Add the \texttt{@Reference} annotation.
\item
  In the annotation, define a \texttt{target} attribute that filters on
  a \texttt{component.name} equal to the default service implementation
  class's fully qualified name.
\end{enumerate}

When your custom component resolves, the OSGi runtime assigns the
targeted service to your field. It's time to add your custom logic.

\section{Step 4: Add the logic}\label{step-4-add-the-logic}

Adding the logic involves overriding the primary method of the base
class you're extending or the interface you're implementing. In your
method override, add your new logic AND then invoke the original
implementation. For example, the following method overrides
\texttt{BaseMVCActionCommand}'s method \texttt{doProcessAction}.

\begin{verbatim}
@Override
protected void doProcessAction(
    ActionRequest actionRequest, ActionResponse actionResponse)
throws Exception {
    // Add custom logic here 
    ...
    
    // Call the original service implementation 
    mvcActionCommand.processAction(actionRequest, actionResponse);
}
\end{verbatim}

The method above defines custom logic and then invokes the original
service it referenced in the previous step.

If you use this approach, your extension will continue to work with new
versions of the original portlet, because no coupling exists between the
original portlet logic and your customization. The command
implementation class can change. Make sure to keep your reference
updated to the name of the current implementation class.

Congratulations on adding logic to your existing MVC command.

\chapter{Overriding
MVCRenderCommands}\label{overriding-mvcrendercommands}

You can override
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
for any portlet that uses Liferay's MVC framework and publishes an
\texttt{MVCRenderCommand} component.

For example, Liferay's Blogs application has a class called
\texttt{EditEntryMVCRenderCommand}, with this component:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}

This MVC render command can be invoked from any of the portlets
specified by the \texttt{javax.portlet.name} parameter, by calling a
render URL that names the MVC command:

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/edit_entry" />
    <portlet:param name="redirect" value="<%= viewEntriesURL %>" />
</portlet:renderURL>
\end{verbatim}

What if you want to override the command, but not for all of the
portlets listed in the original component? In your override component,
just list the \texttt{javax.portlet.name} of the portlets where you want
the override to take effect. For example, if you want to override the
\texttt{/blogs/edit\_entry} MVC render command just for the Blogs Admin
portlet (the Blogs Application accessed in the site administration
section of Liferay), your component could look like this:

\begin{verbatim}
@Component(
  immediate = true,
  property = {
     "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
     "mvc.command.name=/blogs/edit_entry",
     "service.ranking:Integer=100"
  },
  service = MVCRenderCommand.class
)
\end{verbatim}

Note the last property listed, \texttt{service.ranking}. It's used to
tell the OSGi runtime which service to use, in cases where there are
multiple components registering the same service, with the same
properties. The higher the integer you specify here, the more weight
your component carries. In this case, the override component is used
instead of the original one, since the default value for this property
is \texttt{0}.

After that, it's up to you to do whatever you'd like. MVC render
commands can be customized for these purposes:

\begin{itemize}
\tightlist
\item
  \hyperref[adding-logic-to-an-existing-mvc-render-command]{Adding Logic
  to an Existing MVC Render Command}
\item
  \hyperref[redirecting-to-a-new-jsp]{Redirecting to a new JSP}
\end{itemize}

Start by exploring how to add logic to an existing MVC render command.

\section{Adding Logic to an Existing MVC Render
Command}\label{adding-logic-to-an-existing-mvc-render-command}

You can add logic to an MVC render command following the
\href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{general
steps for MVC commands}. Specifically for MVC render commands, you must
directly implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}
interface} and override its \texttt{render} method.

For example, this custom MVC render command has a placeholder (i.e., at
comment \texttt{//Do\ something\ here}) for adding logic to the
\texttt{render} method:

\begin{verbatim}
public CustomEditEntryRenderCommand implements MVCRenderCommand {
    @Override
    public String render(RenderRequest renderRequest, 
                        RenderResponse renderResponse)
           throws PortletException {

        //Do something here

        return mvcRenderCommand.render(renderRequest, renderResponse);
    }

    @Reference(target = 
          "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand)")
      protected MVCRenderCommand mvcRenderCommand;
}
\end{verbatim}

The example references an \texttt{EditEntryMVCRenderCommand}
implementation of \texttt{MVCRenderCommand}. In the \texttt{render}
method, you'd replace the placeholder with new logic and then invoke the
original implementation's logic by calling its \texttt{render} method.

Sometimes, you might need to redirect the request to an entirely new
JSP. You can do that from a custom MVC render command module too.

\section{Redirecting to a New JSP}\label{redirecting-to-a-new-jsp}

\texttt{MVCRenderCommand}'s \texttt{render} method returns a JSP path as
a String. By default, the JSP must live in the original module, so you
cannot simply specify a path to a custom JSP in your override module. To
redirect it to a JSP in your new module, you must make the method skip
dispatching to the original JSP altogether, by using the constant
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderConstants.html}{\texttt{MVCRenderConstants.MVC\_PATH\_VALUE\_SKIP\_DISPATCH}
class}. Then you need to initiate your own dispatching process,
directing the request to your JSP path. Here's how that might look in
practice:

\begin{verbatim}
public class CustomEditEntryMVCRenderCommand implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) throws
            PortletException {

        System.out.println("Rendering custom_edit_entry.jsp");

        RequestDispatcher requestDispatcher =
            servletContext.getRequestDispatcher("/custom_edit_entry.jsp");

        try {
            HttpServletRequest httpServletRequest = 
                PortalUtil.getHttpServletRequest(renderRequest);
            HttpServletResponse httpServletResponse = 
                PortalUtil.getHttpServletResponse(renderResponse);

            requestDispatcher.include
                (httpServletRequest, httpServletResponse);
        } catch (Exception e) {
            throw new PortletException
                ("Unable to include custom_edit_entry.jsp", e);
        }

        return MVCRenderConstants.MVC_PATH_VALUE_SKIP_DISPATCH;
    }

    @Reference(target = "(osgi.web.symbolicname=com.custom.code.web)")
    protected ServletContext servletContext;
}
\end{verbatim}

The servlet context provides access to the request dispatcher. A servlet
context is automatically created for portlets. It can be created for
other modules by including the following line in your \texttt{bnd.bnd}
file:

\begin{verbatim}
Web-ContextPath: /custom-code-web
\end{verbatim}

Follow these steps to fetch the portlet's servlet context in your custom
MVC render command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a \texttt{ServletContext} field.

\begin{verbatim}
protected ServletContext servletContext;
\end{verbatim}
\item
  Add the \texttt{@Reference} annotation to the field and set the
  annotation to filter on the portlet's module. By convention, Liferay
  puts portlets in modules whose symbolic names end in \texttt{.web}.
  For example, this servlet context reference filters on a module whose
  symbolic name is \texttt{com.custom.code.web}.

\begin{verbatim}
@Reference(target = "(osgi.web.symbolicname=com.custom.code.web)")
protected ServletContext servletContext;
\end{verbatim}
\end{enumerate}

Implement your \texttt{render} method this way:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a request dispatcher to your module's custom JSP:

\begin{verbatim}
RequestDispatcher requestDispatcher =
    servletContext.getRequestDispatcher("/custom_edit_entry.jsp");
\end{verbatim}
\item
  Include the HTTP servlet request and response in the request
  dispatcher.

\begin{verbatim}
try {
    HttpServletRequest httpServletRequest = 
        PortalUtil.getHttpServletRequest(renderRequest);
    HttpServletResponse httpServletResponse = 
        PortalUtil.getHttpServletResponse(renderResponse);

    requestDispatcher.include
        (httpServletRequest, httpServletResponse);
} catch (Exception e) {
    throw new PortletException
        ("Unable to include custom_edit_entry.jsp", e);
}
\end{verbatim}
\item
  Return the request dispatcher via the constant
  \texttt{MVC\_PATH\_VALUE\_SKIP\_DISPATCH}.

\begin{verbatim}
return MVCRenderConstants.MVC_PATH_VALUE_SKIP_DISPATCH;
\end{verbatim}
\end{enumerate}

After deploying your module, the
\href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands\#step-2-publish-as-a-component}{portlets
targeted by your custom \texttt{MVCRenderCommand} component} render your
new JSP.

\section{Related Topics}\label{related-topics-28}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{Adding
  Logic to MVC Commands}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-struts-action-hooks}{Converting
  StrutsActionWrappers to MVCCommands}
\end{itemize}

\chapter{Overriding
MVCActionCommands}\label{overriding-mvcactioncommands}

In case you want add to a Liferay MVC action command, you can. The OSGi
framework lets you override MVC action commands if you follow the
instructions for
\href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{adding
logic to MVC commands}. It involves
\href{/docs/7-1/tutorials/-/knowledge_base/t/adding-logic-to-mvc-commands\#publish-as-a-component}{registering
your custom MVC action command as an OSGi component} with the same
properties as the original, but with a higher service ranking.

Custom MVC action commands typically extend the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}
class}, and override its \texttt{doProcessAction} method, which returns
\texttt{void}. Add your logic to the original behavior of the action
method by getting a reference to the original service, and calling it
after your own logic.

For example, this \texttt{MVCActionCommand} override checks whether the
\texttt{delete} action is invoked on a blog entry, and prints a message
to the log, before continuing with the original processing:

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN, 
        "mvc.command.name=/blogs/edit_entry",
        "service.ranking:Integer=100" 
    }, 
    service = MVCActionCommand.class
)
public class CustomBlogsMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction
        (ActionRequest actionRequest, ActionResponse actionResponse) 
        throws Exception {

        String cmd = ParamUtil.getString(actionRequest, Constants.CMD);

        if (cmd.equals(Constants.DELETE)) {
            System.out.println("Deleting a Blog Entry");
        }

        mvcActionCommand.processAction(actionRequest, actionResponse);
    }

    @Reference(
        target = "(component.name=com.liferay.blogs.web.internal.portlet.action.EditEntryMVCActionCommand)")
    protected MVCActionCommand mvcActionCommand;

}
\end{verbatim}

Adding MVC action command logic before existing logic is straightforward
and maintains loose coupling between new and old code.

\section{Related Topics}\label{related-topics-29}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{Adding
  Logic to MVC Commands}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcrendercommand}{Overriding
  MVCRenderCommands}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-struts-action-hooks}{Converting
  StrutsActionWrappers to MVCCommands}
\end{itemize}

\chapter{Overriding
MVCResourceCommands}\label{overriding-mvcresourcecommands}

If you need to add functionality to a Liferay MVC resource command, you
can. The Liferay MVC command framework supports customizing MVC resource
commands. It follows the process for
\href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{adding
logic to MVC commands} and it is similar to the ones described for
\texttt{MVCRenderCommand} and \texttt{MVCActionCommand}. There's a
couple things to keep in mind:

\begin{itemize}
\item
  The service to specify in your component is
  \texttt{MVCResourceCommand.class}
\item
  As with overriding \texttt{MVCRenderCommand}, there's no base
  implementation class to extend. Implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}
  interface} yourself.
\item
  Keep your code decoupled from the original code by adding your logic
  to the original \texttt{MVCResourceCommand}'s logic by getting a
  reference to the original and returning a call to its
  \texttt{serveResource} method:
\end{itemize}

\begin{verbatim}
return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
\end{verbatim}

The following example overrides the behavior of
\texttt{com.liferay.login.web.portlet.action.CaptchaMVCResourceCommand},
from the Liferay's Login portlet's \texttt{login-web} module. It simply
prints a line in the console and then executes the original logic:
returning the Captcha image for the account creation screen.

\begin{verbatim}
@Component(
    property = { 
        "javax.portlet.name=" + LoginPortletKeys.LOGIN,
        "mvc.command.name=/login/captcha"
    }, 
    service = MVCResourceCommand.class
)
public class CustomCaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource
        (ResourceRequest resourceRequest, ResourceResponse resourceResponse) {

        System.out.println("Serving login captcha image");

        return mvcResourceCommand.serveResource(resourceRequest, resourceResponse);
    }

    @Reference(target = 
        "(component.name=com.liferay.login.web.internal.portlet.action.CaptchaMVCResourceCommand)")
    protected MVCResourceCommand mvcResourceCommand;
}
\end{verbatim}

And that, as they say, is that. Even if you don't own the source code of
an application, you can
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-liferay-mvc-commands}{override
its MVC commands} just by knowing the component class name.

\section{Related Topics}\label{related-topics-30}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-logic-to-mvc-commands}{Adding
  Logic to MVC Commands}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-mvcrendercommand}{Overriding
  MVCRenderCommands}
\end{itemize}

\chapter{Overriding OSGi Services}\label{overriding-osgi-services}

Components register as services with the OSGi service registry. A
service component's availability, ranking, and attributes determine
whether components referring to the service type bind to that particular
service. Liferay DXP's OSGI container is a dynamic environment in which
services come and go and can be overridden, which means that if there's
a service whose behavior you want to change, you can override it. Here
are the steps for overriding a service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override}{Get
  the service and service reference details}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service}{Create
  a custom service}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/reconfiguring-components-to-use-your-service}{Configure
  components to use your custom service}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} services in
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/}{portal-impl}
are Spring beans that Liferay makes available as OSGi services.

\noindent\hrulefill

Start with examining the service you want to override.

\chapter{Examining an OSGi Service to
Override}\label{examining-an-osgi-service-to-override}

Creating and injecting a custom service in place of an existing service
requires three things:

\begin{itemize}
\tightlist
\item
  Understanding the service interface
\item
  The existing service
\item
  The references to the service
\end{itemize}

Your custom service must implement the service interface, match
references you want, and might need to invoke the existing service.

Getting components to adopt your custom service immediately can require
reconfiguring their references to the service. Here you'll flesh out
service details to make these decisions.

\section{Gathering Information on a
Service}\label{gathering-information-on-a-service}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Since component service references are extension points, start with
  determining the service you want to override and components that use
  that service.
\item
  Once you know the service and components that use it, use Gogo Shell's
  Service Component Runtime (SCR) to inspect the components and get the
  service and reference details. The
  \href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
  Shell} command \texttt{scr:info\ {[}componentName{]}} lists the
  component's attributes and service references.
\end{enumerate}

Here's an example \texttt{scr:info} command and results (abbreviated
with \texttt{...}) that describe component
\texttt{override.my.service.reference.OverrideMyServiceReference} (from
sample module
\href{https://portal.liferay.dev/documents/113763090/114000186/override-my-service-reference.zip}{override-my-service-reference})
and its reference to a service of type
\texttt{override.my.service.reference.service.api.SomeService}:

\begin{verbatim}
> scr:info override.my.service.reference.OverrideMyServiceReference 

...
Component Description:
    Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
...
Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
...
Component Configuration:
ComponentId: 2399
State: active
SatisfiedReference: _someService
  Target: null
  Bound to:        6840
      Properties:
        component.id = 2400
        component.name = override.my.service.reference.service.impl.SomeServiceImpl
        objectClass = [override.my.service.reference.service.api.SomeService]
        service.bundleid = 524
        service.id = 6840
        service.scope = bundle
...
\end{verbatim}

The \texttt{scr:info} results, like the ones above, contain information
relevant to injecting a custom service. Here's what you'll do with the
information:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[step-1-copy-the-service-interface-name]{Copy the service
  interface name}
\item
  \hyperref[step-2-copy-the-existing-service-name]{Copy the existing
  service name}
\item
  \hyperref[step-3-gather-reference-configuration-details-if-reconfiguration-is-needed]{Gather
  reference configuration details (if reconfiguration is necessary)}
\end{enumerate}

Start with the service interface.

\section{Step 1: Copy the Service Interface
Name}\label{step-1-copy-the-service-interface-name}

The reference's \emph{Interface Name} is the service interface's fully
qualified name.

\begin{verbatim}
...
Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    ...
\end{verbatim}

\textbf{Copy and save the interface name}, because it's the type your
custom service must implement.

\noindent\hrulefill

Javadocs for Liferay DXP service interfaces are at these locations:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/}{Liferay
  DXP core Javadocs}
\item
  \href{https://docs.liferay.com/dxp/apps}{Liferay DXP app Javadocs}
\item
  \href{https://mvnrepository.com/}{MVNRepository} and
  \href{https://search.maven.org/}{Maven Central} (for Liferay and
  non-Liferay artifact Javadocs).
\end{itemize}

\noindent\hrulefill

\section{Step 2: Copy the Existing Service
Name}\label{step-2-copy-the-existing-service-name}

If you want to invoke the existing service along with your custom
service, get the existing service name.

The \texttt{src:info} result's Component Configuration section lists the
existing service's fully qualified name. For example, the
\texttt{OverrideMyServiceReferencePortlet} component's references
\texttt{\_someService} is bound to a service component whose fully
qualified name is
\texttt{override.my.service.reference.service.impl.SomeServiceImpl}.

\begin{verbatim}
Component Configuration:
...
SatisfiedReference: _someService
  ...
  Bound to:        6840
      Properties:
        ...
        component.name = override.my.service.reference.service.impl.SomeServiceImpl
\end{verbatim}

\textbf{Copy the \texttt{component.name}} so you can reference the
service in your
\href{/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service}{custom
service}.

Here's an example of referencing the service above.

\begin{verbatim}
@Reference  (
    target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
)
private SomeService _defaultService;
\end{verbatim}

\section{Step 3: Gather Reference Configuration Details (if
reconfiguration is
needed)}\label{step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}

The service reference's policy and policy option determine a component's
conditions for adopting a particular service.

\begin{itemize}
\item
  If the reference's policy option is \texttt{greedy}, it binds to the
  matching, highest ranking service right away. The reference need not
  be reconfigured to adopt your service.
\item
  If policy is \texttt{static} and its policy option is
  \texttt{reluctant}, however, the component requires one of the
  following conditions to switch from using the existing service it's
  referencing to using the matching, highest ranking service (i.e.,
  you'll rank your custom service highest):

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    The component is reactivated
  \item
    The component's existing referenced service is unavailable
  \item
    The component's reference is modified so that it does not match the
    existing service but matches your service
  \end{enumerate}
\end{itemize}

\href{/docs/7-2/customization/-/knowledge_base/c/reconfiguring-components-to-use-your-service}{Reconfiguring
the reference} can be the quickest way for the component to adopt a new
service.

\textbf{Gather these details:}

\begin{itemize}
\item
  \emph{Component name:} Find this at \emph{Component Description} →
  \emph{Name}. For example,

\begin{verbatim}
  Component Description:
      Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
      ...
\end{verbatim}
\item
  \emph{Reference name:} The \emph{Reference} value (e.g.,
  \texttt{Reference:\ \_someService}).
\item
  \emph{Cardinality:} Number of service instances the reference can bind
  to.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: Declarative Services makes all components configurable
through OSGi Configuration Admin. Each \texttt{@Reference} annotation in
the source code has a name property, either \emph{explicitly} set in the
annotation or \emph{implicitly} derived from the name of the member on
which the annotation is used.

\begin{itemize}
\tightlist
\item
  If no reference name property is used and the \texttt{@Reference} is
  on a field, then the reference name is the field name. If
  \texttt{@Reference} is on a field called \texttt{\_someService}, for
  example, then the reference name is \texttt{\_someService}.
\item
  If the \texttt{@Reference} is on a method, then heuristics derive the
  reference name. Method name suffix is used and prefixes such as
  \texttt{set}, \texttt{add}, and \texttt{put} are ignored. If
  \texttt{@Reference} is on a method called
  \texttt{setSearchEngine(SearchEngine\ se)}, for example, then the
  reference name is \texttt{SearchEngine}.
\end{itemize}

\noindent\hrulefill

After
\href{/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service}{creating
your custom service} (next), you'll use the details you collected here
to
\href{/docs/7-2/customization/-/knowledge_base/c/reconfiguring-components-to-use-your-service}{configure
the component to use your custom service}.

Congratulations on getting the details required for overriding the OSGi
service!

\section{Related Topics}\label{related-topics-31}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
  Services and Dependency Injection with Declarative Services}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
  Shell}
\end{itemize}

\chapter{Creating a Custom OSGi
Service}\label{creating-a-custom-osgi-service}

It's time to implement your OSGi service. Make sure to
\href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override}{examine
the service and service reference details}, if you haven't done so
already. Here you'll create a custom service that implements the service
interface, declares it an OSGi service of that type, and makes it the
best match for binding with other components.

The example custom service \texttt{CustomServiceImpl} implements service
interface (from sample module
\href{https://portal.liferay.dev/documents/113763090/114000186/overriding-service-reference.zip}{\texttt{overriding-service-reference}})
\texttt{SomeService}, declares itself an OSGi service of the
\texttt{SomeService} service type, and even delegates work to the
existing service. Examine the example code below as you follow the steps
for creating your custom service:

\begin{verbatim}
@Component(
    property = {
        "service.ranking:Integer=100"
    },
    service = SomeService.class
)
public class CustomServiceImpl implements SomeService {

    @Override
    public String doSomething() {

        StringBuilder sb = new StringBuilder();
        sb.append(this.getClass().getName());
        sb.append(", which delegates to ");
        sb.append(_defaultService.doSomething());

        return sb.toString();
    }

    @Reference  (
        target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
    )
    private SomeService _defaultService;
}
\end{verbatim}

Here are the steps to create a custom OSGi service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module}.
\item
  Create your custom service class so that it \texttt{implements} the
  \href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override\#step-1-copy-the-service-interface-name}{service
  interface} you want. In the example above,
  \texttt{CustomServiceImpl\ implements\ SomeService}. Step 5 (later)
  demonstrates implementing the interface methods.
\item
  Make your class a Declarative Services component that is the best
  match for references to the service interface:

  \begin{itemize}
  \item
    Use an \texttt{@Component} annotation and \texttt{service} attribute
    to make your classes a Declarative Services (DS) component. This
    declares your class to be an OSGi service that can be made available
    in the OSGi service registry. The example class above is a DS
    service component of service type \texttt{SomeService.class}.
  \item
    Use a \texttt{service.ranking:Integer} component property to rank
    your service higher than existing services. The
    \texttt{"service.ranking:Integer=100"} property above sets the
    example's ranking to \texttt{100}.
  \end{itemize}
\item
  If you want to invoke the existing service implementation, declare a
  field that uses a Declarative Services reference to the existing
  service. Use the
  \href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override\#step-2-copy-the-existing-service-name}{\texttt{component.name}
  you copied when you examined the service} to target the existing
  service. The example above refers to an existing service like this:

\begin{verbatim}
@Reference  (
    target = "(component.name=override.my.service.reference.service.impl.SomeServiceImpl)"
)
private SomeService _defaultService;
\end{verbatim}

  The field lets you invoke the existing service in your custom service.
\item
  Override the interface's methods. Optionally, delegate work to the
  existing service implementation (see previous step).

  The example custom service's \texttt{doSomething} method delegates
  work to the original service implementation.
\item
  Register your custom service with the OSGi runtime framework by
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploying
  your module}.
\end{enumerate}

Components that reference the service type you implemented and whose
reference policy option is \texttt{greedy} bind to your custom service
immediately. Components bound to an existing service and whose reference
policy option is \texttt{reluctant} can be dynamically reconfigured to
use your service. That's demonstrated next.

\section{Related Topics}\label{related-topics-32}

\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\chapter{Reconfiguring Components to Use Your OSGi
Service}\label{reconfiguring-components-to-use-your-osgi-service}

In many cases, assigning your
\href{/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service}{custom
service (service)} a higher ranking convinces components to unbind from
their current service and bind to yours. In other cases, components keep
using their current service. Why is that? And how do you make components
adopt your service? The component's
\href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override\#step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}{service
reference policy option} is the key to determining the service.

Here are the policy options:

\texttt{greedy}: The component uses the matching, highest ranking
service as soon as it's available.

\texttt{reluctant}: The component uses the matching, highest ranking
service available in the following events:

\begin{itemize}
\tightlist
\item
  the component is (re)activated
\item
  the component's existing referenced service becomes unavailable
\item
  the component's reference is modified so that it no longer matches the
  existing bound service
\end{itemize}

In short, references with greedy policy options adopt your higher
ranking service right away, while ones with reluctant policy options
require particular events. What's great is that Liferay DXP's
Configuration Admin lets you use configuration files (config files) or
the API to swap in service reference changes on the fly. Here you'll use
a config file to reconfigure a service reference to use your custom
service immediately.

This article uses example modules \texttt{override-my-service-reference}
and \texttt{overriding-service-reference} to demonstrate reconfiguring a
service reference, binding the component to a different service. you can
apply the steps below to configure your own customization.

\begin{itemize}
\item
  \texttt{override-my-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/override-my-service-reference.zip}{download}):
  This module's portlet component
  \texttt{OverrideMyServiceReferencePortlet}'s field
  \texttt{\_someService} references a service of type
  \texttt{SomeService}. The reference's policy is static and reluctant.
  By default, it binds to an implementation called
  \texttt{SomeServiceImpl}.
\item
  \texttt{overriding-service-reference}
  (\href{https://portal.liferay.dev/documents/113763090/114000186/overriding-service-reference.zip}{download}):
  Provides a custom \texttt{SomeService} implementation called
  \texttt{CustomServiceImpl}. The module's configuration file overrides
  \texttt{OverrideMyServiceReferencePortlet}'s \texttt{SomeService}
  reference so that it binds to \texttt{CustomServiceImpl}.
\end{itemize}

You're ready to reconfigure a component's service reference to target
your custom service.

\section{Reconfiguring the Service
Reference}\label{reconfiguring-the-service-reference}

Liferay DXP's Configuration Admin lets you use configuration files to
swap in service references on the fly.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/user/-/knowledge_base/u/understanding-system-configuration-files}{Create
  a system configuration file} named after the referencing component.
  Follow the name convention \texttt{{[}component{]}.config}, replacing
  \texttt{{[}component{]}} with the
  \href{/docs/7-2/customization/-/knowledge_base/c/examining-an-osgi-service-to-override\#step-3-gather-reference-configuration-details-if-reconfiguration-is-needed}{component
  name}. The configuration file name for the example component
  \texttt{override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
  is:

\begin{verbatim}
override.my.service.reference.portlet.OverrideMyServiceReferencePortlet.config
\end{verbatim}
\item
  In the configuration file, add a reference target entry that filters
  on your custom service. Follow this format for the entry:

\begin{verbatim}
[reference].target=[filter]
\end{verbatim}

  Replace \texttt{{[}reference{]}} with the name of the reference you're
  overriding. Replace \texttt{{[}filter{]}} with service properties that
  filter on your custom service.

  This example filters on the \texttt{component.name} service property:

\begin{verbatim}
_someService.target="(component.name\=overriding.service.reference.service.CustomServiceImpl)" 
\end{verbatim}

  This example filters on the \texttt{service.vendor} service property:

\begin{verbatim}
_someService.target="(service.vendor\=Acme, Inc.)"
\end{verbatim}
\item
  Optionally, you can add a \texttt{cardinality.minimum} entry to
  specify the number of services the reference can use. Here's the
  format:

\begin{verbatim}
[reference].cardinality.minimum=[int]
\end{verbatim}

  Here's an example cardinality minimum:

\begin{verbatim}
_someService.cardinality.minimum=1
\end{verbatim}
\item
  Deploy the configuration by copying the configuration file into the
  folder \texttt{{[}Liferay\_Home{]}/osgi/configs}.
\end{enumerate}

Executing \texttt{scr:info} on your component shows that the custom
service is now bound to the reference.

For example, executing
\texttt{scr:info\ override.my.service.reference.portlet.OverrideMyServiceReferencePortlet}
reports the following information:

\begin{verbatim}
...
Component Description:
  Name: override.my.service.reference.portlet.OverrideMyServiceReferencePortlet
  ...
  Reference: _someService
    Interface Name: override.my.service.reference.service.api.SomeService
    Cardinality: 1..1
    Policy: static
    Policy option: reluctant
    Reference Scope: bundle
    ...
  Component Configuration:
    ComponentId: 2399
    State: active
    SatisfiedReference: _someService
      Target: (component.name=overriding.service.reference.CustomServiceImpl)
      Bound to:        6841
          Properties:
            _defaultService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
            component.id = 2398
            component.name = overriding.service.reference.service.CustomServiceImpl
            objectClass = [override.my.service.reference.service.api.SomeService]
            service.bundleid = 525
            service.id = 6841
            service.scope = bundle
      Component Configuration Properties:
        _someService.target = (component.name=overriding.service.reference.service.CustomServiceImpl)
        ...
\end{verbatim}

The example component's \texttt{\_someService} reference targets the
custom service component
\texttt{overriding.service.reference.service.CustomServiceImpl}.
\texttt{CustomServiceImpl} references default service
\texttt{SomeServiceImpl} to delegate work to it.

\begin{figure}
\centering
\includegraphics{./images/overriding-service-refs-result.png}
\caption{Because the example component's service reference is overridden
by the configuration file deployment, the portlet indicates it's calling
the custom service.}
\end{figure}

Liferay DXP processed the configuration file and injected the service
reference, which in turn bound the custom service to the referencing
component!

\section{Related Topics}\label{related-topics-33}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
  Services and Dependency Injection with Declarative Services}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Using
  Felix Gogo Shell}
\end{itemize}

\chapter{Portlet Filters}\label{portlet-filters}

Portlet filters intercept requests and responses at the start of the
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{portlet request
processing phase}. Portlet filters are commonly used for these things:

\begin{itemize}
\tightlist
\item
  Transform content
\item
  Add or modify request and response attributes
\item
  Suspend a portlet phase to get user input
\item
  Audit portlet activity
\end{itemize}

The
\href{http://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/filter/package-frame.html}{\texttt{javax.portlet.filter}}
package defines a portlet filter interface for each phase. Here are the
steps for developing a portlet filter:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement the
  \href{http://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/filter/package-frame.html}{portlet
  filter interface} for the phase it's intercepting. Here are common
  interface methods to override:

  \texttt{doFilter}: Here's where you take action. This method is
  invoked at the start of the portlet request processing phase. The
  request and response parameters provide access to portlet content and
  attributes. The \texttt{FilterChain} parameter can be used to invoke
  the next filter in the phase.

  \texttt{init}: Initialize the filter. The \texttt{FilterConfig}
  parameter can be used to prepare the filter.

  \texttt{destroy}: Perform any filter cleanup.
\item
  Target the desired portlet(s).
\item
  Choose how to prioritize the filter among other filters in the phase:

  \begin{itemize}
  \tightlist
  \item
    OSGi Declarative Service Component portlet filters use a service
    ranking property. High ranking filters execute before lower ones.
  \item
    \texttt{\textless{}filter-mapping\textgreater{}} element order in a
    portlet application's \texttt{portlet.xml} file.
  \item
    The \texttt{ordinal} element value of a filter class annotated with
    \texttt{@PortletLifecycleFilter}. Low ordinal value filters execute
    before higher ones.
  \end{itemize}
\end{enumerate}

Below is demonstrated applying multiple filters to a portlet's render
phase. The filters are
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Declarative Service (DS) Components}, but filters can also be applied to
a portlet using a \texttt{portlet.xml} descriptor or a
\texttt{@PortletLifecycleFilter} annotation. See the Portlet 3.0
Specification for details. The sample code is available
\href{https://portal.liferay.dev/learn/code-samples/-/cs/list/7.2/java8/workspace-gradle/modules/applications/portlets/render-filter-portlet}{here}.

\section{Sample Portlet}\label{sample-portlet}

The sample portlet \texttt{MembersListPortlet} is a
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlet} that lists names and email addresses when users click its
\emph{Load Users} button. The information is based on \texttt{Person}
objects that the portlet class passes to the View template via a request
attribute called \texttt{MembersListPortlet.MEMBERLIST\_ATTRIBUTE}.

\begin{verbatim}
public void loadUsers(ActionRequest actionRequest, ActionResponse actionResponse) {

    actionRequest.setAttribute(MembersListPortlet.MEMBERLIST_ATTRIBUTE, createStaticUserList());
}
\end{verbatim}

Two render filters are applied to the portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Render filter 1 hides parts of the user email addresses (e.g., for
  privacy) by modifying the request object.
\item
  Render filter 2 logs portlet render phase statistics.
\end{enumerate}

Adding the \texttt{MemberList} portlet to a page and clicking the
\texttt{Load\ Users} button renders each \texttt{Person}'s name and
partially hidden email address, thanks to the filter
\texttt{EncodingPersonEmailsRenderFilter}.

\begin{verbatim}
Sievert Shayne

Sievert.Sha...@...mple.com

Vida Jonas

Vida.Jo...@...mple.com
...
\end{verbatim}

If you set the portlet's log level to \texttt{debug}, it prints the
render phase statistics.

\begin{verbatim}
Portlet com_liferay_code_samples_portal_modules_applications_portlets_render_filter_MembersListPortlet rendered in 7791 ms
Portlet com_liferay_code_samples_portal_modules_applications_portlets_render_filter_MembersListPortlet rendered 2 times with an average 356135 ms render time
\end{verbatim}

The first filter modifies portlet content via the request object.

\section{Render filter 1 hides parts of user email
addresses}\label{render-filter-1-hides-parts-of-user-email-addresses}

\texttt{EncodingPersonEmailsRenderFilter} is a \texttt{RenderFilter}
that hides parts of user email addresses by modifying a request
attribute. Here is the class:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
                "javax.portlet.name=" + MembersListPortlet.MEMBERSLIST_PORTLET_NAME,
                "service.ranking:Integer=1" 
        },
        service = PortletFilter.class
)
public class EncodingPersonEmailsRenderFilter implements RenderFilter {

    @Override
    public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain)
            throws IOException, PortletException {

        //This is executed before the portlet render
        Optional.ofNullable((List<Person>)request.getAttribute(MembersListPortlet.MEMBERLIST_ATTRIBUTE))
                .ifPresent(personList ->
                        request.setAttribute(MembersListPortlet.MEMBERLIST_ATTRIBUTE, ofuscateEmails(personList)));

        // Invoke the rest of the filters in the chain
        //  (it also invokes the Portlet render method if this is the last filter in the chain
        chain.doFilter(request, response);

    }

    private List<Person> ofuscateEmails(List<Person> list) {
        return list.stream()
                .map(this::ofuscatePersonEmail)
                .collect(Collectors.toList());
    }

    private Person ofuscatePersonEmail(Person person) {
        return new Person(person.getName(),
                          person.getEmail().replaceFirst("(.+)(...)@(...)(.*)", "$1...@...$4"));

    }

    @Override
    public void init(FilterConfig filterConfig) throws PortletException {

    }

    @Override
    public void destroy() {

    }
}
\end{verbatim}

The \texttt{@Component} annotation declares the filter to be an OSGi DS
Component. Here are its elements and properties:

\texttt{immediate\ =\ true} sets the component ready to start upon being
installed.

\texttt{service\ =\ PortletFilter.class} defines the component to be a
\texttt{PortletFilter} service.

\texttt{javax.portlet.name\ =\ +\ MembersListPortlet.MEMBERSLIST\_PORTLET\_NAME}
links the filter to the target portlet. Note, multiple portlets can be
listed.

\texttt{service.ranking:Integer=1} sets the filter to execute after
filters that are ranked higher than \texttt{1}.

\texttt{EncodingPersonEmailsRenderFilter} \emph{implements} the
\href{http://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/filter/RenderFilter.html}{\texttt{RenderFilter}}
interface, overriding the \texttt{doFilter}, \texttt{init}, and
\texttt{destroy} methods.

\texttt{doFilter} modifies the attribute
\texttt{MembersListPortlet.MEMBERLIST\_ATTRIBUTE}'s list of
\texttt{Person}s by replacing parts of their email addresses with
ellipses (\texttt{...}). It delegates the \texttt{ofuscatePersonEmail}
method to do the modifications. Then \texttt{doFilter} invokes
\texttt{chain.doFilter(request,\ response)} to execute the next
\texttt{RenderFilter} or next portlet processing phase.

\noindent\hrulefill

\textbf{Note:} Filters can also intercept and block the execution of a
portlet phase. In the \texttt{doFilter} method, this is usually done by
throwing an exception or by not calling the next element in the filter
chain.

\noindent\hrulefill

\section{RenderFilter 2 Logs
Statistics}\label{renderfilter-2-logs-statistics}

\texttt{MembersListStatsRenderFilter} is a \texttt{RenderFilter} that
logs the number of times the portlet is rendered and the average render
time. Here's the code:

\begin{verbatim}
@Component(
        immediate = true,
        property = {
                "javax.portlet.name=" + MembersListPortlet.MEMBERSLIST_PORTLET_NAME,
                "service.ranking:Integer=100"
        },
        service = PortletFilter.class
)
public class MembersListStatsRenderFilter implements RenderFilter {

    //Thread safe - accumulator that keeps the number of times the portlet has been rendered
    private final LongAdder hits = new LongAdder();

    //Thread safe accumulator that keeps total time spent rendering the portlet.
    private final LongAdder accumulatedTimeMs = new LongAdder();

    @Override
    public void doFilter(RenderRequest request, RenderResponse response, FilterChain chain) throws IOException, PortletException {

        long startTime = System.nanoTime();

        chain.doFilter(request, response);

        long renderTime = (System.nanoTime() - startTime) / 1000;
        hits.increment();
        accumulatedTimeMs.add(renderTime);

        if (LOG.isDebugEnabled()) {
            long totalHits = hits.longValue();
            long averageRenderTimeNs = accumulatedTimeMs.longValue() / totalHits;
            LOG.debug("Portlet " + MembersListPortlet.MEMBERSLIST_PORTLET_NAME + " rendered in " + renderTime + " ms");
            LOG.debug("Portlet " + MembersListPortlet.MEMBERSLIST_PORTLET_NAME + " rendered " + hits.longValue()
                    + " times with an average " + averageRenderTimeNs + " ms render time");
        }
    }

    ...

    private static final Log LOG = LogFactoryUtil.getLog(MembersListStatsRenderFilter.class);
}
\end{verbatim}

As with \texttt{EncodingPersonEmailsRenderFilter}, it's an OSGi DS
Component that is a \texttt{PortletFilter} service, starts upon
installation, applies to the \texttt{MembersListPortlet}, and has a
service ranking. Since its ranking is \texttt{100}, it is executed
before render filter \texttt{EncodingPersonEmailsRenderFilter}.

\texttt{MembersListStatsRenderFilter}'s \texttt{doFilter()} method
audits the render phase in these ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Notes the render phase start time.
\item
  Executes \texttt{chain.doFilter(request,\ response)} to invoke all of
  the other \texttt{RenderFilter}s in the \texttt{FilterChain}.
\item
  Increments the number of times the portlet renders.
\item
  Calculates the average render time.
\item
  Logs the times rendered and average render time.
\end{enumerate}

Consider creating your own filters to intercept portlet processing
phases.

\section{Related Topics}\label{related-topics-34}

\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}

\href{/docs/7-2/customization/-/knowledge_base/c/jsp-overrides-using-portlet-filters}{JSP
Overrides Using Portlet Filters}

\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlet}

\chapter{Product Navigation}\label{product-navigation}

Liferay DXP's product navigation consists of the main menus you use to
customize, configure, and navigate the system. When you edit a page,
switch to a different Site scope, access a User's credentials, etc.,
you're using the default navigation menus. Customizing a default menu
can help give your Liferay instance a unique touch. You can extend and
customize the default product navigation to fit your need.

There are four product navigation sections that you can extend:

\begin{itemize}
\tightlist
\item
  Product Menu
\item
  Control Menu
\item
  Simulation Menu
\item
  User Personal Menu
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/product-navigation-summary.png}
\caption{The main product navigation menus include the Product Menu,
Control Menu, Simulation Menu and User Personal Menu.}
\end{figure}

The Product Menu is on the left, and displays the Control Panel and Site
Administration functionality. The Control Menu is on top, offering
navigation to the Product Menu, Simulation Menu (the right menu), and
the \emph{Add} button. When certain settings are enabled (e.g., Staging,
Page Customization, etc.), more tools are offered. The Simulation Menu
offers options to simulate your Site's look for different scenarios
(devices, user segments, etc.). Finally, the User Personal Menu holds
selectable items containing a user's own account settings.

You'll learn more about each of these product navigation sections next.

\section{Product Menu}\label{product-menu}

By default, Liferay's Product Menu consists of two main sections:
Control Panel and Site Administration. These sections are called
\emph{Panel Categories}. For instance, the Control Panel is a single
Panel Category, and when clicking on it, you see six child Panel
Categories: \emph{Users}, \emph{Sites}, \emph{Apps},
\emph{Configuration}, and \emph{Workflow}. Clicking a child Panel
Category shows \emph{panel apps}.

The Product Menu is intuitive and easy to use---but you can still change
it any way you want. You can reorganize the Panel Categories and apps,
or add completely new categories and populate them with custom Panel
Apps. You'll learn how to provide new or modified Panel Categories and
Panel Apps for the Product Menu. For more information, read the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{Customizing
the Product Menu} articles.

\section{Control Menu}\label{control-menu}

The Control Menu is the most visible and accessible menu. For example,
on your home page, the Control Menu offers default options for accessing
the Product Menu, Simulation Menu, and Add Menu. You can think of this
menu as the gateway to configuring options in Liferay DXP.

\begin{figure}
\centering
\includegraphics{./images/control-menu-home.png}
\caption{The Control Menu has three configurable areas: left, right, and
middle. It also displays the title and type of page that you are
currently viewing.}
\end{figure}

If you navigate away from the home page, the Control Menu adapts and
provides helpful functionality for whatever option you're using. For
example, if you navigate to Site Administration → \emph{Content \& Data}
→ \emph{Web Content}, you see a Control Menu with different
functionality tailored for that option.

\begin{figure}
\centering
\includegraphics{./images/control-menu-web-content.png}
\caption{When switching your context to web content, the Control Menu
adapts to provide helpful options for that area.}
\end{figure}

The default Control Menu contains three categories representing the
left, middle, and right portions of the menu. You can create navigation
entries for each category. For more information, read the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-control-menu}{Customizing
the Control Menu} articles.

\section{Simulation Menu}\label{simulation-menu}

When testing how pages and apps appear for users, it's important to
simulate their views in as many ways as possible. The Simulation Menu on
the right-side of the main page allows this, and you can extend the menu
if you need to simulate something that it does not provide.

\begin{figure}
\centering
\includegraphics{./images/simulation-menu-preview.png}
\caption{The Simulation Menu offers a device preview application.}
\end{figure}

There are few differences between the Simulation Menu and Product Menu,
mostly because they extend the same base classes. The Simulation Menu,
by default, is made up of only one Panel Category and one Panel App.
Liferay provides the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/product-navigation/product-navigation-simulation-web/src/main/java/com/liferay/product/navigation/simulation/web/internal/application/list/SimulationPanelCategory.java}{\texttt{SimulationPanelCategory}}
class, a hidden category needed to hold the
\texttt{DevicePreviewPanelApp}. This is the app and functionality you
see in the Simulation Menu by default.

For more information, read the
\href{/docs/7-2/customization/-/knowledge_base/c/extending-the-simulation-menu}{Extending
the Simulation Menu} article.

\section{User Personal Menu}\label{user-personal-menu}

The User Personal Menu displays options unique to the current user. By
default, this menu appears as an avatar button that expands the User
Settings sub-menu just below the Control Menu. In a custom theme, the
User Personal Menu could appear anywhere in the interface.

\begin{figure}
\centering
\includegraphics{./images/user-personal-menu.png}
\caption{By default, the User Personal Menu contains the signed-in
user's avatar, which opens the user's settings when selected.}
\end{figure}

Although Liferay's default User Personal Menu is bare-bones, you can add
more functionality to fit your needs. Unlike other product navigation
menus (e.g., Product Menu), the User Personal Bar does not require the
extension/creation of Panel Categories and Panel Apps. It uses another
common Liferay framework for providing functionality:
\href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes}{Portlet
Providers}.

The User Personal Menu can be seen as a placeholder in every Liferay
theme. By default, Liferay provides one sample \emph{User Personal Bar}
portlet that fills that placeholder, but the portlet Liferay provides
can be replaced by other portlets.

\noindent\hrulefill

\textbf{Note:} You can add the User Personal Bar to your theme by adding
the following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
<@liferay.user_personal_bar />
\end{verbatim}

\noindent\hrulefill

For more information, read the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-user-personal-bar-and-menu}{Customizing
the User Personal Bar and Menu} article.

\chapter{Customizing the Product
Menu}\label{customizing-the-product-menu}

Customizing the Product Menu can be completed by adding Panel Categories
and Panel Apps.

\noindent\hrulefill

\textbf{Note:} The Product Menu cannot be changed by applying a new
theme. To change the layout/style of the Product Menu, you must create
and deploy a theme contributor. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/packaging-independent-ui-resources-for-your-site}{Theme
Contributors} article for more details.

\noindent\hrulefill

To create these entities, you must implement the
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/PanelCategory.html}{\texttt{PanelCategory}}
and
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/PanelApp.html}{\texttt{PanelApp}}
interfaces.

\section{PanelCategory Interface}\label{panelcategory-interface}

The \texttt{PanelCategory} interface requires you to implement the
following methods:

\begin{itemize}
\tightlist
\item
  \texttt{getNotificationCount}: returns the number of notifications to
  be shown in the Panel Category.
\item
  \texttt{include}: renders the body of the Panel Category.
\item
  \texttt{includeHeader}: renders the Panel Category header.
\item
  \texttt{isActive}: whether the panel is selected.
\item
  \texttt{isPersistState}: whether to persist the Panel Category's state
  to the database. This saves the state of the Panel Category when
  navigating away from the menu.
\end{itemize}

You can reduce the number of methods you must implement if you extend a
base class that already implements the \texttt{PanelCategory} interface.
The recommended way to do this is by extending the
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BasePanelCategory.html}{\texttt{BasePanelCategory}}
or
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BaseJSPPanelCategory.html}{\texttt{BaseJSPPanelCategory}}
abstract classes. Typically, the \texttt{BasePanelCategory} is extended
for basic categories (e.g., the Control Panel category) that only
display the category name. To add more complex functionality, you can
then provide a custom UI for your panel using any front-end technology
by implementing the \texttt{include()} or \texttt{includeHeader()} from
the \texttt{PanelCategory} interface.

If you plan to use JSPs as the front-end technology, extend a base class
called \texttt{BaseJSPPanelCategory} that already implements the methods
\texttt{include()} and \texttt{includeHeader()} for you.

\noindent\hrulefill

\textbf{Note:} In this article, example JSPs describe how to provide
functionality to Panel Categories and Panel Apps. JSPs, however, are not
the only way to provide front-end functionality to your categories/apps.
You can create your own class implementing \texttt{PanelCategory} to use
other technologies such as FreeMarker.

\noindent\hrulefill

More information on provided base classes for your
\texttt{PanelCategory} implementation are described next.

\section{BasePanelCategory}\label{basepanelcategory}

If you need something simple for your Panel Category like a name,
extending \texttt{BasePanelCategory} is probably sufficient. For
example, the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/product-navigation/product-navigation-control-panel/src/main/java/com/liferay/product/navigation/control/panel/internal/application/list/ControlPanelCategory.java}{\texttt{ControlPanelCategory}}
extends \texttt{BasePanelCategory} and specifies a \texttt{getLabel}
method to set and display the Panel Category name.

\begin{verbatim}
@Override
public String getLabel(Locale locale) {
    return LanguageUtil.get(locale, "control-panel");
}
\end{verbatim}

\section{BaseJSPPanelCategory}\label{basejsppanelcategory}

If you need more complex functionality, extend
\texttt{BaseJSPPanelCategory} and use JSPs to render the Panel Category.
For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/product-navigation/product-navigation-site-administration/src/main/java/com/liferay/product/navigation/site/administration/internal/application/list/SiteAdministrationPanelCategory.java}{\texttt{SiteAdministrationPanelCategory}}
specifies the \texttt{getHeaderJspPath} and \texttt{getJspPath} methods.
You could create a JSP with the UI you want to render and specify its
path in methods like these:

\begin{verbatim}
@Override
public String getHeaderJspPath() {
    return "/sites/site_administration_header.jsp";
}

@Override
public String getJspPath() {
    return "/sites/site_administration_body.jsp";
}
\end{verbatim}

One JSP renders the Panel Category's header (displayed when panel is
collapsed) and the other its body (displayed when panel is expanded).

Next, you'll learn about the \texttt{PanelApp} interface.

\section{PanelApp Interface}\label{panelapp-interface}

The \texttt{PanelApp} interface requires you to implement the following
methods:

\begin{itemize}
\tightlist
\item
  \texttt{getNotificationCount}: returns the number of notifications for
  the user.
\item
  \texttt{getPortlet}: returns the portlet associated with the
  application.
\item
  \texttt{getPortletId}: returns the portlet's ID associated with the
  application.
\item
  \texttt{getPortletURL}: returns the URL used to render a portlet based
  on the servlet request attributes.
\item
  \texttt{include}: Returns \texttt{true} if the application
  successfully renders.
\item
  \texttt{setGroupProvider}: sets the group provider associated with the
  application.
\item
  \texttt{setPortlet}: sets the portlet associated with the application.
\end{itemize}

You can reduce the number of methods you must implement if you extend a
base class that already implements the \texttt{PanelCategory} interface.
The recommended way to do this is by extending the
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BasePanelApp.html}{\texttt{BasePanelApp}}
or
\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{\texttt{BaseJSPPanelApp}}
abstract classes. If you want to use JSPs to render that UI, extend
\texttt{BaseJSPPanelApp}. This provides additional methods you can use
to incorporate JSP functionality into your app's listing in the Product
Menu.

\noindent\hrulefill

\textbf{Note:} JSPs are not the only way to provide front-end
functionality to your Panel Apps. You can create your own class
implementing \texttt{PanelApp} to use other technologies such as
FreeMarker.

\noindent\hrulefill

The \texttt{BlogsPanelApp} is a simple example of how to specify your
portlet as a Panel App. This class extends \texttt{BasePanelApp},
overriding the \texttt{getPortletId} and \texttt{setPortlet} methods.
These methods specify and set the Blogs portlet as a Panel App.

This is how those methods look for the Blogs portlet:

\begin{verbatim}
@Override
public String getPortletId() {
    return BlogsPortletKeys.BLOGS_ADMIN;
}

@Override
@Reference(
    target = "(javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN + ")",
    unbind = "-"
)
public void setPortlet(Portlet portlet) {
    super.setPortlet(portlet);
}
\end{verbatim}

Each Panel App must belong to a portlet and each portlet can have at
most one Panel App. If more than one Panel App is needed, another
portlet must be created. By default, the Panel App only appears if the
user has permission to view the associated portlet.

Continue on the learn about creating custom Panel Categories and Panel
Apps.

\chapter{Adding Custom Panel
Categories}\label{adding-custom-panel-categories}

As you navigate the Product Menu, you can see that Panel Apps like
\emph{Web Content} and \emph{Settings} are organized into Panel
Categories such as \emph{Content \& Data} and \emph{Configuration}. This
article explains how to add new Panel Categories to the menu. Adding new
Panel Apps is covered in the next section.

There are three steps to creating a new category:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the OSGi structure and metadata.
\item
  Implement Liferay's Frameworks.
\item
  Define the Panel Category.
\end{enumerate}

\section{Creating the OSGi Module}\label{creating-the-osgi-module}

First you must create the project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi module using your favorite third party tool, or use
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}.
  Blade CLI offers a
  \href{/docs/7-2/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template, which is for creating a Panel Category and Panel App.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by
  \texttt{PanelCategory} (e.g., \texttt{ControlPanelCategory}).
\end{enumerate}

\section{Implementing Liferay's
Frameworks}\label{implementing-liferays-frameworks}

Next, you must connect your OSGi module to Liferay's frameworks and use
those to define information about your entry. This takes only two steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert the \texttt{@Component} annotation declaring the panel category
  keys directly above the class's declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.category.key=" + [Panel Category Key],
        "panel.category.order:Integer=[int]"
    },
    service = PanelCategory.class
)
\end{verbatim}

  You can view an example of a similar \texttt{@Component} annotation
  for the \texttt{UserPanelCategory} class below:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.category.key=" + PanelCategoryKeys.ROOT,
        "panel.category.order:Integer=200"
    },
    service = PanelCategory.class
)
\end{verbatim}

  The \texttt{property} element designates two properties that should be
  assigned for your category. The \texttt{panel.category.key} specifies
  the parent category for your custom category. You can find popular
  parent categories to assign in the
  \href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/PanelCategoryKeys.html}{\texttt{PanelCategoryKeys}}
  class. For instance, if you wanted to create a child category in the
  Control Panel, you could assign
  \texttt{PanelCategoryKeys.CONTROL\_PANEL}. Likewise, if you wanted to
  create a root category, like the Control Panel or Site Administration,
  you could assign \texttt{PanelCategoryKeys.ROOT}.

  The \texttt{panel.category.order:Integer} property specifies the order
  in which your category is displayed. The higher the number (integer),
  the lower your category is listed among other sibling categories
  assigned to a parent.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To insert a Panel Category between existing categories in the
 default menu, you must know the `panel.category.order:Integer` property
 for the existing categories. For example, the Product Menu's two main
 sections---Control Panel and Site Administration---have
 `panel.category.order:Integer` properties of 100 and 200, respectively. A
 new panel inserted between Control Panel and Site Administration would
 need a `panel.category.key` of ROOT and a `panel.category.order:Integer`
 of 150.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Finally, your `service` element should specify the `PanelCategory.class`
service.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Implement the \texttt{PanelCategory} interface. See the
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu\#panelcategory-interface}{\texttt{PanelCategory}
  Interface} section for more details. Extending one of the provided
  base classes
  (\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu\#basepanelcategory}{BasePanelCategory}
  or
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu\#basejsppanelcategory}{BaseJSPPanelCategory})
  is a popular way to implement the \texttt{PanelCategory} interface.
\item
  If you elect to leverage JSPs, you must also specify the servlet
  context from where you are loading the JSP files. If this is inside an
  OSGi module, make sure your \texttt{bnd.bnd} file has defined a web
  context path:

\begin{verbatim}
Bundle-SymbolicName: com.sample.my.module.web
Web-ContextPath: /my-module-web
\end{verbatim}

  Then reference the Servlet context using the symbolic name of your
  module like this:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.sample.my.module.web)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}
\end{enumerate}

Excellent! You've successfully created a custom Panel Category to
display in the Product Menu. In many cases, a Panel Category holds Panel
Apps for users to access. You'll learn how to add a Panel App to a Panel
Category next.

\chapter{Adding Custom Panel Apps}\label{adding-custom-panel-apps}

After you have created a Panel Category, create a Panel App to go in it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi module using your favorite third party tool, or use
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}.
  Blade CLI offers a
  \href{/docs/7-2/reference/-/knowledge_base/r/panel-app-template}{Panel
  App} template to help generate a basic Panel Category and Panel App.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by \emph{PanelApp}
  (e.g., \texttt{JournalPanelApp}).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=INTEGER"
        "panel.category.key=" + PANEL_CATEGORY_KEY,
    },
    service = PanelApp.class
)
\end{verbatim}

  You can view an example of a similar \texttt{@Component} annotation
  for the \texttt{JournalPanelApp} class below.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "panel.app.order:Integer=100",
        "panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
    },
    service = PanelApp.class
)
\end{verbatim}

  These properties and attributes are similar to those discussed in the
  previous
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-custom-panel-categories}{article}.
  The \texttt{panel.category.key} assigns your Panel App to a Panel
  Category. The \texttt{panel.app.order:Integer} property specifies the
  order your Panel App appears among other Panel Apps in the same
  category. For example, if you want to add a Panel App to Site
  Administration → \emph{Content \& Data}, add the following property:

\begin{verbatim}
"panel.category.key=" + PanelCategoryKeys.SITE_ADMINISTRATION_CONTENT
\end{verbatim}

  Visit the
  \href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/constants/PanelCategoryKeys.html}{PanelCategoryKeys}
  class for keys you can use to specify default Panel Categories in
  Liferay.

  Set the \texttt{service} attribute to \texttt{PanelApp.class}.
\item
  Implement the \texttt{PanelApp} interface. See the
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu\#panelapp-interface}{\texttt{PanelApp}
  Interface} section for more details. Extending one of the provided
  base classes
  (\href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BasePanelApp.html}{BasePanelApp}
  or
  \href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{BaseJSPPanelApp})
  is a popular way to implement the \texttt{PanelApp} interface. See the
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu\#panelapp-interface}{PanelApp
  Interface} section for more information.
\item
  If you elect to leverage JSPs, you must also specify the servlet
  context from where you are loading the JSP files. If this is inside an
  OSGi module, make sure your \texttt{bnd.bnd} file has defined a web
  context path:

\begin{verbatim}
Bundle-SymbolicName: com.sample.my.module.web
Web-ContextPath: /my-module-web
\end{verbatim}

  Then reference the Servlet context using the symbolic name of your
  module like this:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.sample.my.module.web)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}
\end{enumerate}

Now you know how to add or modify a Panel App in the Product Menu. Not
only does Liferay provide a simple solution to add new Panel Categories
and Panel Apps, it also gives you the flexibility to add a more complex
UI to the Product Menu using any technology.

\chapter{Customizing the Control
Menu}\label{customizing-the-control-menu}

Liferay's Control Menu consists of three main sections: Sites (left
portion), Tools (middle portion), and User (right portion).

\begin{figure}
\centering
\includegraphics{./images/control-menu-areas.png}
\caption{This image shows where your entry will reside depending on the
category you select.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} You can add the Control Menu to a theme by adding the
following snippet into your \texttt{portal\_normal.ftl}:

\begin{verbatim}
<@liferay.control_menu />
\end{verbatim}

The other product navigation menus (e.g., Product Menu, Simulation Menu)
are included in this tag, so specifying the above snippet embeds all
three menus into your theme. Embedding the User Personal Menu is
slightly different. Visit the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-user-personal-bar-and-menu}{Customizing
the User Personal Bar and Menu} article for more information.

\noindent\hrulefill

You can reference a sample Control Menu Entry by visiting the
\href{/docs/7-2/reference/-/knowledge_base/r/control-menu-entry-template}{Control
Menu Entry} article.

\section{ProductNavigationControlMenuEntry
Interface}\label{productnavigationcontrolmenuentry-interface}

To create a control menu entry, you must implement the
\href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/ProductNavigationControlMenuEntry.html}{\texttt{ProductNavigationControlMenuEntry}}
interface. It's recommended to implement this interface by extending the
\href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/BaseProductNavigationControlMenuEntry.html}{\texttt{BaseProductNavigationControlMenuEntry}}
or
\href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/BaseJSPProductNavigationControlMenuEntry.html}{\texttt{BaseJSPProductNavigationControlMenuEntry}}
abstract classes.

These base classes are covered in more detail next.

\section{BaseProductNavigationControlMenuEntry}\label{baseproductnavigationcontrolmenuentry}

Typically, the \texttt{BaseProductNavigationControlMenuEntry} is
extended for basic entries that only display a link with text or a
simple icon. If you want to provide a more complex UI with buttons or a
sub-menu, you can override the \texttt{include()} and
\texttt{includeBody()} methods.

The
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-web/src/main/java/com/liferay/portal/search/web/internal/product/navigation/control/menu/IndexingProductNavigationControlMenuEntry.java}{\texttt{IndexingProductNavigationControlMenuEntry}}
is a simple example for providing text and an icon. It extends the
\texttt{BaseProductNavigationControlMenuEntry} class and is used when
Liferay is indexing. The indexing entry is displayed in the \emph{Tools}
(middle) area of the Control Menu with a \emph{Refresh} icon and text
stating \emph{The Portal is currently indexing}.

\section{BaseJSPProductNavigationControlMenuEntry}\label{basejspproductnavigationcontrolmenuentry}

If you use JSPs for generating the UI, you can extend
\texttt{BaseJSPProductNavigationControlMenuEntry} to save time when
creating/modifying a control menu entry.

The
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/product-navigation/product-navigation-product-menu-web/src/main/java/com/liferay/product/navigation/product/menu/web/internal/product/navigation/control/menu/ProductMenuProductNavigationControlMenuEntry.java}{\texttt{ProductMenuProductNavigationControlMenuEntry}}
creates an entry that appears in the \emph{Sites} (left) area of the
Control Menu. This class extends the
\texttt{BaseJSPProductNavigationControlMenuEntry} class. This provides
several more methods that use JSPs to define your entry's UI. There are
two methods to notice:

\begin{verbatim}
@Override
public String getBodyJspPath() {
return "/portlet/control_menu/product_menu_control_menu_entry_body.jsp";
}

@Override
public String getIconJspPath() {
return "/portlet/control_menu/product_menu_control_menu_entry_icon.jsp";
}
\end{verbatim}

The \texttt{getIconJspPath()} method provides the Product Menu icon
(\includegraphics{./images/icon-menu.png} → !{[}Menu Open{]}(../../..and
the \texttt{getBodyJspPath()} method adds the UI body for the entry
outside of the Control Menu. The latter method must be used when
providing a UI outside the Control Menu. You can test this by opening
and closing the Product Menu on the home page.

Finally, if you provide functionality that is exclusively inside the
Control Menu, the \texttt{StagingProductNavigationControlMenuEntry}
class calls its JSP like this:

\begin{verbatim}
@Override
public String getIconJspPath() {
return "/control_menu/entry.jsp";
}
\end{verbatim}

The \texttt{entry.jsp} is returned, which embeds the Staging Bar portlet
into the Control Menu.

Next, you'll step through the process of customizing the Control Menu.

\chapter{Creating Control Menu
Entries}\label{creating-control-menu-entries}

Now you'll create entries to customize the Control Menu. Make sure to
read
\href{/docs/7-2/customization/-/knowledge_base/c/adding-custom-panel-categories}{Adding
Custom Panel Categories} before beginning this article. This article
assumes you know how to create a Panel Category. Creating a Control Menu
Entry follows the same pattern as creating a Panel Category:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the OSGi structure and metadata.
\item
  Implement Liferay's Frameworks.
\item
  Define the Control Menu Entry.
\end{enumerate}

\section{Creating the OSGi Module}\label{creating-the-osgi-module-1}

First you must create the project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module. Your module must contain a Java class,
  \texttt{bnd.bnd} file, and build file (e.g., \texttt{build.gradle} or
  \texttt{pom.xml}). You'll create your Java class next if your project
  does not already define one.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. Give your class a unique
  name followed by \emph{ProductNavigationControlMenuEntry}
  (e.g.,\texttt{StagingProductNavigationControlMenuEntry}).
\end{enumerate}

\section{Implementing Liferay's
Frameworks}\label{implementing-liferays-frameworks-1}

Next, you need to connect your OSGi module to Liferay's frameworks and
use those to define information about your entry.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Directly above the class's declaration, insert this code:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "product.navigation.control.menu.category.key=" + [Control Menu Category],
        "product.navigation.control.menu.category.order:Integer=[int]"
    },
    service = ProductNavigationControlMenuEntry.class
)
\end{verbatim}

  The \texttt{product.navigation.control.menu.category.key} property
  specifies your entry's category. The default Control Menu provides
  three categories: Sites (left portion), Tools (middle portion), and
  User (right portion).

  To specify the category, reference the appropriate key in the
  \href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/constants/ProductNavigationControlMenuCategoryKeys.html}{ProductNavigationControlMenuCategoryKeys}
  class. For example, this property places your entry in the middle
  portion of the Control Menu:

\begin{verbatim}
"product.navigation.control.menu.category.key=" + ProductNavigationControlMenuCategoryKeys.TOOLS
\end{verbatim}

  Like Panel Categories, you must specify an integer to place your entry
  in the category. Entries are ordered from left to right: an entry with
  order \texttt{1} appears to the left of an entry with order
  \texttt{2}. If the order is not specified, it's chosen at random based
  on which service was registered first in the OSGi container.

  Finally, your \texttt{service} element should specify the
  \texttt{ProductNavigationControlMenuEntry.class} service.
\item
  Implement the
  \href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/ProductNavigationControlMenuEntry.html}{\texttt{ProductNavigationControlMenuEntry}}
  interface. You can also extend the
  \href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/BaseProductNavigationControlMenuEntry.html}{\texttt{BaseProductNavigationControlMenuEntry}}
  or
  \href{https://docs.liferay.com/dxp/apps/product-navigation/latest/javadocs/com/liferay/product/navigation/control/menu/BaseJSPProductNavigationControlMenuEntry.html}{\texttt{BaseJSPProductNavigationControlMenuEntry}}
  abstract classes. See the
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-control-menu}{Customizing
  the Control Menu} article for more information on these classes.
\item
  If you elect to leverage JSPs, you must specify the servlet context
  for the JSP files. If this is inside an OSGi module, make sure your
  \texttt{bnd.bnd} file defines a web context path:

\begin{verbatim}
Bundle-SymbolicName: com.sample.my.module.web
Web-ContextPath: /my-module-web
\end{verbatim}

  And then reference the Servlet context using the symbolic name of your
  module:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.sample.my.module.web)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}
\item
  Part of creating the entry is defining when it appears. The Control
  Menu shows different entries depending on the displayed page. You can
  specify when your entry appears with the
  \texttt{isShow(HttpServletRequest)} method.

  For example, the \texttt{IndexingProductNavigationControlMenuEntry}
  class queries the number of indexing jobs when calling
  \texttt{isShow}. If the query count is \texttt{0}, the indexing entry
  doesn't appear in the Control Menu:

\begin{verbatim}
@Override
public boolean isShow(HttpServletRequest request) throws PortalException {
    int count = _indexWriterHelper.getReindexTaskCount(
        CompanyConstants.SYSTEM, false);

    if (count == 0) {
        return false;
    }

    return super.isShow(request);
}
\end{verbatim}

  The \texttt{StagingProductNavigationControlMenuEntry} class selects
  the pages to appear. The staging entry never appears if the page is an
  administration page (e.g., \emph{Site Administration}, \emph{Control
  Panel}, etc.):

\begin{verbatim}
@Override
public boolean isShow(HttpServletRequest request) throws PortalException {
    ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
        WebKeys.THEME_DISPLAY);

    Layout layout = themeDisplay.getLayout();

    // This controls if the page is an Administration Page

    if (layout.isTypeControlPanel()) {
        return false;
    }

    // This controls if Staging is enabled

  if (!themeDisplay.isShowStagingIcon()) {
        return false;
    }

    return true;
}
\end{verbatim}
\end{enumerate}

Excellent! You've created your entry in one of the three default
sections in the Control Menu.

\chapter{Defining Icons and Tooltips}\label{defining-icons-and-tooltips}

When creating a Control Menu entry, you can use an icon in addition to
or in place of text. You can also use tooltips to provide a more in
depth explanation.

\section{Control Menu Entry Icons}\label{control-menu-entry-icons}

You can provide a Lexicon or CSS icon in your
\texttt{*ControlMenuEntry}. To use a Lexicon icon, you should override
the methods in \texttt{ProductMenuProductNavigationControlMenuEntry}
like this one:

\begin{verbatim}
public String getIconCssClass(HttpServletRequest request) {
    return "";
}

public String getIcon(HttpServletRequest request) {
    return "lexicon-icon";
}

public String getMarkupView(HttpServletRequest request) {
    return "lexicon";
}
\end{verbatim}

Likewise, you can use a CSS icon by overriding the
\texttt{ProductMenuProductNavigationControlMenuEntry} methods like this
one:

\begin{verbatim}
public String getIconCssClass(HttpServletRequest request) {
    return "icon-css";
}

public String getIcon(HttpServletRequest request) {
    return "";
}

public String getMarkupView(HttpServletRequest request) {
    return "";
}
\end{verbatim}

You can find these icons documented
\href{https://clayui.com/docs/components/icons.html}{here}.

\section{Control Menu Entry Tooltips}\label{control-menu-entry-tooltips}

To provide a tooltip for the Control Menu entry, create a
\texttt{getLabel} method like this:

\begin{verbatim}
@Override
public String getLabel(Locale locale) {
    ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
        "content.Language", locale, getClass());

    return LanguageUtil.get(
        resourceBundle, "the-portal-is-currently-reindexing");
}
\end{verbatim}

You need to create a \texttt{Language.properties} to store your labels.
You can learn more about resource bundles in the
\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}
articles.

\chapter{Extending the Simulation
Menu}\label{extending-the-simulation-menu}

To provide your own functionality in the Simulation Menu, you must
create a Panel App in \texttt{SimulationPanelCategory}. If you want to
add extensive functionality, you can even create additional Panel
Categories in the menu to divide up your Panel Apps. This article covers
the simpler case of creating a Panel App for the already present hidden
category.

Before beginning, make sure you're accustomed to using Panel Categories
and Panel Apps. This is covered in detail in the
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{Customizing
the Product Menu} articles. Once you know how to create Panel Categories
and Panel Apps, continue with this article.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the steps documented in
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-custom-panel-apps}{Adding
  Custom Panel Apps} for creating custom Panel Apps. Once you've created
  the foundation of your Panel App, move on to learn how to tweak it so
  it customizes the Simulation Menu.

  You can generate a Simulation Panel App by using Blade CLI's
  \href{/docs/7-2/reference/-/knowledge_base/r/simulation-panel-entry-template}{Simulation
  Panel Entry template}. You can also refer to the
  \href{/docs/7-2/reference/-/knowledge_base/r/simulation-panel-app}{Simulation
  Panel App sample} for a working example.
\item
  Since this article assumes you're providing more functionality to the
  existing simulation category, set the simulation category in the
  \texttt{panel.category.key} of the \texttt{@Component} annotation:

\begin{verbatim}
"panel.category.key=" + SimulationPanelCategory.SIMULATION
\end{verbatim}

  To use this constant, you must add a dependency on
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.product.navigation.simulation/}{\texttt{com.liferay.product.navigation.simulation}}.

  Be sure to also specify the order to display your new Panel App, which
  was explained in
  \href{/docs/7-2/customization/-/knowledge_base/c/adding-custom-panel-apps}{Adding
  Custom Panel Apps}.
\item
  This article assumes you're using JSPs. Therefore, you should extend
  the
  \href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/BaseJSPPanelApp.html}{\texttt{BaseJSPPanelApp}}
  abstract class, which implements the
  \href{https://docs.liferay.com/dxp/apps/application-list/latest/javadocs/com/liferay/application/list/PanelApp.html}{\texttt{PanelApp}}
  interface and also provides additional methods necessary for
  specifying JSPs to render your Panel App's UI. Remember that you can
  also implement your own \texttt{include()} method to use any front-end
  technology you want, if you want to use a technology other than JSP
  (e.g., FreeMarker).
\item
  Define your simulation view. For instance, in
  \texttt{DevicePreviewPanelApp}, the \texttt{getJspPath} method points
  to the \texttt{simulation-device.jsp} file in the
  \texttt{resources/META-INF/resources} folder, where the device
  simulation interface is defined. Optionally, you can also add your own
  language keys, CSS, or JavaScript resources in your simulation module.

  The right servlet context is also provided by implementing this
  method:

\begin{verbatim}
@Override
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.product.navigation.simulation.device)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    super.setServletContext(servletContext);
}
\end{verbatim}

  As explained in
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{Customizing
  The Product Menu}, a Panel App should be associated with a portlet.
  This makes the Panel App visible only when the user has permission to
  view the portlet. This Panel App is associated to the Simulation
  Device portlet using these methods:

\begin{verbatim}
@Override
public String getPortletId() {
    return ProductNavigationSimulationPortletKeys.
        PRODUCT_NAVIGATION_SIMULATION;
}

@Override
@Reference(
    target = "(javax.portlet.name=" + ProductNavigationSimulationPortletKeys.PRODUCT_NAVIGATION_SIMULATION + ")",
    unbind = "-"
)
public void setPortlet(Portlet portlet) {
    super.setPortlet(portlet);
}
\end{verbatim}

  Segments also provides a good example of how to extend the Simulation
  Menu. When segments are available, the Simulation Menu is extended to
  offer personalization options. You can simulate particular experiences
  directly from the Simulation Menu. Its Panel App class is similar to
  \texttt{DevicePreviewPanelApp}, except it points to a different
  portlet and JSP. For more information on Segments, see the
  \href{/docs/7-2/user/-/knowledge_base/u/segmentation-and-personalization}{Segmentation
  and Personalization} section.

  \begin{figure}
  \centering
  \includegraphics{./images/segments-preview.png}
  \caption{The Simulation Menu also displays Segments to help simulate
  different user experiences.}
  \end{figure}
\item
  You can combine your simulation options with the device simulation
  options by interacting with the device preview iFrame. To retrieve the
  device preview frame in an \texttt{aui:script} block of your custom
  simulation view's JavaScript, you can use this code:

\begin{verbatim}
var iframe = A.one('#simulationDeviceIframe');
\end{verbatim}

  Then you can modify the device preview frame URL like this:

\begin{verbatim}
iframe.setAttribute('src', newUrlWithCustomParameters);
\end{verbatim}
\end{enumerate}

Now that you know how to extend the necessary Panel Categories and Panel
Apps to modify the Simulation Menu,
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{create
a module} of your own and customize the Simulation Menu so it's most
helpful for your needs.

\chapter{Customizing the User Personal Bar and
Menu}\label{customizing-the-user-personal-bar-and-menu}

The User Personal Bar is a portlet, but it's also an important concept
in Liferay DXP. In a fresh bundle using the default theme, it's the
section of screen occupied by the User's avatar and the Personal Menu.

\begin{figure}
\centering
\includegraphics{./images/user-personal-bar.png}
\caption{By default, the User Personal Bar contains the signed-in user's
avatar, which opens the Personal Menu when selected.}
\end{figure}

The User Personal Bar holds only the Personal Menu by default, but it
can also contain any functionality you want (even additional portlets).
The User Personal Bar is included by default in every Liferay theme, but
you can replace it with a
\href{/docs/7-2/customization/-/knowledge_base/c/using-a-custom-portlet-in-place-of-the-user-personal-bar}{portlet}
or customize it by adding entries to the existing portlet's menu.

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Replacing the default User Personal Bar portlet with a custom portlet.
\item
  Customizing the default User Personal Bar.
\end{itemize}

\section{Displaying the Personal
Menu}\label{displaying-the-personal-menu}

Starting with 7.0, the Personal Menu is no longer part of the Product
Menu, but is instead included in the User Personal Bar. To display the
existing User Personal Bar in your own theme, embed the portlet into
your theme by adding the following snippet into
\texttt{portal\_normal.ftl}:

\begin{verbatim}
<@liferay.user_personal_bar />
\end{verbatim}

You'll use the same snippet even if you're replacing the default User
Personal Bar portlet with your own.

If you use a custom portlet to provide the User Personal Bar, but wish
to include the default Personal Menu, make sure to render it by using
this tag in your portlet's JSP:

\begin{verbatim}
<liferay-product-navigation:personal-menu
    expanded="<%= true %>"
    label="<%= userAvatar %>"
/>
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The recommended way to display the Personal Menu is by
embedding the User Personal Bar in a theme. If this is not practical, a
workaround exists: go to \emph{Control Panel} → \emph{Configuration} →
\emph{Instance Settings} → \emph{Users} and select \emph{Personal Menu}.
Enable the \emph{Show in Control Menu} toggle and click \emph{Update}.

This places a button to expand the Personal Menu in the Control Menu. It
appears on every site and page in your virtual instance, including sites
that have the User Personal Bar embedded in the theme. So, to avoid
multiple User Personal Bars appearing on the page, you should use only
\emph{one} of these mechanisms to display the User Personal Bar.

\noindent\hrulefill

Unlike the Product Menu, the Personal Menu can be customized without
creating panel categories and panel apps. See
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-personal-menu}{Customizing
the Personal Menu} for details.

\chapter{Using a Custom Portlet in Place of the User Personal
Bar}\label{using-a-custom-portlet-in-place-of-the-user-personal-bar}

In this article, you'll learn how to write the single Java class
required to replace the default User Personal Bar with a custom portlet.
Writing the portlet itself is up to each developer's needs. See the
documentation on
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{portlets} if you
need guidance.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package.
\item
  Above the class declaration, insert the following annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "model.class.name=" + PortalUserPersonalBarApplicationType.UserPersonalBar.CLASS_NAME,
        "service.ranking:Integer=10"
    },
    service = ViewPortletProvider.class
)
\end{verbatim}

  The \texttt{model.class.name} property must be set to the class name
  of the entity type you want the portlet to handle. In this case, you
  want your portlet to be provided based on whether it can be displayed
  in the User Personal Bar.

  You may recall from the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes}{Portlet
  Providers} articles that you can request portlets in several different
  ways (e.g., \emph{Edit}, \emph{Browse}, etc.).

  You should also specify the service rank for your new portlet so it
  overrides the default. Make sure to set the
  \texttt{service.ranking:Integer} property to a number that is ranked
  higher than the portlet being used by default.

  Since you want to display your portlet instead of the User Personal
  Bar, the \texttt{service} element should be
  \texttt{ViewPortletProvider.class}.
\item
  Update the class's declaration to extend the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  abstract class and implement \texttt{ViewPortletProvider}:

\begin{verbatim}
public class ExampleViewPortletProvider extends BasePortletProvider implements ViewPortletProvider {

}
\end{verbatim}
\item
  Specify the portlet you want in the User Personal Bar by declaring the
  following method in your class:

\begin{verbatim}
@Override
public String getPortletName() {
    return PORTLET_NAME;
}
\end{verbatim}

  Replace the \texttt{PORTLET\_NAME} text with the portlet to provide
  when one is requested by the theme template. For example, the default
  portlet uses
  \texttt{com\_liferay\_product\_navigation\_user\_personal\_bar\_web\_portlet\_ProductNavigationPersonalBarPortlet}
\end{enumerate}

If you want to inspect the entire module used for Liferay's User
Personal Bar, see the
\href{https://github.com/liferay/liferay-portal/tree/7.2.0-ga1/modules/apps/product-navigation/product-navigation-user-personal-bar-web}{product-navigation-user-personal-bar-web}
module.

\section{Related Topics}\label{related-topics-35}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{Customizing
  the Product Menu}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-control-menu}{Customizing
  the Control Menu}
\end{itemize}

\chapter{Customizing the Personal
Menu}\label{customizing-the-personal-menu}

The Personal Menu is a portlet in Liferay DXP, and is the only item
occupying the User Personal Bar out of the box. You can add entries to
the Personal Menu by implementing the \texttt{PersonalMenuEntry}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/product-navigation/product-navigation-personal-menu-api/src/main/java/com/liferay/product/navigation/personal/menu/PersonalMenuEntry.java}{interface}.
If you're adding a portlet entry to the Personal Menu, the process is
slightly different. Both approaches are covered below.

\section{Adding an Entry to the Personal
Menu}\label{adding-an-entry-to-the-personal-menu}

Follow these steps. \texttt{SignOutPersonalMenuEntry.java} is used as an
example throughout these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module} and place a new Java class into a package in its
  \texttt{src} folder.
\item
  In the \texttt{@Component} annotation, specify the two properties
  shown below to place your new entry in the Personal Menu:

  \begin{itemize}
  \item
    \texttt{product.navigation.personal.menu.group}: determines the
    section where the entry will be placed.
  \item
    \texttt{product.navigation.personal.menu.entry.order}: determines
    the order of entries within each section. Note that sections are not
    labelled. To create a new section, assign the \texttt{group}
    property a value other than those for the four default sections
    (100, 200, 300, and 400).
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/user-personal-menu-sections.png}
  \caption{The Personal Menu is organized into four sections.}
  \end{figure}

  Here's an example:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
    "product.navigation.personal.menu.group:Integer=400",
        "product.navigation.personal.menu.entry.order:Integer=100"
    },
    service = PersonalMenuEntry.class
)
public class SignOutPersonalMenuEntry implements PersonalMenuEntry {
\end{verbatim}
\item
  Include the interface's methods. \texttt{SignoutPersonalMenuEntry}
  uses \texttt{getLabel} and \texttt{getPortletURL}, which are the only
  two that are mandatory. \texttt{getLabel} retrieves a language key to
  label the entry in the UI:

\begin{verbatim}
    @Override
    public String getLabel(Locale locale) {
        return LanguageUtil.get(locale, "sign-out");
    }
\end{verbatim}

  \texttt{getPortletURL} returns the URL for the portlet or page you
  want to access with the entry:

\begin{verbatim}
    public String getPortletURL(HttpServletRequest httpServletRequest)
        throws PortalException {

        ThemeDisplay themeDisplay =
            (ThemeDisplay)httpServletRequest.getAttribute(
                WebKeys.THEME_DISPLAY);

        return themeDisplay.getURLSignOut();
    }

}
\end{verbatim}
\end{enumerate}

That's all you need to implement the interface. However, the
\texttt{PersonalMenuEntry} interface includes a number of other methods
that you can use if you need them:

\texttt{getIcon}: identify an icon to display in the entry.

\texttt{isActive}: indicate whether the entry is currently active.

\texttt{isShow}: write logic to determine under what circumstances the
entry is displayed.

Learn how to add a portlet entry to the Personal Menu next.

\section{Adding a Portlet Entry to the Personal
Menu}\label{adding-a-portlet-entry-to-the-personal-menu}

If you're adding a portlet to the Personal Menu, you can extend the
\texttt{BasePersonalMenuEntry} class to save time. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module} and place a new Java class into a package in its
  \texttt{src} folder.
\item
  In the \texttt{@Component} annotation, specify the two properties
  shown below to place your new entry in the Personal Menu:

  \begin{itemize}
  \item
    \texttt{product.navigation.personal.menu.group}: determines the
    section where the entry will be placed.
  \item
    \texttt{product.navigation.personal.menu.entry.order}: determines
    the order of entries within each section. Note that sections are not
    labelled. To create a new section, assign the \texttt{group}
    property a value other than those for the four default sections
    (100, 200, 300, and 400).
  \end{itemize}

  An example is shown below:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "product.navigation.personal.menu.entry.order:Integer=100",
        "product.navigation.personal.menu.group:Integer=300"
    },
    service = PersonalMenuEntry.class
)
public class MyAccountPersonalMenuEntry extends BasePersonalMenuEntry {
\end{verbatim}
\item
  Override the \texttt{getPortletId()} method to provide the portlet's
  ID, as shown in the example below:

\begin{verbatim}
public class MyAccountPersonalMenuEntry extends BasePersonalMenuEntry {

    @Override
    public String getPortletId() {
        return UsersAdminPortletKeys.MY_ACCOUNT;
    }

}
\end{verbatim}

  The \texttt{BasePersonalMenuEntry} class automatically determines the
  label, portlet URL, state, and visibility based on the portlet ID.
\end{enumerate}

Once you've completed your implementation and deployed your module, your
new entry is displayed in the personal menu.

\section{Related Topics}\label{related-topics-36}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-product-menu}{Customizing
  the Product Menu}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-the-control-menu}{Customizing
  the Control Menu}
\end{itemize}

\chapter{Customizing Workflow}\label{customizing-workflow}

Liferay's workflow engine calls users to participate in a review process
designed for them. Out of the box, workflow makes it possible to define
simple to complex business processes/workflows, deploy them, and manage
them through a portal interface.

Workflow is flexible, in that you can design workflow processes in XML
to suit your business needs.

In Liferay DXP version 7.2, a new set of workflow features was
introduced around the concept of
\href{/docs/7-2/customization/-/knowledge_base/c/creating-sla-calendars}{Workflow
Metrics}.

The embedded calendar that ships out of the box can be replaced by your
own custom calendar service. More customization points will likely be
added in the future.

\chapter{Creating SLA Calendars}\label{creating-sla-calendars}

By default, an internal calendar assumes the
\href{/docs/7-2/customization/-/knowledge_base/c/creating-sla-calendars}{SLA
deadline clock} should continue counting all the time: in other words,
24 hours per day, seven days per week. If you need a different calendar
format, provide your own implementation of the
\texttt{WorkflowMetricsSLACalendar} interface. New implementations of
this service are picked up automatically by the Workflow Metrics
application, so they become available as soon as the module holding the
service implementation is deployed. The interface has three methods to
implement:

\begin{verbatim}
public interface WorkflowMetricsSLACalendar {

    public Duration getDuration(
        LocalDateTime startLocalDateTime, LocalDateTime endLocalDateTime);

    public LocalDateTime getOverdueLocalDateTime(
        LocalDateTime nowLocalDateTime, Duration remainingDuration);

    public String getTitle(Locale locale);

}
\end{verbatim}

If you define a new calendar, a new option becomes available in the Add
SLA form, allowing you to choose from the default 24/7 calendar or any
custom ones you've provided. For example, you can make the timer run for
8 hours per day, from 9-17 by a 24-hour clock, for 5 days per week. If
you need to, you can even stop the calendar from counting during lunch
hours!

\begin{figure}
\centering
\includegraphics{./images/workflow-custom-sla-calendar.png}
\caption{Write a Custom SLA Calendar if the default, 24/7 calendar isn't
sufficient.}
\end{figure}

\section{Dependencies}\label{dependencies-1}

Along with some artifacts you're probably used to depending on (like
\texttt{com.liferay.portal.kernel}), you'll need the
\texttt{com.liferay.portal.workflow.metrics.sla.api-{[}version{]}.jar}
artifact. For Liferay DXP version 7.2.10-GA1, here's an example Gradle
build dependency declaration:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.portal.workflow.metrics.sla.api", version: "1.1.0"
compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "4.4.0"
compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
\end{verbatim}

\section{Implementation Steps}\label{implementation-steps}

Implement a
\texttt{com.liferay.portal.workflow.metrics.sla.calendar.WorkflowMetricsSLACalendar}
to define your own SLA calendar logic. When you're finished, use the
created calendar when creating the
\href{/docs/7-2/customization/-/knowledge_base/c/creating-sla-calendars}{SLA
definition}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the component and the class:

\begin{verbatim}
import com.liferay.portal.kernel.language.Language;
import com.liferay.portal.workflow.metrics.sla.calendar.WorkflowMetricsSLACalendar;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Locale;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;


@Component(property = "sla.calendar.key=default")
public class DefaultWorkflowMetricsSLACalendar
    implements WorkflowMetricsSLACalendar {
\end{verbatim}

  The component property \texttt{sla.calendar.key} is required to
  identify this calendar.
\item
  Override \texttt{getDuration} to return the time \texttt{Duration}
  when elapsed SLA time should be computed. The start and end dates that
  this method receives represent the time a workflow task has been
  running. For example, given a task that started at
  \emph{2019-05-13T16:00:00} and finished at \emph{2019-05-13T18:00:00},
  then The 24/7 calendar returns 2 elapsed hours, while a 9-17 weekdays
  calendar returns 1 hour as the elapsed time.

\begin{verbatim}
@Override
public Duration getDuration(
    LocalDateTime startLocalDateTime, LocalDateTime endLocalDateTime) {

    return Duration.between(startLocalDateTime, endLocalDateTime);
}
\end{verbatim}
\item
  \texttt{getOverdueLocalDateTime} must return the date (as a
  \texttt{LocalDateTime}) when this SLA is considered overdue given the
  parameter values. For example, given that
  \texttt{nowLocalDateTime}=\emph{2019-05-13T17:00:00} and
  \texttt{remainingDuration}=\emph{24H}, The 24/7 calendar returns a
  \texttt{localDateTime} of \emph{2019-05-14T17:00:00} as the overdue
  date. Given the same parameters, the 9-17 weekdays calendar should
  return \emph{2019-05-17T09:00:00}. The remaining duration of time left
  in the SLA is available in the method as a \texttt{Duration} object;
  your job is to write logic that considers your calendar and create a
  \texttt{LocalDateTime} with the proper overdue date/time.

\begin{verbatim}
@Override
public LocalDateTime getOverdueLocalDateTime(
    LocalDateTime nowLocalDateTime, Duration remainingDuration) {

    return nowLocalDateTime.plus(remainingDuration);
}
\end{verbatim}
\item
  Use \texttt{getTitle} to provide the title for the given locale. Make
  sure you
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{properly
  localize} this extension by providing a \texttt{Language.properties}
  file and any \texttt{Language\_xx.properties} files for translation of
  the value. At runtime, the User's locale is used to return the correct
  translation.

\begin{verbatim}
@Override
public String getTitle(Locale locale) {
    return _language.get(locale, "default");
}

@Reference
private Language _language;
\end{verbatim}
\end{enumerate}

If the 24/7 default calendar works for you, use it. Otherwise create
your own \texttt{WorkflowMetricsSLACalendar}s.

\chapter{Customizing Core Functionality with
Ext}\label{customizing-core-functionality-with-ext}

\noindent\hrulefill

\textbf{Ext plugins are deprecated for 7.0 and should only be used if
absolutely necessary.}

The following app servers should be used for Ext plugin development in
Liferay DXP:

\begin{itemize}
\tightlist
\item
  Tomcat 9.x
\end{itemize}

In most cases, Ext plugins are not necessary. There are, however,
certain cases that require the use of an Ext plugin. Liferay only
supports the following Ext plugin use cases:

\begin{itemize}
\tightlist
\item
  Providing custom implementations for any beans declared in Liferay
  DXP's Spring files (when possible, use
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{service
  wrappers} instead of an Ext plugin). 7.0 removed many beans, so make
  sure your overridden beans are still relevant if converting your
  legacy Ext plugin
  (\href{/docs/7-2/customization/-/knowledge_base/c/extending-core-classes-using-spring-with-ext-plugins}{how
  to}).
\item
  Overwriting a class in a 7.0 core JAR. For a list of core JARs, see
  the
  \href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts\#finding-core-artifact-attributes}{Finding
  Core Liferay DXP Artifacts} section
  (\href{/docs/7-2/customization/-/knowledge_base/c/overriding-core-classes-with-ext-plugins}{how
  to}).
\item
  Modifying Liferay DXP's \texttt{web.xml} file
  (\href{/docs/7-2/customization/-/knowledge_base/c/modifying-the-web-xml-with-ext-plugins}{how
  to}).
\item
  Adding to Liferay DXP's \texttt{web.xml} file
  (\href{/docs/7-2/customization/-/knowledge_base/c/adding-to-the-web-xml-with-ext-plugins}{how
  to}).
\end{itemize}

\textbf{Note:} In previous versions of Liferay Portal, you needed an Ext
plugin to specify classes as portal property values (e.g.,
\texttt{global.starup.events.my.custom.MyStartupAction}), since the
custom class had to be added to the portal class loader. This is no
longer the case in 7.0 since all lifecycle events can use OSGi services
with no need to edit these legacy properties.

\noindent\hrulefill

Ext plugins are used to customize Liferay DXP's core functionality. You
can learn more about what the core encompasses in the
\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts\#finding-core-artifact-attributes}{Finding
Core Liferay DXP Artifacts} article section. In this section, you'll
learn how to

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/creating-an-ext-plugin}{Create
  an Ext plugin}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/developing-an-ext-plugin}{Develop
  an Ext plugin}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/deploying-an-ext-plugin}{Deploy
  an Ext plugin}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/redeploying-an-ext-plugin}{Redeploy
  an Ext plugin}
\end{itemize}

You can also dive into the
\href{/docs/7-2/customization/-/knowledge_base/c/anatomy-of-an-ext-plugin}{Anatomy
of an Ext Plugin} to familiarize yourself with its structure.

You'll start by creating an Ext plugin.

\chapter{Extending Core Classes Using Spring with Ext
Plugins}\label{extending-core-classes-using-spring-with-ext-plugins}

A supported use case for using Ext plugins in Liferay DXP is extending
its core classes (e.g., \texttt{portal-impl}, \texttt{portal-kernel},
etc.) using Spring. You can reference the
\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts\#finding-core-artifact-attributes}{Finding
Core Liferay Portal Artifacts} section for help distinguishing core
classes. Make sure you've reviewed the generalized
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-core-functionality-with-ext}{Customization
with Ext Plugins} section before creating an Ext plugin.

As an example, you'll create a sample Ext plugin that extends the
\href{https://docs.liferay.com/ce/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/util/PortalImpl.html}{PortalImpl}
core class residing in the \texttt{portal-impl.jar}. You'll override the
\texttt{PortalImpl.getComputerName()} method via Spring bean, which
returns your server's node name. The Ext plugin will override this
method and modify the server's returned node name.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your Liferay Workspace's root folder and run the following
  command:

\begin{verbatim}
blade create -t war-core-ext portal-impl-extend-spring-ext
\end{verbatim}

  Your Ext plugin is generated and now resides in the workspace's
  \texttt{/ext} folder with the name you assigned.
\item
  Displaying the server node name in your Liferay DXP installation is
  set to \texttt{false} by default. You'll need to enable this property.
  To do this, navigate into your Liferay bundle's root folder and create
  a \texttt{portal-ext.properties} file. In that file, insert the
  following property:

\begin{verbatim}
web.server.display.node=true
\end{verbatim}

  Now your server's node name will be displayed once your Liferay bundle
  is restarted.
\item
  In the \texttt{/extImpl/java} folder, create the folder structure
  representing the package name you want your new class to reside in
  (e.g., \texttt{com/liferay/portal/util}). Then create your new Java
  class:

\begin{verbatim}
package com.liferay.portal.util;

public class SamplePortalImpl extends PortalImpl {

    @Override
    public String getComputerName() {
        return "SAMPLE_EXT_INSTALLED_" + super.getComputerName();
    }
}
\end{verbatim}
\end{enumerate}

The method defined in the extension class overrides the
\texttt{PortalImpl.getComputerName()} method. The
\texttt{"SAMPLE\_EXT\_INSTALLED\_"} String is now prefixed to your
server's node name.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  In your Ext plugin's \texttt{/extImpl/resources} folder, create a
  \texttt{META-INF/ext-spring.xml} file. In this file, insert the
  following code:

\begin{verbatim}
<?xml version="1.0"?>

<beans
    default-destroy-method="destroy"
    default-init-method="afterPropertiesSet"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
>

    <bean class="com.liferay.portal.util.SamplePortalImpl" id="com.liferay.portal.util.PortalImpl" />
</beans>
\end{verbatim}
\end{enumerate}

Since you plan on modifying a core service class, you can inject its
extension class via a Spring bean. This will ensure your new class is
recognized. Assign your extension class's fully defined class name
(e.g., \texttt{com.liferay.portal.util.SamplePortalImpl}) to the bean
tag's \texttt{class} attribute and the fully defined original class name
(e.g., \texttt{com.liferay.portal.util.PortalImpl}) to the bean tag's
\texttt{id} attribute.

When your Ext plugin is deployed, your new service (e.g.,
\texttt{SamplePortalImpl}) will extend the core \texttt{PortalImpl}
class.

Awesome! You've created an Ext plugin that extends a core class in
Liferay DXP! Follow the instructions in the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-an-ext-plugin}{Deploy
the Plugin} article to deploy it to your server.

\chapter{Overriding Core Classes with Ext
Plugins}\label{overriding-core-classes-with-ext-plugins}

A supported use case for using Ext plugins in Liferay DXP is overriding
its core classes (e.g., \texttt{portal-impl}, \texttt{portal-kernel},
etc.). You can reference the
\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts\#finding-core-artifact-attributes}{Finding
Core Liferay Portal Artifacts} section for help distinguishing core
classes. Make sure you've reviewed the generalized
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-core-functionality-with-ext}{Customization
with Ext Plugins} section before creating an Ext plugin.

As an example, you'll create a sample Ext plugin that overwrites the
\href{https://docs.liferay.com/ce/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/util/PortalImpl.html}{PortalImpl}
core class residing in the \texttt{portal-impl.jar}. You'll edit the
\texttt{PortalImpl.getComputerName()} method, which returns your
server's node name. The Ext plugin will override the entire
\texttt{PortalImpl} class, adding the method modifying the server's
returned node name.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your Liferay Workspace's root folder and run the following
  command:

\begin{verbatim}
blade create -t war-core-ext portal-impl-override
\end{verbatim}

  Your Ext plugin is generated and now resides in the workspace's
  \texttt{/ext} folder with the name you assigned.
\item
  Displaying the server node name in your Liferay DXP installation is
  set to \texttt{false} by default. You'll need to enable this property.
  To do this, navigate into your Liferay bundle's root folder and create
  a \texttt{portal-ext.properties} file. In that file, insert the
  following property:

\begin{verbatim}
web.server.display.node=true
\end{verbatim}

  Now your server's node name will be displayed once your Liferay bundle
  is restarted.
\item
  In the \texttt{/extImpl/java} folder, create the folder structure
  matching the class's folder structure you'd like to override (e.g.,
  \texttt{com/liferay/portal/util}). Then create the new Java class that
  will override the existing core class; your new class must have the
  same name as the original.
\item
  Copy all of the original class's (e.g., \texttt{PortalImpl}) logic
  into your new class. Then modify the method you want to customize. For
  this example, you want to edit the \texttt{getComputerName()} method.
  Therefore, replace it with the method below:

\begin{verbatim}
@Override
public String getComputerName() {
    return "sample_portalimpl_ext_installed_successfully_" + _computerName;
}
\end{verbatim}

  The method defined in the new class overrides the
  \texttt{PortalImpl.getComputerName()} method. The
  \texttt{sample\_portalimpl\_ext\_installed\_successfully\_} String is
  now prefixed to your server's node name.
\end{enumerate}

When your Ext plugin is deployed, your new Java class will override the
core \texttt{PortalImpl} class.

Awesome! You've created an Ext plugin that overrides a core class in
Liferay DXP! Follow the instructions in the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-an-ext-plugin}{Deploy
the Plugin} article to deploy it to your server.

\chapter{Adding to the web.xml with Ext
Plugins}\label{adding-to-the-web.xml-with-ext-plugins}

A supported use case for using Ext Plugins in Liferay DXP is adding
additional functionality to its \texttt{web.xml} file. Before beginning,
make sure you've reviewed the generalized
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-core-functionality-with-ext}{Customization
with Ext Plugins} section.

As an example, you'll create a sample Ext plugin that adds to your
Liferay DXP's existing \texttt{web.xml} file (e.g., in the
\texttt{/tomcat-{[}version{]}/webapps/ROOT/WEB-INF} folder). You'll add
a new printout in the console during startup.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your Liferay Workspace's root folder and run the following
  command:

\begin{verbatim}
blade create -t war-core-ext add-printout
\end{verbatim}

  Your Ext plugin is generated and now resides in the workspace's
  \texttt{/ext} folder with the name you assigned.
\item
  For your Liferay DXP installation to recognize new functionality in
  the \texttt{web.xml}, you must create a class that implements the
  \href{https://javaee.github.io/javaee-spec/javadocs/javax/servlet/ServletContextListener.html}{ServletContextListener}
  interface. This class will initialize a servlet context event for
  which you'll add your new functionality. In the \texttt{extImpl/java}
  folder, create the folder structure representing the package name you
  want your new class to reside in (e.g.,
  \texttt{com/liferay/portal/servlet/context}). Then create your new
  Java class:

\begin{verbatim}
package com.liferay.portal.servlet.context;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ExtAddEntryWebXmlPortalContextLoaderListener
        implements ServletContextListener {

    public void contextDestroyed(ServletContextEvent servletContextEvent) {
    }

    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("EXT_ADD_ENTRY_WEBXML_INSTALLED_SUCCESSFULLY");
    }
}
\end{verbatim}

  The above class includes two methods that initialize and destroy your
  servlet context event. Be sure to add the new \texttt{web.xml}'s
  functionality when the portal context is initializing. To add a
  printout verifying the Ext plugins installation, a simple print
  statement was defined in the \texttt{contextInitialized(...)} method:

\begin{verbatim}
System.out.println("EXT_ADD_ENTRY_WEBXML_INSTALLED_SUCCESSFULLY");
\end{verbatim}
\item
  Now that you've defined a servlet context event, you should add a
  listener to your \texttt{web.xml} that listens for it. In the
  \texttt{ext-web/docroot/WEB-INF} folder, open the \texttt{web.xml}
  file, which was generated for you by default.
\item
  Add the following tag between the tags:

\begin{verbatim}
<listener>
    <listener-class>com.liferay.portal.servlet.context.ExtAddEntryWebXmlPortalContextLoaderListener</listener-class>
</listener>
\end{verbatim}
\end{enumerate}

Excellent! Now when your Ext plugin is deployed, your Liferay DXP
installation will create a \texttt{ServletContextListener} instance,
which will initialize a custom servlet context event. This event will be
recognized by the \texttt{web.xml} file, which will add the new
functionality to your Liferay DXP installation. Follow the instructions
in the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-an-ext-plugin}{Deploy
the Plugin} article for help deploying the Ext plugin to your server.

\chapter{Modifying the web.xml with Ext
Plugins}\label{modifying-the-web.xml-with-ext-plugins}

A supported use case for using Ext Plugins in Liferay DXP is modifying
its \texttt{web.xml} file. Before beginning, make sure you've reviewed
the generalized
\href{/docs/7-2/customization/-/knowledge_base/c/customizing-core-functionality-with-ext}{Customization
with Ext Plugins} section.

As an example, you'll create a sample Ext plugin that modifies Liferay
DXP's existing \texttt{web.xml\ file} (e.g., in the
\texttt{/tomcat-{[}version{]}/webapps/ROOT/WEB-INF} folder). You'll
modify the session timeout configuration, which is set to 30 (minutes)
by default:

\begin{verbatim}
<session-config>
    <session-timeout>30</session-timeout>
    <cookie-config>
        <http-only>true</http-only>
    </cookie-config>
</session-config>
\end{verbatim}

The Ext plugin will update the session timeout to one minute.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate into your Liferay Workspace's \texttt{/ext} folder and run
  the following command:

\begin{verbatim}
blade create -t war-core-ext modify-session-timeout
\end{verbatim}

  Your Ext plugin is generated and now resides in the workspace's
  \texttt{/ext} folder with the name you assigned.
\item
  In the \texttt{ext-web/docroot/WEB-INF} folder, open the
  \texttt{web.xml} file, which was generated for you by default.
\item
  Insert the following logic between the
  \texttt{\textless{}web-app\textgreater{}} tags:

\begin{verbatim}
<session-config>
    <session-timeout>1</session-timeout>
    <cookie-config>
        <http-only>true</http-only>
    </cookie-config>
</session-config>
\end{verbatim}
\end{enumerate}

Notice that the \texttt{\textless{}session-timeout\textgreater{}} tag
has been updated to \texttt{1}.

\noindent\hrulefill

\textbf{Note:} You can configure an uninterrupted session by setting the
\texttt{\textless{}session-timeout\textgreater{}} tag to \texttt{-1}.
Leaving a session permanently active is a risk and is not recommended
for production environments, but is useful for testing.

\noindent\hrulefill

That's it! Now when your Ext plugin is deployed, your Liferay DXP
installation will timeout after one minute of inactivity. Follow the
instructions in the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-an-ext-plugin}{Deploy
the Plugin} article for help deploying the Ext plugin to your server.
