\chapter{Application Development}\label{application-development}

Writing applications on Liferay's standards-based platform makes your
life easier. Whether you create headless services for clients to access,
full-blown web applications with beautiful UIs, or anything in between,
Liferay DXP streamlines the process to help you get your job done
faster.

Liferay's framework embraces your existing tools and build environments
like \href{https://maven.apache.org}{Maven} and
\href{https://gradle.org}{Gradle}. You can work with the standard
technologies you know and leverage Liferay's APIs for Documents,
Permissions, Search, or Content when you need them. Here's a high level
view of what you can do:

\begin{itemize}
\item
  \textbf{Deployment of existing standards-based apps:} If you have an
  existing app built outside of Liferay DXP, you can deploy it on
  Liferay DXP. The Liferay Bundler Generator and Liferay npm Bundler
  provide the project scaffolding and packaging to deploy
  \href{https://angular.io/}{Angular},
  \href{https://reactjs.org/}{React}, and \href{https://vuejs.org/}{Vue}
  web front-ends as Widgets. Spring Portlet MVC app conversion to
  \href{https://github.com/liferay/portletmvc4spring}{PortletMVC4Spring}
  requires only a few steps. JSF applications work almost as-is. Portlet
  3.0 or 2.0 compliant portlets deploy on Liferay DXP.
\item
  \textbf{Back-end Java services, web services, and REST services:}
  Service Builder is an object-relational mapper where you describe your
  data model in a single \texttt{xml} file. From this, you can generate
  the tables, a Java API for accessing your data model, and web
  services. On top of these, REST Builder generates OpenAPI-based REST
  services your client applications can call.
\item
  \textbf{Authentication and single-sign on (SSO):} OAuth 2.0, OpenID
  Connect, and SAML are built-in and ready to go.
\item
  \textbf{Front-end web development using Java EE and/or JavaScript:}
  Use Java EE standard Portlet technology (JSR 168, JSR 286, JSR 362)
  with CDI and/or JSF. Prefer Spring?
  \href{https://github.com/liferay/portletmvc4spring}{PortletMVC4Spring}
  brings the Spring MVC Framework to Liferay. Rather have a client-side
  app? Write it in \href{https://angular.io/}{Angular},
  \href{https://reactjs.org/}{React}, or \href{https://vuejs.org/}{Vue}.
  Been using Liferay DXP for a while? Liferay MVC Portlet is better than
  ever.
\item
  \textbf{Frameworks and APIs for every need:} Be more productive by
  using Liferay's built-in and well-tested APIs that cover often-used
  features like file management(upload/download), permissions, comments,
  out-of-process messaging, or UI elements such as data tables and item
  selectors. Liferay DXP offers many APIs for every need, from an entire
  workflow framework to a streamlined way of getting request parameters.
\item
  \textbf{Tool freedom:} Liferay provides Maven archetypes,
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
  Workspace},
  \href{/docs/7-2/reference/-/knowledge_base/r/gradle-plugins}{Gradle}
  and \href{/docs/7-2/reference/-/knowledge_base/r/maven-plugins}{Maven}
  plugins, a \href{http://yeoman.io/}{Yeoman}-based
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{theme
  generator}, and
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} to
  integrate with any development workflow. On top of that, you can use
  our \href{/docs/7-2/reference/-/knowledge_base/r/intellij}{IntelliJ
  plugin} or the Eclipse-based
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
  Developer Studio} if you need a full-blown development environment.
\item
  \textbf{Developer community:} The \href{https://liferay.dev}{Liferay
  DXP community} is helpful and active.
\end{itemize}

\section{Getting Started with Liferay
Development}\label{getting-started-with-liferay-development}

Want to see what it's like to develop an app on Liferay DXP? Here's a
quick tour.

\section{Create Your Object Model and Database in One
Shot}\label{create-your-object-model-and-database-in-one-shot}

You don't need a database to work with Liferay, but if your app uses
one, you can design it and your object model at the same time with
Liferay's object-relational mapper,
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}. You define your object model in a single \texttt{xml} file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.2.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_7_0_0.dtd">
<service-builder auto-namespace-tables="true" package-path="com.liferay.docs.guestbook">
    <author>liferay</author>
    <namespace>GB</namespace>
    <entity name="Guestbook" local-service="true" remote-service="true" uuid="true">

        <column name="guestbookId" primary="true" type="long" />
        <column name="name" type="String" />

        <finder name="Name" return-type="Collection"/>
            <finder-column name="name" />
        </finder>

    </entity>

    <entity name="Entry" local-service="true" remote-service="true" uuid="true">
    
        <column name="entryId" primary="true" type="long" />
        <column name="name" type="String" />
        <column name="email" type="String" />
        <column name="message" type="String" />
        <column name="guestbookId" type="long" />

        <finder name="Email" return-type="Collection" />
            <finder-column name="email" />
        </finder>

    </entity>

</service-builder>
\end{verbatim}

Service Builder generates your object model, database, SOAP, and JSON
web services automatically. Java classes are ready for you to implement
your business logic around generated CRUD operations. The web services
are mapped to your business logic. If you want a REST interface, you can
create one.

\section{Create a REST Interface}\label{create-a-rest-interface}

\href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder}
helps you define REST interfaces for your APIs, using
\href{https://swagger.io/docs/specification/about/}{OpenAPI/Swagger}.
Create your
\href{https://swagger.io/docs/specification/basic-structure/}{YAML
definition} file for your REST interface along with a configuration file
defining where Java classes, a client, and tests should be generated,
and you have REST endpoints ready to call your API.

Next, you need a client. You can use Liferay DXP in headless mode and
write your web and mobile clients any way you want. Or you can create
your web clients on Liferay's platform and take advantage of its many
tools and APIs that speed up development.

\section{Create a Web Client}\label{create-a-web-client}

Liferay DXP is an ideal platform upon which to build a web client. Its
Java EE-based technology means you can pick from the best it has to
offer: Spring MVC using
\href{https://github.com/liferay/portletmvc4spring}{PortletMVC4Spring},
the new backwards-compatible Portlet 3, JSF using
\href{https://liferayfaces.org}{Liferay Faces}, or the venerable
OSGi-based
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlet}. If you're a front-end developer, deploy your Angular,
React, or Vue-based front-end applications to run as widgets next to the
rest of Liferay DXP's installed applications.

\section{Use Liferay's Frameworks}\label{use-liferays-frameworks}

Your apps need features. Liferay has implemented tons of common
functionality you can use in your applications. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/liferay-ui/tld-summary.html}{Liferay-UI}
tag library has tons of web components like Search Container (a sortable
data table), panels, buttons, and more. Liferay's
\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework} can publish data from your application in context wherever
users need it---as a notification, a related asset, as tagged or
categorized data, or as relevant data based on a
\href{/docs/7-2/user/-/knowledge_base/u/creating-user-segments}{user
segment}. Need to provide file upload/download? Use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
API}. Need a robust permissions system? Use
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{Liferay
permissions}. Want users to submit comments? Use Liferay's
\href{/docs/7-2/frameworks/-/knowledge_base/f/adding-comments-to-your-app}{comments}.
Need to process data outside the request/response? Use the Message Bus.
Should users select items from a list? Use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector}.

\section{Next Steps}\label{next-steps}

So what's next? \href{/download}{Download} Liferay DXP and
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{create
your first project}! Have a look at our
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{back-end},
\href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder},
and \href{/docs/7-2/appdev/-/knowledge_base/a/web-front-ends}{front-end}
docs, examine what Liferay's
\href{/docs/7-2/frameworks/-/knowledge_base/f/frameworks}{frameworks}
have to offer, and then go create the beautiful things that only you can
make.

\chapter{Developing Web Front-Ends}\label{developing-web-front-ends}

Liferay's open development framework removes barriers so developers can
write applications faster. If you already have an application, you can
deploy it on Liferay DXP:

\begin{itemize}
\tightlist
\item
  Java-based standards (CDI, JSF, Portlets, Spring)
\item
  Front-end standards (Angular, React, Vue)
\end{itemize}

If you plan to write a new application and deploy it on Liferay DXP, you
can use the frameworks you know along with the build tools (Gradle,
Maven) you know. Liferay also offers its own development framework
called MVC Portlet that it uses to develop applications. When you want
to integrate with
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Liferay
services} and frameworks such as permissions, assets, and indexers,
you'll find that these easily and seamlessly blend with your application
to provide a great user experience.

Regardless of your development strategy for applications, you'll find
Liferay DXP to be a flexible platform that supports anything you need to
write.

\section{Using Popular Frameworks}\label{using-popular-frameworks}

Liferay gives you a head start on developing and deploying apps that use
these popular Java and JavaScript-based technologies:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-an-angular-application}{Angular
  Widget}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-react-application}{React
  Widget}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-vue-application}{Vue
  Widget}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
  MVC Portlet}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{PortletMVC4Spring
  Portlet}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/jsf-portlet}{JSF Portlet}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The Reference section describes
\href{/docs/7-2/reference/-/knowledge_base/r/sample-projects}{sample
projects} and
\href{/docs/7-2/reference/-/knowledge_base/r/project-templates}{project
templates} for creating UIs using other technologies.

\noindent\hrulefill

Angular, React, and Vue applications are written the same as you would
outside of Liferay DXP---using \href{https://www.npmjs.com/}{npm} and
the webpack dev server. The Liferay JS Generator creates a portlet
bundle (project) for developing and deploying each type of app. The
bundle project comes with npm commands for building, testing, and
deploying the app. It packages the app's dependencies (including
JavaScript packages), deploys the bundle as a JAR, and installs the
bundle to Liferay DXP's run time environment, making your app available
as a widget.

You can also develop web front-ends using Java EE standards. Liferay DXP
supports the \href{https://jcp.org/en/jsr/detail?id=362}{JSR 362}
Portlet 3.0 standard which is backwards-compatible with the
\href{http://jcp.org/en/jsr/detail?id=286}{JSR 286} Portlet 2.0 standard
from the Java Community Process (JCP). Each portlet framework has
benefits you may wish to consider.

Bean Portlet is the only framework containing all of the Portlet 3
features:

\begin{itemize}
\tightlist
\item
  Contexts and Dependency Injection (CDI)
\item
  Extended method annotations
\item
  Explicit render state
\item
  Action, render, and resource parameters
\item
  Asynchronous support
\end{itemize}

If you're a JavaServer Faces (JSF) developer, the
\href{/docs/7-1/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
Faces Bridge} supports deploying JSF web apps as portlets without
writing portlet-specific Java code. It also contains innovative features
that make it possible to leverage the power of JSF 2.x inside a portlet
application.

If Spring is your thing, Spring Portlet MVC portlets are easy to
configure and deploy on Liferay DXP. You can continue using Spring
features, including Spring beans and Spring dependency injection.

Last but not least, Liferay MVC Portlet continues to be a favorite with
experienced Liferay developers, and makes portlet development easy for
Liferay newcomers. It leverages OSGi Declarative Services (DS) for
injecting dependencies and defining configurable extension points. Since
Liferay DXP core and Liferay-written apps use DS, gaining experience
with DS helps you develop Liferay DXP extensions and customizations.
Liferay MVC Portlet works seamlessly with many Liferay frameworks, such
as MVC commands, Service Builder, and more.

No matter which development framework you choose, you'll be able to get
an app up and running fast.

\section{Getting Started}\label{getting-started}

If you have an existing app that uses one the frameworks described
above, your first step is to deploy it to Liferay DXP. Most deployments
involve configuration steps that you can complete in an hour or less.

You can also build apps from scratch using the tools you like or
leveraging Liferay's tool offering. Liferay provides templates for
creating all kinds of apps and samples that you can examine and modify
to fit your needs.

Once your app is functional, you can improve your app by integrating it
with Liferay frameworks:

\begin{itemize}
\tightlist
\item
  Localization
\item
  Permissions
\item
  Search and indexing
\item
  Asset publishing
\item
  Workflow
\item
  Staging
\item
  Data export and import
\end{itemize}

Liferay provides frameworks that integrate these features fast. As you
develop apps on Liferay DXP, you'll enjoy using what you know, discover
frameworks and tools that boost your productivity, and have fun creating
rich, full-featured applications.

If you're experienced with developing one of the listed app types, feel
free to jump ahead to it. Otherwise, Angular Widgets is next.

\chapter{Developing an Angular
Application}\label{developing-an-angular-application}

Running an existing Angular app on Liferay DXP makes the app available
as a widget for using on site pages. You can
\href{/docs/7-2/reference/-/knowledge_base/r/adapting-existing-apps-to-run-on-product}{adapt
your existing Angular app}, but this doesn't give you access to the
bundler and its various loaders to develop your project further in
Liferay DXP. To have access to all of Liferay DXP's features, you must
use the Liferay JS Generator and Liferay npm Bundler to merge your files
into a portlet bundle, adapt your routes and CSS, and deploy your
bundle.

\begin{figure}
\centering
\includegraphics{./images/appdev-angular-app-migrated.png}
\caption{Apps like this Guestbook app are easy to migrate to Liferay
DXP.}
\end{figure}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Using \href{https://www.npmjs.com}{npm}, install the Liferay JS
  Generator:

\begin{verbatim}
npm install -g yo generator-liferay-js
\end{verbatim}
\item
  Generate an Angular-based portlet bundle project for deploying your
  app to your \href{/deployment/docs/installing-product}{Liferay DXP
  installation}.

\begin{verbatim}
yo liferay-js
\end{verbatim}

  Select \texttt{Angular\ based\ portlet} and opt for generating sample
  code. Here's the bundle's structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}my-angular-portlet-bundle{]}}

    \begin{itemize}
    \tightlist
    \item
      \texttt{assets/} → CSS, HTML templates, and resources

      \begin{itemize}
      \tightlist
      \item
        \texttt{css/} → CSS files

        \begin{itemize}
        \tightlist
        \item
          \texttt{styles.css} → Default CSS file
        \end{itemize}
      \item
        \texttt{app/} → HTML templates

        \begin{itemize}
        \tightlist
        \item
          \texttt{app.component.html} → Root component template
        \end{itemize}
      \end{itemize}
    \item
      \texttt{features/} → Liferay DXP bundle features

      \begin{itemize}
      \tightlist
      \item
        \texttt{localization/} → Resource bundles

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties} → Default language keys
        \end{itemize}
      \end{itemize}
    \item
      \texttt{src/} → JavaScript an TypeScript files

      \begin{itemize}
      \tightlist
      \item
        \texttt{app/} → Application modules and Components

        \begin{itemize}
        \tightlist
        \item
          \texttt{app.component.ts} → Main component
        \item
          \texttt{app.module.ts} → Root module
        \item
          \texttt{dynamic.loader.ts} → Loads an Angular component
          dynamically for the portlet to attach to
        \end{itemize}
      \item
        \texttt{types/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{LiferayParams.ts} → Parameters passed by Liferay DXP
          to the JavaScript module
        \end{itemize}
      \item
        \texttt{index.ts} → Main module invoked by the ``bootstrap''
        module to initialize the portlet
      \item
        \texttt{polyfills.ts} → Fills in browser JavaScript
        implementation gaps
      \end{itemize}
    \item
      \texttt{package.json} → npm bundle configuration
    \item
      \texttt{README.md}
    \item
      \texttt{.npmbuildrc} → Build configuration
    \item
      \texttt{.npmbundlerrc} → Bundler configuration
    \item
      \texttt{tsconfig.json} → TypeScript configuration
    \end{itemize}
  \end{itemize}
\item
  Copy your app files, matching the types listed below, into your new
  project.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 File type | Destination | Comments |
 --------- | ----------- | -------- |
 HTML | `assets/app/` | Merge your main component with the existing `app.component.html`. |
 CSS  | `assets/css/` | Overwrite `styles.css`. |
 TypeScript and JavaScript | `src/app/` |  Merge with all files **except** `app.module.ts`---the root module merge is explained in a later step. |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Update your component class \texttt{templateUrl}s to use the
  \texttt{web-context} value declared in your project's
  \texttt{.npmbundlerrc} file. Here's the format:

\begin{verbatim}
templateUrl: `/o/[web-context]/app/[template]`
\end{verbatim}

  Here's an example:

\begin{verbatim}
templateUrl: '/o/my-angular-guestbook/app/add-entry/add-entry.component.html'
\end{verbatim}
\item
  Update your bundle to use portlet-level styling.

  \begin{itemize}
  \item
    Import all component CSS files through the CSS file (default is
    \texttt{styles.css}) your bundle's \texttt{package.json} file sets
    for your portlet. Here's the default setting:

\begin{verbatim}
"portlet": {
    "com.liferay.portlet.header-portlet-css": "/css/styles.css",
...
}
\end{verbatim}
  \item
    Remove \texttt{selector} and \texttt{styleUrls} properties from your
    component classes.
  \end{itemize}
\item
  In your routing module's \texttt{@NgModule} decorator, configure the
  router option \texttt{useHash:\ true}. This tells Angular to use
  client-side routing in the form of \texttt{.../\#/{[}route{]}}, which
  prevents client-side parameters (i.e., anything after \texttt{\#})
  from being sent back to Liferay DXP.

  For example, your routing module class \texttt{@NgModule} decorator
  might look like this:

\begin{verbatim}
@NgModule({
  imports: [RouterModule.forRoot(routes, {useHash: true})],
  exports: [RouterModule]
})
export class AppRoutingModule { }
\end{verbatim}
\item
  Also in your routing module, export your view components for your root
  module (discussed next) to use. For example,

\begin{verbatim}
export const routingComponents = [ViewComponent1, ViewComponent2]
\end{verbatim}
\item
  Merge your root module with \texttt{src/app/app.module.ts},
  configuring it to dynamically load components.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Components must be loaded dynamically to attach to the portlet's
 DOM. The DOM is determined at run time when the portlet's page is
 rendered. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
-   Import the `routingComponents` constant and the app routing module class
    from your app routing module. For example,

    ```javascript
    import { AppRoutingModule, routingComponents } from './app-routing.module';
    ```

-   Specify the base href for the router to use in the navigation URLs. 

    ```javascript
    import { APP_BASE_HREF } from '@angular/common';
    ...
    
    @NgModule({
        ...
        providers: [{provide: APP_BASE_HREF, useValue: '/'}]
    })
    ```

-   Declare the `routingComponents` constant in your `@NgModule` decorator. 

    ```javascript
    @NgModule({
      declarations: [
          routingComponents,
          ...
      ],
      ...
    })
    ```

-   Make sure your `@NgModule` `bootstrap` property has no components. All 
    components are loaded dynamically using the `entryComponents` array
    property. The empty `ngDoBootstrap()` method nullifies the default
    bootstrap implementation. 

    ```javascript
    @NgModule({
      ...
        entryComponents: [AppComponent],
        bootstrap: [],
        ...
    })
    export class AppModule {
        ngDoBootstrap() {}
        ...
    }
    ```

Your root module `app.module.ts` should look like this: 

```javascript
import { APP_BASE_HREF } from '@angular/common';
import { AppRoutingModule, routingComponents } from './app-routing.module';
// more imports ...

@NgModule({
  declarations: [
    AppComponent,
    routingComponents, 
    // more declarations ...
  ],
  imports: [
    AppRoutingModule,
    // more imports ...
  ],
  entryComponents: [AppComponent],
  providers: [{provide: APP_BASE_HREF, useValue: '/'}],
  bootstrap: [],
  // more properties ...
})
export class AppModule {
    ngDoBootstrap() {}

    // ...
}
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\tightlist
\item
  Merge your app \texttt{package.json} file's \texttt{dependencies} and
  \texttt{devDependencies} into the bundle's \texttt{package.json}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To work around build errors caused by the `rxjs` dependency, set
 the dependency to version `"6.0.0"`. See
 [LPS-92848](https://issues.liferay.com/browse/LPS-92848)
 for details. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\item
  Finally, deploy your bundle:

\begin{verbatim}
npm run deploy
\end{verbatim}
\end{enumerate}

Congratulations! Your Angular app is deployed and now available as a
widget that you can add to site pages.

The Liferay npm Bundler confirms the deployment:

\begin{verbatim}
Report written to liferay-npm-bundler-report.html
Deployed my-angular-guestbook-1.0.0.jar to c:\git\bundles
\end{verbatim}

The Liferay DXP console confirms your bundle started:

\begin{verbatim}
2019-03-22 20:17:53.181 INFO  [fileinstall-C:/git/bundles/osgi/modules][BundleStartStopLogger:39] STARTED my-angular-guestbook_1.0.0 [1695]
\end{verbatim}

To find your widget, select the \emph{Add} icon
(\includegraphics{./images/icon-add-app.png}), navigate to
\emph{Widgets} and then the category you specified to the Liferay Bundle
Generator (\emph{Sample} is the default category).

\section{Related Topics}\label{related-topics}

\href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{Web
Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}

\chapter{Developing a React
Application}\label{developing-a-react-application}

Running an existing React app on Liferay DXP makes the app available as
a widget for using on site pages. You can
\href{/docs/7-2/reference/-/knowledge_base/r/adapting-existing-apps-to-run-on-product}{adapt
your existing React app}, but this doesn't give you access to the
bundler and its various loaders to develop your project further in
Liferay DXP. To have access to all of Liferay DXP's features, you must
use the Liferay JS Generator and Liferay npm Bundler to merge your files
into a portlet bundle, update your static resource paths, and deploy
your bundle.

\begin{figure}
\centering
\includegraphics{./images/appdev-react-app-migrated.png}
\caption{Apps like this Guestbook app are easy to migrate to Liferay
DXP.}
\end{figure}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Using \href{https://www.npmjs.com/}{npm}, install the Liferay JS
  Generator:

\begin{verbatim}
npm install -g yo generator-liferay-js
\end{verbatim}
\item
  Generate a React based portlet bundle project for deploying your app
  to your \href{/deployment/docs/installing-product}{Liferay DXP
  installation}.

\begin{verbatim}
yo liferay-js
\end{verbatim}

  Select \texttt{React\ based\ portlet} and opt for generating sample
  code. Here's the bundle's structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{my-react-portlet-bundle}

    \begin{itemize}
    \tightlist
    \item
      \texttt{assets/} → CSS and resources

      \begin{itemize}
      \tightlist
      \item
        \texttt{css/} → CSS files

        \begin{itemize}
        \tightlist
        \item
          \texttt{styles.css} → Default CSS file
        \end{itemize}
      \end{itemize}
    \item
      \texttt{features/} → Liferay DXP bundle features

      \begin{itemize}
      \tightlist
      \item
        \texttt{localization} → Resource bundles

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties} → Default language keys
        \end{itemize}
      \end{itemize}
    \item
      \texttt{src/} → JavaScript and React component files

      \begin{itemize}
      \tightlist
      \item
        \texttt{AppComponent.js} → Sample React component that you can
        remove
      \item
        \texttt{index.js} → Main module used to initialize the portlet
      \end{itemize}
    \item
      \texttt{.babelrc} → Babel configuration
    \item
      \texttt{.npmbuildrc} → Build configuration
    \item
      \texttt{.npmbundlerrc} → Bundler configuration
    \item
      \texttt{package.json} → npm bundle configuration
    \item
      \texttt{README.md}
    \end{itemize}
  \end{itemize}
\item
  Copy your app files, matching the types listed below, into your new
  project.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 File type | Destination | Comments |
 --------- | ----------- | -------- |
 CSS  | `assets/css/` | Overwrite `styles.css`. |
 JavaScript | `src/` |  Merge with all files **except** `index.js`---the main module merge is explained in a later step. |
 Static resources | `assets/` |  Include resources such as image files here |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Update your bundle to use portlet-level styling.

  \begin{itemize}
  \tightlist
  \item
    Import all component CSS files through the CSS file (default is
    \texttt{styles.css}) your bundle's \texttt{package.json} file sets
    for your portlet. Here's the default setting:
  \end{itemize}

\begin{verbatim}
 "portlet": {
     "com.liferay.portlet.header-portlet-css": "/css/styles.css",
     ...
 }
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    Remove any CSS imports you have in your JS files
  \end{itemize}
\item
  Update any static resource references to use the \texttt{web-context}
  value declared in your project's \texttt{.npmbundlerrc} file, and
  remove any imports for the resource. For example, if you have an image
  file called \texttt{logo.png} in your \texttt{assets} folder, you
  would use the format below. Note that the \texttt{assets} folder is
  not included in the path.

  Here is the format:

\begin{verbatim}
/o/[web-context]/[resource]
\end{verbatim}

  Here's an example image resource:

\begin{verbatim}
<img alt="React logo" src="/o/react-guestbook-migrated/logo.png">
\end{verbatim}
\item
  Merge your entry module with \texttt{src/index.js}, configuring it to
  dynamically load components.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Components must be loaded dynamically to attach to the portlet's
 DOM. The DOM is determined at run time when the portlet's page is
 rendered. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
-   Use the `HashRouter` for routing between component views, as Liferay DXP 
    requires hash routing for proper portal navigation:

   ```javascript
    import { HashRouter as Router } from 'react-router-dom';
   ```

-   Place your code inside the `main()` function.

-   Render your app inside the `portletElementId` element that is passed in 
    the `main()` function. This is required to render the React app inside
    the portlet.

Your entry module `index.js` should look like this. 

```javascript
import React from 'react';
import ReactDOM from 'react-dom';
//import './index.css';//removed for Portal Migration
import App from './App';
import { HashRouter as Router } from 'react-router-dom';

export default function main({portletNamespace, contextPath, 
portletElementId}) {
      ReactDOM.render((
        <Router>
          <App/>
        </Router>
      ), document.getElementById(portletElementId));
}
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Merge your app \texttt{package.json} file's \texttt{dependencies} and
  \texttt{devDependencies} into the bundle's \texttt{package.json}.
\item
  Finally, deploy your bundle:

\begin{verbatim}
npm run deploy
\end{verbatim}
\end{enumerate}

Congratulations! Your React app is deployed and now available as a
widget that you can add to site pages.

The Liferay npm Bundler confirms the deployment:

\begin{verbatim}
Report written to liferay-npm-bundler-report.html
Deployed my-react-guestbook-1.0.0.jar to c:\git\bundles
\end{verbatim}

The Liferay DXP console confirms your bundle started:

\begin{verbatim}
2019-03-22 20:17:53.181 INFO  
[fileinstall-C:/git/bundles/osgi/modules][BundleStartStopLogger:39] 
STARTED my-react-guestbook_1.0.0 [1695]
\end{verbatim}

To Find your widget, click the \emph{Add} icon
(\includegraphics{./images/icon-add-app.png}), navigate to
\emph{Widgets} and then the category you specified to the Liferay Bundle
Generator (\emph{Sample} is the default category).

\section{Related Topics}\label{related-topics-1}

\href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{Web
Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}

\chapter{Developing a Vue
Application}\label{developing-a-vue-application}

Running an existing Vue app on Liferay DXP makes the app available as a
widget for using on site pages. You can
\href{/docs/7-2/reference/-/knowledge_base/r/adapting-existing-apps-to-run-on-product}{adapt
your existing Vue app}, but this doesn't give you access to the bundler
and its various loaders to develop your project further in Liferay DXP.
To have access to all of Liferay DXP's features, you must use the
Liferay JS Generator and Liferay npm Bundler to merge your files into a
portlet bundle, update your static resource paths, and deploy your
bundle. The steps below demonstrate how to prepare a Vue app that uses
single file components (\texttt{.vue} files) with multiple views.

\begin{figure}
\centering
\includegraphics{./images/appdev-vue-migrated.png}
\caption{Vue Apps like this Guestbook App are easy to deploy, and they
look great in Liferay DXP.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} if you have a tree of components expressed as
\texttt{.vue} templates, only the root one will be available as a true
AMD module.

\noindent\hrulefill

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Using \href{https://www.npmjs.com/}{npm}, install the Liferay JS
  Generator:

\begin{verbatim}
npm install -g yo generator-liferay-js
\end{verbatim}
\item
  Generate a Vue based portlet bundle project:

\begin{verbatim}
yo liferay-js
\end{verbatim}

  Select \texttt{Vue\ based\ portlet} and opt for generating sample
  code. Here's the bundle's structure:

  \begin{itemize}
  \tightlist
  \item
    \texttt{my-vue-portlet-bundle}

    \begin{itemize}
    \tightlist
    \item
      \texttt{assets/} → CSS and resources

      \begin{itemize}
      \tightlist
      \item
        \texttt{css/} → CSS not included in \texttt{.vue} files.
      \end{itemize}
    \item
      \texttt{features/} → Liferay DXP bundle features

      \begin{itemize}
      \tightlist
      \item
        \texttt{localization/} → Resource bundles

        \begin{itemize}
        \tightlist
        \item
          \texttt{Language.properties} → Default language keys
        \end{itemize}
      \item
        \texttt{settings.json} → Placeholder System Settings
      \end{itemize}
    \item
      \texttt{src/} → JavaScript and Vue files

      \begin{itemize}
      \tightlist
      \item
        \texttt{index.js} → Main module used to initialize the portlet
      \end{itemize}
    \item
      \texttt{.babelrc} → Babel configuration
    \item
      \texttt{.npmbuildrc} → Build configuration
    \item
      \texttt{.npmbundlerrc} → Bundler configuration
    \item
      \texttt{package.json} → npm bundle configuration
    \item
      \texttt{README.md}
    \end{itemize}
  \end{itemize}
\item
  Copy your app files, matching the types listed below, into your new
  project.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 File type | Destination | Comments |
 --------- | ----------- | -------- |
 CSS  | `assets/css/` | Overwrite `styles.css`. |
 Static resources | `assets` |  Include resources such as image files here |
 VUE and JS| `src` | Merge your main component with the existing `index.js`. More info on that below. |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Update your bundle to use portlet-level styling.

  \begin{itemize}
  \item
    If you have internal CSS included with
    \texttt{\textless{}style\textgreater{}} tags in your \texttt{.vue}
    files, import \texttt{.index.css} in \texttt{/assets/styles.css}.
    This is generated by the modified build script further down:

\begin{verbatim}
@import '../index.css';
\end{verbatim}
  \item
    Import all custom CSS files (i.e.~CSS not included in \texttt{.vue}
    files) through the CSS file (default is \texttt{styles.css}) your
    bundle's \texttt{package.json} file sets for your portlet. Here's
    the default setting:

\begin{verbatim}
"portlet": {
    "com.liferay.portlet.header-portlet-css": "/css/styles.css",
...
}
\end{verbatim}
  \end{itemize}
\item
  Update any static resource references to use the \texttt{web-context}
  value declared in your project's \texttt{.npmbundlerrc} file. Here's
  the format:

\begin{verbatim}
/o/[web-context]/[resource]
\end{verbatim}

  Here's an example image resource:

\begin{verbatim}
<img alt="Vue logo" src="/o/vue-guestbook-migrated/logo.png">
\end{verbatim}
\item
  Merge your entry module with \texttt{src/index.js}, following these
  steps to dynamically load components.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Components must be loaded dynamically to attach to the portlet's
 DOM. The DOM is determined at runtime when the portlet's page is
 rendered. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
-   Use Vue's runtime + compiler module 
    (`import Vue from 'vue/dist/vue.common';`) so you don't have to process 
    templates during build time. This is imported by default at the top of 
    the file.

-   Remove the sample content from the `main()` function (i.e. the `node` 
    constant and its use), and replace it with your router code.

-   Make these updates to the `new Vue` instance:

    -   Remove the default data properties (the ones you just removed in the 
        sample content), and set the render element to `portletElementId`. 
        This is required and ensures that your app is rendered inside the 
        portlet.
    -   Add the router.
    -   Add a render function that mounts your component wrapper to the Vue 
        instance and displays it.
        
    Your updated configuration should look like this:

    ```javascript
    new Vue({
      el: `#${portletElementId}`,
      render: h => h(App),
      router
    })
    ```

Your entry module `index.js` should look like this. 

```javascript
import Vue from 'vue/dist/vue.common';
import App from './App.vue'
import VueRouter from 'vue-router'
//Component imports

export default function main({portletNamespace, contextPath, portletElementId}) {

  Vue.config.productionTip = false

  Vue.use(VueRouter)

  const router = new VueRouter({
      routes: [
          {
            ...
          }
      ]
  })
  new Vue({
    el: `#${portletElementId}`,
    render: h => h(App),
    router
  })
}
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Merge your app \texttt{package.json} file's \texttt{dependencies} and
  \texttt{devDependencies} into the project's \texttt{package.json}, and
  replace the \texttt{babel-cli} and \texttt{babel-preset-env} dev
  dependencies with the newer \texttt{"@babel/cli":\ "\^{}7.0.0"} and
  \texttt{"@babel/preset-env":\ "\^{}7.4.2"} packages instead. Also
  include the \texttt{"vueify":\ "9.4.1"} dev dependency.
\item
  Update the \texttt{.babelrc} file to use \texttt{@babel/preset-env}
  instead of \texttt{env}:

\begin{verbatim}
"presets": ["@babel/preset-env"]
\end{verbatim}
\item
  If you're using \texttt{.vue} files, replace the build script in the
  \texttt{package.json} with the one below to use
  \texttt{vue-cli-service}. The updated build script uses vue-cli to
  access the main entrypoint for the app (\texttt{index.js} in the
  example below) and combines all the Vue templates and JS files into
  one single file named \texttt{index.common.js} and generates an
  \texttt{index.css} file for any internal CSS included with
  \texttt{\textless{}style\textgreater{}} tags in \texttt{.vue} files:

\begin{verbatim}
"scripts": {
  "build": "babel --source-maps -d build src && vue-cli-service build --dest 
  build/ --formats commonjs --target lib --name index ./src/index.js && npm 
  run copy-assets && liferay-npm-bundler",
  "copy-assets": "lnbs-copy-assets",
  "deploy": "npm run build && lnbs-deploy",
  "start": "lnbs-start"
}
\end{verbatim}
\item
  Update the \texttt{main} entry of the \texttt{package.json} to match
  the new \href{http://www.commonjs.org/}{CommonJS} file name specified
  in the previous step:

\begin{verbatim}
"main": "index.common"
\end{verbatim}
\item
  Finally, deploy your portlet bundle:

\begin{verbatim}
npm run deploy
\end{verbatim}
\end{enumerate}

Congratulations! Your Vue app is deployed and now available as a widget
that you can add to site pages.

The liferay-npm-bundler confirms the deployment:

\begin{verbatim}
Report written to liferay-npm-bundler-report.html
Deployed my-vue-guestbook-1.0.0.jar to c:\git\bundles
\end{verbatim}

The Liferay DXP console confirms your bundle started:

\begin{verbatim}
2019-03-22 20:17:53.181 INFO  
[fileinstall-C:/git/bundles/osgi/modules][BundleStartStopLogger:39] 
STARTED my-vue-guestbook_1.0.0 [1695]
\end{verbatim}

Find your widget by selecting the \emph{Add} icon
(\includegraphics{./images/icon-add-app.png}) and navigating to
\emph{Widgets} and the category you specified to the Liferay Bundle
Generator (\emph{Sample} is the default category).

\section{Related Topics}\label{related-topics-2}

\href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{Web
Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}

\chapter{Liferay MVC Portlet}\label{liferay-mvc-portlet}

If you're an experienced developer, this is not the first time you've
heard about Model View Controller. If there are so many implementations
of MVC frameworks in Java, why did Liferay create yet another one? Stay
with us and you'll see that Liferay MVC Portlet provides these benefits:

\begin{itemize}
\tightlist
\item
  It's lightweight, as opposed to many other Java MVC frameworks.
\item
  There are no special configuration files that need to be kept in sync
  with your code.
\item
  It's a simple extension of
  \href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/GenericPortlet.html}{\texttt{GenericPortlet}}.
\item
  You avoid writing a bunch of boilerplate code, since Liferay's MVC
  Portlet framework only looks for some pre-defined parameters when the
  \texttt{init()} method is called.
\item
  The controller can be broken down into MVC command classes, each of
  which handles the controller code for a particular
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{portlet phase}
  (render, action, and resource serving phases).
\item
  An MVC command class can serve multiple portlets.
\item
  Liferay's portlets use it. That means there are plenty of robust
  implementations to reference when you need to design or troubleshoot
  your Liferay applications.
\end{itemize}

The Liferay MVC Portlet framework is light and easy to use. The default
\href{/docs/7-2/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{\texttt{MVCPortlet}
project} template generates a fully configured and working project.

Here, you'll learn how MVCPortlet works by covering these topics:

\begin{itemize}
\tightlist
\item
  \hyperref[mvc-layers-and-modularity]{MVC layers and modularity}
\item
  \hyperref[liferay-mvc-command-classes]{Liferay MVC command classes}
\item
  \hyperref[liferay-mvc-portlet-component]{Liferay MVC portlet
  component}
\item
  \hyperref[a-simpler-mvc-portlet]{Simple MVC portlets}
\end{itemize}

Review how each layer of the Liferay MVC portlet framework helps you
separate the concerns of your application.

\section{MVC Layers and Modularity}\label{mvc-layers-and-modularity}

In MVC, there are three layers, and you can probably guess what they
are.

\textbf{Model:} The model layer holds the application data and logic for
manipulating it.

\textbf{View:} The view layer contains logic for displaying data.

\textbf{Controller:} The middle man in the MVC pattern, the Controller
contains logic for passing the data back and forth between the view and
the model layers.

Liferay DXP's applications are divided into multiple discrete modules.
With \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}, the model layer is generated into a \texttt{service} and an
\texttt{api} module. That accounts for the model in the MVC pattern. The
view and the controller layers share a module, the \texttt{web} module.

Generating the skeleton for a
\href{/docs/7-2/reference/-/knowledge_base/r/using-the-service-builder-template}{multi-module
Service Builder-driven MVC application} saves you lots of time and gets
you started on the more important (and interesting, if we're being
honest) development work.

\section{Liferay MVC Command Classes}\label{liferay-mvc-command-classes}

In a larger application, your \texttt{-Portlet} class can become
monstrous and unwieldy if it holds all of the controller logic. Liferay
provides MVC command classes to break up your controller functionality.

\begin{itemize}
\tightlist
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}:}
  Use \texttt{-ActionCommand} classes to hold each of your portlet
  actions, which are invoked by action URLs.
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}:}
  Use \texttt{-RenderCommand} classes to hold a \texttt{render} method
  that dispatches to the appropriate JSP, by responding to render URLs.
\item
  \textbf{\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}:}
  Use \texttt{-ResourceCommand} classes to serve resources based on
  resource URLs.
\end{itemize}

There must be some confusing configuration files to keep everything
wired together and working properly, right? Wrong: it's all easily
managed in the \texttt{-Portlet} class's
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
annotation.

\section{Liferay MVC Portlet
Component}\label{liferay-mvc-portlet-component}

Whether or not you plan to split up the controller into MVC command
classes, the portlet \texttt{@Component} annotation configures the
portlet. Here's a simple portlet component as an example:

\begin{verbatim}
@Component(
    property = {
        "com.liferay.portlet.css-class-wrapper=portlet-hello-world",
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.icon=/icons/hello_world.png",
        "com.liferay.portlet.preferences-owned-by-group=true",
        "com.liferay.portlet.private-request-attributes=false",
        "com.liferay.portlet.private-session-attributes=false",
        "com.liferay.portlet.remoteable=true",
        "com.liferay.portlet.render-weight=50",
        "com.liferay.portlet.use-default-template=true",
        "javax.portlet.display-name=Hello World",
        "javax.portlet.expiration-cache=0",
        "javax.portlet.init-param.always-display-default-configuration-icons=true",
        "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=guest,power-user,user",
        "javax.portlet.supports.mime-type=text/html"
    },
    service = Portlet.class
)
public class HelloWorldPortlet extends MVCPortlet {
}
\end{verbatim}

The \texttt{javax.portlet.name} property is required. When using MVC
commands, the \texttt{javax.portlet.name} property value links
particular portlet URL/command combinations to the correct portlet.

\noindent\hrulefill

\textbf{Important:} Make your portlet name unique, considering how
\href{/docs/7-2/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map\#ten}{Liferay
DXP uses the name to create the portlet's ID}.

\noindent\hrulefill

There can be some confusion over exactly what kind of
\texttt{Portlet.class} implementation you're publishing with a
component. The service registry expects this to be the
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/Portlet.html}{\texttt{javax.portlet.Portlet}}
interface. Import that, and not, for example,
\texttt{com.liferay.portal.kernel.model.Portlet}.

\noindent\hrulefill

\textbf{Note:} The DTD
\href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-portlet-app_7_2_0.dtd.html}{liferay-portlet-app\_7\_2\_0.dtd}
defines all the Liferay-specific attributes you can specify as
properties in your portlet components.

Consider the \texttt{\textless{}css-class-wrapper\textgreater{}} element
from the above link as an example. To specify that property in your
component, use this syntax in your property list:

\texttt{"com.liferay.portlet.css-class-wrapper=portlet-hello-world",}

The properties namespaced with \texttt{javax.portlet.} are elements of
the
\href{https://docs.liferay.com/portlet-api/3.0/portlet-app_3_0.xsd}{\texttt{portlet.xml}
descriptor}.

\noindent\hrulefill

\section{A Simpler MVC Portlet}\label{a-simpler-mvc-portlet}

In simpler applications, you don't use MVC commands. Your portlet render
URLs specify JSP paths in \texttt{mvcPath} parameters.

\begin{verbatim}
<portlet:renderURL var="addEntryURL">
    <portlet:param name="mvcPath" value="/entry/edit_entry.jsp" />
    <portlet:param name="redirect" value="<%= redirect %>" />
</portlet:renderURL>
\end{verbatim}

As you've seen, Liferay's MVC Portlet framework gives you a
well-structured controller layer that takes very little time to
implement. With all your free time, you could

\begin{itemize}
\tightlist
\item
  Learn a new language
\item
  Take pottery classes
\item
  Lift weights
\item
  Work on your application's business logic
\end{itemize}

It's entirely up to you.

To get into the details of creating an MVC Portlet application, continue
with
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-an-mvc-portlet}{Creating
an MVC Portlet}.

\chapter{Creating an MVC Portlet}\label{creating-an-mvc-portlet}

Generating MVC portlet projects is a snap using Liferay's project
templates. Here you'll generate an MVC Portlet project and deploy the
portlet to Liferay DXP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate an
  \href{/docs/7-2/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{MVC
  Portlet project} using a Gradle or Maven.

  Here's the resulting folder structure for an MVC Portlet class named
  \texttt{MyMvcPortlet} in a base package
  \texttt{com.liferay.docs.mvcportlet}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{my-mvc-portlet-project} → Arbitrary project name.

    \begin{itemize}
    \tightlist
    \item
      \texttt{gradle}

      \begin{itemize}
      \tightlist
      \item
        \texttt{wrapper}

        \begin{itemize}
        \tightlist
        \item
          \texttt{gradle-wrapper.jar}
        \item
          \texttt{gradle-wrapper.properties}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{src}

      \begin{itemize}
      \tightlist
      \item
        \texttt{main}

        \begin{itemize}
        \tightlist
        \item
          \texttt{java}

          \begin{itemize}
          \tightlist
          \item
            \texttt{com/liferay/docs/mvcportlet}

            \begin{itemize}
            \tightlist
            \item
              \texttt{constants}

              \begin{itemize}
              \tightlist
              \item
                \texttt{MyMvcPortletKeys.java} → Declares portlet
                constants.
              \end{itemize}
            \item
              \texttt{portlet}

              \begin{itemize}
              \tightlist
              \item
                \texttt{MyMvcPortlet.java} → MVC Portlet class.
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \item
          \texttt{resources}

          \begin{itemize}
          \tightlist
          \item
            \texttt{content}

            \begin{itemize}
            \tightlist
            \item
              \texttt{Language.properties} → Resource bundle
            \end{itemize}
          \item
            \texttt{META-INF}

            \begin{itemize}
            \tightlist
            \item
              \texttt{resources}

              \begin{itemize}
              \tightlist
              \item
                \texttt{init.jsp} → Imports classes and taglibs and
                defines commonly used objects from the theme and the
                portlet.
              \item
                \texttt{view.jsp} → Default view template.
              \end{itemize}
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{bnd.bnd} → OSGi bundle metadata.
    \item
      \texttt{build.gradle}
    \item
      \texttt{gradlew}
    \end{itemize}
  \end{itemize}

  The Maven-generated project includes a \texttt{pom.xml} file and does
  not include the Gradle-specific files, but otherwise is exactly the
  same.

  Here's the resulting MVC Portlet class:
\end{enumerate}

\begin{verbatim}
package com.liferay.docs.mvcportlet.portlet;

import com.liferay.docs.mvcportlet.constants.MyMvcPortletKeys;
import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;
import javax.portlet.Portlet;
import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.display-name=my-mvc-portlet-project Portlet",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + MyMvcPortletKeys.MyMvc,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
public class MyMvcPortlet extends MVCPortlet {
}
\end{verbatim}

The class extends
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCPortlet.html}{\texttt{MVCPortlet}}.
The
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
annotation and \texttt{service\ =\ Portlet.class} attribute makes the
class an OSGi Declarative Services component that provides the
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/Portlet.html}{\texttt{javax.portlet.Portlet}}
service type. The \texttt{immediate\ =\ true} attribute activates the
service immediately on the portlet's deployment.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Set any portlet configuration or Liferay portlet configuration values
  using \texttt{javax.portlet.*} and \texttt{com.liferay.portlet.*}
  \texttt{@Component} annotation properties
  \href{/docs/7-2/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{\texttt{javax.portlet.*}
  and \texttt{com.liferay.portlet.*} \texttt{@Component} annotation
  properties} respectively.

  Here are the example component's properties:

  \begin{itemize}
  \item
    \texttt{"com.liferay.portlet.display-category=category.sample"}:
    Sets the Widget's category to ``Sample''.
  \item
    \texttt{"com.liferay.portlet.instanceable=true"}: Activates the
    component immediately when its bundle installs.
  \item
    \texttt{"javax.portlet.display-name=my-mvc-portlet-project\ Portlet"}:
    Sets the portlet's Widget name.
  \item
    \texttt{"javax.portlet.init-param.template-path=/"}: The path under
    \texttt{src/main/resources/META-INF/resources/} where the templates
    reside.
  \item
    \texttt{"javax.portlet.init-param.view-template=/view.jsp"}: Default
    view template.
  \item
    \texttt{"javax.portlet.name="\ +\ MyMvcPortletKeys.MyMvc}: The
    portlet's unique identity.
  \item
    \texttt{"javax.portlet.resource-bundle=content.Language"}: Sets the
    portlet's
    \href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{resource
    bundle} to the \texttt{content/Language*.properties} file(s) in the
    \texttt{src/main/resources/} folder.
  \item
    \texttt{"javax.portlet.security-role-ref=power-user,user"}: Makes
    the Liferay DXP virtual instance's power user and user Roles
    available for defining the portlet's permissions.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** To opt-in to Portlet 3.0 features, set the component property
 `"javax.portlet.version=3.0"`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  The portlet renders content via the view template
  \texttt{src/main/resources/META-INF/resources/view.jsp} by default.
\item
  Build your project.

  \emph{Gradle:}

\begin{verbatim}
gradlew jar
\end{verbatim}

  \emph{Maven:}

\begin{verbatim}
mvn clean package
\end{verbatim}
\item
  Deploy the project
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{using
  your build environment} or by building the project JAR and copying it
  to the \texttt{deploy/} folder in your
  \href{/docs/7-2/deploy/-/knowledge_base/d/liferay-home}{Liferay Home}.
\end{enumerate}

The MVC Portlet is now available in the Liferay DXP UI, in the Widget
category you assigned it.

\begin{figure}
\centering
\includegraphics{./images/default-mvc-portlet-on-page.png}
\caption{The example portlet shows a message defined by the language
property \texttt{yourmvc.caption=Hello\ from\ YourMVC!} in the
Language.properties file.}
\end{figure}

Congratulations on creating and deploying an MVC Portlet!

\section{Related Topics}\label{related-topics-3}

\href{/docs/7-2/appdev/-/knowledge_base/a/writing-mvc-portlet-controller-code}{Writing
MVC Portlet Controller Code}

\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configuring
the View Layer}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command}

\chapter{Writing MVC Portlet Controller
Code}\label{writing-mvc-portlet-controller-code}

In MVC, your controller is a traffic director: it provides data to the
right front-end view for display to the user, and it takes data the user
entered in the front-end and passes it to the right back-end service.
For this reason, the controller must process requests from the
front-end, and it must determine the right front-end view to pass data
back to the user.

If you have a small application that's not heavy on controller logic,
you can put all your controller code in the \texttt{-Portlet} class. If
you have more complex needs (lots of actions, complex render logic to
implement, or maybe even some resource serving code), consider breaking
the controller into
\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command classes},
\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command classes}, and
\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command classes}. Here you'll implement controller logic for
small applications, where all the controller code is in the
\texttt{-Portlet} class. It involves these things:

\begin{itemize}
\tightlist
\item
  Action methods
\item
  Render logic
\item
  Setting and retrieving request parameters and attributes
\end{itemize}

Start with creating action methods.

\section{Action Methods}\label{action-methods}

Your portlet class can act as your controller by itself and process
requests using action methods. Here's a sample action method:

\begin{verbatim}
public void addGuestbook(ActionRequest request, ActionResponse response)
        throws PortalException, SystemException {

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
        Guestbook.class.getName(), request);

    String name = ParamUtil.getString(request, "name");

    try {
        _guestbookService.addGuestbook(serviceContext.getUserId(),
                name, serviceContext);

        SessionMessages.add(request, "guestbookAdded");

    } catch (Exception e) {
        SessionErrors.add(request, e.getClass().getName());

        response.setRenderParameter("mvcPath",
            "/html/guestbook/edit_guestbook.jsp");
    }

}
\end{verbatim}

This action method has one job: call a service to add a guestbook. If
the call succeeds, the message \texttt{"guestbookAdded"} is associated
with the request and added to the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionMessages.html}{\texttt{SessionMessages}
object}. If an exception is thrown, it's caught, and the class name is
associated with the request and added to the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/SessionErrors.html}{\texttt{SessionErrors}
object}, and the response is set to render \texttt{edit\_guestbook.jsp}.
Setting the \texttt{mvcPath} render parameter is a Liferay
\texttt{MVCPortlet} framework convention that denotes the next view to
render to the user.

While action methods respond to user actions, render logic determines
the view to display to the user. Render logic is next.

\section{Render Logic}\label{render-logic}

Here's how MVC Portlet determines which view to render. Note the
\texttt{init-param} properties you set in your component:

\begin{verbatim}
"javax.portlet.init-param.template-path=/",
"javax.portlet.init-param.view-template=/view.jsp",
\end{verbatim}

The \texttt{template-path} property tells the MVC framework where your
JSP files live. In the above example, \texttt{/} means that the JSP
files are in your project's root \texttt{resources} folder. That's why
it's important to follow Liferay's standard folder structure. The
\texttt{view-template} property directs the default rendering to
\texttt{view.jsp}.

Here's the path of a hypothetical Web module's resource folder:

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources
\end{verbatim}

Based on that resource folder, the \texttt{view.jsp} file is found at

\begin{verbatim}
docs.liferaymvc.web/src/main/resources/META-INF/resources/view.jsp
\end{verbatim}

and that's the application's default view. When the portlet's
\texttt{init} method (e.g., your portlet's override of
\texttt{MVCPortlet.init()}) is called, Liferay reads the initialization
parameters you specify and directs rendering to the default JSP.
Throughout the controller, you can render different views (JSP files) by
setting the render parameter \texttt{mvcPath} like this:

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

You can avoid render logic by using initialization parameters and render
parameters, but most of the time you'll override the portlet's
\texttt{render} method. Here's an example:

\begin{verbatim}
@Override
public void render(RenderRequest renderRequest,
        RenderResponse renderResponse) throws PortletException, IOException {

    try {
        ServiceContext serviceContext = ServiceContextFactory.getInstance(
                Guestbook.class.getName(), renderRequest);

        long groupId = serviceContext.getScopeGroupId();

        long guestbookId = ParamUtil.getLong(renderRequest, "guestbookId");

        List<Guestbook> guestbooks = _guestbookService
                .getGuestbooks(groupId);

        if (guestbooks.size() == 0) {
            Guestbook guestbook = _guestbookService.addGuestbook(
                    serviceContext.getUserId(), "Main", serviceContext);

            guestbookId = guestbook.getGuestbookId();

        }

        if (!(guestbookId > 0)) {
            guestbookId = guestbooks.get(0).getGuestbookId();
        }

        renderRequest.setAttribute("guestbookId", guestbookId);

    } catch (Exception e) {

        throw new PortletException(e);
    }

    super.render(renderRequest, renderResponse);

}
\end{verbatim}

This render logic provides the view layer with data to display to the
user. The \texttt{render} method above sets the render request attribute
\texttt{guestbookId} with the ID of a guestbook to display. If
guestbooks exist, it chooses the first. Otherwise, it creates a
guestbook and sets it to display. Lastly the method passes the render
request and render response objects to the base class via its
\texttt{render} method.

\noindent\hrulefill

\textbf{Note:} Are you wondering how to call
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder services} in 7.0? In short, obtain a reference to the service by
annotating one of your fields of that service type with the
\texttt{@Reference}
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services} annotation.

\texttt{@Reference\ \ private\ GuestbookService\ \_guestbookService;}

Once done, you can call the service's methods.

\texttt{\_guestbookService.addGuestbook(serviceContext.getUserId(),\ "Main",\ \ \ \ \ \ \ \ \ \ serviceContext);}

\noindent\hrulefill

Before venturing into the view layer, the next section demonstrates ways
to pass information between the controller and view layers.

\section{Setting and Retrieving Request and Response Parameters and
Attributes}\label{setting-and-retrieving-request-and-response-parameters-and-attributes}

A handy utility class called
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
facilitates retrieving parameters from an
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/ActionRequest.html}{\texttt{ActionRequest}}
or a
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/RenderRequest.html}{\texttt{RenderRequest}}.

For example, this JSP passes a parameter named \texttt{guestbookId} in
an action URL.

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="guestbookId" 
            value="<%= String.valueOf(entry.getGuestbookId()) %>" />
</portlet:actionURL>
\end{verbatim}

The \texttt{\textless{}portlet:actionURL\textgreater{}} tag's
\texttt{name} attribute maps the action URL to a controller action
method named \texttt{doSomething}. Triggering an action URL invokes the
corresponding method in the controller.

The controller's \texttt{doSomething} method referenced in this example
gets the \texttt{guestbookId} parameter value from the
\texttt{ActionRequest}.

\begin{verbatim}
long guestbookId = ParamUtil.getLong(actionRequest, "guestbookId");
\end{verbatim}

To pass information back to the view layer, the controller code can set
render parameters on response objects.

\begin{verbatim}
actionResponse.setRenderParameter("mvcPath", "/error.jsp");
\end{verbatim}

The code above sets a parameter called \texttt{mvcPath} to JSP path
\texttt{/error.jsp}. This causes the controller's render method to
redirect the user to that JSP.

Your controller class can also set attributes into response objects
using the \texttt{setAttribute} method.

\begin{verbatim}
renderResponse.setAttribute("guestbookId", guestbookId);
\end{verbatim}

JSPs can use Java code in scriptlets to interact with the request
object.

\begin{verbatim}
<%
    long guestbookId = Long.valueOf((Long) renderRequest
            .getAttribute("guestbookId"));
%>
\end{verbatim}

Passing information back and forth from your view and controller is
important, but there's more to the view layer than that. The view layer
is up next.

\section{Related Topics}\label{related-topics-4}

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configuring
the View Layer}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command}

\chapter{Configuring the View Layer}\label{configuring-the-view-layer}

This section briefly covers how to get your view layer working, from
organizing your imports in one JSP file, to creating URLs that direct
processing to methods in your portlet class.

\noindent\hrulefill

Note: As you create JSPs, you can
\href{/docs/7-1/tutorials/-/knowledge_base/t/applying-clay-styles-to-your-app}{apply
Clay styles to your app to match Liferay's apps}.

\noindent\hrulefill

\section{Using the init.jsp}\label{using-the-init.jsp}

Liferay's practice puts all Java imports, tag library declarations, and
variable initializations into a JSP called \texttt{init.jsp}. If you use
\href{/docs/7-1/tutorials/-/knowledge_base/t/blade-cli}{Blade CLI} or
\href{/docs/7-1/tutorials/-/knowledge_base/t/liferay-ide}{Liferay Dev
Studio DXP} to create a module based on the \texttt{mvc-portlet} project
template, these taglib declarations and initializations are added
automatically to your \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%@ taglib uri="http://java.sun.com/portlet_2_0" prefix="portlet" %>

<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
<%@ taglib uri="http://liferay.com/tld/portlet" prefix="liferay-portlet" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %>

<liferay-theme:defineObjects />

<portlet:defineObjects />
\end{verbatim}

Here are the tag libraries it gives you:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/c/tld-frame.html}{\texttt{c}}:
  JSTL core tags.
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/portlet/tld-frame.html}{\texttt{portlet}}:
  Standard portlet component tags.
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/aui/tld-summary.html}{\texttt{aui}}:
  \href{https://alloyui.com/}{AlloyUI} component tags.
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/liferay-portlet/tld-frame.html}{\texttt{liferay-portlet}}:
  Liferay portlet component tags.
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/liferay-theme/tld-frame.html}{\texttt{liferay-theme}}:
  Liferay theme component tags.
\item
  \href{https://docs.liferay.com/ce/portal/7.2-latest/taglibs/util-taglib/liferay-ui/tld-frame.html}{\texttt{liferay-ui}}:
  Liferay UI component tags.
\end{itemize}

These tags make portlet and Liferay objects available:

\begin{itemize}
\item
  \texttt{\textless{}portlet:defineObjects\ /\textgreater{}}: Implicit
  Java variables that reference Portlet API objects. The objects
  available are limited to those available in the current portlet
  request. For details, see the \texttt{defineObjects} tag in
  \href{https://jcp.org/en/jsr/detail?id=286}{JSR-286}.
\item
  \texttt{\textless{}liferay-theme:defineObjects\ /\textgreater{}}:
  Implicit Java variables that reference Liferay objects.
\end{itemize}

To use all that the \texttt{init.jsp} has, include it in your other
JSPs:

\begin{verbatim}
<%@include file="/html/init.jsp"%>
\end{verbatim}

A JSP uses render URLs to display other pages and action URLs to invoke
controller methods.

\section{Using Render URLs}\label{using-render-urls}

A render URL attached to a UI component action displays another page.
For example, this render URL displays the JSP \texttt{/path/to/foo.jsp}.

\begin{verbatim}
<portlet:renderURL var="adminURL">
    <portlet:param name="mvcPath" value="/path/to/foo.jsp" />
</portlet:renderURL>
\end{verbatim}

Here's how to use a render URL:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/renderURL.html}{\texttt{\textless{}portlet:renderURL\textgreater{}}}
  to your JSP.
\item
  Name the render URL via a \texttt{var} attribute in the
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag. The
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag constructs the
  URL and assigns it to the variable. For example, this render URL is
  assigned to the variable named \texttt{adminURL}:

\begin{verbatim}
<portlet:renderURL var="adminURL">
   ...
</portlet:renderURL>
\end{verbatim}
\item
  As sub-element to the
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag, add a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/param.html}{\texttt{\textless{}portlet:param\textgreater{}}}
  tag with the following attributes:

  \texttt{name="mvcPath"}: Your controller's \texttt{render} method
  forwards processing to the JSP at the path specified in the
  \texttt{value}.

  \texttt{value="/path/to/foo.jsp"}: The path to the JSP to render.
  Replace the value \texttt{/path/to/foo.jsp} with your JSP path.

\begin{verbatim}
<portlet:renderURL var="adminURL">
    <portlet:param name="mvcPath" value="/path/to/foo.jsp" />
</portlet:renderURL>
\end{verbatim}
\item
  To invoke the render URL, assign its variable (\texttt{var}) to a UI
  component action, such as a button or navigation bar item action.
\end{enumerate}

Invoking the UI component causes the controller's render method to
display the \texttt{mvcPath} parameter's JSP.

\section{Using Action URLs}\label{using-action-urls}

Action methods are different because they invoke an action (i.e., code),
rather than link to another page. For example, this action URL invokes a
controller method called \texttt{doSomething} and passes a parameter
called \texttt{redirect}. The \texttt{redirect} parameter contains the
path of the JSP to render after invoking the action:

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="redirect" value="<%= redirect %>" />
</portlet:actionURL>
\end{verbatim}

Here's how to use an action URL:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/actionURL.html}{\texttt{\textless{}portlet:actionURL\textgreater{}}}
  to your JSP.
\item
  Add a \texttt{name} and \texttt{var} attribute to the
  \texttt{\textless{}portlet:actionURL\textgreater{}}. The
  \texttt{\textless{}portlet:actionURL\textgreater{}} tag constructs the
  URL and assigns it to the \texttt{var} variable.

  \texttt{name}: Controller action to invoke.

  \texttt{var}: Variable to assign the action URL to.

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
   ...
</portlet:actionURL>
\end{verbatim}
\item
  As sub-element to the
  \texttt{\textless{}portlet:actionURL\textgreater{}} tag, add a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/param.html}{\texttt{\textless{}portlet:param\textgreater{}}}
  tag that has the following attributes:

  \texttt{name="redirect"}: Tells the portlet to redirect to the JSP
  associated with this parameter.

  \texttt{value="/path/to/foo.jsp"}: Redirects the user to this JSP path
  after invoking the action. Replace the value \texttt{/path/to/bar.jsp}
  with your JSP path.

\begin{verbatim}
<portlet:actionURL name="doSomething" var="doSomethingURL">
    <portlet:param name="redirect" value="/path/to/bar.jsp" />
</portlet:actionURL>
\end{verbatim}
\item
  To invoke the action URL, assign its variable (\texttt{var}) to a UI
  component action, such as a button or navigation bar item action.
\end{enumerate}

Congratulations! Your portlet is ready for action.

These simple examples demonstrate how Liferay MVC Portlet facilitates
communication between a smaller application's view layer and controller.

\section{Related Topics}\label{related-topics-5}

\href{/docs/7-2/appdev/-/knowledge_base/a/writing-mvc-portlet-controller-code}{Writing
MVC Portlet Controller Code}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-2/reference/-/knowledge_base/r/front-end-taglibs}{Front-end
Taglibs}

\href{https://portal.liferay.dev/docs/7-2/reference/-/knowledge_base/r/liferay-javascript-apis}{Liferay
JavaScript APIs}

\chapter{MVC Action Command}\label{mvc-action-command}

Liferay's MVC Portlet framework enables you to handle
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{MVCPortlet}
\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer\#using-action-urls}{actions}
in separate classes. This facilitates managing action logic in portlets
that have many actions. Each action URL in your portlet's JSPs invokes
an appropriate action command class.

Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configure
  your JSPs} to use action URLs via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/actionURL.html}{\texttt{\textless{}portlet:actionURL\textgreater{}}}
  tags. For example, the
  \href{https://github.com/liferay/liferay-blade-samples/blob/7.1/gradle/apps/action-command-portlet/src/main/resources/META-INF/resources/view.jsp}{action-command-portlet}
  sample uses this action URL:

\begin{verbatim}
<liferay-portlet:actionURL name="greet" var="greetURL" />
\end{verbatim}

  Name the action URL via its \texttt{name} attribute. Your
  \texttt{*MVCActionCommand} class maps to this name. Assign the
  \texttt{var} attribute a variable name.
\item
  Assign the action URL variable (\texttt{var}) to a UI component.
  Acting on the UI component invokes the action. For example, the
  sample's \texttt{greetURL} action URL variable triggers on submitting
  this form:

\begin{verbatim}
<aui:form action="<%= greetURL %>" method="post" name="fm">
    <aui:input name="name" type="text" />

    <aui:button-row>
        <aui:button type="submit"></aui:button>
    </aui:button-row>
</aui:form>
\end{verbatim}
\item
  Create a class that implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}
  interface, or that extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}}
  class. The latter may save you time, since it already implements
  \texttt{MVCActionCommand}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Tip:** Naming your `*MVCActionCommand` class after the action it 
 performs makes the action mappings more obvious for maintaining the code.
 For example, if your action class edits some kind of entry, you could name
 its class `EditEntryMVCActionCommand`. If your application has several MVC
 command classes, naming them this way helps differentiate them. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Annotate your class with an
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
  annotation, like this one:

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/action/url"
    },
    service = MVCActionCommand.class
)
\end{verbatim}
\item
  Set a \texttt{javax.portlet.name} property to your portlet's internal
  ID.

  Note, you can apply MVC Command classes to multiple portlets by
  setting a \texttt{javax.portlet.name} property for each portlet. For
  example, the \texttt{javax.portlet.name} properties in this component
  apply it to three specific portlets.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_ADMIN,
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS_AGGREGATOR,
        "mvc.command.name=/blogs/edit_entry"
    },
    service = MVCActionCommand.class
)
public class EditEntryMVCActionCommand extends BaseMVCActionCommand {
    ...
}
\end{verbatim}
\item
  Set the \texttt{mvc.command.name} property to your
  \texttt{\textless{}portlet:actionURL\textgreater{}} tag's
  \texttt{name}. This maps your class to the action URL of the same
  name.
\item
  Register your class as an \texttt{MVCActionCommand} service by setting
  the \texttt{service} attribute to \texttt{MVCActionCommand.class}.
\item
  Implement your action logic by overriding the appropriate method of
  the class you're implementing or extending.

  \begin{itemize}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCActionCommand.html}{\texttt{MVCActionCommand}}
    implementations override the \texttt{processAction} method.
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCActionCommand.html}{\texttt{BaseMVCActionCommand}}
    extensions override the \texttt{doProcessAction} method.
  \end{itemize}

  Here's an example of overriding \texttt{MVCActionCommand}'s
  \texttt{processAction} method. This action logic gets the name
  parameter from the \texttt{ActionRequest} and adds it to the session
  messages and to an \texttt{ActionRequest} attribute.

\begin{verbatim}
@Override
public boolean processAction(
        ActionRequest actionRequest, ActionResponse actionResponse)
    throws PortletException {

    _handleActionCommand(actionRequest);

    return true;
}

private void _handleActionCommand(ActionRequest actionRequest) {
    String name = ParamUtil.get(actionRequest, "name", StringPool.BLANK);

    if (_log.isInfoEnabled()) {
        _log.info("Hello " + name);
    }

    String greetingMessage = "Hello " + name + "! Welcome to OSGi";

    actionRequest.setAttribute("GREETER_MESSAGE", greetingMessage);

    SessionMessages.add(actionRequest, "greetingMessage", greetingMessage);
}

private static final Log _log = LogFactoryUtil.getLog(
    GreeterActionCommand.class);
\end{verbatim}
\end{enumerate}

Congratulations! You've created an \texttt{MVCActionCommand} that
handles your portlet actions.

\section{Related Topics}\label{related-topics-6}

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configuring
the View Layer}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-liferay-mvc-commands}{MVC
Command Overrides}

\chapter{MVC Render Command}\label{mvc-render-command}

\texttt{MVCRenderCommand}s are classes that respond to
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{MVCPortlet}
\href{/docs/7-2/appdev/-/knowledge_base/a/writing-mvc-portlet-controller-code\#render-logic}{render
URLs}. If your render logic is simple and you want to implement all of
your render logic in your portlet class, see
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Writing
MVC Portlet Controller Code}. If your render logic is complex or you
want clean separation between render paths, use
\texttt{MVCRenderCommand}s. Each render URL in your portlet's JSPs
invokes an appropriate render command class.

Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configure
  your JSPs} to generate render URLs via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/renderURL.html}{\texttt{\textless{}portlet:renderURL\textgreater{}}}
  tags.

  For example, this
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/render-command-portlet}{render-command-portlet}
  sample render URL invokes an MVC render command named
  \texttt{/blade/render}.

\begin{verbatim}
<portlet:renderURL var="bladeRender">
    <portlet:param name="mvcRenderCommandName" value="/blade/render" />
</portlet:renderURL>
\end{verbatim}
\item
  Name the render URL via its
  \texttt{\textless{}portlet:param\textgreater{}} named
  \texttt{mvcRenderCommandName}. The render URL and
  \texttt{*MVCRenderCommand} class (demonstrated later) map to the
  \texttt{mvcRenderCommandName} value.
\item
  Assign the \texttt{\textless{}portlet:renderURL\textgreater{}}'s
  \texttt{var} attribute a variable name to pass to a UI component.
\item
  Assign the render URL variable (\texttt{var}) to a UI component. When
  the user triggers the UI component, the \texttt{*MVCRenderCommand}
  class that matches the render URL handles the render request.

  For example, the render URL with the variable \texttt{bladeRender}
  triggers on users clicking this button.

\begin{verbatim}
<aui:button href="<%= bladeRender %>" value="goto page render" />
\end{verbatim}
\item
  Create a class that implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}
  interface.
\item
  Annotate the class with an
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
  annotation, like this one:

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=com_liferay_blade_samples_portlet_rendercommand_BladeRenderPortlet",
        "mvc.command.name=/blade/render"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}
\item
  Set a \texttt{javax.portlet.name} property to your portlet's internal
  ID.
\item
  Set a \texttt{mvc.command.name} property to your
  \texttt{\textless{}portlet:renderURL\textgreater{}} tag
  \texttt{mvcRenderCommandName} portlet parameter value. This maps your
  class to the render URL.
\item
  Register your class as an \texttt{MVCRenderCommand} service by setting
  the \texttt{service} attribute to \texttt{MVCRenderCommand.class}.

  Note, you can apply MVC Command classes to multiple portlets by
  setting a \texttt{javax.portlet.name} property for each portlet and
  apply MVC Command classes to multiple command names by setting an
  \texttt{mvc.command.name} property for each command name. For example,
  this component's \texttt{javax.portlet.name} properties and
  \texttt{mvc.command.name} properties apply it to two specific portlets
  and two specific command names.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_MY_WORLD,
       "javax.portlet.name=" + HelloWorldPortletKeys.HELLO_WORLD,
       "mvc.command.name=/hello/edit_super_entry",
       "mvc.command.name=/hello/edit_entry"
    },
    service = MVCRenderCommand.class
)
\end{verbatim}
\item
  Implement your render logic in a method that overrides
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCRenderCommand.html}{\texttt{MVCRenderCommand}}'s
  \texttt{render} method. Some \texttt{*MVCRenderCommand}s, such as the
  one below, always render the same JSP.

\begin{verbatim}
public class BlogsViewMVCRenderCommand implements MVCRenderCommand {

    @Override
    public String render(
        RenderRequest renderRequest, RenderResponse renderResponse) {

        return "/blogs/view.jsp";
    }

}
\end{verbatim}
\end{enumerate}

As you can see, MVC render commands are easy to implement and can
respond to multiple command names for multiple portlets.

\section{Related Topics}\label{related-topics-7}

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configuring
the View Layer}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-resource-command}{MVC
Resource Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-liferay-mvc-commands}{MVC
Command Overrides}

\chapter{MVC Resource Command}\label{mvc-resource-command}

When using Liferay's
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{MVCPortlet
framework}, you can create resource URLs in your JSPs to retrieve
images, XML, or any other kind of resource from a Liferay DXP instance.
The resource URL then invokes the corresponding MVC resource command
class (\texttt{*MVCResourceCommand}) that processes the resource request
and response.

Here how to create your own MVC Resource Command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configure
  your JSPs} to generate resource URLs via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/portlet/resourceURL.html}{\texttt{\textless{}portlet:resourceURL\textgreater{}}}
  tags.

  For example, this
  \href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/resource-command-portlet}{resource-command-portlet}
  sample resource URL invokes an MVC resource command named
  \texttt{/blade/captcha}.

\begin{verbatim}
<portlet:resourceURL id="/blade/captcha" var="captchaURL" />
\end{verbatim}
\item
  Name the resource URL via its \texttt{id} attribute.
\item
  Assign the resource URL's \texttt{var} attribute a variable name to
  pass to a UI component.
\item
  Assign the resource URL variable (\texttt{var}) to a UI component,
  such as a button or icon. When the user triggers the UI component, the
  \texttt{*MVCResourceCommand} class that matches the resource URL
  handles the resource request.

  For example, the sample's resource URL is triggered when the user
  clicks on this
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/taglibdocs/liferay-captcha/captcha.html}{\texttt{liferay-captcha}}
  component:

\begin{verbatim}
<liferay-captcha:captcha url="<%= captchaURL %>" />
\end{verbatim}
\item
  Create a class that implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}
  interface, or that extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCResourceCommand.html}{\texttt{BaseMVCResourceCommand}}
  class. The latter may save you time, since it already implements
  \texttt{MVCResourceCommand}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Tip:** Naming your `*MVCResourceCommand` class after the resource it 
 provides makes the resource mappings more obvious for maintaining the
 code. For example, if your resource URL serves a captcha, you could name
 its class `CaptchaMVCResourceCommand`. If your application has several MVC
 command classes, naming them this way helps differentiate them. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  Annotate your class with an
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
  annotation, like this one:

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=your_portlet_name_YourPortlet",
        "mvc.command.name=/your/jsp/resource/url"
    },
    service = MVCResourceCommand.class
)
public class YourMVCResourceCommand extends BaseMVCResourceCommand {
    // your resource handling code
}
\end{verbatim}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    Set a \texttt{javax.portlet.name} property to your portlet's
    internal ID.
  \item
    Set the \texttt{mvc.command.name} property to your
    \texttt{\textless{}portlet:resourceURL\textgreater{}} tag's
    \texttt{id}. This maps your class to the resource URL of the same
    name.
  \item
    Register your class as an \texttt{MVCResourceCommand} service by
    setting the \texttt{service} attribute to
    \texttt{MVCResourceCommand.class}.
  \end{enumerate}
\item
  Implement your resource logic by overriding the appropriate method of
  the class you're implementing or extending.

  \begin{itemize}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/MVCResourceCommand.html}{\texttt{MVCResourceCommand}}
    implementations override the \texttt{serveResource} method.
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/bridges/mvc/BaseMVCResourceCommand.html}{\texttt{BaseMVCResourceCommand}}
    extensions override the \texttt{doServeResource} method.
  \end{itemize}
\end{enumerate}

For example, the
\href{https://github.com/liferay/liferay-blade-samples/tree/7.1/gradle/apps/resource-command-portlet}{resource-command-portlet}'s
\texttt{CaptchaMVCResourceCommand} class implements the
\texttt{MVCResourceCommand} interface with only a single method:
\texttt{serveResource}.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=com_liferay_blade_samples_portlet_resourcecommand_CaptchaPortlet",
        "mvc.command.name=/blade/captcha"
    },
    service = MVCResourceCommand.class
)
public class CaptchaMVCResourceCommand implements MVCResourceCommand {

    @Override
    public boolean serveResource(
            ResourceRequest resourceRequest, ResourceResponse resourceResponse)
        throws PortletException {

        if (_log.isInfoEnabled()) {
            _log.info("get captcha resource ");
        }

        try {
            CaptchaUtil.serveImage(resourceRequest, resourceResponse);

            return false;
        }
        catch (Exception e) {
            _log.error(e.getMessage(), e);

            return true;
        }
    }

    private static final Log _log = LogFactoryUtil.getLog(
        CaptchaMVCResourceCommand.class);

}
\end{verbatim}

This \texttt{serveResource} method processes the resource request and
response via the \texttt{javax.portlet.ResourceRequest} and
\texttt{javax.portlet.ResourceResponse} parameters, respectively. Note
that the \texttt{try} block uses the helper class
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/captcha/CaptchaUtil.html}{\texttt{CaptchaUtil}}
to serve the CAPTCHA image. Though you don't have to create such a
helper class, doing so often simplifies your code.

Great! Now you know how to use \texttt{MVCResourceCommand} to process
resources in your Liferay MVC Portlets.

\section{Related Topics}\label{related-topics-8}

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-an-mvc-portlet}{Creating
an MVC Portlet}

\href{/docs/7-2/appdev/-/knowledge_base/a/configuring-the-view-layer}{Configuring
the View Layer}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-render-command}{MVC Render
Command}

\href{/docs/7-2/appdev/-/knowledge_base/a/mvc-action-command}{MVC Action
Command}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-liferay-mvc-commands}{MVC
Command Overrides}

\chapter{PortletMVC4Spring}\label{portletmvc4spring}

PortletMVC4Spring is a way to develop portlets using the Spring
Framework and the Model View Controller (MVC) pattern. While the Spring
Framework supports developing \emph{servlet-based} web applications
using
\href{https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html}{Spring
Web MVC}, PortletMVC4Spring supports developing \emph{portlet-based}
applications using MVC. You can build
\href{https://spring.io/projects/spring-framework}{Spring Framework}
Liferay DXP portlets with features like these:

\begin{itemize}
\tightlist
\item
  Inversion of control (IoC) / dependency injection (DI)
\item
  Annotations
\item
  Security
\item
  Binding and validation
\item
  Multi-part file upload
\item
  \ldots{} and more
\end{itemize}

You'll learn these things about PortletMVC4Spring:

\begin{itemize}
\item
  \textbf{Developing a Portlet Using PortletMVC4Spring:} Demonstrates
  creating and deploying a portlet using PortletMVC4Spring.
\item
  \textbf{Annotation-based Controller Development:} Shows how to
  implement controllers using plain old Java objects (POJOs) and
  annotations.
\end{itemize}

\noindent\hrulefill

\textbf{Background:} The PortletMVC4Spring project began as Spring
Portlet MVC and was part of the
\href{https://spring.io/projects/spring-framework}{Spring Framework}.
When the project was pruned from version 5.0.x of the Spring Framework
under
\href{https://github.com/spring-projects/spring-framework/issues/18701}{SPR-14129},
it became necessary to fork and rename the project. This made it
possible to improve and maintain the project for compatibility with the
latest versions of the Spring Framework and the Portlet API.

\href{http://www.liferay.com}{Liferay} adopted Spring Portlet MVC in
March of 2019 and the project was renamed to \textbf{PortletMVC4Spring}.

\noindent\hrulefill

If you're familiar with Spring Web MVC, it's helpful to compare it with
PortletMVC4Spring. Portlet workflow differs from servlet workflow
because a request to the portlet can have two distinct phases: the
\texttt{ACTION\_PHASE} and the \texttt{RENDER\_PHASE}. The
\texttt{ACTION\_PHASE} is executed only once and is where any back-end
changes or actions occur, such as making changes in a database. The
\texttt{RENDER\_PHASE} presents the portlet's content to the user each
time the display is refreshed. Thus for a single request, the
\texttt{ACTION\_PHASE} is executed only once, but the
\texttt{RENDER\_PHASE} may be executed multiple times. This provides
(and requires) a clean separation between the activities that modify the
system's persistent state and the activities that generate content. The
Portlet 2.0 Specification added two more phases: The event phase and the
resource phase, both of which are supported by annotation-driven
dispatching.

PortletMVC4Spring provides annotations that support requests from the
render, action, event, and resource serving portlet phases; Spring Web
MVC provides only a \texttt{@RequestMapping} annotation. Where a Spring
Web MVC controller might have a single handler method annotated with
\texttt{@RequestMapping}, an equivalent PortletMVC4Spring controller
might have multiple handler methods, each using one of the phase
annotations: \texttt{@ActionMapping}, \texttt{@EventMapping},
\texttt{@RenderMapping}, or \texttt{@ResourceMapping}.

The PortletMVC4Spring framework uses a \texttt{DispatcherPortlet} that
dispatches requests to handlers, with configurable handler mappings and
view resolution, just as the \texttt{DispatcherServlet} in the web
framework does.

\noindent\hrulefill

\textbf{Note:} For more information on portlets, portlet specifications,
and how portlets differ from servlets, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}.

\noindent\hrulefill

Liferay also provides full-featured sample portlets that demonstrate
using JSP and \href{https://www.thymeleaf.org}{Thymeleaf} view
templates. They exercise many features that form-based portlet
applications typically require.

\begin{figure}
\centering
\includegraphics{./images/portletmvc4spring-applicant-jsp-app.png}
\caption{This PortletMVC4Spring portlet enables users to enter job
applications. It uses the Spring features mentioned above and handles
requests from multiple portlet phases.}
\end{figure}

The samples are available here:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Source Code
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Maven Central
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\href{https://github.com/liferay/portletmvc4spring/tree/master/demo/applicant-jsp-portlet}{applicant-jsp-portlet}
&
\href{https://search.maven.org/search?q=a:com.liferay.portletmvc4spring.demo.applicant.jsp.portlet}{com.liferay.portletmvc4spring.demo.applicant.jsp.portlet.war} \\
\href{https://github.com/liferay/portletmvc4spring/tree/master/demo/applicant-thymeleaf-portlet}{applicant-thymeleaf-portlet}
&
\href{https://search.maven.org/search?q=a:com.liferay.portletmvc4spring.demo.applicant.thymeleaf.portlet}{com.liferay.portletmvc4spring.demo.applicant.thymeleaf.portlet.war} \\
\end{longtable}

\noindent\hrulefill

Now that you have a basic understanding of PortletMVC4Spring portlets
and how they compare to Spring Web MVC applications, it's time to
develop a PortletMVC4Spring portlet.

\chapter{Developing a Portlet Using
PortletMVC4Spring}\label{developing-a-portlet-using-portletmvc4spring}

PortletMVC4Spring compliments the Spring Web framework and MVC design
pattern by providing annotations that map portlet requests to Controller
classes and methods. Here you'll develop and deploy a portlet
application that uses PortletMVC4Spring, Spring, and JSP/JSPX templates.

\begin{figure}
\centering
\includegraphics{./images/portletmvc4Spring-developing.png}
\caption{The archetype's sample portlet prints a greeting (e.g.,
\emph{Hello, Joe Bloggs}) on submitting a first and last name.}
\end{figure}

Follow these steps to create and deploy your portlet application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a PortletMVC4Spring project. See
  \href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-project-anatomy}{PortletMVC4Spring
  Project Anatomy} for the project structure and commands for generating
  PortletMVC4Spring projects. Here's the Maven command for generating
  the JSP/JSPX project. This article lists sample code from the
  generated project.

\begin{verbatim}
mvn archetype:generate \
-DarchetypeGroupId=com.liferay.portletmvc4spring.archetype \
-DarchetypeArtifactId=com.liferay.portletmvc4spring.archetype.form.jsp.portlet \
-DarchetypeVersion=5.1.0 \ 
-DgroupId=com.mycompany \ 
-DartifactId=com.mycompany.my.form.jsp.portlet
\end{verbatim}
\item
  In your project's Gradle build file or Maven POM, add your app's
  dependencies. Here are the PortletMVC4Spring development dependencies:

  \textbf{Gradle:}

\begin{verbatim}
compile group: 'com.liferay.portletmvc4spring', name: 'com.liferay.portletmvc4spring.framework', version: '5.1.0'
compile group: 'com.liferay.portletmvc4spring', name: 'com.liferay.portletmvc4spring.security', version: '5.1.0'
providedCompile group: 'javax.portlet', name: 'portlet-api', version: '3.0.0'
\end{verbatim}

  \textbf{Maven:}

\begin{verbatim}
<dependency>
    <groupId>com.liferay.portletmvc4spring</groupId>
    <artifactId>com.liferay.portletmvc4spring.framework</artifactId>
    <version>5.1.0</version>
</dependency>
<dependency>
    <groupId>com.liferay.portletmvc4spring</groupId>
    <artifactId>com.liferay.portletmvc4spring.security</artifactId>
    <version>5.1.0</version>
</dependency>
<dependency>
    <groupId>javax.portlet</groupId>
    <artifactId>portlet-api</artifactId>
    <version>3.0.0</version>
    <scope>provided</scope>
</dependency>
\end{verbatim}

  At this point you can develop your Model, View, or Controller
  components, in any order.
\item
  Create your Model class(es) in a package for models (e.g.,
  \texttt{java/{[}my-package-path{]}/dto}). The sample Model class is
  \texttt{User}.

\begin{verbatim}
public class User implements Serializable {

    private static final long serialVersionUID = 1234273427623725552L;

    @NotBlank
    private String firstName;

    @NotBlank
    private String lastName;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
\end{verbatim}
\item
  Create your View using a Spring Web-supported template type. If you
  didn't generate your project using the archetype mentioned above,
  specify a View resolver for template type in your
  \texttt{spring-context/portlet-application-context.xml} portlet
  application context. (See
  \href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-configuration-files}{PortletMVC4Spring
  Configuration Files} for details).

  The sample \texttt{user.jspx} template renders a form for submitting a
  user's first and last name.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"
          xmlns:portlet="http://xmlns.jcp.org/portlet_3_0"
          xmlns:spring="http://www.springframework.org/tags"
          xmlns:form="http://www.springframework.org/tags/form"
          version="2.1">
    <jsp:directive.page contentType="text/html" pageEncoding="UTF-8" />
    <portlet:defineObjects/>
    <link href="${contextPath}/resources/css/main.css" rel="stylesheet" type="text/css"/>
    <portlet:actionURL var="mainFormActionURL"/>
    <form:form id="${namespace}mainForm" action="${mainFormActionURL}" class="user-form" method="post" modelAttribute="user">
        <p class="caption">
            <spring:message code="personal-information" />
        </p>
        <fieldset>
            <div class="form-group">
                <form:label for="${namespace}firstName" path="firstName">
                    <spring:message code="first-name" />
                </form:label>
                <form:input id="${namespace}firstName" cssClass="form-control" path="firstName"/>
                <form:errors path="firstName" cssClass="portlet-msg-error"/>
            </div>
            <div class="form-group">
                <form:label for="${namespace}lastName" path="lastName">
                    <spring:message code="last-name" />
                </form:label>
                <form:input id="${namespace}lastName" cssClass="form-control" path="lastName"/>
                <form:errors path="lastName" cssClass="portlet-msg-error"/>
            </div>
        </fieldset>
        <hr />
        <spring:message code="submit" var="submit" />
        <input class="btn btn-primary" value="${submit}" type="submit"/>
    </form:form>
</jsp:root>
\end{verbatim}

  To invoke actions in your Controller, associate action URLs with your
  templates. The sample template associates the action URL variable
  \texttt{mainFormActionURL} with its form element.

\begin{verbatim}
<portlet:actionURL var="mainFormActionURL"/>
<form:form id="${namespace}mainForm" action="${mainFormActionURL}" class="user-form" method="post" modelAttribute="user">
    ...
\end{verbatim}

  A \texttt{\textless{}form:form/\textgreater{}} element's
  \texttt{modelAttribute} attribute targets an application Model. The
  sample template targets the application's \texttt{user} Model.
\item
  Style your portlet by adding CSS to a stylesheet (e.g.,
  \texttt{webapp/resources/css/main.css}) and linking your template to
  it.

\begin{verbatim}
<link href="${contextPath}/resources/css/main.css" rel="stylesheet" type="text/css"/>
\end{verbatim}
\item
  Define your portlet's messages in a properties file (e.g.,
  \texttt{src/main/resources/content/{[}portlet{]}.properties}). The
  sample \texttt{user.jspx} template references some of these
  properties:

\begin{verbatim}
first-name=First Name
greetings=Greetings, {0} {1}!
javax.portlet.display-name=com.mycompany.my.form.jsp.portlet
javax.portlet.keywords=com.mycompany.my.form.jsp.portlet
javax.portlet.short-title=com.mycompany.my.form.jsp.portlet
javax.portlet.title=com.mycompany.my.form.jsp.portlet
last-name=Last Name
personal-information=Personal Information
submit=Submit
todays-date-is=Today''s date is {0}
\end{verbatim}
\item
  Create a Controller class to handle portlet requests. Here's an
  example:

\begin{verbatim}
@Controller
@RequestMapping("VIEW")
public class MyController {
    ...
}
\end{verbatim}

  The
  \href{https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Controller.html}{\texttt{@Controller}}
  annotation applies the Spring Controller component stereotype. The
  Spring Framework scans Controller classes for Controller annotations.

  The
  \href{https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html}{\texttt{@RequestMapping("VIEW")}}
  annotation marks the class's public methods as request handler methods
  for the portlet's
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{VIEW mode}.
\item
  In your Controller, apply \texttt{@RenderMapping} annotations to
  methods for handling portlet render requests. Import the annotation
  \texttt{com.liferay.portletmvc4spring.bind.annotation.RenderMapping}
  and make sure each handler method returns a string that matches the
  name of a template to render. Here are the sample's render request
  handler methods:

\begin{verbatim}
@RenderMapping
public String prepareView() {
    return "user";
}

@RenderMapping(params = "javax.portlet.action=success")
public String showGreeting(ModelMap modelMap) {

    DateFormat dateFormat = new SimpleDateFormat("EEEE, MMMM d, yyyy G");

    Calendar todayCalendar = Calendar.getInstance();

    modelMap.put("todaysDate", dateFormat.format(todayCalendar.getTime()));

    return "greeting";
}
\end{verbatim}

  The \texttt{@RenderMapping} annotation causes the \texttt{prepareView}
  method above to be invoked if no other handler methods match the
  request. \texttt{prepareView} renders the \texttt{user} template
  (i.e., \texttt{user.jspx}).

  The \texttt{@RenderMapping(params\ =\ "javax.portlet.action=success")}
  annotation causes the \texttt{showGreeting} method to be invoked if
  the render request has the parameter setting
  \texttt{javax.portlet.action=success}. \texttt{showGreeting} renders
  the \texttt{greeting} template (i.e., \texttt{greeting.jspx}).
\item
  In your Controller, apply \texttt{@ActionMapping} annotations to your
  portlet action request handling methods. Import the annotation
  \texttt{com.liferay.portletmvc4spring.bind.annotation.ActionMapping}.

  The sample Controller's action handler method below is annotated with
  \texttt{@ActionMapping}, making it the default action handler if no
  other action handlers match the request. Since this portlet only has
  one action handler, the \texttt{submitApplicant} method handles all of
  the portlet's action requests.

\begin{verbatim}
@ActionMapping
public void submitApplicant(@ModelAttribute("user") User user, BindingResult bindingResult, ModelMap modelMap,
                            Locale locale, ActionResponse actionResponse, SessionStatus sessionStatus) {

    localValidatorFactoryBean.validate(user, bindingResult);

    if (!bindingResult.hasErrors()) {

        if (logger.isDebugEnabled()) {
            logger.debug("firstName=" + user.getFirstName());
            logger.debug("lastName=" + user.getLastName());
        }

        MutableRenderParameters mutableRenderParameters = actionResponse.getRenderParameters();

        mutableRenderParameters.setValue("javax.portlet.action", "success");

        sessionStatus.setComplete();
    }
}
\end{verbatim}

  The
  \href{https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ModelAttribute.html}{\texttt{@ModelAttribute}}
  annotation in method parameter
  \texttt{@ModelAttribute("user")\ User\ user} associates the View's
  \texttt{user} Model (comprising a first name and last name) to the
  \texttt{User} object passed to this method.

  Note, the \texttt{submitApplicant} method sets the
  \texttt{javax.portlet.action} render parameter to
  \texttt{success}---the previous render handler method
  \texttt{showGreeting} matches this request parameter.
\item
  Configure any additional resources and beans in the project's
  descriptors and Spring context files respectively. (See
  \href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-configuration-files}{PortletMVC4Spring
  Configuration Files} for details).
\item
  Build the project WAR using Gradle or Maven.
\item
  Deploy the WAR by copying it to your
  \texttt{{[}Liferay-Home{]}/deploy} folder.
\end{enumerate}

Liferay DXP logs the deployment and the portlet is now available in the
Liferay DXP UI. Find your portlet by selecting the \emph{Add} icon
(\includegraphics{./images/icon-add-app.png}) and navigating to
\emph{Widgets} and the category you specified to the Liferay Bundle
Generator (\emph{Sample} is the default category).

Congratulations! You created and deployed a PortletMVC4Spring Portlet.

\section{Related Topics}\label{related-topics-9}

\href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-project-anatomy}{PortletMVC4Spring
Project Anatomy}

\href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-annotations}{PortletMVC4Spring
Annotations}

\href{/docs/7-2/reference/-/knowledge_base/r/portletmvc4spring-configuration-files}{PortletMVC4Spring
Configuration Files}

\href{/docs/7-2/appdev/-/knowledge_base/a/migrating-to-portletmvc4spring}{Migrating
to PortletMVC4Spring}

\chapter{Migrating to
PortletMVC4Spring}\label{migrating-to-portletmvc4spring}

To continue developing a portlet to use Spring Framework version 5.0
onward, migrate it from Spring Portlet MVC to
\href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{PortletMVC4Spring}.
Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{pom.xml} or \texttt{build.gradle} descriptor, use the
  Spring Framework version 5.1.x artifacts by replacing dependencies on
  the \texttt{spring-webmvc-portlet} artifact with the
  \texttt{com.liferay.portletmvc4spring.framework} artifact.

  Maven:

\begin{verbatim}
<dependency>
    <groupId>com.liferay.portletmvc4spring</groupId>
    <artifactId>com.liferay.portletmvc4spring.framework</artifactId>
    <version>5.1.0</version>    
</dependency>
<dependency>
    <groupId>com.liferay.portletmvc4spring</groupId>
    <artifactId>com.liferay.portletmvc4spring.security</artifactId>
    <version>5.1.0</version>    
</dependency>
\end{verbatim}

  Gradle:

\begin{verbatim}
compile group: 'com.liferay.portletmvc4spring', name: 'com.liferay.portletmvc4spring.framework', version: '5.1.0'
compile group: 'com.liferay.portletmvc4spring', name: 'com.liferay.portletmvc4spring.security', version: '5.1.0'
\end{verbatim}
\item
  In your \texttt{WEB-INF/portlet.xml} descriptor, replace uses of
  \texttt{org.springframework.web.portlet.DispatcherPortlet} with
  \href{https://liferay.github.io/portletmvc4spring/apidocs/com/liferay/portletmvc4spring/DispatcherPortlet.html}{\texttt{com.liferay.portletmvc4spring.DispatcherPortlet}}.
\item
  Replace uses of the Spring Portlet MVC
  \href{https://docs.spring.io/spring-framework/docs/4.3.4.RELEASE/javadoc-api/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.html}{\texttt{AnnotationMethodHandlerAdapter}}
  class with the PortletMVC4Spring
  \href{https://liferay.github.io/portletmvc4spring/apidocs/com/liferay/portletmvc4spring/mvc/method/annotation/PortletRequestMappingHandlerAdapter.html}{\texttt{PortletRequestMappingHandlerAdapter}}
  class. \texttt{PortletRequestMappingHandlerAdapter} uses the
  \texttt{HandlerMethod} infrastructure that
  \href{https://docs.spring.io/spring/docs/5.1.x/spring-framework-reference/web.html\#spring-web}{Spring
  Web MVC 5.1.x} is based on.
\item
  If you specified \texttt{AnnotationMethodHandlerAdapter} as a
  \texttt{\textless{}bean\textgreater{}} in a Spring configuration
  descriptor, replace its fully-qualified class name
  \texttt{org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter}
  with
  \texttt{com.liferay.portletmvc4spring.mvc.method.annotation.PortletRequestMappingHandlerAdapter}.

  Also address these bean property changes:

  \begin{itemize}
  \item
    \href{https://docs.spring.io/spring-framework/docs/4.3.4.RELEASE/javadoc-api/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.html\#setCustomModelAndViewResolver-org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver-}{\texttt{customModelAndViewResolver}}
    (no longer available)
  \item
    \href{https://docs.spring.io/spring-framework/docs/4.3.4.RELEASE/javadoc-api/org/springframework/web/portlet/mvc/annotation/AnnotationMethodHandlerAdapter.html\#setCustomArgumentResolver-org.springframework.web.bind.support.WebArgumentResolver-}{\texttt{customArgumentResolver}}
    (no longer available)
  \item
    \href{https://liferay.github.io/portletmvc4spring/apidocs/com/liferay/portletmvc4spring/mvc/method/annotation/PortletRequestMappingHandlerAdapter.html\#setCustomArgumentResolvers-java.util.List-}{\texttt{customArgumentResolvers}}
    (specify a list of
    \href{https://docs.spring.io/spring/docs/5.1.4.RELEASE/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html}{\texttt{HandlerMethodArgumentResolver}}
    instead of a list of
    \href{https://docs.spring.io/spring-framework/docs/4.3.4.RELEASE/javadoc-api/org/springframework/web/bind/support/WebArgumentResolver.html}{\texttt{WebArgumentResolver}})
  \end{itemize}
\item
  If you're using
  \href{https://commons.apache.org/proper/commons-fileupload/}{Apache
  Commons Fileupload}, update your Spring configuration descriptor:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    Replace this legacy bean:

\begin{verbatim}
<bean id="portletMultipartResolver"
    class="org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver" />
\end{verbatim}

    With this new one from PortletMVC4Spring:

\begin{verbatim}
<bean id="portletMultipartResolver"
    class="com.liferay.portletmvc4spring.multipart.CommonsPortletMultipartResolver" />
\end{verbatim}
  \end{enumerate}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
     **Note:** Alternatively, you can use the native Portlet 3.0 file upload
     support that PortletMVC4Spring provides by setting the
     `portletMultipartResolver` `<bean>` element's `class` to
     `com.liferay.portletmvc4spring.multipart.StandardPortletMultipartResolver`
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
2.  Remove these dependencies from your `pom.xml` or `build.gradle` 
    descriptor:

    ```xml
    <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
    </dependency>
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
    </dependency>
    ```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Throughout your project, replace all uses of the
  \texttt{org.springframework.web.portlet} package path with
  \texttt{com.liferay.portletmvc4spring}.
\item
  Continue
  \href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-portlet-using-portletmvc4spring}{developing
  your portlet using PortletMVC4Spring}.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Build
  and deploy your project}.
\end{enumerate}

Congratulations! You migrated your project from Spring Portlet MVC to
PortletMVC4Spring.

\section{Related Topics}\label{related-topics-10}

\href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{PortletMVC4Spring}

\href{/docs/7-2/appdev/-/knowledge_base/a/developing-a-portlet-using-portletmvc4spring}{Developing
a Portlet Using PortletMVC4Spring}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\chapter{JSF Portlet}\label{jsf-portlet}

Do you want to develop MVC-based portlets using the Java EE standard? Do
you want to use a portlet development framework with a UI component
model that makes it easy to develop sophisticated, rich UIs? Or have you
been writing web apps using JSF that you'd like to use in Liferay DXP?
If you answered \emph{yes} to any of these questions, you're in luck!
You can use the JSF portlet technology in Liferay DXP by leveraging the
Liferay Faces project, which provides all these capabilities and more.

Liferay Faces is an umbrella project that provides support for the
JavaServer™ Faces (JSF) standard in Liferay DXP. It encompasses the
following projects:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
  Faces Bridge} lets you deploy JSF web apps as portlets without writing
  portlet-specific Java code. It also contains innovative features that
  make it possible to leverage the power of JSF 2.x inside a portlet
  application. Liferay Faces Bridge implements the JSR 329/378 Portlet
  Bridge Standard.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-faces-alloy}{Liferay
  Faces Alloy} lets you use AlloyUI components in a way that is
  consistent with JSF development.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-faces-portal}{Liferay
  Faces Portal} lets you leverage Liferay-specific utilities and UI
  components in JSF portlets.
\end{itemize}

For a comprehensive demo for the JSF component suite, visit the
\href{https://faces.liferay.dev}{Liferay Faces Developer site}.

If you're new to JSF, you may want to know its strengths, its
weaknesses, and how it stacks up to developing portlets with
CSS/JavaScript.

Here are some good reasons to use JSF and Liferay Faces:

\begin{itemize}
\tightlist
\item
  JSF is the Java EE standard for developing web applications that use
  the Model/View/Controller (MVC) design pattern. As a standard, the
  specification is actively maintained by the Java Community Process
  (JCP), and the Oracle reference implementation (Mojarra) has frequent
  releases. Software Architects often choose standards like JSF because
  they are supported by Java EE application server vendors and have a
  guaranteed service life according to Service Level Agreements (SLAs).
\item
  JSF was first introduced in 2003 and is a mature technology for
  developing web applications that are (arguably) easy to maintain.
\item
  JSF Portlet Bridges (like Liferay Faces Bridge) are also standardized
  by the JCP and make it possible to deploy JSF web applications as
  portlets without writing portlet-specific Java code.
\item
  Support for JSF (via Liferay Faces) is included with Liferay DXP
  support.
\item
  JSF is a unique framework in that it provides a UI component model
  that makes it easy to develop sophisticated, rich user interfaces.
\item
  JSF has built-in Ajax functionality that provides automatic updates to
  the browser by replacing elements in the DOM.
\item
  JSF is designed with many extension points that make a variety of
  integrations possible.
\item
  There are several JSF component suites available including Liferay
  Faces Alloy, Primefaces, ICEfaces, and RichFaces. Each of these
  component suites fortify JSF with a variety of UI components and
  complimentary technologies.
\item
  JSF is a good choice for server-side developers that need to build web
  user interfaces. This enables server-side developers to focus on their
  core competencies rather than being experts in HTML/CSS/JavaScript.
\item
  JSF provides the Facelets templating engine which makes it possible to
  create reusable UI components that are encapsulated as markup.
\item
  JSF provides good integration with HTML5 markup
\item
  JSF provides the Faces Flows feature which makes it easy for
  developers to create wizard-like applications that flow from
  view-to-view.
\item
  JSF has good integration with dependency injection frameworks such as
  CDI and Spring that make it easy for developers to create beans that
  are placed within a scope managed by a container:
  \texttt{@RequestScoped}, \texttt{@ViewScoped},
  \texttt{@SessionScoped}, \texttt{@FlowScoped}
\item
  Since JSF is a stateful technology, the framework encapsulates the
  complexities of managing application state so the developer doesn't
  have to write state management code. It is also possible to use JSF in
  a stateless manner, but some of the features of application state
  management become effectively disabled.
\end{itemize}

There are some reasons not to use JSF. For example, if you are a
front-end developer who makes heavy use of HTML/CSS/JavaScript, you
might find that JSF UI components render HTML in a manner that gives you
less control over the overall HTML document. Sticking with a JavaScript
framework may be better for you. Or, perhaps standards aren't a major
consideration for you or you may simply prefer developing portlets using
your current framework.

Whether you develop your next portlet application with JSF and Liferay
Faces or with HTML/CSS/JavaScript is entirely up to you. But you
probably want to learn more about Liferay Faces and try it out for
yourself.

\chapter{Developing a JSF Portlet
Application}\label{developing-a-jsf-portlet-application}

To run an existing JSF web app on Liferay DXP, you must leverage the
Liferay Faces project. The
\href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
Faces Bridge} enables you to deploy JSF web apps as portlets without
writing portlet-specific code. You must also provide portlet-specific
descriptor files to make it compatible with the Liferay DXP platform.
The easiest way to do this is by generating a new Liferay JSF Portlet
project and migrating your code to it. Then you can deploy your new JSF
portlet project to Liferay DXP.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new JSF portlet project. The following Maven archetypes are
  available:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.liferay.faces.archetype.alloy.portlet} (Liferay Faces
    Alloy portlet)
  \item
    \texttt{com.liferay.faces.archetype.bootsfaces.portlet} (Liferay
    BootsFaces portlet)
  \item
    \texttt{com.liferay.faces.archetype.butterfaces.portlet} (Liferay
    ButterFaces portlet)
  \item
    \texttt{com.liferay.faces.archetype.icefaces.portlet} (Liferay
    ICEFaces portlet)
  \item
    \texttt{com.liferay.faces.archetype.jsf.portlet} (Liferay JSF
    portlet)
  \item
    \texttt{com.liferay.faces.archetype.primefaces.portlet} (Liferay
    PrimeFaces portlet)
  \item
    \texttt{com.liferay.faces.archetype.richfaces.portlet} (Liferay
    RichFaces portlet)
  \end{itemize}

  Choose the archetype that matches your web app's JSF component suite.
  For example,

\begin{verbatim}
mvn archetype:generate \
    -DarchetypeGroupId=com.liferay.faces.archetype \
    -DarchetypeArtifactId=com.liferay.faces.archetype.jsf.portlet \
    -DarchetypeVersion=5.0.6 \
    -DgroupId=com.mycompany \
    -DartifactId=com.mycompany.my.jsf.portlet
\end{verbatim}

  The above archetypes support both Gradle and Maven development by
  providing a \texttt{build.gradle} and \texttt{pom.xml}, respectively.
  For more information, visit
  \href{https://faces.liferay.dev}{faces.liferay.dev}.

  Here's the resulting project structure for a JSF Standard portlet:

  \begin{itemize}
  \tightlist
  \item
    {[}liferay-jsf-portlet{]}/ → Arbitrary project name

    \begin{itemize}
    \tightlist
    \item
      \texttt{src/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{main/}

        \begin{itemize}
        \tightlist
        \item
          \texttt{java/{[}my-package-path{]}/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{bean/} → Sub-package for managed Java beans
            (optional)
          \item
            \texttt{dto/} → Sub-package for model (data transfer object)
            classes (optional)
          \end{itemize}
        \item
          \texttt{resources/} → Resources to include in the class path

          \begin{itemize}
          \tightlist
          \item
            \texttt{i18n.properties} → Internationalization
            configuration
          \item
            \texttt{log4j.properties} → Log4J logging configuration
          \end{itemize}
        \item
          \texttt{webapp/}

          \begin{itemize}
          \tightlist
          \item
            \texttt{resources/}

            \begin{itemize}
            \tightlist
            \item
              \texttt{images/} → Images
            \end{itemize}
          \item
            \texttt{WEB-INF/}

            \begin{itemize}
            \tightlist
            \item
              \texttt{resources/} Frontend files (e.g., CSS, JS, XHTML,
              etc.) that shouldn't be accessed directly by the browser

              \begin{itemize}
              \tightlist
              \item
                \texttt{css/} → Stylesheets
              \end{itemize}
            \item
              \texttt{views/} → View templates
            \item
              \texttt{faces-config.xml} → JSF application configuration
              file
            \item
              \texttt{liferay-display.xml} → Portlet display
              configuration
            \item
              \texttt{liferay-plugin-package.properties} → Packaging
              descriptor
            \item
              \texttt{liferay-portlet.xml} → Liferay-specific portlet
              configuration
            \item
              \texttt{portlet.xml} → Portlet configuration
            \item
              \texttt{web.xml} → Web application configuration
            \end{itemize}
          \end{itemize}
        \end{itemize}
      \end{itemize}
    \item
      \texttt{test/java/} → Test source files
    \end{itemize}
  \end{itemize}
\item
  Update your dependencies as desired. The generated portlet already
  includes the required artifacts required to deploy a simple JSF
  portlet to Liferay DXP. For example, the
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-faces-bridge}{Liferay
  Faces Bridge} artifacts look like this:

  \textbf{Maven:}

\begin{verbatim}
<dependencies>
    <dependency>
        <groupId>com.liferay.faces</groupId>
        <artifactId>com.liferay.faces.bridge.ext</artifactId>
        <version>5.0.4</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>com.liferay.faces</groupId>
        <artifactId>com.liferay.faces.bridge.impl</artifactId>
        <version>4.1.3</version>
        <scope>runtime</scope>
    </dependency>
</dependencies>
\end{verbatim}

  \textbf{Gradle:}

\begin{verbatim}
dependencies {
    runtime group: 'com.liferay.faces', name: 'com.liferay.faces.bridge.ext', version: '5.0.4'
    runtime group: 'com.liferay.faces', name: 'com.liferay.faces.bridge.impl', version: '4.1.3'
}
\end{verbatim}
\item
  Copy your Java classes to the new \texttt{java/{[}my-package-path{]}/}
  folder.
\item
  Copy your view templates to the new
  \texttt{src/main/webapp/WEBINF/views} folder.
\item
  Add your frontend files (e.g., CSS, JS, etc.) that shouldn't be
  accessed directly by the browser to the
  \texttt{webapp/WEB-INF/resources/} folder. For example, your web app's
  CSS files would reside in the \texttt{webapp/WEB-INF/resources/css}
  folder.
\item
  Add your image files to the \texttt{webapp/resources/images} folder.
\item
  Add localized messages to the \texttt{resources/i18n.properties} file.
  The messages in the \texttt{i18n.properties} file can be accessed via
  the Expression Language using the implicit \texttt{i18n} object
  provided by Liferay Faces Util. The \texttt{i18n} object can access
  messages both from a resource bundle defined in the portlet's
  \texttt{portlet.xml} file, and from Liferay DXP's
  \texttt{Language.properties} file.
\item
  Configure your portlet's logging configuration as desired. The
  \texttt{log4j.properties} file in the \texttt{src/main/resources}
  folder sets properties for the Log4j logging utility defined in your
  JSF portlet (i.e., \texttt{faces-config.xml}).
\item
  Replace your new JSF portlet's
  \texttt{webapp/WEB-INF/faces-config.xml} with your web app's
  \texttt{faces-config.xml} file. The \texttt{faces-config.xml} file is
  a JSF portlet's application configuration file, which is used to
  register and configure objects and navigation rules.
\item
  Replace your new JSF portlet's \texttt{webapp/WEB-INF/web.xml} with
  your web app's \texttt{web.xml} file. The \texttt{web.xml} file serves
  as a deployment descriptor that provides necessary configurations for
  your JSF portlet to deploy and function in Liferay DXP.

  Make sure the Faces Servlet is configured in your \texttt{web.xml}:

\begin{verbatim}
<servlet>
    <servlet-name>Faces Servlet</servlet-name>
    <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
\end{verbatim}

  This is required to initialize JSF and should be defined in all JSF
  portlets deployed to Liferay DXP.
\item
  Modify your \texttt{webapp/WEB-INF/portlet.xml} as desired. The
  \texttt{portlet.xml} descriptor describes the portlet to the portlet
  container. For example, it describes portlet info, security settings,
  etc. Also, the \texttt{javax.portlet.faces.GenericFacesPortlet} is
  defined here, which handles invocations to your JSF portlet and makes
  your portlet, since it relies on Liferay Faces Bridge, easy to develop
  by acting as a turnkey implementation.

  The \texttt{init-param} is also defined here, which ensures your
  portlet is visible when deployed to Liferay DXP by pointing to your
  default view template:

\begin{verbatim}
<init-param>
    <name>javax.portlet.faces.defaultViewId.view</name>
    <value>/WEB-INF/views/view.xhtml</value>
</init-param>
\end{verbatim}
\item
  Modify your \texttt{webapp/WEB-INF/liferay-portlet.xml} as desired. It
  specifies additional information Liferay DXP uses to enhance your
  portlet: supported security roles, portlet icon, CSS and JavaScript
  locations, and more. The
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-portlet-app_7_2_0.dtd.html}{liferay-portlet-app
  DTD} defines the \texttt{liferay-portlet.xml} elements.
\item
  Modify your \texttt{webapp/WEB-INF/liferay-display.xml} as desired. It
  configures characteristics for displaying your portlet. For example,
  this \texttt{liferay-display.xml} snippet specifies the Widget
  category in the Add Widget menu:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE display PUBLIC "-//Liferay//DTD Display 7.2.0//EN" "http://www.liferay.com/dtd/liferay-display_7_2_0.dtd">

<display>
<category name="category.sample">
    <portlet id="jsf-portlet" />
</category>
</display>
\end{verbatim}
\item
  Modify your \texttt{webapp/WEB-INF/liferay-plugin-package.properties}
  as desired. It describes the portlet application's packaging and
  version information and specifies any required OSGi metadata. For
  example, this \texttt{liferay-plugin-package.properties} snippet tells
  the OSGi container not to scan for CDI annotations in Liferay DXP.

\begin{verbatim}
-cdiannotations:
\end{verbatim}

  This is required for JSF portlets leveraging CDI deployed to Liferay
  DXP. They must reference their own included CDI implementation.

  On deploying the WAR file, the
  \href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{WAB
  Generator} adds the specified OSGi metadata to the resulting web
  application bundle (WAB) that's deployed to Liferay DXP's runtime
  framework.

  The
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/liferay-plugin-package_7_2_0.properties.html}{liferay-plugin-package
  reference document} describes the
  \texttt{liferay-plugin-package.properties} file.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Build
  and deploy your project}.
\end{enumerate}

Liferay DXP logs the deployment.

\begin{verbatim}
2019-05-30 14:10:59.405 INFO  [com.liferay.portal.kernel.deploy.auto.AutoDeployScanner][AutoDeployDir:261] Processing guestbook-jsf-portlet.war
...
2019-05-30 14:11:11.401 INFO  [fileinstall-C:/liferay-ce-portal-7.2.0-ga1/osgi/war][BaseDeployer:877] Deploying guestbook-jsf-portlet.war
...
2019-05-30 14:11:26.379 INFO  [fileinstall-C:/liferay-ce-portal-7.2.0-ga1/osgi/war][BundleStartStopLogger:39] STARTED guestbook-jsf-portlet_7.2.0.1 [2155]
...
2019-05-30 14:11:67.569 INFO  [fileinstall-C:/liferay-ce-portal-7.2.0-ga1/osgi/war][PortletHotDeployListener:288] 1 portlet for guestbook-jsf-portlet is available for use
\end{verbatim}

The portlet is now available in the Liferay DXP UI. Find your portlet by
selecting the \emph{Add} icon
(\includegraphics{./images/icon-add-app.png}) and navigating to
\emph{Widgets} and the category you specified (\emph{Sample} is the
default category).

Great! You've successfully developed a Liferay JSF portlet and migrated
your web app logic to it.

\chapter{Bean Portlet}\label{bean-portlet}

\noindent\hrulefill

\textbf{Important:} Bean Portlet is in development and is not yet
available.

\noindent\hrulefill

Portlet 3.0, the \href{https://jcp.org/en/jsr/detail?id=362}{JSR 362}
standard, features a new style of portlet development called Bean
Portlets that use Contexts and Dependency Injection (CDI). Bean Portlets
fully leverage
\href{https://portals.apache.org/pluto/v301/v3Features.html}{all the new
Portlet 3.0 features} in compliant portals, and are fully supported in
Liferay DXP.

Bean Portlets are plain old Java objects (POJOs): they don't need to
extend anything. Portlet descriptors declare them to be portlets.

Configuration annotations, phase method annotations, and CDI are some of
the features you'll use in Portlet 3.0.

\section{Portlet Configuration
Annotations}\label{portlet-configuration-annotations}

The
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/PortletConfiguration.html}{\texttt{@PortletConfiguration}}
annotation describes your portlet to the portlet container. You can use
the annotation instead of or in addition to the traditional
\texttt{portlet.xml} descriptor file. The \texttt{@PortletConfiguration}
annotation describes your portlet in the portlet code instead of a
separate file.

\noindent\hrulefill

\textbf{Note:} You can configure Bean Portlets using configuration
annotations, descriptors, or both. If using annotations and descriptors,
the descriptors take precedence.

\noindent\hrulefill

This example portlet was generated using the
\texttt{com.liferay.project.templates.cdi.bean.portlet} archetype, and
it uses \texttt{@PortletConfiguration} and
\texttt{@LiferayPortletConfiguration} annotations:

\begin{verbatim}
import com.mycompany.constants.FooPortletKeys;

import com.liferay.bean.portlet.LiferayPortletConfiguration;

import javax.portlet.annotations.LocaleString;
import javax.portlet.annotations.PortletConfiguration;

@PortletConfiguration(
    portletName = FooPortletKeys.Foo,
    title = @LocaleString(value = FooPortletKeys.Foo))
@LiferayPortletConfiguration(
    portletName = FooPortletKeys.Foo,
    properties = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true"
    }
)
public class FooPortlet {
    ...
}
\end{verbatim}

\texttt{@PortletConfiguration}'s \texttt{portletName} attribute names
the portlet. It's the only required attribute. The \texttt{title}
attribute typically uses a nicer looking name (e.g., uses spaces and
capitalization). The \texttt{title} above is assigned the key constant
\texttt{FooPortletKeys.Foo}. You can also localize a title to one or
more languages using an array of
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/LocaleString.html}{\texttt{@LocaleString}}
annotations, each specifying a different value for the \texttt{locale}
element.

The \texttt{@LiferayPortletConfiguration} annotation specifies
additional Liferay-specific configuration properties. For example, the
\texttt{com.liferay.portlet.display-category} property lets you assign
the Widget category where users will find your portlet. Setting the
\texttt{com.liferay.portlet.instanceable=true} enables adding multiple
instances of the portlet to a page.

\noindent\hrulefill

\textbf{Note:} The \texttt{@PortletConfiguration} and
\texttt{@LiferayPortletConfiguration} annotations are respectively
synonymous with the \texttt{javax.portlet.*} and
\texttt{com.liferay.portlet.*} properties in the OSGi
\texttt{@Component} annotation (used in
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlets}, for example). If you're familiar with the
\texttt{portlet.xml} and \texttt{liferay-portlet.xml} descriptors, the
\href{/docs/7-2/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{Portlet
Descriptor to OSGi Service Property Map} shows you the OSGi
\texttt{@Component} property equivalent. There's an
\texttt{@PortletConfiguration} or \texttt{@LiferayPortletConfiguration}
equivalent setting for each \texttt{@Component} property.

\noindent\hrulefill

To opt-in to Portlet 3.0 features, add the following
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/PortletApplication.html}{\texttt{@PortletApplication}}
annotation to the class.

\begin{verbatim}
@PortletApplication(version="3.0")
\end{verbatim}

Once you've configured your portlet, you should declare the objects it
uses (depends on).

\section{Dependency Injection}\label{dependency-injection}

Bean Portlets use the \texttt{@Inject} CDI annotation (by default) to
inject dependencies. Apply the annotation to a field you want injected
with an object of the specified type. This example portlet injects the
portlet's \texttt{PortletConfig} object.

\begin{verbatim}
import javax.inject.Inject;

import javax.portlet.PortletConfig;

public class FooPortlet {

    @Inject
    PortletConfig portletConfig;

    // Invoke methods on portletConfig ...

}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:}
\href{/docs/7-2/frameworks/-/knowledge_base/f/osgi-cdi-integration}{OSGi
Integration} allows you to use OSGi services (e.g., Liferay's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/UserLocalService.html}{\texttt{UserLocalService}})
in your Bean Portlets.

\noindent\hrulefill

Portlet 3.0 defines annotations for declaring methods that handle
portlet phases.

\section{Portlet Phase Methods}\label{portlet-phase-methods}

Phase method annotations apply methods for handling a portlet's phases.
You can add them to methods in any class anywhere in the portlet WAR.
There's no mandatory method naming convention: assign a phase annotation
to the methods you want to invoke to process the phase. Here are the
annotations:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.6154}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.3846}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Phase
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Annotation
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Header (new) &
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/HeaderMethod.html}{\texttt{@HeaderMethod}} \\
Render &
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/RenderMethod.html}{\texttt{@RenderMethod}} \\
Action &
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/ActionMethod.html}{\texttt{@ActionMethod}} \\
Event &
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/EventMethod.html}{\texttt{@EventMethod}} \\
Resource-serving &
\href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/ServeResourceMethod.html}{\texttt{@ServeResourceMethod}} \\
\end{longtable}

\noindent\hrulefill

You can specify resource dependencies, such as CSS, in the Header phase
prior to the Render phase. It helps you avoid loading the same resources
multiple times.

You'll definitely want to define a Render method. For example, here's a
method invoked during the Render phase:

\begin{verbatim}
import javax.portlet.annotations.RenderMethod;

@RenderMethod(
    include = "/WEB-INF/jsp/view.jsp",
    portletNames = {FooPortletKeys.Foo})
public String doView() {
    return "Hello from " + portletConfig.getPortletName();
}
\end{verbatim}

The \texttt{@RenderMethod} annotation sets the method to be invoked
during the Render phase of the WAR's portlets matching any of the names
listed for the \texttt{portletNames} attribute.

The example Render method produces this content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A string greeting
  \texttt{"Hello\ from\ "\ +\ portletConfig.getPortletName()}
\item
  The JSP template \texttt{/WEB-INF/jsp/view.jsp}---the
  \texttt{@RenderMethod} annotation's \texttt{include} attribute
  references it.
\end{enumerate}

These are just a few of the Portlet 3.0 features that facilitate
developing applications. This section covers more Portlet 3.0 features
and Bean Portlet demonstrations. Creating and deploying your own Bean
Portlet is next.

\chapter{Creating a Bean Portlet}\label{creating-a-bean-portlet}

\noindent\hrulefill

\textbf{Important:} Bean Portlet is in development and is not yet
available.

\noindent\hrulefill

Your first step in developing a Bean Portlet is to create one. Here
you'll generate a Bean Portlet project and deploy your Bean Portlet to
Liferay DXP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate a Bean Portlet project using a Maven command like this:

\begin{verbatim}
mvn archetype:generate \
-DarchetypeGroupId=com.liferay \
-DarchetypeArtifactId=com.liferay.project.templates.cdi.bean.portlet \
-DarchetypeVersion=1.0.0 \
-DgroupId=com.mycompany \
-DartifactId=com.mycompany.demo.bean.portlet
\end{verbatim}

  Here's the resulting folder structure for a Bean Portlet class named
  \texttt{Foo}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.mycompany.demo.bean.portlet} → Arbitrary project name.

    \begin{itemize}
    \tightlist
    \item
      \texttt{src/main/java/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{com.mycompany.constants.FooPortletKeys} → Declares
        portlet constants.
      \item
        \texttt{com.mycompany.portlet.FooPortlet} → Bean Portlet class.
      \end{itemize}
    \item
      \texttt{src/main/webapp/WEB-INF/}

      \begin{itemize}
      \tightlist
      \item
        \texttt{jsp/view.jsp} → Default view template.
      \item
        \texttt{beans.xml} → Signals CDI to scan the portlet for
        annotations.
      \end{itemize}
    \item
      \texttt{pom.xml} → Specifies the project's dependencies and
      packaging.
    \end{itemize}
  \end{itemize}

  Here's the example Bean Portlet class:

\begin{verbatim}
package com.mycompany.portlet;

import com.mycompany.constants.FooPortletKeys;

import com.liferay.bean.portlet.LiferayPortletConfiguration;

import javax.inject.Inject;

import javax.portlet.PortletConfig;
import javax.portlet.annotations.LocaleString;
import javax.portlet.annotations.PortletConfiguration;
import javax.portlet.annotations.RenderMethod;

@PortletConfiguration(
    portletName = FooPortletKeys.Foo,
    title = @LocaleString(value = FooPortletKeys.Foo))
@LiferayPortletConfiguration(
    portletName = FooPortletKeys.Foo,
    properties = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true"
    }
)
public class FooPortlet {

    @Inject
    PortletConfig portletConfig;

    @RenderMethod(
        include = "/WEB-INF/jsp/view.jsp",
        portletNames = {FooPortletKeys.Foo})
    public String doView() {
        return "Hello from " + portletConfig.getPortletName();
    }

}
\end{verbatim}
\item
  Set any portlet configuration or Liferay portlet configuration values
  using
  \href{/docs/7-2/reference/-/knowledge_base/r/portlet-descriptor-to-osgi-service-property-map}{\texttt{@PortletConfiguration}
  and \texttt{Liferay@PortletConfiguration} attributes}.
\item
  Inject any CDI beans using the \texttt{@Inject} annotation.
\item
  Update your render method \texttt{doView} (it's annotated with
  \texttt{@RenderMethod}). It displays the template
  \texttt{WEB-INF/jsp/view.jsp} by default.
\item
  Add any other logic you like to your portlet class.
\item
  Build your portlet:

\begin{verbatim}
mvn clean package
\end{verbatim}
\item
  Deploy your portlet by copying the portlet WAR to your
  \texttt{{[}Liferay\ \ \ \ \ Home{]}/deploy} folder. The
  \href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{WAB
  Generator} converts the WAR to an OSGi Web Application Bundle (WAB)
  and installs it to Liferay's OSGi container.
\end{enumerate}

Liferay DXP logs the deployment.

\begin{verbatim}
INFO  [main][HotDeployImpl:226] Deploying com.mycompany.demo.bean.portlet from queue
INFO  [main][PluginPackageUtil:1001] Reading plugin package for com.mycompany.demo.bean.portlet
...
INFO  [main][PortletHotDeployListener:181] 1 bean portlets for com.mycompany.demo.bean.portlet are available for use
\end{verbatim}

The Bean Portlet is now available in the Liferay DXP UI. The example
portlet is in the Widget category you assigned it.

\begin{figure}
\centering
\includegraphics{./images/portlet-3-portlet.png}
\caption{The Foo portlet prints the message returned from
\texttt{doView} method and shows the included JSP's contents.}
\end{figure}

Congratulations on creating and deploying a Bean Portlet!

\section{Related Topics}\label{related-topics-11}

\href{/docs/7-2/frameworks/-/knowledge_base/f/osgi-cdi-integration}{OSGi
CDI Integration}

\chapter{Service Builder}\label{service-builder}

An application without reliable business logic or persistence isn't much
of an application at all. Unfortunately, writing your own persistence
code often takes a great deal of time. Service Builder is an
object-relational mapping tool that can generate your model,
persistence, and service layers from a single \texttt{xml} file. Once
generated, the code is completely customizable: you can write your own
persistence code along with custom SQL if necessary. Regardless of how
you produce your persistence code, you can then use Service Builder to
implement your app's business logic.

This section demonstrates using Service Builder to

\begin{itemize}
\item
  Generate and customize your persistence framework
\item
  Implement your business logic
\end{itemize}

When you configure your model and its relationships in your
\texttt{service.xml} file and run Service Builder, it generates these
layers of code:

\begin{itemize}
\item
  \textbf{Model layer:} defines objects to represent your project's
  entities.
\item
  \textbf{Persistence layer:} saves entities to and retrieves entities
  from the database and updates entities.
\item
  \textbf{Service layer:} a blank layer ready for you to create your API
  and business logic. .
\end{itemize}

Here are some key features these layers contain:

\begin{itemize}
\item
  Stubbed-out classes for implementing custom business logic
\item
  Hibernate configurations
\item
  Configurable caching support
\item
  Flexibility and support for adding custom SQL queries and dynamic
  queries
\end{itemize}

\noindent\hrulefill

\textbf{Note:} You don't have to use Service Builder for your back-end
services on @product. It's entirely possible to use your persistence
framework of choice, such as JPA or Hibernate. Note that ``under the
hood,'' Service Builder uses Hibernate.

\noindent\hrulefill

\section{Customization via Implementation
Classes}\label{customization-via-implementation-classes}

Each entity Service Builder generates contains these
\emph{implementation} classes:

\begin{itemize}
\item
  \textbf{Entity implementation} (\texttt{*Impl.java}): Is responsible
  for customizing the entity.
\item
  \textbf{Local service implementation}
  (\texttt{*LocalServiceImpl.java}): Is responsible for calling the
  persistence layer to retrieve and store data entities. Local services
  contain the business logic and access the persistence layer. They can
  be invoked by client code running in the same Java Virtual Machine.
\item
  \textbf{Remote service implementation} (\texttt{*ServiceImpl.java}):
  Generated if the \texttt{service.xml} is configured for remote
  services. Remote services usually contain permission checking code and
  are meant to be accessible from outside the JVM. Service Builder
  automatically generates code that makes the remote services available
  via JSON or SOAP, and you can also create your own remote APIs through
  \href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder}
  or \href{/docs/7-2/frameworks/-/knowledge_base/f/jax-rs}{JAX-RS}.
\end{itemize}

These classes are where you implement custom business logic. They're the
only classes generated by Service Builder intended for customization.

\section{Hibernate Configurations}\label{hibernate-configurations}

Service Builder uses the Hibernate persistence framework for
object-relational mapping. Service Builder hides the complexities of
Hibernate, while still giving you access to technology like dynamic
queries and custom SQL. You can take advantage of Object-Relational
Mapping (ORM) in your projects without having to manually set up a
Hibernate environment or make any configurations.

\section{Caching}\label{caching}

Service Builder caches objects at three levels: \emph{entity},
\emph{finder}, and \emph{Hibernate}. By default, Liferay uses Ehcache as
an underlying cache provider for each of these cache levels. However,
this is configurable via
\href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{portal
properties}. All you must do to enable entity and finder caching in your
project is to set the \texttt{cache-enabled=true} attribute of your
entity's \texttt{\textless{}entity\textgreater{}} element in your
\texttt{service.xml} file.
\href{/docs/7-2/deploy/-/knowledge_base/d/enabling-cluster-link}{Liferay
Clustering} describes Liferay caching in a cluster.

\section{Dynamic Query and Custom SQL
Query}\label{dynamic-query-and-custom-sql-query}

Service Builder automates many of the common tasks associated with
creating database persistence code but it doesn't prevent you from
creating \href{/docs/7-2/appdev/-/knowledge_base/a/custom-sql}{custom
SQL queries}. You can define custom SQL queries in an XML file and
implement finder methods to run the queries. If you have some crazy join
to do, Service Builder gets out of your way. You can also use
\href{/docs/7-2/appdev/-/knowledge_base/a/dynamic-query}{dynamic query}
to access Hibernate's criteria API.

Service Builder is used exclusively throughout Liferay DXP and its
applications, so it's well-tested and robust. It saves lots of
development time, both initial development time and time that would have
to be spent maintaining, extending, or customizing a project. Now
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-a-service-builder-project}{create
your own Service Builder project}.

\chapter{Creating a Service Builder
Project}\label{creating-a-service-builder-project}

To use
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}, you must generate the projects where you'll configure your
object-relational map. There's an API project and an implementation
project.

\begin{itemize}
\item
  \texttt{{[}project{]}/{[}project{]}-api/} → Service interfaces.
\item
  \texttt{{[}project{]}/{[}project{]}-service/} → Service
  implementations and supporting files.
\end{itemize}

Here's how to create a Service Builder project.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Decide on a project name. If the project is part of an application,
  name the project after the application.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a project} using
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI} and
  the
  \href{/docs/7-2/reference/-/knowledge_base/r/using-the-service-builder-template}{\texttt{service-builder}
  project template}, passing your project name as a parameter. For
  example, here are Gradle and Maven commands for creating a Service
  Builder project called \texttt{guestbook}.

  Gradle:

\begin{verbatim}
blade create -t service-builder -p com.liferay.docs.guestbook guestbook
\end{verbatim}

  Maven:

\begin{verbatim}
mvn archetype:generate \
-DarchetypeGroupId=com.liferay \
-DarchetypeArtifactId=com.liferay.project.templates.service.builder \
-DgroupId=com.liferay \
-DartifactId=guestbook \
-Dpackage=com.liferay.docs.guestbook \
-Dversion=1.0 \
-DapiPath=com.liferay.api.path \
-DliferayVersion=7.2
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} To use the Spring dependency injector instead of the
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services} dependency injector, use the
\texttt{-\/-dependency-injector\ spring} option (Blade CLI) or
\texttt{-DdependencyInjector=spring} (Maven).

\noindent\hrulefill

A message like this one reports project creation success:

\begin{verbatim}
Successfully created project bookmarks in C:\workspaces_liferay\72-ws\modules
\end{verbatim}

Blade CLI generates the parent project folder and sub-folders for the
\texttt{*-api} and \texttt{*-service} module projects.

\begin{itemize}
\tightlist
\item
  \texttt{guestbook/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{guestbook-api/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{bnd.bnd}
    \item
      \texttt{build.gradle}
    \end{itemize}
  \item
    \texttt{guestbook-service/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{bnd.bnd}
    \item
      \texttt{build.gradle}
    \item
      \texttt{service.xml} → Service definition file.
    \end{itemize}
  \item
    \texttt{build.gradle}
  \end{itemize}
\end{itemize}

Congratulations! You've created your Service Builder project. The
\texttt{service.xml} file is where you'll define your model objects
(entities) and services.

\section{Related Topics}\label{related-topics-12}

\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Service Builder
Samples}

\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-gradle-plugin}{Service
Builder Gradle Plugin}

\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-plugin}{Service
Builder Maven Plugin}

\chapter{Creating the service.xml
File}\label{creating-the-service.xml-file}

To define a service for your portlet project, you must create a
\texttt{service.xml} file. The DTD (Document Type Declaration) file
\href{https://docs.liferay.com/ce/portal/7.2-latest/definitions/liferay-service-builder_7_2_0.dtd.html}{liferay-service-builder\_7\_2\_0.dtd}
specifies the format and requirements of the XML to use.

A \texttt{service.xml} was created for you when you
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-a-service-builder-project}{created
your Service Builder project}. It's in your \texttt{*-service} module's
root folder with an \texttt{entity} element named \emph{Foo}. This is
(obviously) an example entity, but you can use it as a pattern for
creating your own.

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-dev-studio}{Liferay
Dev Studio DXP} provides a Diagram mode and a Source mode to give you
different perspectives of the service information in your
\texttt{service.xml} file.

\begin{itemize}
\tightlist
\item
  \textbf{Diagram mode} facilitates creating and visualizing
  relationships between service entities.
\item
  \textbf{Source mode} brings up the \texttt{service.xml} file's raw XML
  content in the editor.
\end{itemize}

If you use Liferay Dev Studio DXP, you can switch between these modes.
Of course, you don't have to use Liferay Dev Studio DXP to work on
Liferay projects.

Next, you'll specify your service's global information.

\chapter{Defining Global Service
Information}\label{defining-global-service-information}

A service's global information applies to all its entities. It contains
the

\begin{itemize}
\tightlist
\item
  \hyperref[dependency-injector]{Dependency Injector}
\item
  \hyperref[package-path]{Package path}
\item
  \hyperref[namespace-options]{Namespace options}
\item
  \hyperref[multiversion-concurrency-control-mvcc]{Multiversion
  concurrency control}
\item
  \hyperref[author]{Author}
\end{itemize}

\section{Dependency Injector}\label{dependency-injector}

The default dependency injector is
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Declarative Services}. This makes Service Builder work consistently the
way other modules do. Prior versions of Liferay used Spring. The only
difference is how you inject the services when you
\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{go to
use them later}.

Declarative Services Dependency Injector:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.2.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_7_2_0.dtd">

<service-builder dependency-injector="ds"
         package-path="com.liferay.docs.guestbook">
\end{verbatim}

Spring Dependency Injector:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.2.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_7_2_0.dtd">

<service-builder dependency-injector="spring"
         package-path="com.liferay.docs.guestbook">
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} When a project is created using the
\href{/docs/7-2/reference/-/knowledge_base/r/using-the-service-builder-template}{Service
Builder template}, the Declarative Services dependency injector and its
dependencies are configured for the project by default. To use the
Spring dependency injector instead, create the project using the Service
Builder template and the \texttt{-\/-dependency-injector\ spring} option
(Blade CLI) or \texttt{-DdependencyInjector=spring} (Maven).

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} Prior to Liferay DXP 7.2, Spring was the sole dependency
injector. The services were Spring beans. Liferay's Spring bean
framework accommodates Spring beans referencing each other: for example,
Spring bean A has a Spring bean B field and vice versa. When Spring is
the dependency injector, the base services Service Builder generates
include local service and persistence fields of all the
\texttt{service.xml}'s entities. This causes circular references. Since
OSGi Declarative Services doesn't accommodate circular references,
Service Builder does not create these fields in the base classes when DS
is the dependency injector. For more details, see
\href{understanding-the-code-generated-by-service-builder}{Understanding
the Code}.

\noindent\hrulefill

\section{Package Path}\label{package-path}

The package path specifies the package where the service and persistence
classes are generated. The package path for Guestbook ensures that the
\texttt{*-api} module's service classes are generated in the
\texttt{com.liferay.docs.guestbook} package. The persistence classes are
generated in a package of the same name in the \texttt{*-service}
module. A later article
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{describes
the package content}.

\section{Multiversion concurrency control
(MVCC)}\label{multiversion-concurrency-control-mvcc}

The \texttt{service-builder} element's \texttt{mvcc-enabled} attribute
is \texttt{false} by default. Setting \texttt{mvcc-enabled="true"}
(hint: edit \texttt{service.xml} in \emph{Source} view) enables
\href{https://en.wikipedia.org/wiki/Multiversion_concurrency_control}{multiversion
concurrency control} (MVCC) for all of the service's entities. In
systems, concurrent updates are common. Without MVCC people may read or
overwrite data from an invalid state unknowingly. With MVCC, each
modification is made upon a given base version number. When Hibernate
receives the update, it generates an \texttt{update} SQL statement that
uses a \texttt{where} clause to make sure the current data version is
the version you expect.

If the current data version

\begin{itemize}
\item
  \textbf{matches the expected version}, your data operation is based on
  up-to-date data and is accepted.
\item
  \textbf{doesn't match the expected version}, the data you're operating
  on is outdated. Liferay DXP rejects your data operation and throws an
  exception, which you can catch to help the user handle the exception
  (e.g., suggest retrying the operation).
\end{itemize}

\textbf{Important:} Enable MVCC for all your services by setting
\texttt{mvcc-enabled="true"} in your
\texttt{\textless{}service-builder/\textgreater{}} element. When
invoking service entity updates (e.g.,
\texttt{fooService.update(object)}), make sure to do so in transactions.
Propagate rejected transactions to the UI for the user to handle.

\begin{verbatim}
<service-builder dependency-injector="ds"
         package-path="com.liferay.docs.guestbook"
         mvcc-enabled="true">
\end{verbatim}

\section{Namespace Options}\label{namespace-options}

Service Builder names the database tables using the service namespace.
For example, \emph{GB} could serve as the namespace for a Guestbook
application service.

\begin{verbatim}
<namespace>GB</namespace>
\end{verbatim}

Service Builder uses the namespace in the following SQL scripts it
generates in your \texttt{src/main/resources/sql} folder:

\begin{itemize}
\tightlist
\item
  \texttt{indexes.sql}
\item
  \texttt{sequences.sql}
\item
  \texttt{tables.sql}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} The generated SQL script folder location is configurable.
For example, if you're using Gradle, you can define the \texttt{sqlDir}
setting in the project's Gradle \texttt{build.gradle} file or Maven
\texttt{pom.xml} file, the same way the \texttt{databaseNameMaxLength}
setting is applied in the examples below.

\noindent\hrulefill

Service Builder uses the SQL scripts to create database tables for all
the entities the \texttt{service.xml} defines. The database table names
have the namespace prepended when they are created. Since the example
namespace value is \texttt{GB}, the database table names created for the
entities start with \texttt{GB\_\_} as their prefix. Each Service
Builder project's namespace must be unique. Separate plugins should use
separate namespaces and should not use a namespace already used by
Liferay entities (such as \texttt{Users} or \texttt{Groups}). Check the
table names in Liferay's database to see the namespaces already in use.

\textbf{Warning:} Use caution when assigning namespace values. Some
databases have strong restrictions on database table and column name
lengths. The Service Builder
\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-gradle-plugin\#task-properties}{Gradle}
and
\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-plugin\#available-parameters}{Maven}
plugin parameter \texttt{databaseNameMaxLength} sets the maximum length
you can use for your table and column names. Here are paraphrased
examples of setting \texttt{databaseNameMaxLength} in build files:

\textbf{Gradle \texttt{build.gradle}}

\begin{verbatim}
buildService {
    ...
    databaseNameMaxLength = 64
    ...
}
\end{verbatim}

\textbf{Maven \texttt{pom.xml}}

\begin{verbatim}
<configuration>
    ...
    <databaseNameMaxLength>64</databaseNameMaxLength>
    ...
</configuration>
\end{verbatim}

\section{Author}\label{author}

As the last piece of global information, enter your name as the
service's \emph{author} in your \texttt{service.xml} file. Service
Builder adds \texttt{@author} annotations with the specified name to all
the Java classes and interfaces it generates. Save your
\texttt{service.xml} file. Next, you'll add entities for your services.

\begin{verbatim}
<author>Liferay</author>
\end{verbatim}

\chapter{Defining Service Entities}\label{defining-service-entities}

Entities are the heart and soul of a service. They represent the map
between the model objects in Java and your database fields and tables.
Service Builder maps your Java model to the entities you define
automatically, giving you a facility for taking Java objects and
persisting them. For the Guestbook application, two entities are created
according to its \texttt{service.xml}: one for Guestbooks and one for
Guestbook Entries.

Here's a summary of the \texttt{Guestbook} entity information:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \texttt{Guestbook}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

And here's what is used for the \texttt{GuestbookEntry} entity:

\begin{itemize}
\tightlist
\item
  \textbf{Name:} \texttt{GuestbookEntry}
\item
  \textbf{Local service:} \emph{yes}
\item
  \textbf{Remote service:} \emph{yes}
\end{itemize}

Here's how you define entities:

\begin{verbatim}
<entity name="Guestbook" uuid="true" local-service="true" remote-service="true">
</entity>

<entity name="GuestbookEntry" uuid="true" local-service="true" remote-service="true">
</entity>
\end{verbatim}

The entity's database table name includes the entity name prefixed with
the namespace. The Guestbook example creates one database table named
\texttt{GW\_Guestbook} and another named \texttt{GB\_GuestbookEntry}.

Setting \emph{Local Service} (the \texttt{local-service} attribute) to
\texttt{true} instructs Service Builder to generate local interfaces for
the entity's services. Local services can only be invoked from the
Liferay server on which they're deployed.

Setting \emph{Remote Service} (the \texttt{remote-service} attribute) to
\texttt{true} instructs Service Builder to generate remote interfaces
for the service. You can build a fully-functional application without
generating remote services. In that case, you could set your entity
local services to \texttt{true} and remote services to \texttt{false}.
If, however, you want to enable remote access to your application's
services, set both local service and remote service to \texttt{true}.

\noindent\hrulefill

\textbf{Tip:} Suppose you have an existing Data Access Object (DAO)
service for an entity built using some other framework such as JPA. You
can set local service to \texttt{false} and remote service to
\texttt{true} so that the methods of your remote \texttt{-Impl} class
can call the methods of your existing DAO. This enables your entity to
integrate with Liferay's permission-checking system and provides access
to the web service APIs generated by Service Builder. This is a very
handy, quite powerful, and often used feature of Liferay.

\noindent\hrulefill

Now that you've seen how to create your application's entities, you'll
learn how to describe their attributes using entity \emph{columns}.

\chapter{Defining the Columns (Attributes) for Each Service
Entity}\label{defining-the-columns-attributes-for-each-service-entity}

An entity's columns represent its attributes. These attributes map table
fields to Java object fields. To add attributes for your entity, add
\texttt{\textless{}column\ /\textgreater{}} tags to your entity
definition:

\begin{verbatim}
<column name="guestbookId" primary="true" type="long" />
\end{verbatim}

Service Builder creates a database field for each column you add to the
\texttt{service.xml} file. It maps a database field type appropriate to
the Java type specified for each column, and it does this across all the
databases Liferay supports. Once Service Builder runs, it generates a
Hibernate configuration that handles the object-relational mapping.
Service Builder automatically generates getter/setter methods in the
model class for these attributes. The column's name specifies the name
used in the getters and setters that are created for the entity's Java
field. The column's type indicates the Java type of this field for the
entity. If a column's \texttt{primary} (i.e., primary key) attribute is
set to \texttt{true}, the column becomes part of the primary key for the
entity. If only one column has \texttt{primary} set to \texttt{true},
that column represents the entire primary key for the entity. This is
the case in the Guestbook application. If you define multiple columns
with the \texttt{primary} attribute set to true, the combination of
columns makes up a compound primary key for the entity.

\noindent\hrulefill

\textbf{Note:} The
\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method\#step-3-generate-a-primary-key}{Implementing
an Add Method} article demonstrates how to generate unique primary keys
for entity instances.

\noindent\hrulefill

\section{Create Entity Columns}\label{create-entity-columns}

Define the columns you need for your first entity. The Guestbook entity
is simple: it has only two attributes; a primary key and a name:

\begin{verbatim}
<column name="guestbookId" primary="true" type="long" />
<column name="name" type="String" />
\end{verbatim}

\textbf{Note}: On deploying a \texttt{*service} module, Service Builder
automatically generates indexes for all entity primary keys.

Create a column for each attribute of your entity or entities, using the
Java type you'll use in your application. Service Builder handles
mapping it to SQL for you.

\section{Support Multi-tenancy}\label{support-multi-tenancy}

In addition to columns for your entity's primary key and attributes, add
portal instance ID and site ID columns. Then you can support Liferay's
multi-tenancy features, so that each portal instance and each Site in a
portal instance can have independent sets of your application's data. To
hold the site's ID, add a column called \texttt{groupId} of type
\texttt{long}. To hold the portal instance's ID, add a column called
\texttt{companyId} of type \texttt{long}:

\begin{verbatim}
<!-- Group instance -->

<column name="groupId" type="long" />
<column name="companyId" type="long" />
\end{verbatim}

\section{Workflow Fields}\label{workflow-fields}

You can support Liferay's
\href{/docs/7-2/user/-/knowledge_base/u/workflow}{workflow system} by
adding the fields it needs to track an entity's progress:

\begin{verbatim}
<!-- Status fields -->

<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}

\section{Audit Entities}\label{audit-entities}

Finally, you can add columns to help audit your entities. To track each
entity instance's owner, add a column called \texttt{userId} of type
\texttt{long}. Create a column named \texttt{createDate} of type
\texttt{Date} to note an entity instance's creation date. Add a column
named \texttt{modifiedDate} of type \texttt{Date} to track the last time
an entity instance was modified.

\begin{verbatim}
<!-- Audit fields -->

<column name="userId" type="long" />
<column name="userName" type="String" />
<column name="createDate" type="Date" />
<column name="modifiedDate" type="Date" />
\end{verbatim}

Great! Your entities have columns that not only represent their
attributes, but also support multi-tenancy, workflow, and auditing.
Next, you'll learn how to specify the relationship service entities.

\chapter{Defining Relationships Between Service
Entities}\label{defining-relationships-between-service-entities}

Relationships between database entities or Java objects are necessary
for most applications. The Guestbook application, therefore, defines a
relationship between a Guestbook and its entries.

As mentioned earlier, each entry must belong to a particular Guestbook.
Therefore, each \texttt{GuestbookEntry} entity must relate to a
\texttt{Guestbook} entity.

Create the \texttt{GuestbookEntry} entity's fields:

\begin{verbatim}
<entity name="GuestbookEntry" local-service="true" uuid="true" remote-service="true">

    <column name="entryId" primary="true" type="long" />
    <column name="name" type="String" />
    <column name="email" type="String" />
    <column name="message" type="String" />
    <column name="guestbookId" type="long" />
\end{verbatim}

Note the last field in the list is the \texttt{guestbookId} field. Since
it's the same name as the \texttt{Guestbook} object's primary key, a
relationship is created between the two objects. If you're using Liferay
Dev Studio DXP, you can see this relationship in its diagram mode.

\begin{figure}
\centering
\includegraphics{./images/service-builder-relate-entities.png}
\caption{Relating entities is a snap in Liferay Dev Studio DXP's
\emph{Diagram} mode for \texttt{service.xml}.}
\end{figure}

Congratulations! You've related two entities.

Next, add the instance, audit, and status fields mentioned from the
previous step to enable Liferay's multi-tenancy, audit, and workflow
features.

Now that your entity columns are in place and entity relationships are
established, you can specify the default order in which the entity
instances are retrieved from the database.

\chapter{Defining Ordering of Service Entity
Instances}\label{defining-ordering-of-service-entity-instances}

Often, you want to retrieve multiple instances of a given entity and
list them in a particular order. The \texttt{service.xml} file lets you
specify the default order of your entities.

Suppose you want to return \texttt{GuestbookEntry} entities by their
creation date. It's easy to specify these default orderings:

\begin{verbatim}
<order>
    <order-column name="createDate" order-by="desc" />
</order>
\end{verbatim}

You can enter \texttt{asc} or \texttt{desc} for ascending or descending
order.

Now that you know how to order your service entities, the last thing to
do is to define the finder methods for retrieving entity instances from
the database.

\chapter{Defining Service Entity Finder
Methods}\label{defining-service-entity-finder-methods}

Finder methods retrieve entity objects from the database based on
specified parameters. For each finder defined, Service Builder generates
several methods to fetch, find, remove, and count entity instances based
on the finder's parameters.

When supporting Liferay's multi-tenancy, it's important to be able to
find its entities per Site.

\section{Creating Finders}\label{creating-finders}

Finders are easy to create:

\begin{verbatim}
<finder name="GroupId" return-type="Collection">
   <finder-column name="groupId" />
</finder> 
\end{verbatim}

The example above is among the simplest of finders, and is one you
should always add if you're supporting multi-tenancy. This finder
returns a collection of objects that belong to the Site on which your
application has been placed. Service Builder generates finder-related
methods (e.g., \texttt{fetchByGroupId}, \texttt{findByGroupId},
\texttt{removeByGroupId}, \texttt{countByGroupId}) for the your entities
in the \texttt{*Persistence} and \texttt{*PersistenceImpl} classes. The
first of these classes is the interface; the second is its
implementation. For example, the Guestbook application generates its
entity finder methods in the \texttt{-Persistence} classes found in the
\texttt{/guestbook-api/src/main/java/com/liferay/docs/guestbook/service/persistence}
folder and the \texttt{-PersistenceImpl} classes in the
\texttt{/guestbook/src/main/java/com/liferay/docs/service/persistence/impl}
folder.

You're not limited to finding by one column, however; you can create
multi-column finders:

\begin{verbatim}
<finder name="G_S" return-type="Collection">
    <finder-column name="groupId" />
    <finder-column name="status" />
</finder>
\end{verbatim}

\noindent\hrulefill

\textbf{Important}: DO NOT create finders that use entity primary key as
parameters. They're unnecessary as Service Builder automatically
generates \texttt{findByPrimaryKey} and \texttt{fetchByPrimaryKey}
methods for all entity primary keys. On deploying a \texttt{*service}
module, Service Builder creates indexes for all entity primary key
columns and finder columns. Adding finders that use entity primary keys
results in attempts to create multiple indexes for the same
columns---Oracle DB, for example, reports these attempts as errors.

\noindent\hrulefill

Now you know to configure Service Builder to create finder methods for
your entity. Terrific!

Now that you've specified the service for your project, you're ready to
\emph{build} the service by running Service Builder. It's time to
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{run
Service Builder and examine the code it generates}.

\chapter{Running Service Builder}\label{running-service-builder}

Here you'll learn how to run Service Builder. If want to use Service
Builder in your application but haven't yet
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{created
a \texttt{service.xml} file that defines an object-relational map for
you application}, make sure to do so before proceeding.

Open a command line and navigate to your application folder (the folder
that contains your \texttt{*-api} and \texttt{*-service} modules).

\section{Gradle}\label{gradle}

To build your services using Gradle, enter the following command:

\begin{verbatim}
blade gw buildService
\end{verbatim}

or

\begin{verbatim}
gradlew buildService
\end{verbatim}

Blade's \texttt{gw} command works in any project that has a Gradle
Wrapper available to it. Projects generated using Liferay project
templates have a Gradle Wrapper.

\noindent\hrulefill

\textbf{Note:} Liferay Workspace's Gradle Wrapper script is in the
workspace root folder. If your application project folder is located at
\texttt{{[}workspace{]}/modules/{[}application{]}}, for example, the
Gradle Wrapper is available at \texttt{../../gradlew}.

\noindent\hrulefill

\section{Maven}\label{maven}

If you're using Maven, build the services by running the following
command:

\begin{verbatim}
mvn service-builder:build
\end{verbatim}

\textbf{Important:} The \texttt{mvn\ service-builder:build} command only
works if you're using the
\texttt{com.liferay.portal.tools.service.builder} plugin version
1.0.145+. Maven projects using an earlier version of the Service Builder
plugin should update their POM accordingly. More information is
available on
\href{/docs/7-2/reference/-/knowledge_base/r/using-service-builder-in-a-maven-project}{using
Maven to run Service Builder}.

On successfully building the services, Service Builder prints the
message \texttt{BUILD\ SUCCESSFUL}. Many generated files appear in your
project. They represent a model layer, service layer, and persistence
layer for your entities. Don't worry about the number of generated
files---they're explained in the next article, where you can review the
code Service Builder generates for your entities.

\chapter{Understanding the Code Generated by Service
Builder}\label{understanding-the-code-generated-by-service-builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Service
Builder generates code} to support your entities. The files listed under
Local Service and Remote Service below are only generated for an entity
that has both \texttt{local-service} and \texttt{remote-service}
attributes set to \texttt{true}. Service Builder generates services for
these entities in your application's \texttt{*-api} and
\texttt{*-service} modules in the packages you specified in
\texttt{service.xml}. For example, here are the package paths for
Liferay's Bookmarks application:

\begin{itemize}
\tightlist
\item
  \texttt{/guestbook-api/src/main/java/com/liferay/docs/guestbook}
\item
  \texttt{/guestbook-service/src/main/java/com/liferay/docs/guestbook}
\end{itemize}

The \texttt{guestbook-api} module's interfaces define the Guestbook
application API. The \texttt{*-api} module interfaces define the
application's persistence layer, service layer, and model layer.
Whenever you compile and deploy the \texttt{*-api} module, all its
classes and interfaces are packaged in a \texttt{.jar} file called
\texttt{PROJECT\_NAME-api.jar} in the module's \texttt{build/libs}
folder. Deploying this JAR to Liferay \emph{defines} the API as OSGi
services.

The \texttt{guestbook-service} module classes implement the
\texttt{guestbook-api} module interfaces. The \texttt{*-service} module
provides the OSGi service implementations to deploy to Liferay's OSGi
framework.

Next, examine the classes and interfaces generated for the entities you
specified. Similar classes are generated for each entity, depending on
how each entity is specified in the \texttt{service.xml}. Here are the
three types of customizable classes:

\begin{itemize}
\tightlist
\item
  \texttt{*LocalServiceImpl}
\item
  \texttt{*ServiceImpl}
\item
  \texttt{*Impl}
\end{itemize}

The \texttt{*} represents the entity name in the classes listed above.

Here are the persistence, service, and model classes:

\begin{itemize}
\tightlist
\item
  Persistence

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Persistence}: Persistence interface that
    defines CRUD methods for the entity such as \texttt{create},
    \texttt{remove}, \texttt{countAll}, \texttt{find}, \texttt{findAll},
    etc.
  \item
    \texttt{{[}ENTITY\_NAME{]}PersistenceImpl}: Persistence
    implementation class that implements
    \texttt{{[}ENTITY\_NAME{]}Persistence}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Util}: Persistence utility class that
    wraps \texttt{{[}ENTITY\_NAME{]}PersistenceImpl} and provides direct
    access to the database for CRUD operations. This utility should only
    be used by the service layer; in your portlet classes, use the
    \texttt{{[}ENTITY\_NAME{]}} class by referencing it with the
    \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
    annotation}.
  \end{itemize}

  \begin{figure}
  \centering
  \includegraphics{./images/service-builder-persistence-diagram.png}
  \caption{Service Builder generates these persistence classes and
  interfaces for an example entity called \emph{Event}. You shouldn't
  (and you won't need to) customize any of these classes or interfaces.}
  \end{figure}
\item
  Local Service (generated for an entity only if the entity's
  \texttt{local-service} attribute is set to \texttt{true} in
  \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalService}: Local service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl} (\textbf{LOCAL SERVICE
    IMPLEMENTATION}): Local service implementation. This is the only
    class in the local service that you should modify: it's where you
    add your business logic. For any methods added here, Service Builder
    adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}LocalService} interface the next time you
    run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceBaseImpl}: Local service base
    implementation. This is an abstract class. Service Builder injects a
    number of instances of various service and persistence classes into
    this class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceUtil}: Local service utility
    class which wraps \texttt{{[}ENTITY\_NAME{]}LocalServiceImpl}. This
    class is generated for backwards compatibility purposes only. Use
    the \texttt{*LocalService} class by referencing it with the
    \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
    annotation}.
  \item
    \texttt{{[}ENTITY\_NAME{]}LocalServiceWrapper}: Local service
    wrapper which implements \texttt{{[}ENTITY\_NAME{]}LocalService}.
    This class is designed to be extended and it lets you
    \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{customize
    the entity's local services}.
  \end{itemize}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/service-builder-service-diagram.png}
\caption{Service Builder generates these service classes and interfaces.
Only the {[}ENTITY\_NAME{]}LocalServiceImpl (e.g., EventLocalServiceImpl
for the Event entity) allows custom methods to be added to the service
layer.}
\end{figure}

\begin{itemize}
\tightlist
\item
  Remote Service (generated for an entity only if an entity's
  \texttt{remote-service} attribute is \emph{not} set to \texttt{false}
  in \texttt{service.xml})

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Service}: Remote service interface.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceImpl} (\textbf{REMOTE SERVICE
    IMPLEMENTATION}): Remote service implementation. This is the only
    class in the remote service that you should modify manually. Here,
    you can write code that adds additional security checks and invokes
    the local services. For any custom methods added here, Service
    Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}Service} interface the next time you run
    it.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceBaseImpl}: Remote service base
    implementation. This is an abstract class. \texttt{@abstract}
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceUtil}: Remote service utility class
    which wraps \texttt{{[}ENTITY\_NAME{]}ServiceImpl}. This class is
    generated for backwards compatibility purposes only. Use the
    \texttt{*Service} class by referencing it with the
    \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
    annotation}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceWrapper}: Remote service wrapper
    which implements \texttt{{[}ENTITY\_NAME{]}Service}. This class is
    designed to be extended and it lets you
    \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{customize
    the entity's remote services}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ServiceSoap}: SOAP utility which the
    remote \texttt{{[}ENTITY\_NAME{]}ServiceUtil} remote service utility
    can access.
  \item
    \texttt{{[}ENTITY\_NAME{]}Soap}: SOAP model, similar to
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}.
    \texttt{{[}ENTITY\_NAME{]}Soap} is serializable; it does not
    implement \texttt{{[}ENTITY\_NAME{]}}.
  \end{itemize}
\item
  Model

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}ENTITY\_NAME{]}Model}: Base model interface. This
    interface and its \texttt{{[}ENTITY\_NAME{]}ModelImpl}
    implementation serve only as a container for the default property
    accessors Service Builder generates. Any helper methods and all
    application logic should be added to
    \texttt{{[}ENTITY\_NAME{]}Impl}.
  \item
    \texttt{{[}ENTITY\_NAME{]}ModelImpl}: Base model implementation.
  \item
    \texttt{{[}ENTITY\_NAME{]}}: \texttt{{[}ENTITY\_NAME{]}} model
    interface which extends \texttt{{[}ENTITY\_NAME{]}Model}.
  \item
    \texttt{{[}ENTITY\_NAME{]}Impl}: (\textbf{MODEL IMPLEMENTATION})
    Model implementation. You can use this class to add helper methods
    and application logic to your model. If you don't add any helper
    methods or application logic, only the auto-generated field getters
    and setters are available. Whenever you add custom methods to this
    class, Service Builder adds corresponding methods to the
    \texttt{{[}ENTITY\_NAME{]}} interface the next time you run it.
  \item
    \texttt{{[}ENTITY\_NAME{]}Wrapper}: Wrapper, wraps
    \texttt{{[}ENTITY\_NAME{]}}. This class is designed to be extended
    and it lets you
    \href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{customize
    the entity}.
  \end{itemize}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/service-builder-model-diagram.png}
\caption{Service Builder generates these model classes and interfaces.
Only \texttt{{[}ENTITY\_NAME{]}Impl} (e.g., \texttt{EventImpl} for the
Event entity) allows custom methods to be added to the service layer.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} \texttt{*Util} classes are generated for backwards
compatibility purposes only. Your module applications should avoid
calling the util classes. Use the non-util classes instead--you can
reference them using the
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
annotation}.

\noindent\hrulefill

Each file that Service Builder generates is assembled from an associated
FreeMarker template. The FreeMarker templates are in the
\href{https://github.com/liferay/liferay-portal/tree/master/modules/util/portal-tools-service-builder}{portal-tools-service-builder
module's}
\texttt{src/main/resources/com/liferay/portal/tools/service/builder/dependencies/}
folder. For example, Service Builder uses the \texttt{service\_impl.ftl}
template to generate the \texttt{*ServiceImpl.java} classes.

You can modify any \texttt{*Impl} class Service Builder generates. The
most common are \texttt{*LocalServiceImpl}, \texttt{*ServiceImpl} and
\texttt{*Impl}. If you modify the other classes, Service Builder
overwrites the changes the next time you run it. Whenever you add
methods to, remove methods from, or change a method signature of a
\texttt{*LocalServiceImpl} class, \texttt{*ServiceImpl} class, or
\texttt{*Impl} class, you should run Service Builder again to regenerate
the affected interfaces and the service JAR.

\noindent\hrulefill

\textbf{Note:} Service Builder may generate code that requires adding
dependencies to your \texttt{*-service} module build file.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} When \texttt{spring} is the dependency injector (see
\emph{Dependency Injector} in
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information}{Defining
Global Service Information}), the \texttt{-LocalServiceBaseImpl} classes
Service Builder generates include \texttt{-LocalService} and
\texttt{-Persistence} member fields of all the \texttt{service.xml}'s
entities. \texttt{-LocalServiceImpl} classes inherit these fields and
are Spring beans. The Spring beans can reference each other. For
example, Spring bean A can have a Spring bean B field and vice versa.
Liferay's \texttt{spring} dependency injector accommodates Spring bean
circular references. The \texttt{ds} dependency injector does not
accommodate circular references.

When using \texttt{ds} as the dependency injector,
\texttt{-LocalServiceImpl} classes are OSGi Declarative Services. Such
services start only after all the other services they reference have
started. If declarative service A has a declarative service B member
field and vice versa, neither service can start. For this reason, the
\texttt{-LocalServiceBaseImpl} classes Service Builder generates don't
include \texttt{-LocalService} member fields of the
\texttt{service.xml}'s other entities. When using the \texttt{ds}
dependency injector, you must make sure member fields you add to service
classes don't create circular dependencies.

\noindent\hrulefill

Congratulations! You've generated your application's initial model,
persistence, and service layers and you understand the generated code.

\textbf{Related Topics}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Running
Service Builder}

\href{/docs/7-2/frameworks/-/knowledge_base/f/understanding-servicecontext}{Understanding
Service Context}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Services}

\chapter{Iterative Development}\label{iterative-development}

As you develop an application, you might need to add fields to your
database. This is a normal process of iterative development: you get an
idea for a new feature, or it's suggested to you, and that feature
requires additional data in the database. \textbf{New fields added to
\texttt{service.xml} are not automatically added to the database.} To
add the fields, you must do one of two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write an
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes}{upgrade
  process} to modify the tables and preserve the data, or
\item
  Run the \texttt{cleanServiceBuilder}
  \href{/docs/7-2/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
  task} (also supported on Maven and Ant), which drops your tables so
  they get re-created the next time your app is deployed. The
  \href{/docs/7-2/reference/-/knowledge_base/r/db-support-plugin}{Maven
  DB Support Plugin} reference article explains how to run this command
  from a Maven project.
\end{enumerate}

Use the first option if you have a released application and you must
preserve user data. Use the second option if you're adding new columns
during development.

\section{Related Topics}\label{related-topics-13}

\href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes}{Upgrade
Processes}

\href{/docs/7-2/reference/-/knowledge_base/r/db-support-gradle-plugin}{Gradle
DB Support Plugin}

\href{/docs/7-2/reference/-/knowledge_base/r/db-support-plugin}{Maven DB
Support Plugin}

\chapter{Customizing Model Entities With Model
Hints}\label{customizing-model-entities-with-model-hints}

Once you've used Service Builder to define model entities, you may want
to further refine how users enter that data. For example, model hints
can define a calendar field with selectable dates only in the future.
Model hints specify entity data restrictions and other formatting.

You define model hints in a file called
\texttt{portlet-model-hints.xml}. The \texttt{portlet-model-hints.xml}
file goes in the service module's \texttt{src/main/resources/META-INF}
folder.

Model hints define two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How entities are presented to users
\item
  The size of database columns
\end{enumerate}

As Liferay renders your form fields, it customizes the form's input
fields based on your configuration.

\noindent\hrulefill

\textbf{Note:} If you chose Spring as the dependency injector, Service
Builder generates a number of XML configuration files in your service
module's \texttt{src/main/resources/META-INF} folder. Service Builder
uses most of these files to manage Spring and Hibernate configurations.
Don't modify the Spring or Hibernate configuration files; changes to
them are overwritten when Service Builder runs. You can, however, safely
edit the \texttt{portlet-model-hints.xml} file.

\noindent\hrulefill

Since the Guestbook doesn't have much of a model hints file, as an
example, consider the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.bookmarks.service/}{Bookmarks
app service module's} model hints file:

\begin{verbatim}
<?xml version="1.0"?>

<model-hints>
    <model name="com.liferay.bookmarks.model.BookmarksEntry">
        <field name="uuid" type="String" />
        <field name="entryId" type="long" />
        <field name="groupId" type="long" />
        <field name="companyId" type="long" />
        <field name="userId" type="long" />
        <field name="userName" type="String" />
        <field name="createDate" type="Date" />
        <field name="modifiedDate" type="Date" />
        <field name="folderId" type="long" />
        <field name="treePath" type="String">
            <hint name="max-length">4000</hint>
        </field>
        <field name="name" type="String">
            <hint name="max-length">255</hint>
        </field>
        <field name="url" type="String">
            <hint-collection name="URL" />
            <validator name="required" />
            <validator name="url" />
        </field>
        <field name="description" type="String">
            <hint-collection name="TEXTAREA" />
        </field>
        <field name="visits" type="int" />
        <field name="priority" type="int">
            <hint name="display-width">20</hint>
        </field>
        <field name="lastPublishDate" type="Date" />
        <field name="status" type="int" />
        <field name="statusByUserId" type="long" />
        <field name="statusByUserName" type="String" />
        <field name="statusDate" type="Date" />
    </model>
    <model name="com.liferay.bookmarks.model.BookmarksFolder">
        ...
    </model>
</model-hints>
\end{verbatim}

The root-level element is \texttt{model-hints}. Model entities are
represented by \texttt{model} sub-elements of the \texttt{model-hints}
element. Each \texttt{model} element must have a \texttt{name} attribute
specifying the fully-qualified class name. Models have \texttt{field}
elements representing their entity's columns. Lastly, \texttt{field}
elements must have a name and a type. Each \texttt{field} element's name
and type maps to the name and type specified for the entity's column in
the service module's \texttt{service.xml} file. Service Builder
generates all these elements for you, based on the \texttt{service.xml}.

To add hints to a field, add a \texttt{hint} child element. For example,
you can add a \texttt{display-width\ hint} to specify the pixel width to
use in displaying the field. The default pixel width is \texttt{350}. To
show a \texttt{String} field with 50 pixels, you could nest a
\texttt{hint} element named \texttt{display-width} and give it a value
of \texttt{50}.

To see the effect of a hint on a field,
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{run
Service Builder} again and
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{redeploy
your module}. Note that changing \texttt{display-width} doesn't limit
the number of characters a user can enter into the \texttt{name} field;
it only controls the field's width in the AlloyUI input form.

To configure the maximum size of a model field's database column (i.e.,
the maximum number of characters that can be saved for the field), use
the \texttt{max-length} hint. The default \texttt{max-length} value is
\texttt{75} characters. If you want the \texttt{name} field to persist
up to 100 characters, add a \texttt{max-length} hint to that field:

\begin{verbatim}
<field name="name" type="String">
    <hint name="display-width">50</hint>
    <hint name="max-length">100</hint>
</field>
\end{verbatim}

Remember to run Service Builder and redeploy your project after updating
the \texttt{portlet-model-hints.xml} file.

\section{Model Hint Types}\label{model-hint-types}

So far, you've seen a few different hints. The following table describes
the portlet model hints available for use.

\textbf{Model Hint Values and Descriptions}

\noindent\hrulefill

\begin{verbatim}
  Name       | Value Type | Description | Default |
\end{verbatim}

\texttt{auto-escape} \textbar{} boolean \textbar{} sets whether text
values should be escaped via \texttt{HtmlUtil.escape} \textbar{} true
\textbar{} \texttt{autoSize} \textbar{} boolean \textbar{} displays the
field in a for scrollable text area \textbar{} false \textbar{}
\texttt{day-nullable} \textbar{} boolean \textbar{} allows the day to be
null in a date field \textbar{} false \textbar{} \texttt{default-value}
\textbar{} String \textbar{} sets the default value of the form field
rendered using the aui taglib \textbar{} (empty String) \textbar{}
\texttt{display-height} \textbar{} integer \textbar{} sets the display
height of the form field rendered using the aui taglib \textbar{} 15
\textbar{} \texttt{display-width} \textbar{} integer \textbar{} sets the
display width of the form field rendered using the aui taglib \textbar{}
350 \textbar{} \texttt{editor} \textbar{} boolean \textbar{} sets
whether to provide an editor for the input \textbar{} false \textbar{}
\texttt{max-length} \textbar{} integer \textbar{} sets the maximum
column size for SQL file generation \textbar{} 75 \textbar{}
\texttt{month-nullable} \textbar{} boolean \textbar{} allows the month
to be null in a date field \textbar{} false \textbar{} \texttt{secret}
\textbar{} boolean \textbar{} sets whether to hide the characters input
by the user \textbar{} false \textbar{} \texttt{show-time} \textbar{}
boolean \textbar{} sets whether to show the time along with the date
\textbar{} true \textbar{} \texttt{upper-case} \textbar{} boolean
\textbar{} converts all characters to upper case \textbar{} false
\textbar{} \texttt{year-nullable} \textbar{} boolean \textbar{} allows a
date field's year to be null \textbar{} false \textbar{}
\texttt{year-range-delta} \textbar{} integer \textbar{} specifies the
number of years to display from today's date in a date field rendered
with the aui taglib \textbar{} 5 \textbar{} \texttt{year-range-future}
\textbar{} boolean \textbar{} sets whether to include future dates
\textbar{} true \textbar{} \texttt{year-range-past} \textbar{} boolean
\textbar{} sets whether to include past dates \textbar{} true \textbar{}

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: The aui taglib is fully supported and not related to
AlloyUI (the JavaScript library) that's deprecated.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: You can use a mix of Clay and aui tags in a form. Model
hints, however, affect aui tags only.

\noindent\hrulefill

Note that Liferay has its own model hints file
(\texttt{portal-model-hints.xml}). It's in \texttt{portal-impl.jar}'s
\texttt{META-INF} folder. This file contains many hint examples, so you
can reference it when creating \texttt{portlet-model-hints.xml} files.

\section{Default Hints}\label{default-hints}

You can use the \texttt{default-hints} element to define a list of hints
to apply to every field of a model. For example, adding the following
element inside a model element applies a \texttt{display-width} of 300
pixels to each field:

\begin{verbatim}
<default-hints>
    <hint name="display-width">300</hint>
</default-hints>
\end{verbatim}

\section{Hint Collections}\label{hint-collections}

You can define \texttt{hint-collection} elements inside the
\texttt{model-hints} root-level element to define a list of hints to
apply together. A hint collection must have a name. For example,
Liferay's \texttt{portal-model-hints.xml} defines the following hint
collections:

\begin{verbatim}
<hint-collection name="CLOB">
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="EDITOR">
    <hint name="editor">true</hint>
    <hint name="max-length">2000000</hint>
</hint-collection>
<hint-collection name="EMAIL-ADDRESS">
    <hint name="max-length">254</hint>
</hint-collection>
<hint-collection name="HOSTNAME">
    <hint name="max-length">200</hint>
</hint-collection>
<hint-collection name="SEARCHABLE-DATE">
    <hint name="month-nullable">true</hint>
    <hint name="day-nullable">true</hint>
    <hint name="year-nullable">true</hint>
    <hint name="show-time">false</hint>
</hint-collection>
<hint-collection name="TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
<hint-collection name="URL">
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

You can apply a hint collection to a model field by referencing the hint
collection's name. For example, if you define a \texttt{SEARCHABLE-DATE}
collection like the one above in your \texttt{model-hints} element, you
can apply it to your model's date field by using a
\texttt{hint-collection} element that references the collection by its
name:

\begin{verbatim}
<field name="date" type="Date">
    <hint-collection name="SEARCHABLE-DATE" />
</field>
\end{verbatim}

Suppose you want to use a couple of model hints in your project. Start
by providing users with an editor for filling in their comment fields.
To apply the same hint to multiple entities, define it as a hint
collection. Then reference the hint collection in each entity.

To define a hint collection, add a \texttt{hint-collection} element
inside the \texttt{model-hints} root element in your
\texttt{portlet-model-hints.xml} file. For example:

\begin{verbatim}
<hint-collection name="COMMENT-TEXTAREA">
    <hint name="display-height">105</hint>
    <hint name="display-width">500</hint>
    <hint name="max-length">4000</hint>
</hint-collection>
\end{verbatim}

To reference a hint collection for a specific field, add the
\texttt{hint-collection} element inside the field's \texttt{field}
element:

\begin{verbatim}
<field name="comment" type="String">
    <hint-collection name="COMMENT-TEXTAREA" />
</field>
\end{verbatim}

After defining hint collections and adding hint collection references,
rebuild your services, redeploy your project, and check that the hints
defined in your hint collection have taken effect.

Nice work! Now you can not only influence how your model's input fields
are displayed, but you can also can set its database table column sizes.
You can organize hints, insert individual hints directly into your
fields, apply a set of default hints to all of a model's fields, or
define collections of hints to apply at either of those scopes.

\chapter{Configuring
service.properties}\label{configuring-service.properties}

Service Builder generates a \texttt{service.properties} file in your
\texttt{*-service} module's \texttt{src/main/resources} folder. Liferay
DXP uses this file's properties to alter your service's database schema.
You should not modify this file directly, but rather make any necessary
property overrides in a \texttt{service-ext.properties} file in that
same folder.

Here are some of the properties the \texttt{service.properties} file
includes:

\begin{itemize}
\tightlist
\item
  \texttt{build.namespace}: This is the
  \href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{namespace
  you defined in your \texttt{service.xml}}. Liferay distinguishes
  different modules from each other using their namespaces.
\item
  \texttt{build.number}: Liferay distinguishes your module's different
  Service Builder builds. Each time you deploy a distinct Service
  Builder build to Liferay, Liferay increments this number.
\item
  \texttt{build.date}: This is the time of your module's latest Service
  Builder build.
\item
  \texttt{include-and-override}: The default value of this property
  defines \texttt{service-ext.properties} as an override file for
  \texttt{service.properties}.
\end{itemize}

\noindent\hrulefill

\textbf{Note}: In Liferay Portal 6.x Service Builder portlets, the
\texttt{build.auto.upgrade} property in \texttt{service.properties}
applies Liferay Service schema changes upon rebuilding services and
redeploying the portlets. This property was deprecated in Liferay 7.0.

The Build Auto Upgrade feature is now different and is set in a global
property \texttt{schema.module.build.auto.upgrade} in the file
\texttt{{[}Liferay\_Home{]}/portal-developer.properties}.

\noindent\hrulefill

Awesome! You now have all the tools necessary to set up your own
\texttt{service-ext.properties} file.

\section{Related Topics}\label{related-topics-14}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder?}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Services}

\chapter{Connecting Service Builder to an External
Database}\label{connecting-service-builder-to-an-external-database}

If you want to use a database separate from Liferay DXP's, follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Specify your database and a data source name in your
  \texttt{service.xml}.
\item
  Create the database manually.
\item
  Define the data source.
\item
  Connect your Service Builder module to the data source.
\item
  Run Service Builder.
\end{enumerate}

There are two different ways to create the connection:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{\texttt{DataSourceProvider}:} This approach involves
  implementing a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/jdbc/DataSourceProvider.html}{\texttt{DataSourceProvider}}
  \href{https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html}{\texttt{ServiceProviderInterface}}
  (SPI). This way requires the fewest files and steps and works
  regardless of whether your Service Builder module uses the \texttt{ds}
  or \texttt{spring}
  \href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#dependency-injector}{dependency
  injector}.
\item
  \textbf{Spring Beans:} Configure the connection using Spring XML
  files. This approach only works with Service Builder modules that use
  the \texttt{spring}
  \href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#dependency-injector}{dependency
  injection option}.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} All entities defined in a Service Builder module's
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{\texttt{service.xml}}
file are bound to the same data source. Binding different entities to
different data sources requires defining the entities in separate
Service Builder modules and configuring each of the modules to use a
different data source.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Warning:} If your Service Builder services require nested
transactions, using an external data source may not be appropriate.
Transactions between separate data sources cannot be fully nested.
Rollbacks may not propagate between services that use an external data
source and Liferay DXP services (or another app's services) that use a
different data source.

\noindent\hrulefill

Since \texttt{DataSourceProvider} is the easiest, most versatile
approach, it's explained first.

\chapter{Connecting the Data Source Using a
DataSourceProvider}\label{connecting-the-data-source-using-a-datasourceprovider}

Connecting to an external database by creating and registering a
\texttt{DataSourceProvider} as a JDK
\href{https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html}{\texttt{ServiceProviderInterface}}
(SPI) is the easiest way. This approach works regardless of whether your
Service Builder module uses the \texttt{ds} or \texttt{spring}
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#dependency-injector}{dependency
injection option} and it requires the fewest files and steps.

\noindent\hrulefill

\textbf{Note:} All entities defined in a Service Builder module's
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{\texttt{service.xml}}
file are bound to the same data source. Binding different entities to
different data sources requires defining the entities in separate
Service Builder modules and configuring each of the modules to use a
different data source.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Warning:} If your Service Builder services require nested
transactions, using an external data source may not be appropriate for
you. Transactions between separate data sources cannot be fully nested.
Rollbacks may not propagate between a module that uses an external data
source and Liferay DXP services (or another app's services) that use a
different data source.

\noindent\hrulefill

Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{service.xml} file, specify the same arbitrary data
  source name for all of the entities, a unique table name for each
  entity, and a database column name for each column. Here's an example:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.2.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_7_2_0.dtd">

<service-builder dependency-injector="spring" package-path="com.liferay.example" >
    <namespace>TestDB</namespace>
    <entity local-service="true" name="Foo" table="testdata" data-source="extDataSource"
            remote-service="false" uuid="false">
           <column name="id" db-name="id" primary="true" type="long" />
           <column name="foo" db-name="foo" type="String" />
           <column name="bar" db-name="bar" type="long" />
    </entity>
</service-builder>
\end{verbatim}

  Note the example's \texttt{\textless{}entity\textgreater{}} tag
  attributes:

  \emph{\texttt{data-source}}: The \texttt{liferayDataSource} alias
  \texttt{ext-spring.xml} specifies.

  \emph{\texttt{table}}: Your entity's database table.

  Also note that your entity's \texttt{\textless{}column\textgreater{}}s
  must have a \emph{\texttt{db-name}} attribute set to the column name.
\item
  \href{https://learn.liferay.com/dxp/latest/en/installation-and-upgrades/installing-liferay/configuring-a-database.html}{Manually
  create the database} you defined in your \texttt{service.xml}.
\item
  Define the data source. One way is to use
  \href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{portal
  properties} in a \texttt{portal-ext.properties} file. Distinguish your
  data source from Liferay's default data source by giving it a prefix
  other than \texttt{jdbc.default.}. This example uses prefix
  \texttt{jdbc.ext.}.

\begin{verbatim}
jdbc.ext.driverClassName=org.mariadb.jdbc.Driver
jdbc.ext.password=userpassword
jdbc.ext.url=jdbc:mariadb://localhost/external?useUnicode=true&characterEncoding=UTF-8&useFastDateParsing=false
jdbc.ext.username=yourusername
\end{verbatim}
\item
  Restart your server if you defined your data source using portal
  properties.
\item
  Connect your Service Builder module to the data source by implementing
  the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/jdbc/DataSourceProvider.html}{\texttt{DataSourceProvider}}
  interface. Since the \texttt{DataSourceProvider} must be visible to
  your \texttt{*-service} module class loader, it's common to put the
  \texttt{DataSourceProvider} in the \texttt{*-service} module.

  This example uses
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/jdbc/DataSourceFactoryUtil.html}{\texttt{DataSourceFactoryUtil}}
  to create a data source from
  \href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{portal
  properties} that have the prefix \texttt{jdbc.ext.}.

\begin{verbatim}
package com.liferay.external.data.source.test.internal;

import com.liferay.portal.kernel.dao.jdbc.DataSourceFactoryUtil;
import com.liferay.portal.kernel.dao.jdbc.DataSourceProvider;
import com.liferay.portal.kernel.util.PropsUtil;

import javax.sql.DataSource;

public class DataSourceProviderImpl implements DataSourceProvider {

    @Override
    public DataSource getDataSource() {
        try {
            return DataSourceFactoryUtil.initDataSource(
                PropsUtil.getProperties("jdbc.ext.", true));
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

}
\end{verbatim}
\item
  Register the implementation as a JDK
  \href{https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html}{\texttt{ServiceProviderInterface}}
  (SPI) in a
  \texttt{/META-INF/services/com.liferay.portal.kernel.dao.jdbc.DataSourceProvider}
  file in your \texttt{*-service} module. For example, this file
  registers the \texttt{DataSourceProvider} implementation from the
  previous step.

\begin{verbatim}
com.liferay.external.data.source.test.internal.DataSourceProviderImpl
\end{verbatim}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Run
  Service Builder}.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy}
  your \texttt{-service} module. If your \texttt{DataSourceProvider} is
  in a different project, deploy it too.
\end{enumerate}

Congratulations! Your module's Service Builder services are persisting
data to your external data source.

\section{Related Topics}\label{related-topics-15}

\href{/docs/7-2/appdev/-/knowledge_base/a/connecting-to-data-sources-using-jndi}{Connecting
to JNDI Data Sources}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Connecting the Data Source Using Spring
Beans}\label{connecting-the-data-source-using-spring-beans}

Sometimes you want to use a database other than Liferay DXP's. To do
this, its data source must be defined in \texttt{portal-ext.properties}
or configured as a JNDI data source on the app server. Here you'll
connect
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} to a data source using Spring XML files. This approach only
works with Service Builder modules that use the \texttt{spring}
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#dependency-injector}{dependency
injection option}. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Specify your database and a data source name in your
  \texttt{service.xml}.
\item
  Create the database manually.
\item
  Define the data source.
\item
  Create a Spring bean that points to the data source.
\item
  Run Service Builder.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} All entities defined in a Service Builder module's
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{\texttt{service.xml}}
file are bound to the same data source. Binding different entities to
different data sources requires defining the entities in separate
Service Builder modules and configuring each of the modules to use a
different data source.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Warning:} If your Service Builder services require nested
transactions, using an external data source may not be appropriate for
you. Transactions between separate data sources cannot be fully nested.
Rollbacks may not propagate between a module that uses an external data
source and Liferay DXP services (or another app's services) that use a
different data source.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Important:} Connecting to an external data source using JNDI is
broken in Portal CE 7.2 GA1 and GA2, and in DXP 7.2 releases prior to
FP5/SP2. See
\href{https://issues.liferay.com/browse/LPS-107733}{LPS-107733} for
details.

\noindent\hrulefill

\section{\texorpdfstring{Specify Your Database and a Data Source Name in
Your
\texttt{service.xml}}{Specify Your Database and a Data Source Name in Your service.xml}}\label{specify-your-database-and-a-data-source-name-in-your-service.xml}

In your \texttt{service.xml} file, specify the same arbitrary data
source name for all of the entities, a unique table name for each
entity, and a database column name for each column. Here's an example:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 7.2.0//EN"
    "http://www.liferay.com/dtd/liferay-service-builder_7_2_0.dtd">

<service-builder dependency-injector="spring" package-path="com.liferay.example" >
    <namespace>TestDB</namespace>
    <entity local-service="true" name="Foo" table="testdata" data-source="extDataSource"
            remote-service="false" uuid="false">
           <column name="id" db-name="id" primary="true" type="long" />
           <column name="foo" db-name="foo" type="String" />
           <column name="bar" db-name="bar" type="long" />
    </entity>
</service-builder>
\end{verbatim}

Note the example's \texttt{\textless{}entity\textgreater{}} tag
attributes:

\emph{\texttt{data-source}}: The \texttt{liferayDataSource} alias
\texttt{ext-spring.xml} specifies.

\emph{\texttt{table}}: Your entity's database table.

Also note that your entity's \texttt{\textless{}column\textgreater{}}s
must have a \emph{\texttt{db-name}} attribute set to the column name.

\section{Create the Database
Manually}\label{create-the-database-manually}

\href{https://learn.liferay.com/dxp/latest/en/installation-and-upgrades/installing-liferay/configuring-a-database.html}{Create
the database} per the database specification in your
\texttt{service.xml}.

Next, use portal properties to set your data source.

\section{Define the Data Source}\label{define-the-data-source}

If the application server defines the data source using JNDI, skip this
step. Otherwise, specify the data source in a
\href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{\texttt{portal-ext.properties}
file}. Distinguish it from Liferay's default data source by giving it a
prefix other than \texttt{jdbc.default.}. This example uses prefix
\texttt{jdbc.ext.}:

\begin{verbatim}
jdbc.ext.driverClassName=org.mariadb.jdbc.Driver
jdbc.ext.password=userpassword
jdbc.ext.url=jdbc:mariadb://localhost/external?useUnicode=true&characterEncoding=UTF-8&useFastDateParsing=false
jdbc.ext.username=yourusername
\end{verbatim}

Restart your server if you defined your data source using portal
properties.

\section{Connect Your Service Builder Module to the Data Source Via a
Spring
Bean}\label{connect-your-service-builder-module-to-the-data-source-via-a-spring-bean}

To do this, create a parent context extension
(e.g.,\texttt{ext-spring.xml}) in your \texttt{*-service} module's
\texttt{src/main/resources/META-INF/spring} folder or in your
traditional portlet's \texttt{WEB-INF/src/META-INF} folder. Create this
folder if it doesn't exist already.

Define the following elements:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A data source factory Spring bean for the data source. It's different
  based on the type.

  \begin{itemize}
  \tightlist
  \item
    \textbf{JNDI}: Specify an arbitrary property prefix and prepend the
    prefix to a JNDI name property key. Here's an example:
  \end{itemize}

\begin{verbatim}
<bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
    id="liferayDataSourceFactory">
    <property name="propertyPrefix" value="custom." />
    <property name="properties">
        <props>
            <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
        </props>
    </property>
</bean>
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    \textbf{Portal Properties}: Specify a property prefix that matches
    the prefix (e.g., \texttt{jdbc.ext.}) you used in
    \texttt{portal-ext.properties}.
  \end{itemize}

\begin{verbatim}
<bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
    id="liferayDataSourceFactory">
    <property name="propertyPrefix" value="jdbc.ext." />
</bean>
\end{verbatim}
\item
  A Liferay data source bean that refers to the data source factory
  Spring bean.
\item
  An alias for the Liferay data source bean. Name the alias after the
  data source name you specified in the \texttt{service.xml}.

  Here's an example \texttt{ext-spring.xml} that points to a JNDI data
  source:

\begin{verbatim}
<?xml version="1.0"?>

<beans default-destroy-method="destroy" default-init-method="afterPropertiesSet"
   xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- To define an external data source, the liferayDataSource Spring bean
       must be overridden. Other default Spring beans like liferaySessionFactory
       and liferayTransactionManager may optionally be overridden.

       liferayDataSourceFactory refers to the data source configured on the
       application server. -->
   <bean class="com.liferay.portal.dao.jdbc.spring.DataSourceFactoryBean"
       id="liferayDataSourceFactory">
       <property name="propertyPrefix" value="custom." />
       <property name="properties">
           <props>
               <prop key="custom.jndi.name">jdbc/externalDataSource</prop>
           </props>
       </property>
   </bean>

   <!-- The data source bean refers to the factory to access the data source.
   -->
   <bean
       class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"
       id="liferayDataSource">
       <property name="targetDataSource" ref="liferayDataSourceFactory" />
   </bean>

   <!-- In service.xml, we associated our entity with the extDataSource. To
       associate the extDataSource with our overridden liferayDataSource, we define
       this alias. -->
   <alias alias="extDataSource" name="liferayDataSource" />
</beans>
\end{verbatim}
\end{enumerate}

The \texttt{liferayDataSourceFactory} above refers to a JNDI data source
named \texttt{jdbc/externalDataSource}. If the data source is in a
\texttt{portal-ext.properties} file, the bean requires only a
\texttt{propertyPrefix} property that matches the data source property
prefix.

The data source bean \texttt{liferayDataSource} is overridden with one
that refers to the \texttt{liferayDataSourceFactory} bean. The override
affects this bundle (module or
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Web
Application Bundle}) only.

The alias \texttt{extDataSource} refers to the
\texttt{liferayDataSource} data source bean.

\noindent\hrulefill

\textbf{Important:} The \texttt{alias} element's \texttt{alias}
attribute value must match the data source name specified in the
\texttt{service.xml}. For example, the alias attribute value above is
\texttt{extDataSource}.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note}: To use an external data source in multiple Service
Builder bundles, you must override the \texttt{liferayDataSource} bean
in each bundle.

\noindent\hrulefill

\section{Run Service Builder}\label{run-service-builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Run
Service Builder} and
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy}
your \texttt{-service} module. Now your Service Builder services use the
data source. You can
\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{use
the services in your business logic} as you always have regardless of
the underlying data source.

Congratulations! You've connected Service Builder to your external data
source.

\section{Related Topics}\label{related-topics-16}

\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-application-using-external-database-via-jndi}{Sample
Service Builder Application Using External Database via JNDI}

\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-application-using-external-database-via-jdbc}{Sample
Service Builder Application Using External Database via JDBC}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Migrating a Service Builder Module from Spring DI to OSGi
DS}\label{migrating-a-service-builder-module-from-spring-di-to-osgi-ds}

Prior to Liferay DXP 7.2, Service Builder modules could only use Spring
for dependency injection (DI). Now
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Declarative Services} (DS) is the default dependency injection mechanism
for new Service Builder modules. It's easier to learn and fosters loose
coupling between services. If you have an existing Service Builder
module that uses Spring DI, you can modify it to use DS.

Here are the conversion steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Prepare your project for DS
\item
  Update your Spring bean classes
\item
  Resolve any circular dependencies
\end{enumerate}

Now prepare your project.

\section{Step 1: Prepare Your Project for
DS}\label{step-1-prepare-your-project-for-ds}

Prepare your project's metadata, dependencies, and \texttt{service.xml}
for DS.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Enable the DS annotation option for your inherited dependencies by
  adding this line to your \texttt{bnd.bnd} file:

\begin{verbatim}
-dsannotations-options: inherit
\end{verbatim}
\item
  Since DS Service Builder modules use the AOP API, add it as a compile
  dependency in \texttt{build.gradle}:

\begin{verbatim}
compileOnly group: "com.liferay:com.liferay.portal.aop.api", version: "1.0.0"
\end{verbatim}
\item
  Add the \texttt{dependency-injector="ds"} attribute to your
  \texttt{service.xml} file's
  \texttt{\textless{}service-builder\textgreater{}} element:

\begin{verbatim}
<service-builder dependency-injector="ds" >
\end{verbatim}
\end{enumerate}

\section{Step 2: Update Your Spring Bean
Classes}\label{step-2-update-your-spring-bean-classes}

Some of your
\href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{non-generated
Spring bean classes} must be updated to use DS.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
  annotation to your \texttt{*LocalServiceImpl}, \texttt{*ServiceImpl},
  and \texttt{*FinderImpl} classes.
\item
  If the class implements a \texttt{*Finder} interface, declare the
  component as that service type. Example:

\begin{verbatim}
@Component(service = MyFinder.class)
\end{verbatim}
\item
  If the class implements a remote or local service, declare the
  component as the \texttt{com.liferay.portal.aop.AopService} service
  type. Example:

\begin{verbatim}
@Component(service = AopService.class)
\end{verbatim}
\item
  If it's a remote service (i.e., \texttt{-ServiceImpl} instead of
  \texttt{-LocalServiceImpl}), enable JSON web services by setting these
  properties in your \texttt{@Component} annotation:

  \begin{itemize}
  \tightlist
  \item
    \texttt{json.web.service.context.name}
  \item
    \texttt{json.web.service.context.path}
  \end{itemize}

  Set them to the same values as the properties in your remote service
  interface's
  \href{https://docs.liferay.com/ce/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/spring/osgi/OSGiBeanProperties.html}{\texttt{@OSGiBeanProperties}}
  annotation.
\item
  If it's a local service, enable
  \href{https://docs.liferay.com/ce/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/PersistedModelLocalService.html}{\texttt{PersistedModelLocalService}}
  service tracking by setting the \texttt{@Component} property
  \texttt{model.class.name} to the service entity's fully qualified
  class name.
\item
  Replace all the \texttt{@ServiceReference} and \texttt{@BeanReference}
  field annotations with the DS
  \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}}
  annotation.
\item
  Use the \texttt{@Reference} field annotation to access any other
  services you need.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Run
  Service Builder} to regenerate the interfaces based on your
  implementation changes.
\item
  Replace the following methods:

  \begin{itemize}
  \item
    \texttt{afterPropertiesSet()\ \{...\}} →
    \texttt{activate()\ \{...\}} and annotate with
    \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Activate.html}{\texttt{@Activate}}.
  \item
    \texttt{destroy()\ \{...\}} → \texttt{deactivate()\ \{...\}} and
    annotate with
    \href{https://osgi.org/javadoc/r6/cmpn/org/osgi/service/component/annotations/Deactivate.html}{\texttt{@Deactivate}}.
  \end{itemize}
\end{enumerate}

Next, you'll work out any remaining references you need.

\section{Step 3: Resolve Any Circular
Dependencies}\label{step-3-resolve-any-circular-dependencies}

Circular dependencies occur in a module if two or more of its DS
services refer to each another (either directly or indirectly). A direct
reference occurs, for example, when service \texttt{A} references
service \texttt{B}, and \texttt{B} references \texttt{A}. Here's what
the service components might look like:

\texttt{AImpl.java}:

\begin{verbatim}
@Component(service = A.class)
public class AImpl implements A {
    @Reference
    private B _b;
}
\end{verbatim}

\texttt{BImpl.java}:

\begin{verbatim}
@Component(service = B.class)
public class BImpl implements B {
    @Reference
    private A _a;
} 
\end{verbatim}

\texttt{AImpl} and \texttt{BImpl} directly depend on each other. This
circular dependency prevents each service component from resolving. DS
service activation requires that all of a service's dependencies
(references) be satisfied.

\textbf{Note:} Service resolution is independent and separate from
module (OSGi bundle) resolution:

\begin{itemize}
\tightlist
\item
  Module resolution is determined by the module's manifest.
\item
  Modules resolve before any of their services become active.
\item
  Services inside a module cannot activate if the module cannot resolve.
\item
  A module can resolve even if none of its services activate.
\end{itemize}

The example above demonstrates a very small circle, composed of only two
classes, but a circle can compose more classes. For example, \texttt{A}
references \texttt{B}, \texttt{B} references \texttt{C}, \texttt{C}
references \texttt{A}. Detecting and resolving such a dependency can be
complicated.

There is no general, correct way to detect and resolve circular
dependencies; cases vary. However, Liferay provides tools that
facilitate detecting circular dependencies and examining the DS service
components involved.

\begin{itemize}
\item
  \texttt{system:check}: This
  \href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
  shell} command provides several checks, including one that detects
  inactive service components whose required references are unresolved.
\item
  \texttt{scr:info\ {[}component{]}}: Execute this
  \href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
  shell} command on an unresolved component to report its unresolved
  references.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Service resolution in DS dependency injection (DI) is
different than in services that use Liferay's Spring DI. In the latter
case, all Spring beans in the same module act as a single bundle of
services that activate together and can bind together before activation.
DS doesn't have this feature. With DS, each component in a module is its
own service and must resolve on its own.

\noindent\hrulefill

Congratulations on converting your service module to use Declarative
Services.

\section{Related Topics}\label{related-topics-17}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{Understanding
the Code Service Builder Generates}

\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services}

\chapter{Business Logic with Service
Builder}\label{business-logic-with-service-builder}

Once you've
\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{defined
your application's entities} and
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{run
Service Builder} to generate your service and persistence layers, you
can begin adding business logic. Each entity generated by Service
Builder contains a model implementation, local service implementation,
and optionally a remote service implementation class. Your application's
business logic can be implemented in these classes. The generated
service layer contains default methods that call CRUD operations from
the persistence layer. Once you've added your business logic, running
Service Builder again regenerates your application's interfaces and
makes your new logic available for invocation.

The heart of your service is its \texttt{*LocalServiceImpl} class. This
class is your entity's local service extension point. Local services are
invoked from your application or by other applications running on the
same instance as your application.

Creating services takes these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Deciding to Create Local and Remote Services.
\item
  Implementing the \texttt{add} Method.
\item
  Implementing the \texttt{update} and \texttt{delete} Methods.
\item
  Implementing \texttt{get} and \texttt{get*Count} Methods
\item
  Implementing Other Business Logic
\item
  Integrating with Liferay's Services.
\end{enumerate}

Start with deciding the service types you need.

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file}{Defining
your object model} involves choosing whether to generate local and or
remote service interfaces. Local services can only be invoked from the
Liferay server on which they're deployed. Remote services are accessible
to clients outside of the Liferay server. Before implementing local or
remote services, consider the best practices described here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you plan to have remote services, enable local services too.
\item
  Implement your business logic in \texttt{*LocalServiceImpl}.
\item
  Create corresponding remote services methods in your
  \texttt{*ServiceImpl}.
\item
  Use the remote service methods to call the local service, wrapping the
  calls in permission checks.
\item
  In your application, call only the remote services. This ensures that
  your service methods are secured and that you don't have to duplicate
  permissions code.
\end{enumerate}

If you are turning on local or remote services in your
\texttt{service.xml} file just now, make sure to
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{run
Service Builder} again to generate the service interfaces.

Now you're ready to implement your business logic.

\chapter{Implementing an Add Method}\label{implementing-an-add-method}

Your \texttt{*LocalServiceImpl} represents your service layer, where you
create the business logic that operates on your application's data and
then calls the persistence layer to persist, retrieve, or delete your
data, using the object model defined in \texttt{service.xml}.

One of the first methods you'll likely implement is one that creates
entities. Liferay's convention is to implement this in an \texttt{add*}
method, where the part after \texttt{add} is the entity name (or a
shortened version of it). Here are the steps for implementing an
\texttt{add*} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an \texttt{add*} method with parameters for creating the
  entity.
\item
  Validate the parameters.
\item
  Generate a primary key.
\item
  Create an entity instance.
\item
  Populate the entity attributes.
\item
  Persist the entity.
\item
  Return the entity instance.
\end{enumerate}

This article refers to the Guestbook application's
\texttt{addGuestbookEntry} method from
\texttt{GuestbookEntryLocalServiceImpl}. To keep things simple, we have
excluded the code that integrates with Liferay services, such as assets,
social bookmarks, and more.

Here's the Guestbook application's \texttt{addGuestbookEntry} method:

\begin{verbatim}
public GuestbookEntry addEntry(long userId, long guestbookId, String name, String email, String message,
        ServiceContext serviceContext) throws PortalException {

    long groupId = serviceContext.getScopeGroupId();

    User user = userLocalService.getUserById(userId);

    Date now = new Date();

    validate(name, email, message);

    long entryId = counterLocalService.increment();

    GuestbookEntry entry = guestbookEntryPersistence.create(entryId);

    entry.setUuid(serviceContext.getUuid());
    entry.setUserId(userId);
    entry.setGroupId(groupId);
    entry.setCompanyId(user.getCompanyId());
    entry.setUserName(user.getFullName());
    entry.setCreateDate(serviceContext.getCreateDate(now));
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setExpandoBridgeAttributes(serviceContext);
    entry.setGuestbookId(guestbookId);
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);

    guestbookEntryPersistence.update(entry);

    // Calls to other Liferay frameworks go here

    return entry;
}
\end{verbatim}

This method uses the parameters to create \texttt{GuestbookEntry}. It
validates the parameters, creates an entry with a generated entry ID
(primary key), populates the entry, persists the entry, and returns it.
You can refer to this method as you create your own \texttt{add*}
method. Note that there's no real business logic here; it's a simple
application that takes data the user entered, validates it, and then
persists it to the database.

\section{Step 1: Declare an add method with parameters for creating the
entity}\label{step-1-declare-an-add-method-with-parameters-for-creating-the-entity}

Create a public method for \emph{adding} (creating) your application's
entity. Make it a public method that returns the entity it creates.

\begin{verbatim}
public [ENTITY] add[ENTITY](...) {
    
} 
\end{verbatim}

For example, here's the \texttt{addEntry} method signature:

\begin{verbatim}
public GuestbookEntry addEntry(long userId, long guestbookId, 
    String name, String email, String message, 
    ServiceContext serviceContext) throws PortalException {
    ...
    }
\end{verbatim}

This method specifies all the parameters needed to create and populate a
\texttt{GuestbookEntry} as you specified them in your
\texttt{service.xml} file. It throws a \texttt{PortalException} in case
the parameters are invalid or a processing exception occurs (more on
this in a later step).

Make sure to account for primary keys of other related entities. For
example, the \texttt{addEntry} method above includes a parameter
\texttt{long\ guestbookId} to associate the new \texttt{GuestbookEntry}
to a \texttt{Guestbook}.

\section{Step 2: Validate the
parameters}\label{step-2-validate-the-parameters}

Validate the parameters as needed. You might need to make sure a
parameter is not empty or \texttt{null}, or that a parameter value is
within a valid range. Throw a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/exception/PortalException.html}{\texttt{PortalException}}
or an extension of \texttt{PortalException} for any invalid parameters.

For example, the \texttt{addEntry} method invokes the following
\texttt{validate} method to check if the URL parameter is \texttt{null}.

\begin{verbatim}
protected void validate(String name, String email, String entry) throws PortalException {

    if (Validator.isNull(name)) {
        throw new GuestbookEntryNameException();
    }

    if (!Validator.isEmailAddress(email)) {
        throw new GuestbookEntryEmailException();
    }

    if (Validator.isNull(entry)) {
        throw new GuestbookEntryMessageException();
    }
}
\end{verbatim}

Next, generate a primary key for the entity instance you're creating.

\section{Step 3: Generate a primary
key}\label{step-3-generate-a-primary-key}

Entities must each have a unique primary key. Liferay's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/counter/kernel/service/CounterLocalService.html}{\texttt{CounterLocalService}}
generates them per entity. Every \texttt{*BaseLocalServiceImpl} has a
\texttt{counterLocalService} field that references a
\texttt{CounterLocalService} object for the entity. Invoke the counter
service's \texttt{increment} method to generate a primary key for your
entity instance.

\begin{verbatim}
long id = counterLocalService.increment();
\end{verbatim}

Now you have a unique ID for your entity instance. Always generate
primary keys in this way, as it ensures your code is compatible with all
the databases Liferay supports.

\section{Step 4: Create an entity
instance}\label{step-4-create-an-entity-instance}

The \texttt{*Peristence} instance associated with your entity has a
\texttt{create(long\ id)} method that constructs an entity instance with
the given ID. Every \texttt{*BaseLocalServiceImpl} has a
\texttt{*Persistence} field that references a \texttt{*Persistence}
object for the entity. For example,
\texttt{GuestbookEntryLocalServiceImpl} as a child of
\texttt{GuestbookEntryLocalServiceBaseImpl} has a field
\texttt{guestbookEntryPersistence}, which is a reference to a
\texttt{GuestbookEntryPersistence} instance.

\begin{verbatim}
@Reference
protected GuestbookEntryPersistence guestbookEntryPersistence;
\end{verbatim}

\texttt{GuestbookEntryLocalServiceImpl}'s \texttt{addEntry} method
creates a \texttt{GuestbookEntry} instance using this call:

\begin{verbatim}
GuestbookEntry entry = guestbookEntryPersistence.create(entryId);
\end{verbatim}

To create an instance of your entity, invoke the \texttt{create} method
on the \texttt{*Persistence} field associated with the entity, making
sure to pass in the entity primary key you generated in the previous
step.

\begin{verbatim}
 [ENTITY_NAME] entity = [ENTITY_NAME]Persistence.create(id);
\end{verbatim}

It's time to populate the new entity instance.

\section{Step 5: Populate the entity
attributes}\label{step-5-populate-the-entity-attributes}

Use the \texttt{add*} method parameter values and the entity's setter
methods to populate your entity's attributes. For example, here are the
\texttt{GuestbookEntry} attribute assignments:

\begin{verbatim}
entry.setUuid(serviceContext.getUuid());
entry.setUserId(userId);
entry.setGroupId(groupId);
entry.setCompanyId(user.getCompanyId());
entry.setUserName(user.getFullName());
entry.setCreateDate(serviceContext.getCreateDate(now));
entry.setModifiedDate(serviceContext.getModifiedDate(now));
entry.setExpandoBridgeAttributes(serviceContext);
entry.setGuestbookId(guestbookId);
entry.setName(name);
entry.setEmail(email);
entry.setMessage(message);
\end{verbatim}

Note that the \texttt{ServiceContext} is commonly used to carry an
entity's UUID and the \texttt{User} is associated to a company.

\section{Step 6: Persist the entity}\label{step-6-persist-the-entity}

It's time to store the entity. Invoke the \texttt{*Persistence} field's
\texttt{update} method, passing in the entity object. For example,
here's how the new \texttt{GuestbookEntry} is persisted:

\begin{verbatim}
guestbookEntryPersistence.update(entry);
\end{verbatim}

Your entity is persisted for the application.

\section{Step 7: Return the entity}\label{step-7-return-the-entity}

Finally, return the entity you just created so the caller can use it.

\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{Run
Service Builder} to propagate your new service method to the
\texttt{*LocalService} interface.

You've implemented your local service's \texttt{add*} method to create
and persist your application's entities.

\chapter{Implementing Update and Delete
Methods}\label{implementing-update-and-delete-methods}

After you've implementing an
\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method}{\texttt{add*}
method} for creating service entities, you'll want to create
\hyperref[implementing-an-update-method]{\texttt{update*}} and
\hyperref[implementing-a-delete-method]{\texttt{delete*}} methods for
updating and deleting them. The main difference between these and the
\texttt{add*} method is they must know which entity they're updating or
deleting.

\section{Implementing an Update
Method}\label{implementing-an-update-method}

An \texttt{update*} method for a local service resembles an
\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method}{\texttt{add*}
method} most because it has parameters for setting entity attribute
values. Create an \texttt{update*} method this way:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare an \texttt{update*} method with parameters for updating the
  entity.
\item
  Validate the parameters.
\item
  Retrieve the entity instance, if necessary.
\item
  Update the entity attributes.
\item
  Persist the updated entity.
\item
  Run Service Builder.
\end{enumerate}

The following code snippets from
\texttt{GuestbookEntryLocalServiceImpl}'s \texttt{updateEntry} method
are helpful to examine.

\begin{verbatim}
public GuestbookEntry updateEntry(long userId, long guestbookId, long entryId, String name, String email, String message,
        ServiceContext serviceContext) throws PortalException, SystemException {

    Date now = new Date();

    validate(name, email, message);

    GuestbookEntry entry = getGuestbookEntry(entryId);

    User user = userLocalService.getUserById(userId);

    entry.setUserId(userId);
    entry.setUserName(user.getFullName());
    entry.setModifiedDate(serviceContext.getModifiedDate(now));
    entry.setName(name);
    entry.setEmail(email);
    entry.setMessage(message);
    entry.setExpandoBridgeAttributes(serviceContext);

    guestbookEntryPersistence.update(entry);

    // Integrate with Liferay frameworks here.

    return entry;
}
\end{verbatim}

This method has all the makings of a good \texttt{update*} method:

\begin{itemize}
\tightlist
\item
  parameter for looking up the entity instance
\item
  parameters for updating the entity attributes
\item
  parameter validation
\item
  entity attribute updates
\item
  entity persistence
\item
  returns the entity instance
\end{itemize}

Refer to the example method above as you follow the steps to create your
own \texttt{update*} method.

\section{Step 1: Declare an Update Method with Parameters for Updating
the
Entity}\label{step-1-declare-an-update-method-with-parameters-for-updating-the-entity}

Create a public method for updating your application's entity.

\begin{verbatim}
public [ENTITY] update[ENTITY](...)
    throws PortalException {
    
} 
\end{verbatim}

Replace \texttt{{[}ENTITY{]}} with your entity's name or nickname.
Create a parameter list that satisfies the entity attributes you're
updating. Include an entity instance parameter or an ID parameter for
fetching the entity instance.

For example, the \texttt{GuestbookEntryLocalServiceImpl}'s
\texttt{updateEntry} method signature has an ID parameter
(\texttt{entryId}) for fetching the \texttt{GuestbookEntry} entity
instance. Also it has parameters \texttt{folderId}, \texttt{name},
\texttt{url}, and \texttt{description} for updating the
\texttt{GuestbookEntry}'s respective attributes.

\begin{verbatim}
public GuestbookEntry updateEntry(long userId, long guestbookId, long entryId, String name, String email, String message,
        ServiceContext serviceContext) throws PortalException, SystemException {
\end{verbatim}

Note, user ID, group ID, and service context parameters are useful for
integrating with Liferay's services. More on that later.

\section{Step 2: Validate the
Parameters}\label{step-2-validate-the-parameters-1}

Similar to validating the
\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method}{\texttt{add*}
method} parameters, validate your \texttt{update*} parameters. Your
\texttt{add*} and \texttt{update*} methods might be able to use the same
validation code. Throw a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/exception/PortalException.html}{\texttt{PortalException}}
or an extension of \texttt{PortalException} for any invalid parameters.

\section{Step 3: Retrieve the Entity
Instance}\label{step-3-retrieve-the-entity-instance}

If you're passing in an entity instance, you can update it directly.
Otherwise, pass in the entity ID (the primary key). The
\texttt{*Persistence} class Service Builder injects into
\texttt{*BaseLocalServiceImpl} classes has a
\texttt{findByPrimaryKey(long)} method that retrieves instances by ID.
For example, the \texttt{GuestbookEntryLocalServiceImpl} retrieves the
\texttt{GuestbookEntry} with the primary key \texttt{entryId}.

\begin{verbatim}
GuestbookEntry entry = guestbookEntryPersistence.findByPrimaryKey(
    entryId);
\end{verbatim}

Invoke the \texttt{findByPrimaryKey(long\ id)} method of your
\texttt{*Persistence} class to retrieve the entity instance that matches
your primary key parameter.

\begin{verbatim}
 [ENTITY] entity = [ENTITY]Persistence.findByPrimaryKey(id);
\end{verbatim}

It's time to update the entity attributes.

\section{Step 4: Update the Entity
Attributes}\label{step-4-update-the-entity-attributes}

Invoke the entity's setter methods to replace its attribute values.

\section{Step 5: Persist and Return the Updated Entity
Instance}\label{step-5-persist-and-return-the-updated-entity-instance}

Persist the updated entity to the database and return the instance to
the caller.

\begin{verbatim}
[ENTITY]Persistence.update(entity);

...

return entity;
\end{verbatim}

\section{Step 6: Run Service Builder}\label{step-6-run-service-builder}

Finally, run Service Builder to propagate your new service method to the
\texttt{*LocalService} interface.

You've created a service method to update your entity. If you thought
that was easy, implementing a \texttt{delete*} method is even easier.

\section{Implementing a Delete
Method}\label{implementing-a-delete-method}

The \texttt{remove} method of an entity's \texttt{*Persistence} class
deletes an entity instance from the database. Use it in your local
service's \texttt{delete*} method. Here's what a \texttt{delete*} method
looks like:

\begin{verbatim}
public [ENTITY] delete[ENTITY](ENTITY entity) throws PortalException
{
    [ENTITY]Persistence.remove(entity);

    // Clean up related to additional Liferay services goes here ... 

    return entity;
}
\end{verbatim}

Make sure to replace \texttt{{[}ENTITY{]}} with your entity's name or
nickname.

For example, here's paraphrased code from
\texttt{GuestbookEntryLocalServiceImpl}'s \texttt{deleteEntry} method:

\begin{verbatim}
public GuestbookEntry deleteEntry(GuestbookEntry entry)
    throws PortalException {

    guestbookEntryPersistence.remove(entry);

    // Clean up related to additional Liferay services goes here ...  

    return entry;
}
\end{verbatim}

After implementing your \texttt{delete*} method, run Service Builder to
propagate your new service method to the \texttt{*LocalService}
interface.

\section{Related Topics}\label{related-topics-18}

\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method}{Implementing
an add method}

\chapter{Implementing Methods to Get and Count
Entities}\label{implementing-methods-to-get-and-count-entities}

Service Builder generates \texttt{findBy*} methods and \texttt{countBy*}
methods in your
\href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
classes} based on your \texttt{service.xml} file's
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{finders}.
You can leverage finder methods in your local services to get and count
entities.

\begin{itemize}
\tightlist
\item
  \hyperref[getter-methods]{Getters}: \texttt{get*} methods return
  entity instances matching criteria.
\item
  \hyperref[counter-methods]{Counters}: \texttt{get*Count} methods
  return the number of instances matching criteria
\end{itemize}

Start with getting entities that match criteria.

\section{Getter Methods}\label{getter-methods}

The \texttt{findByPrimaryKey} methods and \texttt{findBy*} methods
search for and return entity instances based on criteria. Your local
service implementation must only wrap calls to the finder methods that
get what you want.

Here's how to create a method that gets an entity based on an ID
(primary key):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a method using this format:

\begin{verbatim}
public [ENTITY] get[ENTITY_NAME](long id) {
    return [ENTITY]Persistence.findByPrimaryKey(id);
}
\end{verbatim}
\item
  Replace \texttt{{[}ENTITY{]}} and \texttt{{[}ENTITY\_NAME{]}} with the
  respective entity type and entity name (or nickname).
\item
  Run Service Builder to propagate the method to your local service
  interface.
\end{enumerate}

Here's how to get entities based on criteria:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the criteria for finding the entity instance(s).
\item
  If there is no
  \href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{\texttt{finder}
  element} for the criteria, create one for it and run Service Builder.
\item
  Determine the
  \href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
  class} \texttt{findBy*} method you want to call. Depending on your
  \texttt{finder} element columns, Service Builder might overload the
  method to include these parameters:

  \begin{itemize}
  \tightlist
  \item
    \texttt{int\ start} and \texttt{int\ end} parameters for specifying
    a range of entities.
  \item
    \texttt{com.liferay.portal.kernel.util.OrderByComparator\ orderByComparator}
    parameter for arranging the matching entities.
  \end{itemize}
\item
  Specify your \texttt{get*} method signature, making sure to account
  for the \texttt{*Persistence} class \texttt{findBy*} method parameters
  you must satisfy. Use this method format:

\begin{verbatim}
public List<[ENTITY]> get[DESCRIBE_THE_ENTITIES](...) {

}
\end{verbatim}

  Replace \texttt{{[}ENTITY{]}} with the entity type. Replace
  \texttt{{[}DESCRIBE\_THE\_ENTITIES{]}} with a descriptive name for the
  entities you're getting.
\item
  Call the \texttt{*Persistence} class \texttt{findBy*} method and
  return the list of matching entities.
\item
  Run Service Builder.
\end{enumerate}

For example, \texttt{getGuestbookEntries} from
\texttt{GuestbookEntryLocalServiceImpl} returns a range of
\texttt{GuestbookEntry}s associated with a \texttt{Group} primary key:

\begin{verbatim}
public List<GuestbookEntry> getGuestbookEntries(long groupId, long guestbookId) {
    return guestbookEntryPersistence.findByG_G(groupId, guestbookId);
}
\end{verbatim}

Now you know how to leverage finder methods to get entities. Methods
that count entities are next.

\section{Counter Methods}\label{counter-methods}

Counting entities is just as easy as getting them. Your
\texttt{*Persistence} class \texttt{countBy*} methods do all the work.
Service Builder generates \texttt{countBy*} methods based on each finder
and its columns.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the criteria for entity instances you're counting and
  determine the
  \href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{\texttt{*Persistence}
  class} \texttt{countBy*} method that satisfies the criteria.
\item
  Create a \texttt{get*Count} method signature following this format:

\begin{verbatim}
public int get[DESCRIBE_THE_ENTITIES]Count(...) {

}
\end{verbatim}

  Replace \texttt{{[}DESCRIBE\_THE\_ENTITIES{]}} with a descriptive name
  for the entities you're counting.
\item
  Call the \texttt{*Persistence} class' \texttt{countBy} method and
  return the value. For example, the method \texttt{getEntriesCount}
  from \texttt{GuestbookEntryLocalServiceImpl} returns the number of
  \texttt{GuestbookEntry}s that are associated with a group (matching
  \texttt{groupId}) and a guestbook (matching \texttt{guestbookId}).
\end{enumerate}

\begin{verbatim}
public int getGuestbookEntriesCount(long groupId, long guestbookId) {
    return guestbookEntryPersistence.countByG_G(groupId, guestbookId);
}
\end{verbatim}

Now your local service can get entities matching your criteria and
return quick entity counts.

\section{Service Method Prefixes and Transactional
Aspects}\label{service-method-prefixes-and-transactional-aspects}

Service Builder applies transactions to services by adding
\texttt{@Transactional} annotations to the \texttt{*LocalService} and
\texttt{*Service} interfaces and their methods. By default, Service
Builder applies read-only transactions (e.g.,
\texttt{@Transactional\ (readOnly\ =\ true\ ...)}) to service methods
prefixed with any of these words:

\begin{itemize}
\tightlist
\item
  \texttt{dynamicQuery}
\item
  \texttt{fetch}
\item
  \texttt{get}
\item
  \texttt{has}
\item
  \texttt{is}
\item
  \texttt{load}
\item
  \texttt{reindex}
\item
  \texttt{search}
\end{itemize}

Since these methods operate in read-only transactions, Liferay DXP
optimizes their performance. Transactional service methods that don't
have the read-only setting operate in regular transactions.

\noindent\hrulefill

\textbf{Note:} A method implementation can override its interface's
\texttt{@Transactional} annotation attributes. For example, applying
\texttt{@Transactional\ (readOnly\ =\ false\ ...)} to a method
implementation makes it operate in a transaction that is not read only.

\noindent\hrulefill

\textbf{Important:} In methods that operate in read-only transactions,
invoking a service method that persists data (adds, updates, or deletes
data) must be done via the service object. Using the service object
ensures that the defined transactional behavior is applied.

\begin{verbatim}
someService.addSomething();
\end{verbatim}

For example, this \texttt{*LocalServiceImpl}'s getter method adds
(\emph{persists}) a \texttt{ClassName} object if no object with that
value exists.

\begin{verbatim}
public ClassName getClassName(String value) {
    if (Validator.isNull(value)) {
        return _nullClassName;
    }

    ClassName className = _classNames.get(value);

    if (className == null) {
        try {
            className = classNameLocalService.addClassName(value);
            ...
        }
        ...
    }
    ...
}
\end{verbatim}

Using the service object \texttt{classNameLocalService} to invoke its
\texttt{addClassName} method applies the service method's transaction
(the regular transaction specified for the method in the
\texttt{*Service} interface). If the \texttt{addClassName} method was
invoked WITHOUT using the service object, the \texttt{ClassName} object
would not persist because the method's regular transaction would not be
applied.

\section{Related Topics}\label{related-topics-19}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-an-add-method}{Implementing
an Add Method}

\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{Defining
Service Entity Finder Methods}

\href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{Understanding
the Code Generated by Service Builder}

\chapter{Implementing Any Other Business
Logic}\label{implementing-any-other-business-logic}

This section's earlier local service articles focus on CRUD methods:
methods that \textbf{c}reate (add), \textbf{r}ead (get),
\textbf{u}pdate, and \textbf{d}elete entities. But you might also need
methods that provide business logic.

Since the Guestbook application doesn't have any business logic, the
Bookmarks application, which is extremely similar, (Bookmark Folders and
Bookmark entries instead of Guestbooks and Guestbook entries) is used
here to illustrate simple business logic. Bookmarks application users
\emph{open} bookmarks (navigate to a URLs) by clicking on them.
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{BookmarksEntryLocalServiceImpl}}'s
\texttt{openEntry} method supports this functionality:

\begin{verbatim}
public BookmarksEntry openEntry(long userId, BookmarksEntry entry) {
    entry.setVisits(entry.getVisits() + 1);

    bookmarksEntryPersistence.update(entry);

    assetEntryLocalService.incrementViewCounter(
        userId, BookmarksEntry.class.getName(), entry.getEntryId(), 1);

    return entry;
}
\end{verbatim}

The \texttt{openEntry} method tracks and persists the number of visits
to the \texttt{BookmarksEntry}'s URL, increments the number of views for
the \texttt{BookmarksEntry} as an asset, and returns the
\texttt{BookmarksEntry}. This method implements required business logic
that compliments the CRUD methods.

\emph{Convenience methods} might also be appropriate for your app.
They're easier to use because they typically have these characteristics:

\begin{itemize}
\tightlist
\item
  Shorter parameter list
\item
  Intuitive name
\end{itemize}

Short parameter lists are easier to satisfy, and methods that have
intuitive names are easier to find in Javadoc.

For example, the Bookmarks application lets users move bookmarks to
different folders. Moving a bookmark can be done using the service's
\texttt{updateEntry(...)} method, but its long parameter list is
overkill since all the operation requires is the bookmarks entry and the
folder where it's going. Compare the following \texttt{update*} method
call to a convenience method call.

\textbf{Update method}:

\begin{verbatim}
bookmarksEntryLocalService.updateEntry(userId, entryId, groupId, folderId, name, url, description, serviceContext);
\end{verbatim}

\textbf{Convenience method}:

\begin{verbatim}
bookmarksEntryLocalService.moveEntry(entryId, folderId);
\end{verbatim}

Here's the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/service/impl/BookmarksEntryLocalServiceImpl.java}{\texttt{moveEntry}
method}:

\begin{verbatim}
public BookmarksEntry moveEntry(long entryId, long parentFolderId)
    throws PortalException {

    BookmarksEntry entry = getBookmarksEntry(entryId);

    entry.setFolderId(parentFolderId);
    entry.setTreePath(entry.buildTreePath());

    bookmarksEntryPersistence.update(entry);

    return entry;
}
\end{verbatim}

The \texttt{moveEntry} method retrieves the \texttt{BookmarksEntry}
entity by its ID, assigns it a new parent folder, updates its tree path,
persists all the entity's changes, and returns the entity. Convenience
methods like this one facilitate updating a subset of the entity's
attributes.

After implementing your custom business methods,
\href{/docs/7-2/appdev/-/knowledge_base/a/running-service-builder}{run
Service Builder} to propagate them to the interface.

In your local services, you can implement business logic methods that
suit your application.

\textbf{Related Topics}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-services-from-spring-service-builder-code}{Invoking
Services from Spring Service Builder Code}

\chapter{Integrating with Liferay's
Frameworks}\label{integrating-with-liferays-frameworks}

New car buyers expect certain standard features: power windows, cruise
control, floor mats (at least the cheap ones), and so on. Similarly,
users expect applications to have certain features, and those features
should behave consistently across applications.

For example, a user might expect the app's content can be shared on
social networks, tagged and rated, and discussed in comments. Liferay's
frameworks implement these features users expect to see. Integrating
with the frameworks is easy, and the frameworks provide intuitive,
consistent user experiences.

Here are some of Liferay's most popular frameworks:

\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{Permissions}:
Defines resources and permissions for entities and actions that can be
performed on them.

\href{/docs/7-2/frameworks/-/knowledge_base/f/configurable-applications}{Configurable
Applications}: Provide configuration screens in the Control Panel.

\href{/docs/7-2/frameworks/-/knowledge_base/f/the-workflow-framework}{Workflow}:
Equips entities for reviewing in workflows before publishing.

\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector}: Provides a consistent experience for browsing and selecting
entities.

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework}: Provides a way to make entity data generic, so common tasks
can be performed on them. This enables users to tag, categorize, rate,
prioritize, and comment on anything that has been asset-enabled. Users
can relate entities to each other as assets, and entities can be
published in the Asset Publisher.

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-asset-categorization-and-tagging}{Tags
  and Categories}: Enables users to tag entities and categorize them
  into logical hierarchies.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-asset-priority}{Priority}:
  Users can ascribe numerical priorities to entities.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/relating-assets}{Related
  Assets}: Users can associate one entity with another as an asset.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
  Renderer}: Enables entities appearing in Asset Publisher queries.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-comments-to-your-app}{Comments}:
  Lets users comment on entities.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Ratings}:
  Enables rating systems, such as five stars or thumbs up/down, on
  entities.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/flagging-inappropriate-asset-content}{Flags}:
  Users can flag entity content as inappropriate.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/applying-social-bookmarks}{Social
  Bookmarks}: Users can share entity content on Twitter, Facebook, and
  more.
\end{itemize}

\href{/docs/7-2/frameworks/-/knowledge_base/f/export-import}{Export/Import}:
Export entity data to and import entity data from files (\texttt{.lpkg}
files). Exported data can be imported to another portal instance or
saved for later use.

\href{/docs/7-2/frameworks/-/knowledge_base/f/staging}{Staging}: Modify
content behind the scenes without affecting the live site, and then
publish to the live site when the content is ready.

\href{/docs/7-2/frameworks/-/knowledge_base/f/search}{Search}: Index
entities for searching.

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Recycle
Bin}: Instead of deleting entities, put them into the Recycle Bin.
Entities can be restored from the Recycle Bin or deleted permanently
(manually or per a schedule).

\section{Related Topics}\label{related-topics-20}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Internationalization}

\href{/docs/7-2/frameworks/-/knowledge_base/f/javascript-module-loaders}{JavaScript
Module Loaders}

\href{/docs/7-2/reference/-/knowledge_base/r/front-end-taglibs}{Java
Taglibs}

\href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes}{Upgrade
Processes}

\chapter{Invoking Local Services}\label{invoking-local-services}

Once you deploy your services module, those services are available in
the container. Service Builder generates local and remote service
classes as OSGi Declarative Services (DS) components. These components
are accessible to other DS components, so you can invoke them from other
components, such as your web application. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a reference to the local service component.
\item
  Call the component's methods.
\end{enumerate}

There's a Blade sample called
\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-samples}{Basic
Service Builder}. Its \texttt{basic-web} module has a \texttt{Portlet}
service component that demonstrates referencing a local service
component. This module also has JSPs that invoke the component's
methods. Your first step is to add a reference to the local service
component object.

\section{Step 1: Reference the Local Service
Component}\label{step-1-reference-the-local-service-component}

Your application's Service Builder-generated local services are DS
components that you can inject into your application's other DS
components (classes annotated with \texttt{@Component})
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{using
the \texttt{@Reference} annotation}. The \texttt{basic-web} module's
\texttt{JSPPortlet} class is a \texttt{Portlet} service component that
references the \texttt{FooLocalService} local service as a DS component.

\begin{verbatim}
@Reference
private volatile FooLocalService _fooLocalService;
\end{verbatim}

The OSGi service registry wires the service implementation object to
your class that references it. The \texttt{JSPPortlet} sample class
declares the \texttt{\_fooLocalService} field to be volatile, but making
a field volatile is completely optional.

\noindent\hrulefill

\textbf{Note}: If you chose Spring as the dependency injector, Service
Builder generates \texttt{*LocalServiceImpl}, \texttt{*ServiceImpl},
\texttt{*PersistenceImpl}, and \texttt{{[}ENTITY\_NAME{]}Impl} classes
for your entities as Service Builder Spring Beans---not OSGi Declarative
Services.
\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-services-from-spring-service-builder-code}{Service
Builder Spring Beans must use means other than the \texttt{@Reference}
annotation to reference Liferay services and OSGi services}.

\noindent\hrulefill

\textbf{Important:} You should never invoke \texttt{*LocalServiceImpl}
objects directly. You should only invoke them indirectly through their
\texttt{*LocalService} service interface. The OSGi service registry
wires the service implementation object to your class.

You can make a service object available to JSPs by associating it with a
\texttt{RenderRequest} attribute. For example, the \texttt{JSPPortlet}'s
\texttt{render} method associates the \texttt{FooLocalService} object
with an attribute called \texttt{fooLocalService}.

\begin{verbatim}
@Override
public void render(RenderRequest request, RenderResponse response)
    throws IOException, PortletException {

    //set service bean
    request.setAttribute("fooLocalService", getFooLocalService());

    super.render(request, response);
}

public FooLocalService getFooLocalService() {
    return _fooLocalService;
}
\end{verbatim}

If your JSP declares the
\texttt{\textless{}portlet:defineObjects\ /\textgreater{}} tag, it can
retrieve the service object from the \texttt{RenderRequest} attribute.
For example, the \texttt{JSPPortlet}'s \texttt{init.jsp} file retrieves
the \texttt{FooLocalService} object from the \texttt{"fooLocalService"}
attribute.

\begin{verbatim}
...
<%@
page import="com.liferay.blade.samples.servicebuilder.service.FooLocalService" %>
...

<liferay-theme:defineObjects />

<portlet:defineObjects />

<%
...

//get service bean
FooLocalService fooLocalService = (FooLocalService)request.getAttribute("fooLocalService");
%>
\end{verbatim}

All JSPs that include the above \texttt{init.jsp} can use the
\texttt{fooLocalService} variable to invoke the local service
component's methods.

\section{Step 2: Call the Component's
Methods}\label{step-2-call-the-components-methods}

Now that you have the service component object, you can invoke its
methods as you would any Java object's methods.

The \texttt{basic-web} sample module's \texttt{view.jsp} and
\texttt{edit\_foo.jsp} files include the \texttt{init.jsp} shown in the
previous section. Therefore, they can access the
\texttt{fooLocalService} variable which references the service component
object. The \texttt{view.jsp} file uses the component's
\texttt{getFoosCount} method and \texttt{getFoos} method in a Liferay
Search Container that lists \texttt{Foo} instances.

\begin{verbatim}
<liferay-ui:search-container
    total="<%= fooLocalService.getFoosCount() %>"
>
    <liferay-ui:search-container-results
        results="<%= fooLocalService.getFoos(searchContainer.getStart(), searchContainer.getEnd()) %>"
    />
    ...
</liferay-ui:search-container>
\end{verbatim}

The \texttt{edit\_foo.jsp} file calls \texttt{getFoo(long\ id)} to
retrieve a \texttt{Foo} entity based on the entity instance's ID.

\begin{verbatim}
long fooId = ParamUtil.getLong(request, "fooId");
Foo foo = null;
if (fooId > 0) {
    foo = fooLocalService.getFoo(fooId);
}
\end{verbatim}

\noindent\hrulefill

\textbf{Important:} When invoking service entity updates (e.g.,
\texttt{fooService.update(object)}) for services that have MVCC enabled,
make sure to do so in transactions. Propagate rejected transactions to
the UI for the user to handle. For details, see
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#multiversion-concurrency-control-mvcc}{Multiversion
concurrency control (MVCC)}.

\noindent\hrulefill

Using the \texttt{@Reference} annotation, you can inject your
application's OSGi DS components (such as a portlet DS component) with
instances of your application's Service Builder-generated local service
components. Also you can provide your JSPs access to the component
instances via \texttt{RenderRequest} attributes.

\section{Related Topics}\label{related-topics-21}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-services-from-spring-service-builder-code}{Invoking
Local Services from Spring Service Builder Code}

\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{OSGi
Services and Dependency Injection with Declarative Services}

\chapter{Invoking Services from Spring Service Builder
Code}\label{invoking-services-from-spring-service-builder-code}

When using Spring as the dependency injector, all the services created
within a Service Builder application are wired using an internal Spring
Application Context. This uses AOP proxies to adapt the services for
transactions, indexing, and security. In a module's
\texttt{module-spring.xml} Spring Application Context file, Service
Builder defines each entity's \texttt{*LocalServiceImpl},
\texttt{*ServiceImpl}, and \texttt{*PersistenceImpl} classes as Spring
Beans. For example, Service Builder defines Spring Beans for the
\texttt{Foo} entity in the
\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-samples}{Liferay
Blade Service Builder \texttt{basic-service} sample module's}
\texttt{src/main/resources/META-INF/spring/module-spring.xml} file:

\begin{verbatim}
<?xml version="1.0"?>

<beans
    default-destroy-method="destroy"
    default-init-method="afterPropertiesSet"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
>
    <bean class="com.liferay.blade.samples.servicebuilder.service.impl.FooLocalServiceImpl" id="com.liferay.blade.samples.servicebuilder.service.FooLocalService" />
    <bean class="com.liferay.blade.samples.servicebuilder.service.impl.FooServiceImpl" id="com.liferay.blade.samples.servicebuilder.service.FooService" />
    <bean class="com.liferay.blade.samples.servicebuilder.service.persistence.impl.FooPersistenceImpl" id="com.liferay.blade.samples.servicebuilder.service.persistence.FooPersistence" parent="basePersistence" />
</beans>
\end{verbatim}

Here's a summary of the beans the example context defines:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4118}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5882}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Interface ID}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Implementation Class}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{com.liferay.blade.samples.servicebuilder.service.FooLocalService}
&
\texttt{com.liferay.blade.samples.servicebuilder.service.impl.FooLocalServiceImpl} \\
\texttt{com.liferay.blade.samples.servicebuilder.service.FooService} &
\texttt{com.liferay.blade.samples.servicebuilder.service.impl.FooServiceImpl} \\
\texttt{com.liferay.blade.samples.servicebuilder.service.persistence.FooPersistence}
&
\texttt{com.liferay.blade.samples.servicebuilder.service.persistence.impl.FooPersistenceImpl} \\
\end{longtable}

Since these classes are Spring Beans and NOT OSGi Declarative Services
components, they don't use the \texttt{@Reference} Declarative Services
annotation to inject themselves. Here are the recommended Liferay
annotations a Service Builder Spring Bean can use.

\begin{itemize}
\tightlist
\item
  Use \texttt{@BeanReference} to reference a Spring Bean that is in the
  Application Context.
\item
  Use \texttt{@ServiceReference} to reference an OSGi service.
\end{itemize}

\noindent\hrulefill

\textbf{Important:} When invoking service entity updates (e.g.,
\texttt{fooService.update(object)}) for services that have MVCC enabled,
make sure to do so in transactions. Propagate rejected transactions to
the UI for the user to handle. For details, see
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-global-service-information\#multiversion-concurrency-control-mvcc}{Multiversion
concurrency control (MVCC)}.

\noindent\hrulefill

The \texttt{@BeanReference} annotation is explained first.

\section{Referencing a Spring Bean that is in the Application
Context}\label{referencing-a-spring-bean-that-is-in-the-application-context}

A Service Builder Spring Bean class, such as a
\texttt{*LocalServiceImpl} class, should use Liferay's
\texttt{@BeanReference} annotation to access other Spring Beans the
module's Spring Application Context defines.

For example, if your service module's \texttt{service.xml} file defines
local services for entities named \texttt{Foo} and \texttt{Bar}, Service
Builder generates a \texttt{module-spring.xml} file that defines local
service Spring Beans for both entities. To inject the
\texttt{BarLocalService} Spring Bean into the
\texttt{FooLocalServiceImpl} class, for example, the
\texttt{FooLocalServiceImpl} class must declare a
\texttt{BarLocalService} field and apply an \texttt{@BeanReference}
annotation to it.

\begin{verbatim}
@BeanReference
private BarLocalService _barLocalService;
\end{verbatim}

The \texttt{@BeanReference} tells Liferay's AOP to treat the bean
reference for use in transactions, search indexing, or security, if
needed. The referencing class can invoke the Spring Bean class's
methods.

Besides the services Service Builder makes available for your
application, Service Builder Spring Bean classes can also access any
service published in the OSGi Registry. This means the following
services are available:

\begin{itemize}
\tightlist
\item
  Beans defined in Liferay's core
\item
  Beans created in other module app contexts
\item
  Services declared using OSGi Declarative Services
\item
  Services registered using the OSGi low level API
\end{itemize}

These are all OSGi services. The next section demonstrates a Service
Builder Spring Bean referencing OSGi services.

\section{Referencing OSGi Services}\label{referencing-osgi-services}

In many cases, your Service Builder code (Spring Beans) must use
external services. Liferay's \texttt{@ServiceReference} annotation lets
Liferay Spring Beans reference OSGi services.

Suppose you're building an application with a simple entity your service
module defines in its \texttt{service.xml} file. The application must
send an SMS every time a new entity is created, and the
\texttt{SMSService} is provided by a module installed in the system.

Your \texttt{*LocalServiceImpl} (Spring Bean) could use an
\texttt{@ServiceReference} annotation to reference the \emph{external}
service.

\begin{verbatim}
@ServiceReference
private SMSService _smsService;
\end{verbatim}

This annotation retrieves a reference to the OSGi service and provides
some nice benefits. None of the Spring context is created until the
\texttt{SMSService} service is available. Likewise, if the
\texttt{SMSService} suddenly disappears, the whole Spring Application
Context is destroyed. This makes Liferay Spring apps robust and
versatile.

Fortunately, Service Builder generates this kind of code for every
entity your \texttt{service.xml} file references. For example, the
\href{/docs/7-2/reference/-/knowledge_base/r/service-builder-samples}{Liferay
Blade Service Builder sample project} \texttt{basic-service} module's
\texttt{service.xml} file defines a \texttt{Foo} entity that references
an \texttt{AssetEntry} entity:

\begin{verbatim}
<reference entity="AssetEntry" package-path="com.liferay.portlet.asset" />
\end{verbatim}

Service Builder generated the \texttt{FooLocalServiceBaseImpl} class
(the base class is part of the \texttt{FooLocalServiceImpl} class's
hierarchy), which references the \texttt{AssetEntry} entity's local
service \texttt{AssetEntryLocalService} using a field annotated with
\texttt{@ServiceReference}:

\begin{verbatim}
@ServiceReference(type = com.liferay.asset.kernel.service.AssetEntryLocalService.class)
protected com.liferay.asset.kernel.service.AssetEntryLocalService assetEntryLocalService;
\end{verbatim}

Great! You now know how to add a reference to any OSGi service to a
Service Builder Spring Bean. You also know how to add a reference to any
other Spring Bean in the Application Context of your Service Builder
Spring Bean.

\section{Related Topics}\label{related-topics-22}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{Service
Trackers}

\chapter{Advanced Queries}\label{advanced-queries}

Service Builder doesn't limit you to what you can cook up with
\texttt{\textless{}finder\ /\textgreater{}} elements in
\texttt{service.xml}. If simple finders aren't sufficient for getting
data out of your application, you can use Liferay's Dynamic Query API,
which wraps Hibernate's Criteria API, or your own SQL to make exactly
the queries you need.

Though you can use custom SQL queries with Service Builder to retrieve
data from the database, sometimes it's more convenient to build queries
dynamically at runtime. You can do this with Liferay's Dynamic Query
API, which wraps Hibernate's Criteria API. The Dynamic Query API lets
you build queries without writing any SQL. It helps you think in terms
of objects and member variables instead of tables and columns. Complex
queries can be significantly easier to understand and maintain than the
equivalent custom SQL (or HQL) queries. While you technically don't need
to know SQL to construct Dynamic Queries, you still must take care to
construct efficient queries. For information on Hibernate's Criteria
API, please see
\href{http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/chapters/query/criteria/Criteria.html}{Hibernate's
manual}.

Whichever way you decide to implement your custom queries, this guide
shows you how. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If using SQL,
  \href{/docs/7-2/appdev/-/knowledge_base/a/custom-sql}{create your SQL
  query}.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/defining-a-custom-finder-method}{Define
  a custom finder method}.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/dynamic-query}{Implement
  your finder using Dynamic Query API or SQL}.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/accessing-your-custom-finder-method-from-the-service-layer}{Add
  a method to your \texttt{*LocalServiceImpl} class that invokes your
  finder}.
\end{enumerate}

Once you've taken these steps, you can access your custom finder as a
service method. Note: You can create multiple or overloaded
\texttt{findBy*} finder methods in your \texttt{*FinderImpl} class.
Next, you'll examine these steps in more detail.

\chapter{Custom SQL}\label{custom-sql}

Service Builder creates finder methods that retrieve entities by their
attributes: their column values. When you add a column as a parameter
for the finder in your \texttt{service.xml} file and run Service
Builder, it generates the finder method in your persistence layer and
adds methods to your service layer that invoke the finder. If your
queries are simple enough, consider using
\href{/docs/7-2/appdev/-/knowledge_base/a/dynamic-query}{Dynamic Query}
to access Liferay's database. If you want to do something more
complicated like JOINs, you can write your own custom SQL queries. Here,
you'll learn how.

The Guestbook application has two tables, one for guestbooks and one for
guestbook entries. The entry entity's foreign key to its guestbook is
the guestbook's ID. That is, the entry entity table,
\texttt{GB\_GuestbookEntry}, tracks an entry's guestbook by its long
integer ID in the table's \texttt{guestbookId} column. If you want to
find a guestbook entry based on its name, message, and guestbook name,
you must access the \emph{name} of the entry's guestbook. Of course,
with SQL you can join the entry and guestbook tables to include the
guestbook name. Service Builder lets you do this by specifying the SQL
as \emph{Liferay custom SQL} and invoking it in your service via a
\emph{custom finder method}.

Using Custom SQL in Service Builder is the same as using dynamic
queries; it just takes an additional first step to place the SQL you
want to run in an XML file. If you plan to use dynamic queries instead,
skip the rest of this tutorial and move on to the next one.

\section{Specify Your Custom SQL}\label{specify-your-custom-sql}

After you've tested your SQL, you must specify it in a particular file
for Liferay to access it. \texttt{CustomSQL} class (from module
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.dao.orm.custom.sql.api/}{\texttt{com.liferay.portal.dao.orm.custom.sql.api}})
retrieves SQL from a file called \texttt{default.xml} in your service
module's \texttt{src/main/resources/META-INF/custom-sql/} folder. You
must create the \texttt{custom-sql} folder and create the
\texttt{default.xml} file in that \texttt{custom-sql} folder. The
\texttt{default.xml} file must adhere to the following format:

\begin{verbatim}
<custom-sql>
    <sql id="[fully-qualified class name + method]">
    SQL query wrapped in <![CDATA[...]]>
    No terminating semi-colon
    </sql>
</custom-sql>
\end{verbatim}

Create a \texttt{custom-sql} element for every SQL query you want in
your application, and give each query a unique ID. The recommended
convention to use for the ID value is the fully-qualified class name of
the finder followed by a dot (\texttt{.}) character and the name of the
finder method. More detail on the finder class and finder methods is
provided in the next step.

For example, in the Guestbook application, you could use the following
ID value to specify a query:

\begin{verbatim}
com.liferay.docs.guestbook.service.persistence.EntryFinder.findByEntryNameEntryMessageGuestbookName
\end{verbatim}

Custom SQL must be wrapped in character data (\texttt{CDATA}) for the
\texttt{sql} element. Importantly, do not terminate the SQL with a
semi-colon. Following these rules, the \texttt{default.xml} file of the
Guestbook application specifies an SQL query that joins the
\texttt{GB\_GuestbookEntry} and \texttt{GB\_Guestbook} tables:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<custom-sql>
    <sql id="com.liferay.docs.guestbook.service.persistence.EntryFinder.findByEntryNameEntryMessageGuestbookName">
        <![CDATA[
            SELECT GB_GuestbookEntry.*
            FROM GB_GuestbookEntry
            INNER JOIN 
                GB_Guestbook ON GB_GuestbookEntry.guestbookId = GB_Guestbook.guestbookId
            WHERE
                (GB_GuestbookEntry.name LIKE ?) AND
                (GB_GuestbookEntry.message LIKE ?) AND
                (GB_Guestbook.name LIKE ?)
        ]]>
    </sql>
</custom-sql>
\end{verbatim}

Now that you've specified some custom SQL, the next step is to implement
a finder method to invoke it. The method name for the finder should
match the ID you just specified for the \texttt{sql} element.

Congratulations on developing a custom SQL query and custom finder for
your application!

\section{Related Topics}\label{related-topics-23}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-service-builder-services-service-wrappers}{Customizing
Liferay Services}

\chapter{Defining a Custom Finder
Method}\label{defining-a-custom-finder-method}

Dynamic queries and custom SQL belong in finder methods. You implement
them and then make them available through an interface. This article
demonstrates defining the finder method in an implementation class,
generating its interface and tying the implementation to the interface.

An example of this is a Guestbook application with two entities:
guestbook and entry. Each entry belongs to a guestbook so the entry
entity has a \texttt{guestbookId} field as a foreign key. If you need a
finder to search for guestbook entries by entry name and guestbook name,
you'd add a finder method to \texttt{GuestbookFinderImpl} and name it
\texttt{findByEntryNameGuestbookName}. The full method signature would
be
\texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}.
The steps are below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{{[}Entity{]}FinderImpl} class in the
  \texttt{{[}package\ \ \ \ \ \ path{]}.service.persistence.impl}
  package of your service module's \texttt{src/main/java} folder. Recall
  that you specify the \texttt{{[}package\ path{]}} in your
  \texttt{service.xml} file. Here's an example:

\begin{verbatim}
<service-builder package-path="com.liferay.docs.guestbook">
    ...
</service-builder>
\end{verbatim}
\item
  Define a \texttt{findBy*} finder method in the class you created. Make
  sure to add any required arguments to your finder method signature.
\item
  Run Service Builder to generate the appropriate interface in the
  \texttt{{[}package\ \ \ \ \ \ path{]}.service.persistence} package in
  the \texttt{service} folder of your API and service modules.

  For example, after adding
  \texttt{findByEntryNameGuestbookName(String\ entryName,\ String\ guestbookName)}
  to \texttt{GuestbookFinderImpl} and running Service Builder, the
  interface
  \texttt{com.liferay.docs.guestbook.service.persistence.GuestbookFinder}
  is generated.
\item
  Make the finder class a component (annotated with
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}})
  that implements the \texttt{GuestbookFinder} interface. For example,
  the class declaration should look like this:

\begin{verbatim}
@Component(service = GuestbookFinder.class)
public class GuestbookFinderImpl extends BasePersistenceImpl<Guestbook> implements GuestbookFinder
\end{verbatim}
\end{enumerate}

Your next step is to implement the query in your finder. You can do this
via the Dynamic Query API or Custom SQL. The next tutorial covers
Dynamic Query. To simply call custom SQL you have written, create a
finder method to run your SQL:

\begin{verbatim}
public List<Entry> findByEntryNameEntryMessageGuestbookName(
    String entryName, String entryMessage, String guestbookName,
    int begin, int end) {

    Session session = null;
    try {
        session = openSession();

        String sql = _customSQL.get(
            getClass(),
            FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME);

        SQLQuery q = session.createSQLQuery(sql);
        q.setCacheable(false);
        q.addEntity("GB_Entry", EntryImpl.class);

        QueryPos qPos = QueryPos.getInstance(q);
        qPos.add(entryName);
        qPos.add(entryMessage);
        qPos.add(guestbookName);

        return (List<Entry>) QueryUtil.list(q, getDialect(), begin, end);
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }

    return null;
}

public static final String FIND_BY_ENTRYNAME_ENTRYMESSAGE_GUESTBOOKNAME =
    EntryFinder.class.getName() +
        ".findByEntryNameEntryMessageGuestbookName";

@Reference
private CustomSQL _customSQL;
\end{verbatim}

The custom finder method opens a new Hibernate session and uses
Liferay's
\texttt{CustomSQL.get(Class\textless{}?\textgreater{}\ clazz,\ String\ id)}
method to get the custom SQL to use for the database query. The
\texttt{FIND\_BY\_ENTRYNAME\_ENTRYMESSAGE\_GUESTBOOKNAME} static field
contains the custom SQL query's ID. The
\texttt{FIND\_BY\_EVENTNAME\_EVENTDESCRIPTON\_LOCATIONNAME} string is
based on the fully-qualified class name of the \texttt{*Finder}
interface (\texttt{EventFinder}) and the name of the finder method
(\texttt{findByEntryNameEntryMessageGuestbookName}).

Awesome! You've implemented your finder class, and if you're using
custom SQL, you've even implemented a method to call your finder. If
you're using Dynamic Query, the next tutorial shows you how to implement
a dynamic query finder method.

\chapter{Dynamic Query}\label{dynamic-query}

Once you've
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-a-custom-finder-method}{defined
your custom finder method}, you can use the Dynamic Query API to
implement your query in it. Here's what you must do in your finder
method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \hyperref[using-a-hibernate-session]{Open a Hibernate Session}
\item
  \hyperref[creating-dynamic-queries]{Create a dynamic query using these
  Hibernate features}:

  \begin{itemize}
  \tightlist
  \item
    \emph{Restrictions}: Similar to \texttt{where} clauses of an SQL
    query, restrictions limit results based on criteria.
  \item
    \emph{Projections}: Modify the kind of results the query returns.
  \item
    \emph{Orders}: Organize results.
  \end{itemize}
\item
  \hyperref[executing-the-dynamic-query]{Execute the Dynamic Query and
  return the results}
\end{enumerate}

Before implementing a dynamic query in your own finder method, it can be
helpful to examine an example. The following example method uses
multiple dynamic queries and all the Hibernate features. Instructions
for implementing your own finder method follow the example.

\section{Example Finder Method:
findByGuestbookNameEntryName}\label{example-finder-method-findbyguestbooknameentryname}

This finder method for the Guestbook application retrieves a list of
Guestbook entries that have a specific name and that also belong to a
Guestbook of a specific name:

\begin{verbatim}
public List<Entry> findByEntryNameGuestbookName(String entryName, String guestbookName) {

    Session session = null;
    try {
        session = openSession();

        ClassLoader classLoader = getClass().getClassLoader();

        DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader)
            .add(RestrictionsFactoryUtil.eq("name", guestbookName))
            .setProjection(ProjectionFactoryUtil.property("guestbookId"));

        Order order = OrderFactoryUtil.desc("modifiedDate");

        DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader))
            .add(RestrictionsFactoryUtil.eq("name", entryName))
            .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
            .addOrder(order);

        List<Entry> entries = _entryLocalService.dynamicQuery(entryQuery);

        return entries;
    }
    catch (Exception e) {
        try {
            throw new SystemException(e);
        }
        catch (SystemException se) {
            se.printStackTrace();
        }
    }
    finally {
        closeSession(session);
    }
}
\end{verbatim}

The method first opens a Hibernate session. While the session is open in
the \texttt{try} block, it creates and executes a dynamic query, which
returns results (a list of guestbook \texttt{Entry} objects) if all goes
well.

The finder method has two distinct dynamic queries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first query retrieves a list of guestbook IDs corresponding to
  guestbook names that match the \texttt{guestbookName} parameter of the
  finder method.
\item
  The second query retrieves a list of guestbook entries with entry
  names that match the \texttt{entryName} parameter and have
  \texttt{guestbookId} foreign keys belonging to the list returned by
  the first query.
\end{enumerate}

Here's the first query:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class, classLoader))
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Guestbook.class,\ classLoader))}
returns a query that retrieves a list of all guestbook entities. Adding
the \texttt{.add(RestrictionsFactoryUtil.eq("name",\ guestbookName))}
restriction limits the results to only those guestbooks whose guestbook
names match the \texttt{guestbookName} parameter. The
\texttt{.setProjection(ProjectionFactoryUtil.property("guestbookId"))}
projection changes the result set from a list of guestbook entries to a
list of guestbook IDs. This is useful since guestbook IDs are much less
expensive to retrieve than full guestbook entities, and the entry query
only needs the guestbook IDs.

Next appears an order:

\begin{verbatim}
Order order = OrderFactoryUtil.desc("modifiedDate");
\end{verbatim}

This arranges the results list in descending order of the query entity's
\texttt{modifiedDate} attribute. Thus the most recently modified
entities (guestbook entries, in our example) appear first and the least
recently modified entities appear last.

Here's the second query:

\begin{verbatim}
DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader))
    .add(RestrictionsFactoryUtil.eq("name", entryName))
    .add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
    .addOrder(order);
\end{verbatim}

By default,
\texttt{DynamicQueryFactoryUtil.forClass(Entry.class,\ classLoader))}
returns a list of all guestbook entry entities. The
\texttt{.add(RestrictionsFactoryUtil.eq("name",\ entryName))}
restriction limits the results to only those guestbook entries whose
names match the finder method's \texttt{entryName} parameter.
\href{https://docs.liferay.com/dxp/portal/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{\texttt{PropertyFactoryUtil}}
is a Liferay utility class whose method
\texttt{forName(String\ propertyName)} returns the specified property.
This property can be passed to another Liferay dynamic query. This is
exactly what happens in the following line of our example:

\begin{verbatim}
.add(PropertyFactoryUtil.forName("guestbookId").in(guestbookQuery))
\end{verbatim}

Here, the code makes sure that the guestbook IDs (foreign keys) of the
entry entities in the \texttt{entityQuery} belong to the list of
guestbook IDs returned by the \texttt{guestbookQuery}. Declaring that an
entity property in one query must belong to the result list of another
query is a way to use the dynamic query API to create complex queries,
similar to SQL joins.

Lastly, the order defined earlier is applied to the entries returned by
the \texttt{findByEntryNameGuestbookName} finder method:

\begin{verbatim}
.addOrder(order);
\end{verbatim}

This orders the list of guestbook entities by the \texttt{modifiedDate}
attribute, from most recent to least recent.

Lastly, the dynamic query is invoked on the \texttt{EntryLocalService}
instance. It returns a list of \texttt{Entry} objects which are then
returned by the finder method.

\begin{verbatim}
List<Entry> entries = _entryLocalService.dynamicQuery(entryQuery);

return entries;
\end{verbatim}

It's time to implement your finder method to use Dynamic Query. Start
with opening and managing a Hibernate session.

\section{Using a Hibernate Session}\label{using-a-hibernate-session}

Your first step in implementing your custom finder method in your
\texttt{*FinderImpl} class is to open a new Hibernate session. Since
your \texttt{*FinderImpl} class extends
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}}, and
\texttt{BasePersistenceImpl\textless{}Entity\textgreater{}} contains a
session factory object and an
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/persistence/impl/BasePersistenceImpl.html\#openSession--}{\texttt{openSession}}
method, you can invoke the \texttt{openSession} method of your
\texttt{*FinderImpl}'s parent class to open a new Hibernate session. The
structure of your finder method should look like this:

\begin{verbatim}
public List<Entity> findBy-(...) {

    Session session = null;
    try {
            session = openSession();
            
            /*
            create a dynamic
            query to retrieve and return the desired list of entity
            objects
            */
    }
    catch (Exception e) {
            // Exception handling
    }
    finally {
            closeSession(session);
    }

    return null;
    /*
    Return null only if there was an error returning the
    desired list of entity objects in the try block
    */

}
\end{verbatim}

Next, in the try block, create your dynamic query objects.

\section{Creating Dynamic Queries}\label{creating-dynamic-queries}

In Liferay, you don't create criteria objects directly from the
Hibernate session. Instead, you create dynamic query objects using
Liferay's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/DynamicQueryFactoryUtil.html}{\texttt{DynamicQueryFactoryUtil}}
service. Thus, instead of

\begin{verbatim}
Criteria entryCriteria = session.createCriteria(Entry.class);
\end{verbatim}

you use

\begin{verbatim}
DynamicQuery entryQuery = DynamicQueryFactoryUtil.forClass(Entry.class, classLoader));
\end{verbatim}

In your finder method, initialize your dynamic query for your entity
class.

Most features of Hibernate's Criteria API, including restrictions,
projections, and orders, can be used on Liferay dynamic query objects.
Each criteria can be applied to your query. The restriction criteria
type is described first.

\section{Restriction Criteria}\label{restriction-criteria}

Restrictions in Hibernate's Criteria API roughly correspond to the
\texttt{where} clause of an SQL query: they offer a variety of ways to
limit the results returned by the query. You can use restrictions, for
example, to cause a query to return only results where a certain field
has a particular value, or a value in a certain range, or a non-null
value, etc.

When you need to add restrictions to a dynamic query, don't call
Hibernate's \texttt{Restrictions} class directly. Instead, use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/RestrictionsFactoryUtil.html}{\texttt{RestrictionsFactoryUtil}}
service. \texttt{RestrictionsFactoryUtil} has the same methods that
you're used to from Hibernate's \texttt{Restrictions} class:
\texttt{in}, \texttt{between}, \texttt{like}, \texttt{eq}, \texttt{ne},
\texttt{gt}, \texttt{ge}, \texttt{lt}, \texttt{le}, etc.

Thus, instead of using this call to specify that a guestbook must have a
certain name,

\begin{verbatim}
entryCriteria.add(Restrictions.eq("name", guestbookName));
\end{verbatim}

you use

\begin{verbatim}
entryQuery.add(RestrictionsFactoryUtil.eq("name", guestbookName));
\end{verbatim}

The restriction above limits the results to guestbook entries whose
\texttt{name} attribute matches the value of the variable
\texttt{guestbookName}. Add the restrictions you need to get the results
you want.

Projections are the next criteria type. They let you transform the query
results to return the field type you desire.

\section{Projection Criteria}\label{projection-criteria}

Projections in Hibernate's Criteria API let you modify the kind of
results returned by a query. For example, if you don't want your query
to return a list of entity objects (the default), you can set a
projection on a query to return only a list of the values of a certain
entity field, or fields. You can also use projections on a query to
return the maximum or minimum value of an entity field, or the sum of
all the values of a field, or the average, etc. For more information on
restrictions and projections, please refer to Hibernate's
\href{http://docs.jboss.org/hibernate/orm/3.6/reference/en-US/html/querycriteria.html}{documentation}.

Similarly, to set projections, create properties via Liferay's
\href{https://docs.liferay.com/dxp/portal/7.0-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/PropertyFactoryUtil.html}{PropertyFactoryUtil}
service instead of through Hibernate's \texttt{Property} class. Thus,
instead of

\begin{verbatim}
entryCriteria.setProjection(Property.forName("guestbookId"));
\end{verbatim}

you use

\begin{verbatim}
entryQuery.setProjection(PropertyFactoryUtil.forName("guestbookId"));
\end{verbatim}

The projection above specifies the \texttt{guestbookId} entity field to
changes the result set to a list of those field values. If you want to
return a specific field type from your entities, add a projection for
it.

The last criteria type lets you organize results your way.

\section{Order Criteria}\label{order-criteria}

Orders in Hibernate's Criteria API let you control the order of the
elements in the list a query returns. You can choose the property or
properties to which an order applies as well as whether they're in
ascending or descending order.

This code creates an order by the entity's \texttt{modifiedDate}
attribute:

\begin{verbatim}
Order order = OrderFactoryUtil.desc("modifiedDate");
\end{verbatim}

When you apply this order, the results are arranged in descending order
of the query entity's \texttt{modifiedDate} attribute. Thus the most
recently modified entities (guestbook entries, in our example) appear
first and the least recently modified entities appear last.

Like Hibernate criteria, Liferay's dynamic queries are
\emph{chain-able}: you can add criteria to, set projections on, and add
orders to Liferay's dynamic query objects just by appending the
appropriate method calls to the query object. For example, the following
snippet demonstrates chaining a restriction criterion and a projection
to a dynamic query object declaration:

\begin{verbatim}
DynamicQuery guestbookQuery = DynamicQueryFactoryUtil.forClass(Guestbook.class)
    .add(RestrictionsFactoryUtil.eq("name", guestbookName))
    .setProjection(ProjectionFactoryUtil.property("guestbookId"));
\end{verbatim}

It's time to execute your dynamic query.

\section{Executing the Dynamic Query}\label{executing-the-dynamic-query}

In the previous article, you ran Service Builder after
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-a-custom-finder-method}{defining
your custom finder}. Service Builder generated a
\texttt{dynamicQuery(DynamicQuery\ dynamicQuery)} method in your
\texttt{*LocalServiceBaseImpl} class. Using a \texttt{*LocalService}
instance, invoke \texttt{dynamicQuery} method, passing it your dynamic
query. Here's an example dynamic query execution.

\begin{verbatim}
List<Entity> entities = _someLocalService.dynamicQuery(entityQuery);

return entities;
\end{verbatim}

The dynamic query execution returns a list of entities and the finder
method returns that list.

\noindent\hrulefill

\textbf{Note:} Service Builder not only generates a
\texttt{public\ List\ \ dynamicQuery(DynamicQuery\ dynamicQuery)} method
in \texttt{*LocalServiceBaseImpl} but it also generates
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ \ start,\ int\ end)}
and
\texttt{public\ List\ dynamicQuery(DynamicQuery\ dynamicQuery,\ int\ \ start,\ int\ end,\ OrderByComparator\ orderByComparator)}
methods. You can go back to
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-a-custom-finder-method}{defining
custom finder methods} and either modify your finder method or create
overloaded versions of it to take advantage of these extra methods and
their parameters. The \texttt{int\ start} and \texttt{int\ \ end}
parameters are useful when paginating a result list. \texttt{start} is
the lower bound of the range of model entity instances and \texttt{end}
is the upper bound. The \texttt{OrderByComparator\ orderByComparator} is
the comparator by which to order the results.

\noindent\hrulefill

To use the overloaded \texttt{dynamicQuery} methods of your
\texttt{*LocalServiceBaseImpl} class in the (optionally overloaded)
custom finders of your \texttt{*FinderImpl} class, just choose the
appropriate methods for running the dynamic queries:
\texttt{dynamicQuery(entryQuery)}, or
\texttt{dynamicQuery(entryQuery,\ start,\ end)} or
\texttt{dynamicQuery(entryQuery,\ start,\ end,\ orderByComparator)}.

Great! You've now created a finder method using Liferay's Dynamic Query
API. Your last step is to add a service method that calls your finder.

\chapter{Accessing Your Custom Finder Method from the Service
Layer}\label{accessing-your-custom-finder-method-from-the-service-layer}

So far, you've created a \texttt{*FinderImpl} class, defined a
\texttt{findBy*} finder method in that class, and implemented the finder
method using Dynamic Query or custom SQL. Now how do you call your
finder method from the service layer?

When you ran Service Builder (if you haven't run it yet; run it now),
the \texttt{*Finder} interface was generated (e.g.,
\texttt{GuestbookFinder}). For proper separation of concerns, only a
local or remote service implementation (i.e., \texttt{*LocalServiceImpl}
or \texttt{*ServiceImpl}) in your service module should invoke the
\texttt{*Finder} class. The portlet classes in your application's web
module invoke the business logic of the services published from your
application's service module. The services, in turn, access the data
model using the persistence layer's finder classes.

\noindent\hrulefill

\textbf{Note:} In previous versions of Liferay DXP, your finder methods
were accessible via \texttt{*FinderUtil} utility classes. Finder methods
are now injected into your app's local services, removing the need to
call finder utilities.

\noindent\hrulefill

You'll add a method in the \texttt{*LocalServiceImpl} class that invokes
the finder method implementation via the \texttt{*Finder} class. Then
you'll rebuild your application's service layer so that the portlet
classes and JSPs in your web module can access the services.

For example, for the Guestbook application, you'd add the following
method to the \texttt{GuestbookEntryLocalServiceImpl} class:

\begin{verbatim}
public List<GuestbookEntry> findByEntryNameGuestbookName(String entryName,
    String guestbookName) throws SystemException {

    return entryFinder.findByEntryNameGuestbookName(String entryName,
        String guestbookName);
}
\end{verbatim}

After you've added your \texttt{findBy*} method to your
\texttt{*LocalServiceImpl} class, run Service Builder to generate the
interface and make the finder method available in the
\texttt{EntryLocalService} class.

Now you can indirectly call the finder method from your portlet class or
from a JSP by calling
\texttt{\_entryLocalService.findByEntryNameGuestbookName(...)}!

Congratulations on following the process of developing custom queries in
a custom finder and exposing it as a service for your portlet!

\section{Related Topics}\label{related-topics-24}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Service}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\chapter{Actionable Dynamic Queries}\label{actionable-dynamic-queries}

Suppose you have over a million users, and you want to perform some kind
of mass update to some of them. One approach might be to use a dynamic
query to retrieve the list of users in question. Once loaded into
memory, you could loop through the list and update each user. However,
with over a million users, the memory cost of such an operation would be
too great. In general, retrieving large numbers of Service Builder
entities using dynamic queries requires too much memory and time.

Liferay actionable dynamic queries solve this problem. Actionable
dynamic queries use a pagination strategy to load only small numbers of
entities into memory at a time and perform processing (i.e., perform an
\emph{action}) on each entity. So instead of trying to use a dynamic
query to load a million users into memory and then perform some
processing on each of them, a much better strategy is to use an
actionable dynamic query. This way, you can still process your million
users, but only small numbers are loaded into memory at a time.

Here's how to use actionable dynamic query:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/ActionableDynamicQuery.html}{\texttt{ActionableDynamicQuery}}
  from your \texttt{*LocalService} by invoking its
  \texttt{getActionableDynamicQuery} method.
\item
  Add query criteria and constraints, using the query's
  \texttt{setAddCriteriaMethod} and \texttt{setAddOrderCriteriaMethod}
  methods.
\item
  Set an action to perform on the matching entities, using
  \texttt{setPerformActionMethod}.
\item
  Execute the action on each matching entity, by invoking the query's
  \texttt{performActions} method.
\end{enumerate}

This method from a sample portlet creates an actionable dynamic query,
adds a query restriction and an action, and executes the query:

\begin{verbatim}
protected void massUpdate() {
    ActionableDynamicQuery adq = _barLocalService.getActionableDynamicQuery();
    
    adq.setAddCriteriaMethod(new ActionableDynamicQuery.AddCriteriaMethod() {
        
        @Override
        public void addCriteria(DynamicQuery dynamicQuery) {
            dynamicQuery.add(RestrictionsFactoryUtil.lt("field3", 100));
        }
        
    });
    
    adq.setPerformActionMethod(new ActionableDynamicQuery.PerformActionMethod<Bar>() {
        
        @Override
        public void performAction(Bar bar) {
            int field3 = bar.getField3();
            field3++;
            bar.setField3(field3);
            _barLocalService.updateBar(bar);
        }
        
    });
    
    try {
        adq.performActions();
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}
\end{verbatim}

The example method demonstrates executing an actionable dynamic query on
\texttt{Bar} entities that match certain criteria.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve an
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/ActionableDynamicQuery.html}{\texttt{ActionableDynamicQuery}}
  from local service \texttt{BarLocalService}.

\begin{verbatim}
ActionableDynamicQuery adq = _barLocalService.getActionableDynamicQuery();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Service Builder generates method `getActionableDynamicQuery()` in
 each entity's `*LocalService` interface and implements it in each entity's
 `*BaseLocalServiceImpl` class.
 
     @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
     public ActionableDynamicQuery getActionableDynamicQuery();
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Set query criteria to match \texttt{field3} values less than
  \texttt{100}.

\begin{verbatim}
adq.setAddCriteriaMethod(new ActionableDynamicQuery.AddCriteriaMethod() {

     @Override
     public void addCriteria(DynamicQuery dynamicQuery) {
         dynamicQuery.add(RestrictionsFactoryUtil.lt("field3", 100));
     }

 });
\end{verbatim}
\item
  Set an action to perform. The action increments the matching entity's
  \texttt{field3} value.

\begin{verbatim}
adq.setPerformActionMethod(new ActionableDynamicQuery.PerformActionMethod<Bar>() {

     @Override
     public void performAction(Bar bar) {
         int field3 = bar.getField3();
         field3++;
         bar.setField3(field3);
         _barLocalService.updateBar(bar);
     }

 });
\end{verbatim}
\item
  Execute the action on each matching entity.

\begin{verbatim}
try {
    adq.performActions();
}
catch (Exception e) {
    e.printStackTrace();
}
\end{verbatim}
\end{enumerate}

Actionable dynamic queries let you act on large numbers of entities in
smaller groups. It's an efficient and high performing way to update
entities.

\section{Related Topics}\label{related-topics-25}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Creating
Local Service}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\chapter{REST Builder}\label{rest-builder}

\noindent\hrulefill

\textbf{Note:} This documentation is in beta. Stay tuned for more to
come!

\noindent\hrulefill

Liferay DXP's headless REST APIs follow the
\href{https://swagger.io/docs/specification/about/}{OpenAPI}
specification and let your apps consume RESTful web services. These APIs
are developed using a mixture of the Contract First and Contract Last
development approaches. This presents a best-of-both-worlds approach to
API development. For more detailed information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/headless-rest-apis}{Headless
REST APIs}.

Here, you'll learn how to use Liferay's
\href{https://github.com/liferay/liferay-portal/tree/master/modules/util/portal-tools-rest-builder}{REST
Builder tool} to create headless REST APIs for your own apps. REST
Builder is an API generator that consumes OpenAPI profiles and generates
the API scaffolding: JAX-RS endpoints, parsing, XML generation, and
advanced features like filtering or multipart (binary file) support. The
developer only has to fill in the resource implementations, calling
Liferay DXP's remote services.

Read on to learn how to generate REST services with REST Builder!

\chapter{Generating APIs with REST
Builder}\label{generating-apis-with-rest-builder}

\noindent\hrulefill

\textbf{Note:} This documentation is in beta. Stay tuned for more to
come!

\noindent\hrulefill

Follow these steps to use REST Builder to create a headless REST API for
your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{project}.
\item
  Install REST Builder. For instructions on this, see
  \href{/docs/7-2/reference/-/knowledge_base/r/rest-builder-gradle-plugin}{REST
  Builder Gradle Plugin}.
\item
  Run \texttt{gradlew\ clean\ deploy}. Note that your Gradle wrapper may
  not be in your app's project directory, so you may need to use
  \texttt{..} to locate it (e.g.,
  \texttt{../../../gradlew\ clean\ deploy}).
\item
  Create the \texttt{*-api} and \texttt{*-impl} projects with the usual
  files (\texttt{build.gradle}, \texttt{bnd.bnd}). Also create a
  \texttt{rest-config.yaml} with the author, paths, and packages. For
  example, here's the \texttt{rest-config.yaml} for Liferay's
  \texttt{headless-delivery} API:

\begin{verbatim}
apiDir: "../headless-delivery-api/src/main/java"
apiPackagePath: "com.liferay.headless.delivery"
application:
    baseURI: "/headless-delivery"
    className: "HeadlessDeliveryApplication"
    name: "Liferay.Headless.Delivery"
author: "Javier Gamarra"
clientDir: "../headless-delivery-client/src/main/java"
testDir: "../headless-delivery-test/src/testIntegration/java"
\end{verbatim}
\item
  In your \texttt{*-impl} module's root folder, write your OpenAPI
  profile in YAML. You can use the
  \href{https://editor.swagger.io/}{Swagger Editor} to validate syntax
  and ensure compliance with the OpenAPI specification.
\item
  In your \texttt{*-impl} module folder, run \texttt{gradlew\ buildREST}
  (make sure you locate your Gradle wrapper as instructed in step two
  above).
\item
  REST Builder generates the interfaces with the JAX-RS endpoints. It
  also generates a \texttt{*ResourceImpl} class where you must implement
  the business logic for each service.
\item
  After implementing the business logic for each service, deploy your
  modules. Your APIs are then available at this URL:

\begin{verbatim}
http://[host]:[port]/o/[APPLICATION_CLASSNAME]/[OPEN_API_VERSION]/
\end{verbatim}

  You can also execute \texttt{jaxrs:check} in the OSGi console to see
  all the JAX-RS endpoints.
\end{enumerate}

\section{Related Topics}\label{related-topics-26}

\href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder}

\href{/docs/7-2/frameworks/-/knowledge_base/f/headless-rest-apis}{Headless
REST APIs}

\href{/docs/7-2/reference/-/knowledge_base/r/rest-builder-gradle-plugin}{REST
Builder Gradle Plugin}

\chapter{Troubleshooting Application Development
Issues}\label{troubleshooting-application-development-issues}

When coding on any platform, you can sometimes run into issues that have
no clear resolution. This can be particularly frustrating. If you have
issues building, deploying, or running apps and modules, you want to
resolve them fast. These frequently asked questions and answers help you
troubleshoot and correct problems.

Here are the troubleshooting sections:

\begin{itemize}
\tightlist
\item
  \hyperref[modules]{Modules}
\item
  \hyperref[services-and-components]{Services and Components}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/troubleshooting-front-end-development-issues}{Front-end}
\end{itemize}

Click a question to view the answer.

\section{Modules}\label{modules}

{How can I configure dependencies on Liferay artifacts?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies">Configuring Dependencies</a>. </p>
\end{verbatim}

{What are optional package imports and how can I specify them?~{}}

\begin{verbatim}
<p>When developing modules, you can declare <em>optional</em> package imports. An optional package import is one your module can use if it's available, but can still function without it. <a href="/docs/7-2/appdev/-/knowledge_base/a/declaring-optional-import-package-requirements">Specifying optional package imports</a> is straightforward. </p>
\end{verbatim}

{How can I connect to a JNDI data source from my module?~{}}

\begin{verbatim}
<p>Connecting to an application server's JNDI data sources from Liferay's OSGi environment is almost the same as connecting to them from the Java EE environment. In an OSGi environment, the only difference is that you must <a href="/docs/7-2/appdev/-/knowledge_base/a/connecting-to-data-sources-using-jndi">use Liferay DXP's class loader to load the application server's JNDI classes</a>. </p>
\end{verbatim}

{My module has an unresolved requirement. What can I do?~{}}

\begin{verbatim}
<p>If one of your bundles imports a package that no other bundle in the Liferay OSGi runtime exports, Liferay DXP reports an unresolved requirement:</p>
<pre><code>! could not resolve the bundles: ...
Unresolved requirement: Import-Package: ...
...
Unresolved requirement: Require-Capability ...
</code></pre>
<p>To satisfy the requirement, <a href="/docs/7-2/appdev/-/knowledge_base/a/resolving-bundle-requirements">find a module that provides the capability, add it to your build file's dependencies, and deploy it</a>. </p>
\end{verbatim}

{An IllegalContextNameException reports that my bundle's context name
does not follow Bundle-SymbolicName syntax. How can I fix the context
name?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/appdev/-/knowledge_base/a/resolving-bundle-symbolicname-syntax-issues">Adjust the <code>Bundle-SymbolicName</code> to adhere to the syntax</a>. </p>
\end{verbatim}

{How can I adjust my module's logging?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-2/appdev/-/knowledge_base/a/adjusting-module-logging">Adjusting Module Logging</a>. </p>
\end{verbatim}

{How can I implement logging in my module or plugin?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/appdev/-/knowledge_base/a/implementing-logging">Use Simple Logging Facade for Java (SLF4J) to log messages</a>.</p>
\end{verbatim}

{After creating a relational mapping between Service Builder entities,
my portlet is using too much memory. What can I do?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/appdev/-/knowledge_base/a/disabling-cache-for-table-mapper-tables">Disabling the cache related to the entity mapping lowers memory usage.</a>.</p>
\end{verbatim}

\section{Services and Components}\label{services-and-components}

{How can I see what's happening in the OSGi container?~{}}

\begin{verbatim}
<p><a href="/docs/7-2/appdev/-/knowledge_base/a/system-check">Run a System Check.</a>. </p>
\end{verbatim}

{How can I detect unresolved OSGi components?~{}}

\begin{verbatim}
<p>module components that use Service Builder use Dependency Manager (DM) and most other module components use Declarative Services (DS). <a href="/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components">Gogo shell commands and tools help you find and inspect unsatisfied component references for DM and DS components</a>. </p>
\end{verbatim}

{What is the safest way to call OSGi services from non-OSGi code?~{}}

\begin{verbatim}
<p>See <a href="/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker
\end{verbatim}

``\textgreater Calling Non-OSGi Code that Uses OSGi Services.

\chapter{Adjusting Module Logging}\label{adjusting-module-logging}

Liferay DXP uses \href{http://logging.apache.org/log4j/1.2/}{Log4j}
logging services. Here are the ways to configure logging for module
classes and class hierarchies.

\begin{itemize}
\tightlist
\item
  \emph{Log Levels} in
  \href{/docs/7-2/user/-/knowledge_base/u/server-administration}{Liferay
  DXP's UI}
\item
  Configure Log4j for multiple modules in a
  \texttt{{[}anyModule{]}/src/main/resources/META-INF/module-log4j.xml}
  file.
\item
  Configure Log4j for a specific module in a
  \texttt{{[}Liferay\ Home{]}/osgi/log4j/{[}symbolicNameOfBundle{]}-log4j-ext.xml}
  file.
\item
  Configure Log4j for an OSGi fragment host module in a
  \texttt{/META-INF/module-log4j-ext.xml} file
\end{itemize}

Here's an example Log4j XML configuration:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <category name="org.foo">
        <priority value="DEBUG" />
    </category>
</log4j:configuration>
\end{verbatim}

Use \texttt{category} elements to specify each class or class hierarchy
to log messages for. Set the \texttt{name} attribute to that class name
or root package. The example category sets logging for the class
hierarchy starting at package \texttt{org.foo}. Log messages at or above
the \texttt{DEBUG} log level are printed for classes in \texttt{org.foo}
and classes in packages starting with \texttt{org.foo}.

Set each category's \texttt{priority} element to the log
\href{http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html}{level}
(priority) you want.

\begin{itemize}
\tightlist
\item
  ALL
\item
  TRACE
\item
  DEBUG
\item
  INFO
\item
  WARN
\item
  ERROR
\item
  FATAL
\item
  OFF
\end{itemize}

The log messages are printed to Liferay log files in
\texttt{{[}Liferay\_Home{]}/logs}.

You can see examples of module logging in several Liferay sample
projects. For example, the
\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/apps/action-command-portlet}{action-command-portlet},
\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/extensions/document-action}{document-action},
and
\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/apps/service-builder/jdbc}{service-builder/jdbc}
samples (among others) leverage module logging.

\noindent\hrulefill

\textbf{Note:} If the log level configuration isn't appearing (e.g., you
set the log level to \texttt{ERROR} but you're still getting
\texttt{WARN} messages), make sure the log configuration file name
prefix matches the module's symbolic name. If you have bnd installed,
output from command \texttt{bnd\ print\ {[}path-to-bundle{]}} includes
the module's symbolic name
(\href{https://github.com/bndtools/bnd/wiki/Install-bnd-on-the-command-line}{Here}
are instructions for installing bnd for the command line).

\noindent\hrulefill

That's it for module log configuration. You're all set to print the
information you want.

\section{Related Topics}\label{related-topics-27}

\href{/docs/7-2/appdev/-/knowledge_base/a/implementing-logging}{Implementing
Logging}

\chapter{Identifying Liferay Artifact Versions for
Dependencies}\label{identifying-liferay-artifact-versions-for-dependencies}

When you're developing an application using Liferay APIs or tools---for
example, you might create a Service Builder application or use Message
Bus or Asset Framework---you must determine which versions of Liferay
artifacts (modules, apps, etc.) you application's modules must specify
as dependencies. To learn how to find Liferay artifacts and configure
dependencies on them, see
\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}.

\section{Related Topics}\label{related-topics-28}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\chapter{Resolving Bundle-SymbolicName Syntax
Issues}\label{resolving-bundle-symbolicname-syntax-issues}

Liferay's OSGi Runtime framework sometimes throws an
\texttt{IllegalContextNameException}. Often, this is because an OSGi
bundle's \texttt{Bundle-SymbolicName} manifest header has a space in it.

The \texttt{Bundle-SymbolicName} uniquely identifies the bundle---along
with the \texttt{Bundle-Version} manifest header---and cannot contain
spaces. To follow naming best practices, use a reverse-domain name in
your \texttt{Bundle-SymbolicName}. For example, a module with the domain
\texttt{troubleshooting.liferay.com} would be reversed to
\texttt{com.liferay.troubleshooting.}.

There are three ways to specify a bundle's \texttt{Bundle-SymbolicName}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{Bundle-SymbolicName} header in a bundle's \texttt{bnd.bnd}
  file.
\item
  \texttt{Bundle-SymbolicName} header in a plugin WAR's
  \texttt{liferay-plugin-package.properties} file.
\item
  Plugin WAR file name, if the WAR's
  \texttt{liferay-plugin-package.properties} has no
  \texttt{Bundle-SymbolicName} header.
\end{enumerate}

For plugin WARs, specifying the \texttt{Bundle-SymbolicName} in the
\texttt{liferay-plugin-package.properties} file is preferred.

For example, if you deploy a plugin WAR that has no
\texttt{Bundle-SymbolicName} header in its
\texttt{liferay-plugin-package.properties}, the
\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{WAB
Generator} uses the WAR's name as the WAB's
\texttt{Bundle-SymbolicName}. If the WAR's name has a space in it (e.g.,
\texttt{space-program-theme\ v1.war}) an
\texttt{IllegalContextNameException} occurs on deployment.

\begin{verbatim}
org.apache.catalina.core.ApplicationContext.log The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
org.eclipse.equinox.http.servlet.internal.error.IllegalContextNameException: The context name 'space-program-theme v1' does not follow Bundle-SymbolicName syntax.
\end{verbatim}

However you set your a \texttt{Bundle-SymbolicName}, refrain from using
spaces.

\section{Related Topics}\label{related-topics-29}

\href{/docs/7-2/customization/-/knowledge_base/c/deploying-wars-wab-generator}{Using
the WAB Generator}

\chapter{Calling Non-OSGi Code that Uses OSGi
Services}\label{calling-non-osgi-code-that-uses-osgi-services}

Liferay DXP's static service utilities (e.g., \texttt{UserServiceUtil},
\texttt{CompanyServiceUtil}, \texttt{GroupServiceUtil}, etc.) are
examples of non-OSGi code that use OSGi services. Service Builder
generates them for backwards compatibility purposes only. If you're
tempted to call a \texttt{*ServiceUtil} class or your existing code
calls one, access the \texttt{*Service} directly instead using one these
alternatives:

\begin{itemize}
\item
  If your class is a Declarative Services component, use an
  \href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
  annotation} to access the \texttt{*Service} class.
\item
  If your class isn't a Declarative Services component, use a
  \href{/docs/7-2/frameworks/-/knowledge_base/f/service-trackers-for-osgi-services}{\texttt{ServiceTracker}}
  to access the \texttt{*Service} class.
\end{itemize}

You can check the state of Liferay DXP's services in
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{the
Gogo shell}. The \texttt{scr:list} Gogo shell command shows all
Declarative Services components, including inactive ones from
unsatisfied dependencies. To find unsatisfied dependencies for Service
Builder services, use the Dependency Manager's
\texttt{dependencymanager:dm\ wtf} command. Note that these commands
only show components that haven't been activated because of unsatisfied
dependencies. They don't show pure service trackers that are waiting for
a service because of unsatisfied dependencies.

\section{Related Topics}\label{related-topics-30}

\href{/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\chapter{Connecting to JNDI Data
Sources}\label{connecting-to-jndi-data-sources}

Connecting to an application server's JNDI data sources from Liferay
DXP's OSGi environment is almost the same as connecting to them from the
Java EE environment. In an OSGi environment, the only difference is that
you must use Liferay DXP's class loader to load the application server's
JNDI classes. The following code demonstrates this.

\begin{verbatim}
Thread thread = Thread.currentThread();

// Get the thread's class loader. You'll reinstate it after using
// the data source you look up using JNDI

ClassLoader origLoader = thread.getContextClassLoader();

// Set Liferay's class loader on the thread

thread.setContextClassLoader(PortalClassLoaderUtil.getClassLoader());

try {

        // Look up the data source and connect to it

        InitialContext ctx = new InitialContext();
        DataSource datasource = (DataSource)
            ctx.lookup("java:comp/env/jdbc/TestDB");

        Connection connection = datasource.getConnection();
        Statement statement = connection.createStatement();

        // Execute SQL statements here ...

        connection.close();
}
catch (NamingException ne) {

    ne.printStackTrace();
}
catch (SQLException sqle) {

    sqle.printStackTrace();
}
finally {
       // Switch back to the original context class loader

       thread.setContextClassLoader(origLoader);
}
\end{verbatim}

The example code sets Liferay DXP's classloader on the thread to access
the JNDI API.

\begin{verbatim}
thread.setContextClassLoader(PortalClassLoaderUtil.getClassLoader());
\end{verbatim}

It uses JNDI to look up the data source.

\begin{verbatim}
InitialContext ctx = new InitialContext();
DataSource datasource = (DataSource)
    ctx.lookup("java:comp/env/jdbc/TestDB"); 
\end{verbatim}

After working with the data source, the code reinstates the thread's
original classloader.

\begin{verbatim}
thread.setContextClassLoader(origLoader);
\end{verbatim}

Here are the class imports for the example code:

\begin{verbatim}
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import com.liferay.portal.kernel.util.PortalClassLoaderUtil;
\end{verbatim}

Your applications can use similar code to access a data source. Make
sure to substitute \texttt{jdbc/TestDB} with your data source name.

\noindent\hrulefill

\textbf{Note}: An OSGi bundle's attempt to connect to a JNDI data source
without using Liferay DXP's classloader results in a
\texttt{java.lang.ClassNotFoundException}. For example, here's an
exception from attempting to use Apache Tomcat's JNDI API without using
Liferay DXP's classloader:

\begin{verbatim}
 javax.naming.NoInitialContextException: Cannot instantiate class:
 org.apache.naming.java.javaURLContextFactory [Root exception is
 java.lang.ClassNotFoundException:
 org.apache.naming.java.javaURLContextFactory]
\end{verbatim}

\noindent\hrulefill

An easier way to work with databases is to connect to them using Service
Builder.

\chapter{Detecting Unresolved OSGi
Components}\label{detecting-unresolved-osgi-components}

Liferay DXP includes
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell} commands that come in handy when trying to diagnose a problem due
to an unresolved OSGi component. The specific tools to use depend on the
component framework of the unresolved component. Most Liferay DXP
components are developed using Declarative Services (DS), also known as
SCR (Service Component Runtime). An exception to this is Liferay DXP's
Service Builder services, which are Dependency Manager (DM) components.
Both
\href{http://felix.apache.org/documentation/subprojects/apache-felix-service-component-runtime.html}{Declarative
Services} and
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{Dependency
Manager} are Apache Felix projects.

The unresolved component troubleshooting instructions are divided into
these sections:

\begin{itemize}
\tightlist
\item
  \hyperref[declarative-services-components]{Declarative Services
  Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
    Services Unsatisfied Component Scanner}
  \item
    \hyperref[dsunsatisfied-command]{ds:unsatisfied Command}
  \end{itemize}
\item
  \hyperref[service-builder-components]{Service Builder Components}

  \begin{itemize}
  \tightlist
  \item
    \hyperref[unavailable-component-scanner]{Unavailable Component
    Scanner}
  \item
    \hyperref[dm-na-command]{dm na Command}
  \item
    \hyperref[serviceproxyfactory]{\texttt{ServiceProxyFactory}}
  \end{itemize}
\end{itemize}

\section{Declarative Services
Components}\label{declarative-services-components}

Start with DS, since most Liferay DXP components, apart from Service
Builder components, are DS components. Suppose one of your bundle's
components has an unsatisfied service reference. How can you detect
this? Two ways:

\begin{itemize}
\item
  Enable a
  \hyperref[declarative-services-unsatisfied-component-scanner]{Declarative
  Services Unsatisfied Component Scanner} to report unsatisfied
  references automatically or
\item
  Use the \hyperref[dsunsatisfied-command]{Gogo shell command
  \texttt{ds:unsatisfied}} to check for them manually.
\end{itemize}

\section{Declarative Services Unsatisfied Component
Scanner}\label{declarative-services-unsatisfied-component-scanner}

Here's how to enable the unsatisfied component scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a file
  \texttt{com.liferay.portal.osgi.debug.declarative.service.internal.configuration.UnsatisfiedComponentScannerConfiguration.cfg}.
\item
  Add the following content:

\begin{verbatim}
unsatisfiedComponentScanningInterval=5
\end{verbatim}
\item
  Copy the file into \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner detects and logs unsatisfied service component references.
The log message describes the bundle, the referencing DS component
class, and the referenced component.

Here's an example scanner message:

\begin{verbatim}
11:18:28,881 WARN  [Declarative Service Unsatisfied Component Scanner][UnsatisfiedComponentScanner:91]
Bundle {id: 631, name: com.liferay.blogs.web, version: 2.0.0}
    Declarative Service {id: 3333, name: com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand, unsatisfied references:
        {name: ItemSelectorHelper, target: null}
    }
\end{verbatim}

The message above warns that the \texttt{com.liferay.blogs.web} bundle's
DS component
\texttt{com.liferay.blogs.web.internal.portlet.action.EditEntryMVCRenderCommand}
has an unsatisfied reference to a component of type
\texttt{ItemSelectorHelper}. The referencing component's ID (SCR ID) is
\texttt{3333} and its bundle ID is \texttt{631}.

\section{ds:unsatisfied Command}\label{dsunsatisfied-command}

Another way to detect unsatisfied component references is to invoke the
Gogo shell command \texttt{ds:unsatisfied}.

\begin{itemize}
\tightlist
\item
  \texttt{ds:unsatisfied} shows all unsatisfied DS components
\item
  \texttt{ds:unsatisfied\ {[}BUNDLE\_ID{]}} shows the bundle's
  unsatisfied DS components
\end{itemize}

To view more detailed information about the unsatisfied DS component,
pass the component's ID to the command
\texttt{scr:info\ {[}component\ ID{]}}. For example, the following
command does this for a component with ID \texttt{1701}:

\begin{verbatim}
g! scr:info 1701
*** Bundle: org.foo.bar.command (507)
Component Description:
    Name: org.foo.bar.command
    Implementation Class: org.foo.bar.command.FooBarCommand
    Default State: enabled
    Activation: delayed
    Configuration Policy: optional
    Activate Method: activate
    Deactivate Method: deactivate
    Modified Method: -
    Configuration Pid: [org.foo.bar.command]
    Services:
        org.foo.bar.command.DuckQuackCommand
    Service Scope: singleton
    Reference: Duck
        Interface Name: org.foo.bar.api.Foo
        Cardinality: 1..1
        Policy: static
        Policy option: reluctant
        Reference Scope: bundle
    Component Description Properties:
        osgi.command.function = foo
        osgi.command.scope = bar
    Component Configuration:
        ComponentId: 1701
        State: unsatisfied reference
        UnsatisfiedReference: Foo
        Target: null
        (no target services)
        Component Configuration Properties:
        component.id = 1701
        component.name = org.foo.bar.command
        osgi.command.function = foo
        osgi.command.scope = bar
\end{verbatim}

In the \texttt{Component\ Configuration} section,
\texttt{UnsatisfiedReference} lists the unsatisfied reference's type.
This bundle's component isn't working because it's missing a
\texttt{Foo} service. Now you can focus on why \texttt{Foo} is
unavailable. The solution may be as simple as starting or deploying a
bundle that provides the \texttt{Foo} service.

\section{Service Builder Components}\label{service-builder-components}

Service Builder modules are implemented using Spring. Liferay DXP uses
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager.html}{the
Apache Felix Dependency Manager} to manage Service Builder module OSGi
components via the
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.spring.extender/}{Portal
Spring Extender} module.

When developing a Liferay Service Builder application, you might
sometimes have an unresolved Spring-related OSGi component. This can
occur if you update your application's database schema but forget to
trigger an upgrade.

These features detect unresolved Service Builder related components.

\begin{itemize}
\tightlist
\item
  \hyperref[unavailable-component-scanner]{Unavailable Component
  Scanner}
\item
  \hyperref[dm-na-command]{dm na Command}
\item
  \hyperref[serviceproxyfactory]{ServiceProxyFactory}
\end{itemize}

\section{Unavailable Component
Scanner}\label{unavailable-component-scanner}

The
\href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.osgi.debug.spring.extender/}{OSGi
Debug Spring Extender} module's Unavailable Component Scanner reports
missing components in modules that use Service Builder. Here's how to
enable the scanner:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the configuration file
  \texttt{com.liferay.portal.osgi.debug.spring.extender.internal.configuration.UnavailableComponentScannerConfiguration.cfg}.
\item
  In the configuration file, set the time interval (in seconds) between
  scans:

  \texttt{unavailableComponentScanningInterval=5}
\item
  Copy the file into \texttt{{[}LIFERAY\_HOME{]}/osgi/configs}.
\end{enumerate}

The scanner reports Spring extender dependency manager component status
on the set interval. If all components are registered, the scanner sends
a confirmation message.

\begin{verbatim}
11:10:53,817 INFO  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:166] All Spring extender dependency manager components are registered
\end{verbatim}

If a component is unavailable, it warns you:

\begin{verbatim}
11:13:08,851 WARN  [Spring Extender Unavailable Component Scanner][UnavailableComponentScanner:173] Found unavailable component in bundle com.liferay.screens.service_1.0.28 [516].
Component ComponentImpl[null com.liferay.portal.spring.extender.internal.context.ModuleApplicationContextRegistrator@1541eee] is unavailable due to missing required dependencies: ServiceDependency[interface com.liferay.blogs.service.BlogsEntryService null].
\end{verbatim}

Component unavailability, such as what's reported above, can occur when
DS components and Service Builder components are published and used in
the same module. Use separate modules to publish DS components and
Service Builder components.

\section{dm na Command}\label{dm-na-command}

Dependency Manager's
\href{http://felix.apache.org/documentation/subprojects/apache-felix-dependency-manager/tutorials/leveraging-the-shell.html}{Gogo
shell command \texttt{dm}} lists all Service Builder components, their
required services, and whether each required service is available.

To list unresolved components only execute this Gogo shell command:

\begin{verbatim}
dm na
\end{verbatim}

The \texttt{na} option stands for ``not available.''

\section{ServiceProxyFactory}\label{serviceproxyfactory}

Liferay DXP's logs report unresolved Service Builder components too. For
example, Liferay DXP logs an error when a Service Proxy Factory can't
create a new instance of a Service Builder based entity because a
service component is unresolved.

The following code demonstrates using a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ServiceProxyFactory.html}{\texttt{ServiceProxyFactory}
class} to create a new entity instance:

\begin{verbatim}
private static volatile MessageBus _messageBus =
    ServiceProxyFactory.newServiceTrackedInstance(
        MessageBus.class, MessageBusUtil.class, "_messageBus", true);
\end{verbatim}

This message alerts you to the unavailable service:

\begin{verbatim}
11:07:35,139 ERROR [localhost-startStop-1][ServiceProxyFactory:265] Service "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory" is unavailable in 60000 milliseconds while setting field "_singleDestinationMessageSenderFactory" for class "com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactoryUtil", will retry...
\end{verbatim}

Based on the message above, there's no bundle providing the service
\texttt{com.liferay.portal.kernel.messaging.sender.SingleDestinationMessageSenderFactory}.

Now you can detect unresolved components, DS and DM components,
automatically using scanners, manually using Gogo shell commands, and
programmatically using a \texttt{ServiceProxyFactory}.

\section{Related Topics}\label{related-topics-31}

\href{/docs/7-2/appdev/-/knowledge_base/a/system-check}{System Check}

\chapter{Disabling Cache for Table Mapper
Tables}\label{disabling-cache-for-table-mapper-tables}

Service Builder creates relational mappings between entities. It uses
mapping tables to associate the entities. In your \texttt{service.xml}
file, both entities have a \texttt{mapping-table} column attribute of
the format \texttt{mapping-table="table1\_table2"}. For example, a
\texttt{service.xml} that maps \texttt{AssetEntry}s to
\texttt{AssetCategory}s has an \texttt{AssetCategory} entity with this
column:

\begin{verbatim}
<column entity="AssetEntry" 
mapping-table="AssetEntries_AssetCategories" 
name="entries" type="Collection" />
\end{verbatim}

and an \texttt{AssetEntry} entity element with this column:

\begin{verbatim}
<column entity="AssetCategory" 
mapping-table="AssetEntries_AssetCategories" 
name="categories" type="Collection" />
\end{verbatim}

By default, a table mapper cache is associated with each mapping table.
The cache optimizes object retrieval. In some cases, however, it's best
to disable a table mapper cache.

\section{Why would I want to disable cache on a table
mapper?}\label{why-would-i-want-to-disable-cache-on-a-table-mapper}

Super-large entity tables can result in a memory-hogging table mapper
cache. For this reason, consider disabling cache on a table mapper.

The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Table\%20Mapper}{\texttt{table.mapper.cacheless.mapping.table.names}
Portal property} disables cache for table mappers associated with the
specified mapping tables. Here's the default property setting:

\begin{verbatim}
##
## Table Mapper
##

  #
  # Set a list of comma delimited mapping table names that will not be using
  # cache in their table mappers.
  #
  table.mapper.cacheless.mapping.table.names=\
    Users_Groups,\
    Users_Orgs,\
    Users_Roles,\
    Users_Teams,\
    Users_UserGroups
\end{verbatim}

All of the disabled caches above pertain to the \texttt{User} object
because the table mappers tend to be much too large to have a useful
cache---each \texttt{User} can have several entries in each related
table.

Potential race conditions retrieving objects from the cache is another
reason to disable a table mapper.

For example,
\href{https://issues.liferay.com/browse/LPS-84374}{LPS-84374} describes
a race condition in which a custom entity's table mapper cache can be
cleared while in use, causing transactional rollbacks. Publishing
\texttt{AssetEntry}s clears all associated table mapper caches. If
they're published at the same time getter methods are retrieving objects
from the \texttt{AssetEntries\_AssetCategories} mapping table,
transaction rollbacks occur.

\section{Disabling a Table Mapper
Cache}\label{disabling-a-table-mapper-cache}

Adding a mapping table name to the
\texttt{table.mapper.cacheless.mapping.table.names} Portal property
disables the associated table mapper cache.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your
  \href{/docs/7-1/deploy/-/knowledge_base/d/liferay-home}{\texttt{{[}Liferay\_Home{]}/portal-ext.properties}
  file}, add the current
  \texttt{table.mapper.cacheless.mapping.table.names} property setting.
  The setting is in your Liferay DXP installation's
  \texttt{portal-impl.jar/portal.properties} file.
\item
  Append your mapping table name to the list. For example, to disable
  the cache associated with a mapping table named
  \texttt{AssetEntries\_AssetCategories}, add that name to the list.

\begin{verbatim}
table.mapper.cacheless.mapping.table.names=\
    Users_Groups,\
    Users_Orgs,\
    Users_Roles,\
    Users_Teams,\
    Users_UserGroups,\
    AssetEntries_AssetCategories
\end{verbatim}
\item
  Restart the Liferay DXP instance to delete the table mapper cache.
\end{enumerate}

You've disabled an unwanted table mapper cache.

\chapter{Implementing Logging}\label{implementing-logging}

7.0 uses the Log4j logging framework, but it may be replaced in the
future. It's a best practice to use \href{https://www.slf4j.org/}{Simple
Logging Facade for Java (SLF4J)} to log messages in your modules and
traditional plugins. SLF4J is already integrated into Liferay DXP, so
you can focus on logging messages.

Here's how to use SLF4J to log messages in a class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a private static SLF4J
  \href{https://www.slf4j.org/apidocs/org/slf4j/Logger.html}{\texttt{Logger}
  field}.

\begin{verbatim}
private static Logger _logger;
\end{verbatim}
\item
  Instantiate the logger.

\begin{verbatim}
_logger = LoggerFactory.getLogger(this.getClass().getName());
\end{verbatim}
\item
  Throughout your class, log messages where noteworthy things happen.

  For example,

\begin{verbatim}
_logger.debug("...");
_logger.warn("...");
_logger.error("...");
...
\end{verbatim}

  Use \texttt{Logger} methods appropriate for each message:

  \begin{itemize}
  \tightlist
  \item
    \texttt{trace}: Provides more information than debug. This is the
    most verbose message level.
  \item
    \texttt{debug}: Event and application information helpful for
    debugging.
  \item
    \texttt{info}: High level events.
  \item
    \texttt{warn}: Information that might, but does not necessarily,
    indicate a problem.
  \item
    \texttt{error}: Normal errors. This is the least verbose message
    level.
  \end{itemize}
\end{enumerate}

Log verbosity should correlate with the log level set for the class or
package. Make sure you provide additional information at log levels
expected to be more verbose, such as \texttt{info} and \texttt{debug}.

You're all set to add logging to your modules and traditional plugins.

\section{Related Topics}\label{related-topics-32}

\href{/docs/7-2/appdev/-/knowledge_base/a/adjusting-module-logging}{Adjusting
Module Logging}

\chapter{Declaring Optional Import Package
Requirements}\label{declaring-optional-import-package-requirements}

When developing modules, you can declare \emph{optional} dependencies.
An optional dependency is one your module can use if available, but can
still function without it.

\noindent\hrulefill

\textbf{Important:} Try to avoid optional dependencies. The best module
designs rely on normal dependencies. If an optional dependency seems
desirable, your module may be trying to provide more than one distinct
type of functionality. In such a situation, it's best to split it into
multiple modules that provide smaller, more focused functionality.

\noindent\hrulefill

If you decide that your module requires an optional dependency, follow
these steps to add it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your module's \texttt{bnd.bnd} file, declare the package your
  module optionally depends on:

\begin{verbatim}
Import-Package: com.liferay.demo.foo;resolution:="optional"
\end{verbatim}

  Note that you can use either an optional or dynamic import. The
  differences are explained
  \href{https://osgi.org/specification/osgi.core/7.0.0/framework.module.html\#i2548181}{here}.
\item
  Create a component to use the optional package:

\begin{verbatim}
import com.liferay.demo.foo.Foo; // A class from the optional package

@Component(
    enabled = false // instruct declarative services to ignore this component by default
)
public class OptionalPackageConsumer implements Foo {...}
\end{verbatim}
\item
  Create a second component to be a controller for the first. The second
  component checks the class loader for the optional class on the
  classpath. If it's not there, this means you must catch any
  \texttt{ClassNotFoundException}. For example:

\begin{verbatim}
@Component
public class OptionalPackageConsumerStarter {
    @Activate
    void activate(ComponentContext componentContext) {
        try {
            Class.forName(com.liferay.demo.foo.Foo.class.getName());

            componentContext.enableComponent(OptionalPackageConsumer.class.getName());
        }
        catch (Throwable t) {
            _log.warn("Could not find {}", t.getMessage()); // Could use _log.info instead
        }
    }
}
\end{verbatim}
\end{enumerate}

If the class loader check in the controller component is successful, the
client component is enabled. This check is automatically performed
whenever there are any wiring changes to the module containing these
components (Declarative Services components are always restarted when
there are wiring changes).

If you install the module when the optional dependency is missing from
Liferay DXP's OSGi runtime, your controller component catches a
\texttt{ClassNotFoundException} and logs a warning or info message (or
takes whatever other action you implement to handle this case). If you
install the optional dependency, refreshing your module triggers the
OSGi bundle lifecycle events that trigger your controller's
\texttt{activate} method and the check for the optional dependency.
Since the dependency exists, your client component uses it.

Note that you can refresh a bundle from
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell} with this command:

\begin{verbatim}
equinox:refresh [bundle ID] 
\end{verbatim}

\section{Related Topics}\label{related-topics-33}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\chapter{Resolving Bundle
Requirements}\label{resolving-bundle-requirements}

If one of your bundles needs a package that is not exported by any other
bundle in the Liferay OSGi runtime, you get a bundle exception. Here's
an example exception:

\begin{verbatim}
! could not resolve the bundles: [com.liferay.messaging.client.command-1.0.0.201707261701 org.osgi.framework.BundleException: Could not resolve module: com.liferay.messaging.client.command [1]
Unresolved requirement: Import-Package: com.liferay.messaging.client.api; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging.client.api; bundle-symbolic-name="com.liferay.messaging.client.provider"; bundle-version="1.0.0.201707261701"; version="1.0.0"; uses:="org.osgi.framework"
com.liferay.messaging.client.provider [2]
Unresolved requirement: Import-Package: com.liferay.messaging; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.messaging; bundle-symbolic-name="com.liferay.messaging.api"; bundle-version="1.0.0"; version="1.0.0"; uses:="com.liferay.petra.concurrent"
com.liferay.messaging.api [12]
Unresolved requirement: Import-Package: com.liferay.petra.io; version="[1.0.0,2.0.0)"
-> Export-Package: com.liferay.petra.io; bundle-symbolic-name="com.liferay.petra.io"; bundle-version="1.0.0"; version="1.0.0"
com.liferay.petra.io [16]
Unresolved requirement: Require-Capability osgi.extender; filter:="(osgi.extender=osgi.serviceloader.processor)"
\end{verbatim}

The first line states \emph{could not resolve the bundles}. What follows
is a string of requirements that Liferay's OSGi Runtime could not
resolve.

The bundle exception message follows this general pattern:

\begin{itemize}
\tightlist
\item
  Module A has an unresolved requirement (package or capability)
  \texttt{aaa.bbb}.
\item
  Module B provides \texttt{aaa.bbb} but has an unresolved requirement
  \texttt{ccc.ddd}.
\item
  Module C provides \texttt{ccc.ddd} but has an unresolved requirement
  \texttt{eee.fff}.
\item
  etc.
\item
  Module Z provides \texttt{www.xxx} but has an unresolved requirement
  \texttt{yyy.zzz}.
\end{itemize}

The pattern stops at the final unsatisfied requirement. The last
module's dependencies are key to resolving the bundle exception. There
are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A dependency that satisfies the final requirement might be missing
  from the build file.
\item
  A dependency that satisfies the final requirement might not be
  deployed.
\end{enumerate}

Both cases require deploying a bundle that provides the missing
requirement.

The example bundle exception concludes that module
\texttt{com.liferay.petra.io} requires capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}.
To resolve the requirement, make sure all of
\texttt{com.liferay.petra.io}'s dependencies are deployed.

The \texttt{com.liferay.petra.io} module's \texttt{build.gradle} file
lists its dependencies:

\begin{verbatim}
dependencies {
    provided group: "com.liferay", name: "com.liferay.petra.concurrent", version: "1.0.0"
    provided group: "com.liferay", name: "com.liferay.petra.memory", version: "1.0.0"
    provided group: "org.apache.aries.spifly", name: "org.apache.aries.spifly.dynamic.bundle", version: "1.0.8"
    provided group: "org.slf4j", name: "slf4j-api", version: "1.7.2"
    testCompile group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "default"
}
\end{verbatim}

Then use
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell's \texttt{lb\ command}} to verify the dependencies are in
Liferay's OSGi Runtime:

\begin{verbatim}
lb
START LEVEL 1
   ID|State      |Level|Name
    0|Active     |    0|OSGi System Bundle (3.10.100.v20150529-1857)|3.10.100.v20150529-1857
    1|Active     |    1|com.liferay.messaging.client.command (1.0.0.201707261923)|1.0.0.201707261923
    2|Active     |    1|com.liferay.messaging.client.provider (1.0.0.201707261927)|1.0.0.201707261927
    3|Active     |    1|Apache Felix Configuration Admin Service (1.8.8)|1.8.8
    4|Active     |    1|Apache Felix Log Service (1.0.1)|1.0.1
    5|Active     |    1|Apache Felix Declarative Services (2.0.2)|2.0.2
    6|Active     |    1|Meta Type (1.4.100.v20150408-1437)|1.4.100.v20150408-1437
    7|Active     |    1|org.osgi:org.osgi.service.metatype (1.3.0.201505202024)|1.3.0.201505202024
    8|Active     |    1|Apache Felix Gogo Command (0.16.0)|0.16.0
    9|Active     |    1|Apache Felix Gogo Runtime (0.16.2)|0.16.2
   10|Active     |    1|Apache Felix Gogo Runtime (1.0.0)|1.0.0
...
\end{verbatim}

The dependency module \texttt{org.apache.aries.spifly.dynamic.bundle} is
missing from the runtime bundle list. The
\texttt{org.apache.aries.spifly.dynamic.bundle} module's
\texttt{MANIFEST.MF} file shows it provides the requirement capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}:

\begin{verbatim}
Provide-Capability: osgi.extender;osgi.extender="osgi.serviceloader.regi
 strar";version:Version="1.0",osgi.extender;osgi.extender="osgi.servicel
 oader.processor";version:Version="1.0"
\end{verbatim}

This capability
\texttt{osgi.extender;\ filter:="(osgi.extender=osgi.serviceloader.processor)"}
is the unresolved requirement we identified earlier. Deploying this
missing bundle \texttt{org.apache.aries.spifly.dynamic.bundle} satisfies
the example module's requirement and allows the module to resolve and
install.

You can resolve your bundle exceptions by following steps similar to
these.

\noindent\hrulefill

Note: Bndtools's \emph{Resolve} button can resolve bundle dependencies
automatically. You specify the bundles your application requires and
Bndtools adds transitive dependencies from your configured artifact
repository.

\noindent\hrulefill

\section{Related Topics}\label{related-topics-34}

\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Configuring
Dependencies}

\href{/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Adding
Third Party Libraries to a Module}

\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Felix
Gogo Shell}

\href{/docs/7-2/customization/-/knowledge_base/c/finding-artifacts}{Finding
Artifacts}

\chapter{Resolving ClassNotFoundException and NoClassDefFoundError in
OSGi
Bundles}\label{resolving-classnotfoundexception-and-noclassdeffounderror-in-osgi-bundles}

\texttt{ClassNotFoundException} and \texttt{NoClassDefFoundError} are
common, well known exceptions:

\begin{itemize}
\tightlist
\item
  \texttt{ClassNotFoundException} is thrown when looking up a class that
  isn't on the classpath or using an invalid name to look up a class
  that isn't on the runtime classpath.
\item
  \texttt{NoClassDefFoundError} occurs when a compiled class references
  another class that isn't on the runtime classpath.
\end{itemize}

In OSGi environments, however, there are additional cases where a
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} can
occur:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The missing class belongs to a module dependency that's an OSGi
  module.
\item
  The missing class belongs to a module dependency that's \emph{not} an
  OSGi module.
\item
  The missing class belongs to a global library, either at the Liferay
  DXP web app scope or the application server scope.
\item
  The missing class belongs to a Java runtime package.
\end{enumerate}

This tutorial explains how to handle each case.

\section{Case 1: The Missing Class Belongs to an OSGi
Module}\label{case-1-the-missing-class-belongs-to-an-osgi-module}

In this case, there are two possible causes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The module doesn't import the class's package:} For a module
  (or WAB) to consume another module's exported class, the consuming
  module must import the exported package that contains the class. To do
  this, you add an \texttt{Import-Package} header in the consuming
  module's \texttt{bnd.bnd} file. If the consuming module tries to
  access the class without importing the package, a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}
  occurs.

  Check the package name and make sure the consuming module imports the
  right package. If the import is correct but you still get the
  exception or error, the class might no longer exist in the package.
\item
  \textbf{The class no longer exists in the imported package:} Modules
  are changed frequently in OSGi runtime environments. If you reference
  another module's class that its developer removed, a
  \texttt{NoClassDefFoundError} or \texttt{ClassNotFoundException}
  occurs. \href{http://semver.org}{Semantic Versioning} guards against
  this scenario: removing a class from an exported package constitutes a
  new major version for that package. Neglecting to increment the
  package's major version breaks dependent modules.

  For example, say a module that consumes the class \texttt{com.foo.Bar}
  specifies the package import
  \texttt{com.foo;version={[}1.0.0,\ 2.0.0)}. The module uses
  \texttt{com.foo} versions from \texttt{1.0.0} up to (but not
  including) \texttt{2.0.0}. The first part of the version number (the
  \texttt{1} in \texttt{1.0.0}) represents the \emph{major} version. The
  consuming module doesn't expect any \emph{major} breaking changes,
  like a class removal. Removing \texttt{com.foo.Bar} from
  \texttt{com.foo} without incrementing the package to a new major
  version (e.g., \texttt{2.0.0}) causes a
  \texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError} when
  other modules look up or reference that class.

  You have limited options when the class no longer exists in the
  package:

  \begin{itemize}
  \item
    Adapt to the new API. To learn how to do this, read the
    package's/module's Javadoc, release notes, and/or formal
    documentation. You can also ask the author or search forums.
  \item
    Revert to the module version you used previously. Deployed module
    versions reside in \texttt{{[}Liferay\_Home{]}/osgi/}. For details,
    see
    \href{/docs/7-2/deploy/-/knowledge_base/d/backing-up-a-liferay-installation}{Backing
    up Liferay Installations}.
  \end{itemize}

  Do what you think is best to get your module working properly.
\end{enumerate}

Now you know how to resolve common situations involving
\texttt{ClassNotFoundException} or \texttt{NoClassDefFoundError}. For
additional information on \texttt{NoClassDefFoundError}, see OSGi
Enroute's article
\href{http://enroute.osgi.org/faq/class-not-found-exception.html}{What
is NoClassDefFoundError?}.

\section{Case 2: The Missing Class Doesn't Belong to an OSGi
Module}\label{case-2-the-missing-class-doesnt-belong-to-an-osgi-module}

In this case, you have two options:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Convert the dependency into an OSGi module so it can export the
  missing class. Converting a non-OSGi \texttt{JAR} file dependency into
  an OSGi module that you can deploy alongside your application is the
  ideal solution, so it should be your first choice.
\item
  Embed the dependency in your module by embedding the dependency
  \texttt{JAR} file's packages as private packages in your module. If
  you want to embed a non-OSGi \texttt{JAR} file in your application,
  see
  \href{https://portal.liferay.dev/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Resolving
  Third Party Library Package Dependencies}.
\end{enumerate}

\section{Case 3: The Missing Class Belongs to a Global
Library}\label{case-3-the-missing-class-belongs-to-a-global-library}

In this case, you can configure Liferay DXP so the OSGi system module
exports the missing class's package. Then your module can import it. You
should \textbf{NOT}, however, undertake this lightly. If Liferay
intended to make a global library available for use by developers, the
system module would already export this library! Proceed only if you
have no other solution, and watch out for unintended consequences. There
are two ways to export the package:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your \texttt{portal-ext.properties} file, use the property
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{\texttt{module.framework.system.packages.extra}}
  to specify the packages to export. Preserve the property's current
  list.
\item
  If the package you need is from a Liferay DXP JAR, you might be able
  to add the module to the list of exported packages in
  \texttt{{[}LIFERAY\_HOME{]}/osgi/core/com.liferay.portal.bootstrap.jar}'s
  \texttt{META-INF/system.packages.extra.bnd} file. Try this option only
  if the first option doesn't work.
\end{enumerate}

If the package you need is from a Liferay DXP module, (i.e., it's
\textbf{NOT} from a global library), you can add the package to that
module's \texttt{bnd.bnd} exports. You should \textbf{NOT}, however,
undertake this lightly. The package would already be exported if Liferay
intended for it to be available.

\section{Case 4: The Missing Class Belongs to a Java Runtime
Package}\label{case-4-the-missing-class-belongs-to-a-java-runtime-package}

\texttt{rt.jar} (the JRE library) has non-public packages. If your
module imports one of them, configure Liferay DXP's system bundle to
export the package to the module framework.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the current
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Module\%20Framework}{\texttt{module.framework.system.packages.extra}
  property setting} to a
  \href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{\texttt{portal-ext.properties}
  file}. Your server's current setting is in the Liferay DXP web
  application's \texttt{/WEB-INF/lib/portal-impl.jar/portal.properties}
  file.
\item
  In your \texttt{portal-ext.properties} file, append the required Java
  runtime package to the end of the
  \texttt{module.framework.system.packages.extra} property's package
  list.
\item
  Restart your server.
\end{enumerate}

Your module should resolve and install.

\section{Related Topics}\label{related-topics-35}

\href{/docs/7-2/deploy/-/knowledge_base/d/backing-up-a-liferay-installation}{Backing
up Liferay Installations}

\href{https://portal.liferay.dev/docs/7-2/customization/-/knowledge_base/c/adding-third-party-libraries-to-a-module}{Resolving
Third Party Library Package Dependencies}

\chapter{System Check}\label{system-check}

During development, all kinds of strange things can happen in the OSGi
container. Liferay's \texttt{system:check}
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell} command can help you see what's happening. You can enable it to
run as the last Portal startup step and you can execute it any time in
Gogo shell.

\texttt{system:check} aggregates these commands:

\begin{itemize}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components\#dsunsatisfied-command}{\texttt{ds:unsatisfied}}:
  Reports unsatisfied Declarative Service components.
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components\#dm-na-command}{\texttt{dm\ na}}:
  Reports unsatisfied Dependency Manager service components, including
  Service Builder services.
\end{itemize}

System checking functionality from future Liferay tools will be added to
\texttt{system:check}.

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Developer
mode} runs \texttt{system:check} automatically on every startup.

You can enable \texttt{system:check} to run on startup outside of
developer mode by setting this property in your
\texttt{portal-ext.properties} file:

\begin{verbatim}
module.framework.properties.initial.system.check.enabled=true
\end{verbatim}

As stated previously, you can run the \texttt{system:check} command any
time in
\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell}. Enjoy detecting unresolved components and other issues fast
using \texttt{system:check}.

\section{Related Topics}\label{related-topics-36}

\href{/docs/7-2/appdev/-/knowledge_base/a/detecting-unresolved-osgi-components}{Detecting
Unresolved OSGi Components}

\href{/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell}{Gogo
shell}

\chapter{Troubleshooting Front-End Development
Issues}\label{troubleshooting-front-end-development-issues}

Front-end development involves many moving parts. Sometimes it's hard to
tell what may be causing the issues you run into along the way. This can
be particularly frustrating. These frequently asked questions and
answers help you troubleshoot and correct problems arising during
front-end development.

Here are the troubleshooting sections:

\begin{itemize}
\tightlist
\item
  \hyperref[css]{CSS}
\item
  \hyperref[modules]{Modules}
\item
  \hyperref[portlets]{Portlets}
\end{itemize}

Click a question to view the answer.

\section{CSS}\label{css}

\phantomsection\label{broken-css-angular-app}
{Why are my CSS templates not applied in my Angular app?~{}}

\begin{verbatim}
<p>A known <a href="https://github.com/angular/angular/issues/4974">bug</a> with Angular causes absolute URLs for CSS files not to be recognized.</p>
<p>Due to the nature of portals, a relative URL is not an option either because the app can be placed on any page.</p>
<p>To fix this, you can either provide the CSS with a theme or themelet, or you can specify the path to the CSS file with the <code>com.liferay.portlet.header-portlet-css</code> property in the portlet containing your Angular code.</p>
\end{verbatim}

\phantomsection\label{portal-css-broken-ie}
{Why is Liferay Portal's CSS broken in Internet Explorer?~{}}

\begin{verbatim}
<p>By default CSS files are minified in the browser. This can cause issues in Internet Explorer. You can disable this behavior by including <code>theme.css.fast.load=false</code> and <code>minifier.enabled=false</code> in your <code>portal-ext.properties</code> file. </p>
\end{verbatim}

\section{Modules}\label{modules-1}

\phantomsection\label{jquery-anonymous-module-error}
{Why does my JQuery module throw an anonymous module error when I try to
load it?~{}}

\begin{verbatim}
<p>If you're using an external library that you host, you must disable the <i>Expose Global</i> option as described in the <a href="/docs/7-2/frameworks/-/knowledge_base/f/using-external-javascript-libraries#using-libraries-that-you-host">Using External JavaScript Libraries</a> tutorial.</p>
\end{verbatim}

\phantomsection\label{source-maps-not-showing}
{Why are my source maps not showing for my Angular or Typescript
module?~{}}

\begin{verbatim}
<p>This is due to <a href="https://issues.liferay.com/browse/LPS-83052">LPS-83052</a>.</p>
<p>To solve this, activate the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html"><code>inlineSources</code> compiler option</a> via argument or your <code>tsconfig.json</code> file.</p>
\end{verbatim}

\phantomsection\label{disable-bundler-analytics}
{I'm using the liferay-npm-bundler for multiple projects. How can I
disable analytics tracking for the liferay-npm-bundler in my
projects?~{}}

\begin{verbatim}
<p>There are a couple options you can use to disable reporting:</p>
<ul>
  <li><p>Use the <code>--no-tracking</code> flag in your <code>package.json</code>'s build script to disable reporting:</p>
  <p><pre><code>liferay-npm-bundler --no-tracking</code></pre></p>
  </li>
  <li>
  <p>Create a <code>.liferay-npm-bundler-no-tracking</code> file in your project's root folder, or any of its ancestors, to disable reporting.</p>
  <p>This equates to answering <code>No</code> to the <code>May liferay-npm-bundler anonymously report usage statistics to improve the tool over time?</code> question.</p>
  </li>
</ul>
\end{verbatim}

\section{Portlets}\label{portlets}

\phantomsection\label{angular-react-vue-portlet-disable-spa}
{I want to use a custom router in my Angular/React/Vue portlet. How can
I disable the default Senna JS SPA engine in my portlet?~{}}

\begin{verbatim}
<p>By default, the <a href="/docs/7-2/frameworks/-/knowledge_base/f/automatic-single-page-applications#what-is-sennajs">Senna JS SPA engine</a> is enabled in your portlets and sites. This disables full page reloads during portlet navigation.</p>
<p>If you want to use a custom router in your portlet instead, follow the <a href="/docs/7-2/frameworks/-/knowledge_base/f/automatic-single-page-applications#disabling-spa">instructions in the SPA documentation</a> to blacklist your portlet from SPA.</p>
\end{verbatim}
