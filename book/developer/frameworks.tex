\chapter{Application Security}\label{application-security}

Liferay's development framework provides an application security
platform with years of experience behind it. You don't need to roll your
own security for your applications. Instead, you can specify security
for your applications using Liferay's framework.

Beyond security for applications, there are many ways to extend the
default security model by customizing the authentication process. This
group of tutorials teaches you about them:

\begin{itemize}
\tightlist
\item
  Resources, Roles, and Permissions
\item
  Custom SSO Providers
\item
  Authentication Pipelines
\item
  Service Access Policies
\item
  Authentication Verifiers
\end{itemize}

Read on to learn about implementing Liferay's security framework!

\chapter{Defining Application
Permissions}\label{defining-application-permissions}

When you're writing an application, there are almost always parts of the
application or its data that should be protected by permissions. Some
users should access all the functions or data, but most users shouldn't.

On many platforms, developers have to create the security model
themselves. On Liferay DXP, an application security model has been
provided for you; you only need to make use of it.

Fortunately, no matter what your application does, access to it and to
its content can be controlled with permissions. Read on to learn about
Liferay's permissions system and how add permissions to your
application.

The permissions system has three parts: \emph{Resources},
\emph{Actions}, and \emph{Permissions}.

\textbf{Action}: An operation that can be performed by a user. For
example, users can perform these actions on the Bookmarks application:
\texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and \texttt{VIEW}. Users
can perform these actions on Bookmarks entry entities:
\texttt{ADD\_ENTRY}, \texttt{DELETE}, \texttt{PERMISSIONS},
\texttt{UPDATE}, and \texttt{VIEW}.

\textbf{Resource}: A generic representation of any application or entity
on which an action can be performed. Resources are used for permission
checking. For example, resources could include the RSS application with
instance ID \texttt{hF5f}, a globally scoped Wiki page, a Bookmarks
entry of the site X, and a Message Boards post with the ID
\texttt{5052}.

\textbf{Permission}: A flag that determines whether an action can be
performed on a resource. In the database, resources and actions are
saved in pairs. Each entry in the \texttt{ResourceAction} table contains
both the name of a portlet or entity and the name of an action. For
example, the \texttt{VIEW} action with respect to \emph{viewing the
Bookmarks application} is associated with the
\texttt{com\_liferay\_bookmarks\_web\_portlet\_BookmarksPortlet} portlet
ID. The \texttt{VIEW} actions with respect to \emph{viewing a Bookmarks
Folder} or \emph{viewing a Bookmarks entry} are associated with the
\texttt{com.liferay.bookmarks.model.BookmarksFolder} and
\texttt{com.liferay.bookmarks.model.BookmarksEntry} entities,
respectively.

To do permissions, therefore, you define \emph{Users} (Roles) who have
\emph{Permission} to perform \emph{Actions} on \emph{Resources}. User
definition is done by administrators once your application is deployed;
developers define resources, actions, and default permissions.

You can implement permissions in your applications in four steps that
spell the acronym \emph{DRAC}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define all resources and their permissions.
\item
  Register all defined resources in the permissions system.
\item
  Associate the necessary permissions with resources.
\item
  Check permission before returning resources.
\end{enumerate}

The next four tutorials show these steps in detail.

\chapter{Defining Resources and
Permissions}\label{defining-resources-and-permissions}

Your first step in implementing permissions is to define the resources
and the permissions that protect them. There are two different kinds of
resources: \emph{portlet resources} and \emph{model resources}.

Portlet resources represent portlets. The names of portlet resources are
the portlet IDs from the portlets' \texttt{@Component} properties or if
you're using a WAR file, \texttt{portlet.xml} files. Model resources
refer to model objects, usually persisted as entities to a database. The
names of model resources are their fully qualified class names. In the
XML displayed below, permission implementations are first defined for
the \emph{portlet} resource and then for the \emph{model} resources.

Model resources represent models, such as blog entries. Resources are
named using the fully qualified class names of the entities they
represent.

\noindent\hrulefill

\textbf{Note:} For each resource, there are four scopes to which the
permissions can be applied: company, group, group-template, or
individual. Because these are called \emph{portlet resources} here and
in the code, this can be confusing. The other scopes are mostly used
internally for various Liferay constructs (such as Sites or Categories).

\noindent\hrulefill

You define resources and their permissions using an XML file. By
convention, this file is called \texttt{default.xml} and exists in a
module's \texttt{src/main/resources/resource-actions} folder.

Because of the two different types of resources, you'll have two of
these files: one in your portlet module to define the portlet resources
and one in your service module to define the model resources.

\section{Defining Portlet Resource
Permissions}\label{defining-portlet-resource-permissions}

Define the portlet resources first; here's an example using Liferay's
Blogs application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start with the DTD declaration:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.2.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">
\end{verbatim}
\item
  The root tag contains all the resources to be declared:

\begin{verbatim}
<resource-action-mapping>

</resource-action-mapping> 
\end{verbatim}
\item
  Inside these tags, define your resources. The Blogs application
  defines two portlet resources:

\begin{verbatim}
<portlet-resource>
    <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ACCESS_IN_CONTROL_PANEL</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
<portlet-resource>
    <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    <permissions>
        <supports>
            <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
            <action-key>ADD_TO_PAGE</action-key>
            <action-key>CONFIGURATION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>ADD_PORTLET_DISPLAY_TEMPLATE</action-key>
            <action-key>CONFIGURATION</action-key>
        </guest-unsupported>
    </permissions>
</portlet-resource>
\end{verbatim}
\end{enumerate}

The Blogs application comprises two portlets: the Blogs portlet itself
and the Blogs Admin portlet that appears in the Site menu for
administrators. Define your portlets by their names, and then list the
permissions for the portlet. The Blogs portlet, for example, supports
four permissions: \texttt{ADD\_PORTLET\_DISPLAY\_TEMPLATE},
\texttt{ADD\_TO\_PAGE}, \texttt{CONFIGURATION}, and \texttt{VIEW}. The
Blogs Admin portlet has an additional permission:
\texttt{ACCESS\_IN\_CONTROL\_PANEL}, which defines who can see the entry
in the Site menu.

Once you've defined permissions at the portlet level, you can set
default permissions for different types of users. The DTD allows for
site member and guest defaults. Since guests are users that aren't
logged in, there's also a \texttt{guest-unsupported} tag for defining
permissions guests can \emph{never} have (in other words, the user must
be logged in and identifiable).

That's all there is to it! Your next task is to define permissions for
your model resources.

\section{Defining Model Resource
Permissions}\label{defining-model-resource-permissions}

Defining permissions for models is a similar process. Create a
\texttt{default.xml} file in your service module's
\texttt{src/main/resources/resource-actions} folder. In this file, you
must define top-level function permissions and individual entity
permissions using the same
\texttt{\textless{}model-resource\textgreater{}} tag.

This can be confusing, so some explanation is in order. Model
permissions for what Liferay calls the \emph{root model} are defined
separately from permissions on stored entities, which Liferay calls the
\emph{model}. This makes sense when you think about the functions users
can perform:

\begin{itemize}
\tightlist
\item
  Creating something new
\item
  Editing something that exists
\end{itemize}

Creating something new (like adding a new Blog entry) is different from
accessing something that exists. A Blog owner should be able to create
or edit a Blog entry, but a User or guest should have read permission
for existing entries and no permission to create them.

Permission to create something new that doesn't yet exist is a
\emph{root model} permission, whether that functionality is exposed in a
portlet or not. Permission on an existing resource is a \emph{model}
permission.

Now you're ready to define both your root model and model permissions.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, create the skeleton for your file:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE resource-action-mapping PUBLIC "-//Liferay//DTD Resource Action Mapping 7.1.0//EN" "http://www.liferay.com/dtd/liferay-resource-action-mapping_7_0_0.dtd">

<resource-action-mapping>

</resource-action-mapping> 
\end{verbatim}
\item
  Inside the \texttt{\textless{}resource-action-mapping\textgreater{}}
  tags, use a \texttt{\textless{}model-resource\textgreater{}} tag to
  define permissions for the root model:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.blogs</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    </portlet-ref>
    <root>true</root>
    <weight>1</weight>
    <permissions>
        <supports>
            <action-key>ADD_ENTRY</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>SUBSCRIBE</action-key>
        </supports>
        <site-member-defaults>
            <action-key>SUBSCRIBE</action-key>
        </site-member-defaults>
        <guest-defaults />
        <guest-unsupported>
            <action-key>ADD_ENTRY</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>SUBSCRIBE</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}

  The model name (\texttt{com.liferay.blogs}) is just a package name.
  The
  \texttt{\textless{}root\textgreater{}true\textless{}/root\textgreater{}}
  tag defines this as a root model. The
  \texttt{\textless{}weight\textgreater{}} tag defines the order of
  these permissions in the GUI. The permissions defined are ADD\_ENTRY
  (add a Blog entry), PERMISSIONS (set permissions on Blog entries), and
  SUBSCRIBE (receive notifications when Blog entries are created). These
  are all root model permissions, because no primary key in the database
  can be assigned to any of these functions.
\item
  Finally, define your model permissions:

\begin{verbatim}
<model-resource>
    <model-name>com.liferay.blogs.model.BlogsEntry</model-name>
    <portlet-ref>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsAdminPortlet</portlet-name>
        <portlet-name>com_liferay_blogs_web_portlet_BlogsPortlet</portlet-name>
    </portlet-ref>
    <weight>2</weight>
    <permissions>
        <supports>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>DELETE</action-key>
            <action-key>DELETE_DISCUSSION</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>UPDATE_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </supports>
        <site-member-defaults>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </site-member-defaults>
        <guest-defaults>
            <action-key>ADD_DISCUSSION</action-key>
            <action-key>VIEW</action-key>
        </guest-defaults>
        <guest-unsupported>
            <action-key>DELETE</action-key>
            <action-key>DELETE_DISCUSSION</action-key>
            <action-key>PERMISSIONS</action-key>
            <action-key>UPDATE</action-key>
            <action-key>UPDATE_DISCUSSION</action-key>
        </guest-unsupported>
    </permissions>
</model-resource>
\end{verbatim}
\end{enumerate}

Note the lack of a \texttt{\textless{}root\textgreater{}} tag, the fully
qualified class name for the model, and the permissions that operate on
an entity with a primary key.

\section{Enabling Your Permissions
Configuration}\label{enabling-your-permissions-configuration}

Your last step is to enable your permission definitions. Each module
that contains a \texttt{default.xml} permissions definition file must
also have a \texttt{portlet.properties} file with a property that
defines where to find the permissions definition file. For your service
and your web modules, create a \texttt{portlet.properties} file in
\texttt{src/main/resources} and make sure it has this property:

\begin{verbatim}
resource.actions.configs=resource-actions/default.xml
\end{verbatim}

Once you've defined portlet permissions, root model permissions, and
model permissions, you've completed step 1 (the \emph{D} in DRAC).
Congratulations! You're now ready to \emph{register} the resources
you've now defined in the permissions system.

\chapter{Registering Permissions}\label{registering-permissions}

Defining permissions was your first step; now you're ready to register
the permissions you've defined. You must register your entities both in
the database and in the permissions service running in the OSGi
container.

\section{Registering Permissions Resources in the
Database}\label{registering-permissions-resources-in-the-database}

All this takes is a call to Liferay's resource service in your service
layer. If you're using Service Builder, this is very easy to do.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{-LocalServiceImpl} class.
\item
  In your method that adds an entity, add a call to add a resource with
  the entity. For example, Liferay's Blogs application adds resources
  this way:

\begin{verbatim}
resourceLocalService.addResources(
    entry.getCompanyId(), entry.getGroupId(), entry.getUserId(),
    BlogsEntry.class.getName(), entry.getEntryId(), false,
    addGroupPermissions, addGuestPermissions);
\end{verbatim}

  This method requires passing in the company ID, the group ID, the user
  ID, the entity's class name, the entity's primary key, and some
  boolean settings. In order, these settings define

  \begin{itemize}
  \tightlist
  \item
    Whether the permission is a portlet resource
  \item
    Whether the default group permissions defined in
    \texttt{default.xml} should be added
  \item
    Whether the default guest permissions defined in
    \texttt{default.xml} should be added
  \end{itemize}
\end{enumerate}

Note that the resource local service is injected automatically into your
Service Builder-generated service.

If you're not using Service Builder, but you are using OSGi modules for
your application, you should be able to inject the resource service with
an \texttt{@Reference} annotation. If you're building a WAR-style
plugin, you need a
\href{/docs/7-2/frameworks/-/knowledge_base/f/service-trackers-for-osgi-services}{service
tracker} to gain access to the service. Note that your model classes
must also implement Liferay's \texttt{ClassedModel} interface.

Similarly, when you delete an entity, you should also delete its
associated resource. Here's how the Blogs application does it in its
\texttt{deleteEntry()} method:

\begin{verbatim}
resourceLocalService.deleteResource(
    entry.getCompanyId(), BlogsEntry.class.getName(),
    ResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());
\end{verbatim}

As with adding resources, the method needs to know the entity's company
ID, class, and primary key. Most of the time, its scope is an individual
entity of your own choosing. Other scopes available as constants are for
company, group, or group template (site template). These are used
internally for those objects, so you'd only use them if you were
customizing functionality for creating and deleting them.

Now you're ready to register your entities with the permissions service.

\section{Registering Entities to the Permissions
Service}\label{registering-entities-to-the-permissions-service}

The permissions service that's running must know about your entities and
how to check permissions for them. This requires creating a permissions
registrar class.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your service bundle, create a package that by convention ends in
  \texttt{internal.security.permission.resource}. For example, the Blogs
  application's package is named
  \texttt{com.liferay.blogs.internal.security.permission.resource}.
\item
  Create a class in this package called
  \texttt{{[}Entity\ \ \ \ \ Name{]}ModelResourcePermissionRegistrar}.
  For example, the Blogs application's class is named
  \texttt{BlogsEntryModelResourcePermissionRegistrar}.
\item
  This class is a component class that requires overriding the
  \texttt{activate} method to register the permissions logic you want
  for your entities. For example, this is how the Blogs application
  registers its permissions:

\begin{verbatim}
@Component(immediate = true)
public class BlogsEntryModelResourcePermissionRegistrar {

    @Activate
    public void activate(BundleContext bundleContext) {
        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("model.class.name", BlogsEntry.class.getName());

        _serviceRegistration = bundleContext.registerService(
            ModelResourcePermission.class,
            ModelResourcePermissionFactory.create(
                BlogsEntry.class, BlogsEntry::getEntryId,
                _blogsEntryLocalService::getEntry, _portletResourcePermission,
                (modelResourcePermission, consumer) -> {
                    consumer.accept(
                        new StagedModelPermissionLogic<>(
                            _stagingPermission, BlogsPortletKeys.BLOGS,
                            BlogsEntry::getEntryId));
                    consumer.accept(
                        new WorkflowedModelPermissionLogic<>(
                            _workflowPermission, modelResourcePermission,
                            BlogsEntry::getEntryId));
                }),
            properties);
    }

    @Deactivate
    public void deactivate() {
        _serviceRegistration.unregister();
    }

    @Reference
    private BlogsEntryLocalService _blogsEntryLocalService;

    @Reference(target = "(resource.name=" + BlogsConstants.RESOURCE_NAME + ")")
    private PortletResourcePermission _portletResourcePermission;

    private ServiceRegistration<ModelResourcePermission> _serviceRegistration;

    @Reference
    private StagingPermission _stagingPermission;

    @Reference
    private WorkflowPermission _workflowPermission;

}
\end{verbatim}
\end{enumerate}

We call these types of classes Registrars because the classes' job is to
configure, register and unregister the \texttt{ModelResourcePermission}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{model.class.name} is set in the properties so that other
  modules' service trackers can find this model resource permission by
  its type when it's needed. Liferay has several service trackers
  checking for model resource permissions. The \texttt{service.ranking}
  property can also be set to a value greater than zero to override
  other module's model resource permissions.
\item
  This registrar uses two portal-kernel permission logic classes for
  Staging and Workflow. Custom logic classes can be reused or composed
  inline since \texttt{ModelResourcePermissionLogic} is a
  \texttt{@FunctionalInterface}. Permission logic classes are executed
  in order of when they are accepted in the \texttt{Consumer}.
\item
  \texttt{ModelResourcePermissionLogic} classes return \texttt{true}
  when users have permission for the action, \texttt{false} when they
  are denied permission for the action, and \texttt{null} when wanting
  to delegate responsibility to the next permission logic. If all
  permission logics return null then the
  \texttt{PermissionChecker.hasPermission} method is called to determine
  if the action is allowed for the user.
\end{enumerate}

This class uses an \texttt{@Reference} with the target filter to inject
the appropriate \texttt{PortletResourcePermission}.
\texttt{BlogsConstants.RESOURCE\_NAME} evaluates to
\texttt{com.liferay.blogs}, which is defined in the \texttt{default.xml}
you created earlier. If you were to reference this
\texttt{ModelResourcePermission}, you'd use a target filter matching the
\texttt{model.class.name} property set in the \texttt{activate} method.

Note that you specify your entity's class, primary key, and the entity
itself for the factory so it can create permission objects specific to
your entity.

Great! You've now completed step 2 in \emph{DRAC} by registering your
permissions. Now you're ready to provide users the interface to
associate permissions with resources.

\chapter{Associating Permissions with
Resources}\label{associating-permissions-with-resources}

Now that you've defined and registered permissions, you must expose the
permissions interface so users can set permissions.

To allow permissions to be configured for model resources, you must add
the permissions interface to the UI. Add these two Liferay UI tags to
your JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{\textless{}liferay-security:permissionsURL\textgreater{}}:
  Returns a URL to the permission settings configuration page.
\item
  \texttt{\textless{}liferay-ui:icon\textgreater{}}: Shows an icon to
  the user. These are defined in the theme and one of them (see below)
  is used for permissions.
\end{enumerate}

The Blogs application uses these tags like this:

\begin{verbatim}
<liferay-security:permissionsURL
            modelResource="<%= BlogsEntry.class.getName() %>"
            modelResourceDescription="<%= BlogsEntryUtil.getDisplayTitle(resourceBundle, entry) %>"
            resourceGroupId="<%= String.valueOf(entry.getGroupId()) %>"
            resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
            var="permissionsEntryURL"
            windowState="<%= LiferayWindowState.POP_UP.toString() %>"
        />

<liferay-ui:icon
    label="<%= true %>"
    message="permissions"
    method="get"
    url="<%= permissionsEntryURL %>"
    useDialog="<%= true %>"
/>
\end{verbatim}

For the
\texttt{\textless{}liferay-security:permissionsURL\ /\textgreater{}}
tag, specify these attributes:

\texttt{modelResource}: The fully qualified class name of the entity
class. This class name gets translated into a more readable name as
specified in \texttt{Language.properties}.

\texttt{Language.properties}: The entity class in the example above is
the Blogs entry class for which the fully qualified class name is
\texttt{com.liferay.blogs.model.BlogsEntry}.

\texttt{modelResourceDescription}: You can enter anything that best
describes this model instance. In the example above, the Blog title is
used for the model resource description.

\texttt{resourcePrimKey}: Your entity's primary key.

\texttt{var}: The name of the variable to which the resulting URL string
is assigned. The variable is then passed to the
\texttt{\textless{}liferay-ui:icon\textgreater{}} tag so the permission
icon has the proper URL link.

There's an optional attribute called \texttt{redirect} that's available
if you want to override the default behavior of the upper right arrow
link. That's it; now your users can configure the permission settings
for model resources!

You've completed step 3 in \emph{DRAC}. Your next step is to check for
permissions in the appropriate areas of your application.

\chapter{Checking Permissions}\label{checking-permissions}

Now that you've defined your permissions, registered resources in the
database and with the OSGi container, and enabled users to associate
permissions with resources, you're ready to add permission checks in the
appropriate places in your application. This takes three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add permission checks to your service calls.
\item
  Create permission helper classes in your web module.
\item
  Add permission checks to your web application.
\end{enumerate}

These things are covered next.

\section{Add Permission Checks to Your Service
Calls}\label{add-permission-checks-to-your-service-calls}

A best practice is to create methods in your \texttt{-ServiceImpl}
classes that call the same methods in your \texttt{-LocalServiceImpl}
classes, but wrap those calls in permission checks. If you expose your
services as web services, then any client calling those services must
have permission to call the service. In this way, you separate your
business logic (contained in the \texttt{-LocalServiceImpl} class) from
your permissions logic (contained in the \texttt{-ServiceImpl} class).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your entity's \texttt{-ServiceImpl} class.
\item
  Use the \texttt{ModelResourcePermissionFactory} and the
  \texttt{PortletResourcePermissionFactory} to reference permission
  checkers that can check permissions as you've defined them in
  \texttt{default.xml}. Here's how the Blogs portlet does this:

\begin{verbatim}
private static volatile ModelResourcePermission<BlogsEntry>
    _blogsEntryFolderModelResourcePermission =
        ModelResourcePermissionFactory.getInstance(
            BlogsEntryServiceImpl.class,
            "_blogsEntryFolderModelResourcePermission", BlogsEntry.class);
private static volatile PortletResourcePermission
    _portletResourcePermission =
        PortletResourcePermissionFactory.getInstance(
            BlogsEntryServiceImpl.class, "_portletResourcePermission",
            BlogsConstants.RESOURCE_NAME);
\end{verbatim}

  You declare the class, the variable, and for the portlet resource, the
  resource name from \texttt{default.xml}. In the Blogs application,
  \texttt{BlogsConstants.RESOURCE\_NAME} is a \texttt{String} with the
  value \texttt{com.liferay.blogs}.

  You must use \texttt{ModelResourcePermissionFactory.getInstance()} in
  the service because Service Builder is wired with Spring, so
  \texttt{@Reference} can't be used. Make sure to use the correct
  service class and the name of the field that's being set (in this case
  \texttt{"\_blogsEntryFolderModelResourcePermission"}), because it's
  set with reflection when the service is registered. If you get the
  field wrong, it'll be set wrong. The field must be \texttt{static} and
  \texttt{volatile}, and should never be used outside of
  \texttt{-ServiceImpl} classes.
\item
  Check permissions in the appropriate places. For example, adding a
  blog entry requires the \texttt{ADD\_ENTRY} permission, so the Blogs
  application does this:

\begin{verbatim}
@Override
public BlogsEntry addEntry(
        String title, String subtitle, String description, String content,
        int displayDateMonth, int displayDateDay, int displayDateYear,
        int displayDateHour, int displayDateMinute, boolean allowPingbacks,
        boolean allowTrackbacks, String[] trackbacks,
        String coverImageCaption, ImageSelector coverImageImageSelector,
        ImageSelector smallImageImageSelector,
        ServiceContext serviceContext)
    throws PortalException {

    _portletResourcePermission.check(
        getPermissionChecker(), serviceContext.getScopeGroupId(),
        ActionKeys.ADD_ENTRY);

    return blogsEntryLocalService.addEntry(
        getUserId(), title, subtitle, description, content,
        displayDateMonth, displayDateDay, displayDateYear, displayDateHour,
        displayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,
        coverImageCaption, coverImageImageSelector, smallImageImageSelector,
        serviceContext);
}
\end{verbatim}

  The check throws an exception if it fails, preventing the local
  service call that adds the entry. A convention Liferay uses is to
  place the action keys from \texttt{default.xml} as constants in an
  \texttt{ActionKeys} class. If \texttt{ActionKeys} doesn't have an
  action key appropriate for your application, extend Liferay's class
  and add your own keys.
\end{enumerate}

Add permission checks where necessary to protect your application's
functions at the service level. Next, you'll learn how to create
permission helper classes for your web module.

\section{Create Permission Helper Classes in Your Web
Module}\label{create-permission-helper-classes-in-your-web-module}

A helper class can make it easier to check permissions in your portlet
application. You can create helper classes for both portlet permissions
and model permissions. Here's how to create a portlet permission helper:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a package with the suffix
  \texttt{web.internal.security.permission.resource}. For example, the
  Blogs application has the package
  \texttt{com.liferay.blogs.web.internal.security.permission.resource}.
\item
  Create a component class with at least one static method for checking
  permissions. For example, here's the \texttt{BlogsPermission} class:

\begin{verbatim}
@Component(immediate = true)
public class BlogsPermission {

    public static boolean contains(
        PermissionChecker permissionChecker, long groupId, String actionId) {

        return _portletResourcePermission.contains(
            permissionChecker, groupId, actionId);
    }

    @Reference(
        target = "(resource.name=" + BlogsConstants.RESOURCE_NAME + ")",
        unbind = "-"
    )
    protected void setPortletResourcePermission(
        PortletResourcePermission portletResourcePermission) {

        _portletResourcePermission = portletResourcePermission;
    }

    private static PortletResourcePermission _portletResourcePermission;

}
\end{verbatim}

  Note the \texttt{@Reference} annotation that tells the OSGi container
  to supply an object via the permission registrar you created
  previously. The \texttt{\_portletResourcePermission} field is static,
  while the setter method is an instance method: this is how Liferay
  avoids having service references in JSPs.
\end{enumerate}

The procedure for creating a model permission helper is similar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the same package, create a component class with at least one static
  method for checking permissions. For example, here's the
  \texttt{BlogsEntryPermission} class:

\begin{verbatim}
@Component(immediate = true)
public class BlogsEntryPermission {

    public static boolean contains(
            PermissionChecker permissionChecker, BlogsEntry entry,
            String actionId)
        throws PortalException {

        return _blogsEntryFolderModelResourcePermission.contains(
            permissionChecker, entry, actionId);
    }

    public static boolean contains(
            PermissionChecker permissionChecker, long entryId, String actionId)
        throws PortalException {

        return _blogsEntryFolderModelResourcePermission.contains(
            permissionChecker, entryId, actionId);
    }

    @Reference(
        target = "(model.class.name=com.liferay.blogs.model.BlogsEntry)",
        unbind = "-"
    )
    protected void setEntryModelPermission(
        ModelResourcePermission<BlogsEntry> modelResourcePermission) {

        _blogsEntryFolderModelResourcePermission = modelResourcePermission;
    }

    private static ModelResourcePermission<BlogsEntry>
        _blogsEntryFolderModelResourcePermission;

}
\end{verbatim}

  As you can see, this class is almost the same as the portlet
  permission class. The real difference is in the \texttt{@Reference}
  annotation that specifies the fully qualified class name of the model,
  rather than the resource name from \texttt{default.xml}.
\item
  Save both files.
\end{enumerate}

Now you're ready to use these helper classes to check permissions in
your web module.

\section{Add Permission Checks to Your Web
Application}\label{add-permission-checks-to-your-web-application}

You can use the permission helper classes to check for permissions
before displaying UI elements. If the element never appears, a user
can't access it (though you should also protect your services as
described above). Here's how to do that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When you have a function you want to protect, wrap it in an
  \texttt{if} statement that uses the permission helper class. For
  example, the Blogs application has many functions protected by
  permissions, including \texttt{ADD\_ENTRY} and \texttt{SUBSCRIBE}.
  Clearly, only blog owners should be able to add blog entries. The
  button for this, therefore, should only appear if a user has
  permission to add entries:

\begin{verbatim}
<c:if test="<%= BlogsPermission.contains(permissionChecker, scopeGroupId, ActionKeys.ADD_ENTRY) %>">
    <div class="button-holder">
        <portlet:renderURL var="editEntryURL" windowState="<%= WindowState.MAXIMIZED.toString() %>">
            <portlet:param name="mvcRenderCommandName" value="/blogs/edit_entry" />
            <portlet:param name="redirect" value="<%= currentURL %>" />
        </portlet:renderURL>

        <aui:button href="<%= editEntryURL %>" icon="icon-plus" value="add-blog-entry" />
    </div>
</c:if>
\end{verbatim}
\item
  Do this for any function. For example, the Permissions function you
  added in
  \href{/docs/7-2/frameworks/-/knowledge_base/f/associating-permissions-with-resources}{step
  3} should definitely be protected by permissions:

\begin{verbatim}
<c:if test="<%= BlogsEntryPermission.contains(permissionChecker, entry, ActionKeys.PERMISSIONS) %>">
    <liferay-security:permissionsURL
        modelResource="<%= BlogsEntry.class.getName() %>"
        modelResourceDescription="<%= BlogsEntryUtil.getDisplayTitle(resourceBundle, entry) %>"
        resourceGroupId="<%= String.valueOf(entry.getGroupId()) %>"
        resourcePrimKey="<%= String.valueOf(entry.getEntryId()) %>"
        var="permissionsEntryURL"
        windowState="<%= LiferayWindowState.POP_UP.toString() %>"
    />

    <liferay-ui:icon
        label="<%= true %>"
        message="permissions"
        method="get"
        url="<%= permissionsEntryURL %>"
        useDialog="<%= true %>"
    />
</c:if>
\end{verbatim}

  This prevents anyone without the permission to set permissions from
  seeing the permissions button. Say that three times fast!
\end{enumerate}

That's all there is to it! You've now learned all the steps in
\emph{DRAC}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define permissions
\item
  Register permissions
\item
  Associate permissions with resources
\item
  Check permissions
\end{enumerate}

Follow these steps, and your applications can take advantage of
Liferay's integrated and well-tested permissions system.

\chapter{Using JSR Roles in a
Portlet}\label{using-jsr-roles-in-a-portlet}

Roles in Liferay DXP are the primary means for granting or restricting
access to content. If you've decided \emph{not} to use Liferay's
permissions system, you can use the basic system offered by the JSR 168,
286, and 362 specifications that map Roles in a portlet to Roles
provided by the portal.

\section{JSR Portlet Security}\label{jsr-portlet-security}

The portlet specification defines a means to specify Roles used by
portlets in their \texttt{docroot/WEB-INF/portlet.xml} descriptors. The
Role names themselves, however, are not standardized. When these
portlets run in Liferay DXP, the Role names defined in the portlet must
be mapped to Roles that exist in the Portal.

For example, consider a Guestbook project that contains two portlets:
The Guestbook portlet and the Guestbook Admin portlet. The WAR version
of the Guestbook project's \texttt{portlet.xml} file references the
\emph{administrator}, \emph{guest}, \emph{power-user}, and \emph{user}
Roles:

\begin{verbatim}
<?xml version="1.0"?>

<portlet-app xmlns="http://xmlns.jcp.org/xml/ns/portlet" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/portlet http://xmlns.jcp.org/xml/ns/portlet/portlet-app_3_0.xsd" version="3.0">
    <portlet>
        <portlet-name>guestbook-war</portlet-name>
        <display-name>guestbook-war</display-name>
        <portlet-class>com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet</portlet-class>
        <init-param>
            <name>template-path</name>
            <value>/</value>
        </init-param>
        <init-param>
            <name>view-template</name>
            <value>/view.jsp</value>
        </init-param>
        <expiration-cache>0</expiration-cache>
        <supports>
            <mime-type>text/html</mime-type>
        </supports>
        <resource-bundle>content.Language</resource-bundle>
        <portlet-info>
            <title>guestbook-war</title>
            <short-title>guestbook-war</short-title>
            <keywords>guestbook-war</keywords>
        </portlet-info>
        <security-role-ref>
            <role-name>administrator</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>guest</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>power-user</role-name>
        </security-role-ref>
        <security-role-ref>
            <role-name>user</role-name>
        </security-role-ref>
    </portlet>
</portlet-app>
\end{verbatim}

An OSGi-based \texttt{guestbook-web} module project defines Roles
without an XML file, in the portlet class's \texttt{@Component}
annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.name=" + GuestbookPortletKeys.Guestbook,
        "javax.portlet.resource-bundle=content.Language",
        "javax.portlet.security-role-ref=power-user,user"
    },
    service = Portlet.class
)
\end{verbatim}

If you are using an OSGi-based MVC Portlet, you must use Liferay's
permissions system, as the only way to map JSR-362 Roles to Liferay
Roles is to place them in the Liferay WAR file's \texttt{portlet.xml}.

Your \texttt{portlet.xml} Roles must be mapped to specific Roles that
have been created. These mappings allow Liferay DXP to resolve conflicts
between Roles with the same name that are from different portlets
(e.g.~portlets from different developers).

\noindent\hrulefill

\textbf{Note:} Each Role named in a portlet's
\texttt{\textless{}security-role-ref\textgreater{}} element is given
permission to add the portlet to a page.

\noindent\hrulefill

\section{Mapping Portlet Roles to Portal
Roles}\label{mapping-portlet-roles-to-portal-roles}

To map the Roles to Liferay DXP, you must use the
\texttt{docroot/WEB-INF/liferay-portlet.xml} Liferay-specific
configuration file. For an example, see the mapping defined in the
Guestbook project's \texttt{liferay-portlet.xml} file.

\begin{verbatim}
<role-mapper>
    <role-name>administrator</role-name>
    <role-link>Administrator</role-link>
</role-mapper>
<role-mapper>
    <role-name>guest</role-name>
    <role-link>Guest</role-link>
</role-mapper>
<role-mapper>
    <role-name>power-user</role-name>
    <role-link>Power User</role-link>
</role-mapper>
<role-mapper>
    <role-name>user</role-name>
    <role-link>User</role-link>
</role-mapper>
\end{verbatim}

If a portlet definition references the Role \texttt{power-user}, that
portlet is mapped to the Liferay Role called \emph{Power User} that's
already in Liferay's database.

As stated above, there is no standardization with portal Role names. If
you deploy a portlet with Role names different from the above default
Liferay names, you must add the names to the \texttt{system.roles}
property in your \texttt{portal-ext.properties} file:

\begin{verbatim}
system.roles=my-role,your-role,our-role
\end{verbatim}

This prevents Roles from being created accidentally.

Once Roles are mapped to the portal, you can use methods as defined in
the portlet specification:

\begin{itemize}
\tightlist
\item
  \texttt{getRemoteUser()}
\item
  \texttt{isUserInRole()}
\item
  \texttt{getUserPrincipal()}
\end{itemize}

For example, you can use the following code to check if the current User
has the \texttt{power-user} Role:

\begin{verbatim}
if (renderRequest.isUserInRole("power-user")) {
    // ...
}
\end{verbatim}

By default, Liferay doesn't use the \texttt{isUserInRole()} method in
any built-in portlets. Liferay uses its own permission system directly
to achieve more fine-grained security. If you don't intend on deploying
your portlets to other portal servers, we recommend using Liferay's
permission system, because it offers a much more robust way of tailoring
your application's permissions.

\section{Related Topics}\label{related-topics}

\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{Liferay
Permissions}

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework}

\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}

\href{/docs/7-2/frameworks/-/knowledge_base/f/understanding-servicecontext}{Understanding
ServiceContext}

\chapter{Authentication Pipelines}\label{authentication-pipelines}

The authentication process is a pipeline through which users can be
validated by one or several systems. As a developer, you can
authenticate users to anything you wish, rather than be limited by what
Liferay DXP supports out of the box.

Here's how authentication works under most circumstances:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Users provide their credentials to the Login Portlet to begin an
  authenticated session in a browser.
\item
  Alternatively, credentials are provided to Liferay DXP's API
  endpoints, where they are sent in an HTTP BASIC Auth header.
\item
  Alternatively, credentials can be provided by another system. These
  are managed by \texttt{AutoLogin} components.
\item
  Credentials are checked by default against the database, but they can
  be delegated to other systems instead of or in addition to it. This is
  called an \emph{Authentication Pipeline}. You can add
  \texttt{Authenticator}s to the pipeline to support any system.
\item
  You can also customize the Login Portlet to support whatever user
  interface any of these systems need. This gives you full flexibility
  over the entire authentication process.
\end{enumerate}

This structure lets you support an authentication mechanism and/or
accept credentials from a system that Liferay DXP doesn't yet support.
If you don't like the user interface for signing in, you can replace it
with your own.

These tutorials guide you through these customizations. You'll discover
three kinds of customizations:

\begin{itemize}
\item
  \textbf{Auto Login:} the easiest of the three, this enables
  authentication to Liferay DXP using credentials provided in the HTTP
  header from another system.
\item
  \textbf{Authentication Pipelines:} if you must check credentials
  against other systems instead of or in addition to Liferay DXP's
  database, you can create a pipeline.
\item
  \textbf{Custom Login Portlet:} if you want to change the user's
  sign-in experience completely, you can implement your own Login
  portlet.
\end{itemize}

Read on to discover how to customize your users' sign-in experience.

\chapter{Auto Login}\label{auto-login}

While Liferay DXP supports a wide variety of
\href{/docs/7-2/deploy/-/knowledge_base/d/securing-product}{authentication
mechanisms}, you may use a home-grown system or some other product to
authenticate users. To do so, you can write an Auto Login component to
support your authentication system.

Auto Login components can check if the request contains something (a
cookie, an attribute) that can be associated with a user in any way. If
the component can make that association, it can authenticate that user.

\section{Creating an Auto Login
Component}\label{creating-an-auto-login-component}

Create a
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Declarative
Services component}. The component should implement the
\texttt{com.liferay.portal.kernel.security.auto.login.AutoLogin}
interface. Here's an example template:

\begin{verbatim}
import com.liferay.portal.kernel.security.auto.login.AutoLogin;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true)
public class MyAutoLogin implements Autologin {

    public String[] handleException(
            HttpServletRequest request, HttpServletResponse response,
            Exception e)
        throws AutoLoginException {

        /* This method is no longer used in the interface and can be 
      left empty */

    }

    public String[] login(
            HttpServletRequest request, HttpServletResponse response)
        throws AutoLoginException {

        /* Your Code Goes Here */

    }

}
\end{verbatim}

As you can see, you have access to the \texttt{HttpServletRequest} and
the \texttt{HttpServletResponse} objects. If your sign-on solution
places anything here that identifies a user such as a cookie, an
attribute, or a parameter, you can retrieve it and take whatever action
you need to retrieve the user information and authenticate that user.

For example, say that there's a request attribute that contains the
encrypted value of a user key. This can only be there if the user has
authenticated with a third party system that knew the value of the user
key, encrypted it, and added it as a request attribute. You could write
code that reads the value, decrypts it using the same pre-shared key,
and uses the value to look up and authenticate the user.

The \texttt{login} method is where this all happens. This method must
return a \texttt{String} array with three items in this order:

\begin{itemize}
\tightlist
\item
  The user ID
\item
  The user password
\item
  A boolean flag that's \texttt{true} if the password is encrypted and
  \texttt{false} if it's not (\texttt{Boolean.TRUE.toString()} or
  \texttt{Boolean.FALSE.toString()}).
\end{itemize}

Sending redirects is an optional \texttt{AutoLogin} feature. Since
\texttt{AutoLogin}s are part of the servlet filter chain, you have two
options. Both are implemented by setting attributes in the request. Here
are the attributes:

\begin{itemize}
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT}: This key causes
  \texttt{AutoLoginFilter} to stop the filter chain's execution and
  redirect immediately to the location specified in the attribute's
  value.
\item
  \texttt{AutoLogin.AUTO\_LOGIN\_REDIRECT\_AND\_CONTINUE}: This key
  causes \texttt{AutoLoginFilter} to set the redirect and continue
  executing the remaining filters in the chain.
\end{itemize}

Auto Login components are useful ways of providing an authentication
mechanism to a system that Liferay DXP doesn't yet support. You can
write them fairly quickly to provide the integration you need.

\section{Related Topics}\label{related-topics-1}

\href{/docs/7-2/frameworks/-/knowledge_base/f/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-2/frameworks/-/knowledge_base/f/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\chapter{Password-Based Authentication
Pipelines}\label{password-based-authentication-pipelines}

By default, once a user submits credentials, those credentials are
checked against Liferay DXP's database, though you can also delegate
authentication to an LDAP server. To use some other system in your
environment instead of or in addition to checking credentials against
the database, you can write an \texttt{Authenticator} and insert it as a
step in the authentication pipeline.

Because the \texttt{Authenticator} is checked by the Login Portlet, you
can't use this approach if the user must be redirected to the external
system or needs a token to authenticate. In those cases, you should use
an \href{/docs/7-2/frameworks/-/knowledge_base/f/auto-login}{Auto Login}
or an
\href{/docs/7-2/deploy/-/knowledge_base/d/authentication-verifiers}{Auth
Verifier}.

\texttt{Authenticator}s let you do these things:

\begin{itemize}
\tightlist
\item
  Log into Liferay DXP with a user name and password maintained in an
  external system
\item
  Make secondary user authentication checks
\item
  Perform additional processing when user authentication fails
\end{itemize}

Read on to learn how to create an \texttt{Authenticator}.

\section{Anatomy of an Authenticator}\label{anatomy-of-an-authenticator}

\texttt{Authenticator}s are implemented for various steps in the
authentication pipeline. Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{auth.pipeline.pre}: Comes before default authentication to the
  database. In this step, you can skip credential validation against the
  database. Implemented by \texttt{Authenticator}.
\item
  Default (optional) authentication to the database.
\item
  \texttt{auth.pipeline.post}: Further (secondary, tertiary)
  authentication checks. Implemented by \texttt{Authenticator}.
\item
  \texttt{auth.failure}: Perform additional processing after
  authentication fails. Implemented by \texttt{AuthFailure}.
\end{enumerate}

To create an \texttt{Authenticator}, create a module and add a component
that implements the interface:

\begin{verbatim}
@Component(
    immediate = true, property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class MyCustomAuth implements Authenticator {

    public int authenticateByEmailAddress(
            long companyId, String emailAddress, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
}

    public int authenticateByScreenName(
            long companyId, String screenName, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }

    public int authenticateByUserId(
            long companyId, long userId, String password,
            Map<String, String[]> headerMap, Map<String, String[]> parameterMap)
        throws AuthException {

return Authenticator.SUCCESS;
    }
}
\end{verbatim}

This example has been stripped down so you can see its structure. First,
note the \texttt{@Component} annotation's contents:

\begin{itemize}
\tightlist
\item
  \texttt{immediate\ =\ true}: sets the component to start immediately
\item
  \texttt{key=auth.pipeline.post}: sets the \texttt{Authenticator} to
  run in the \texttt{auth.pipeline.post} phase. To run the
  \texttt{auth.pipeline.pre} phase, substitute
  \texttt{auth.pipeline.pre}.
\item
  \texttt{service\ =\ Authenticator.class}: implements the
  \texttt{Authenticator} service. All \texttt{Authenticator}s must do
  this.
\end{itemize}

The three methods below the annotation run based on how you've
configured authentication: by email address (the default), by screen
name, or by user ID. All the methods throw an \texttt{AuthException} in
case the \texttt{Authenticator} can't perform its task: if the system
it's authenticating against is unavailable or if some dependency can't
be found. The methods in this barebones example return success in all
cases. If you deploy its module, it has no effect. Naturally, you'll
want to provide more functionality. Next is an example that shows you
how to do that.

\section{Creating an Authenticator}\label{creating-an-authenticator}

This example is an \texttt{Authenticator} that only allows users whose
email addresses end with \emph{@liferay.com} or \emph{@example.com}. You
can implement this using one module that does everything. If you think
other modules might use the functionality that validates the email
addresses, you should create two modules: one to implement the
\texttt{Authenticator} and one to validate email addresses. This example
shows the two module approach.

To create an \texttt{Authenticator}, create a module for your
implementation. The most appropriate Blade template for this is the
\href{/docs/7-2/reference/-/knowledge_base/r/using-the-service-template}{service
template}. Once you have the module, creating the \texttt{Activator} is
straightforward:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{@Component} annotation to bind your \texttt{Activator}
  to the appropriate authentication pipeline phase.
\item
  Implement the \texttt{Authenticator} interface and provide the
  functionality you need.
\item
  Deploy your module. If you're using
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}, do
  this via \texttt{blade\ deploy}.
\end{enumerate}

For this example, you'll do this twice: once for the email address
validator module and once for the \texttt{Authenticator} itself. The
\texttt{Authenticator} project contains the interface for the validator,
and the validator project contains the implementation. Here's what the
\texttt{Authenticator} module structure looks like:

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-authenticator-project.png}
\caption{The Authenticator module contains the validator's interface and
the authenticator.}
\end{figure}

Since the \texttt{Authenticator} is the most relevant, examine it first:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator;

import java.util.Map;

import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;
import com.liferay.portal.kernel.security.auth.AuthException;
import com.liferay.portal.kernel.security.auth.Authenticator;
import com.liferay.portal.kernel.service.UserLocalService;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;

@Component(
    immediate = true,
    property = {"key=auth.pipeline.post"},
    service = Authenticator.class
)
public class EmailAddressAuthenticator implements Authenticator {

    @Override
    public int authenticateByEmailAddress(long companyId, String emailAddress,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByScreenName(long companyId, String screenName,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserByScreenName(companyId, screenName).getEmailAddress();
        
        return validateDomain(emailAddress);
    }

    @Override
    public int authenticateByUserId(long companyId, long userId,
            String password, Map<String, String[]> headerMap,
            Map<String, String[]> parameterMap) throws AuthException {
        
        String emailAddress = 
            _userLocalService.fetchUserById(userId).getEmailAddress();
        
        return validateDomain(emailAddress);
    }
    
    private int validateDomain(String emailAddress) throws AuthException {
        
        if (_emailValidator == null) {
            
            String msg = "Email address validator is unavailable, cannot authenticate user";            
            _log.error(msg);
            
            throw new AuthException(msg);
        }
        
        if (_emailValidator.isValidEmailAddress(emailAddress)) {        
            return Authenticator.SUCCESS;
        }
        return Authenticator.FAILURE;
    }
    
    @Reference
    private volatile UserLocalService _userLocalService;
    
    @Reference(
        policy = ReferencePolicy.DYNAMIC,
        cardinality = ReferenceCardinality.OPTIONAL
    )
    private volatile EmailAddressValidator _emailValidator;
    
    private static final Log _log = LogFactoryUtil.getLog(EmailAddressAuthenticator.class);
}
\end{verbatim}

This time, rather than stubs, the three authentication methods contain
functionality. The \texttt{authenticateByEmailAddress} method directly
checks the email address provided by the Login Portlet. The other two
methods, \texttt{authenticateByScreenName} and
\texttt{authenticateByUserId} call \texttt{UserLocalService} to look up
the user's email address before checking it. The OSGi container injects
this service because of the \texttt{@Reference} annotation. Note that
the validator is also injected in this same manner, though it's
configured not to fail if the implementation can't be found. This allows
this module to start regardless of its dependency on the validator
implementation. In this case, this is safe because the error is handled
by throwing an \texttt{AuthException} and logging the error.

Why would you want to do it this way? To err gracefully. Because this is
an \texttt{auth.pipeline.post} \texttt{Authenticator}, you presumably
have other \texttt{Authenticator}s checking credentials before this one.
If this one isn't working, you want to inform administrators with an
error message rather than catastrophically failing and preventing users
from logging in.

The only other Java code in this module is the Interface for the
validator:

\begin{verbatim}
package com.liferay.docs.emailaddressauthenticator.validator;

import aQute.bnd.annotation.ProviderType;

@ProviderType
public interface EmailAddressValidator {

    public boolean isValidEmailAddress(String emailAddress);
}
\end{verbatim}

This defines a single method for checking the email address.

Next, you'll address the validator module.

\begin{figure}
\centering
\includegraphics{./images/auth-pipeline-validator-project.png}
\caption{The validator project implements the Validator Interface and
depends on the authenticator module.}
\end{figure}

This module contains only one class. It implements the Validator
interface:

\begin{verbatim}
package com.liferay.docs.emailaddressvalidator.impl;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import org.osgi.service.component.annotations.Component;
import com.liferay.docs.emailaddressauthenticator.validator.EmailAddressValidator;

@Component(
    immediate = true,
    property = {
    },
    service = EmailAddressValidator.class
)
public class EmailAddressValidatorImpl implements EmailAddressValidator {

    @Override
    public boolean isValidEmailAddress(String emailAddress) {

        if (_validEmailDomains.contains(
            emailAddress.substring(emailAddress.indexOf('@')))) {

            return true;
        }
        return false;
    }

    private Set<String> _validEmailDomains = 
        new HashSet<String>(Arrays.asList(new String[] {"@liferay.com", "@example.com"}));
}
\end{verbatim}

This code checks to make sure that the email address is from the
\emph{@liferay.com} or \emph{@example.com} domains. The only other
interesting part of this module is the Gradle build script, because it
defines a compile-only dependency between the two projects. This is
divided into two files: a \texttt{settings.gradle} and a
\texttt{build.gradle}.

The \texttt{settings.gradle} file defines the location of the project
(the \texttt{Authenticator}) the validator depends on:

\begin{verbatim}
include ':emailAddressAuthenticator'
project(':emailAddressAuthenticator').projectDir = new File(settingsDir, '../com.liferay.docs.emailAddressAuthenticator')
\end{verbatim}

Since this project contains the interface, it must be on the classpath
at compile time, which is when \texttt{build.gradle} is running:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins", version: "3.0.23"
    }

    repositories {
        mavenLocal()

        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.plugin"

dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
    compileOnly group: "org.osgi", name: "org.osgi.compendium", version: "5.0.0"

    compileOnly project(":emailAddressAuthenticator")
}

repositories {
    mavenLocal()

    maven {
        url "https://repository-cdn.liferay.com/nexus/content/groups/public"
    }
}
\end{verbatim}

Note the line in the dependencies section that refers to the
\texttt{Authenticator} project defined in \texttt{settings.gradle}.

When these projects are deployed, the \texttt{Authenticator} you defined
runs, enforcing logins for the two domains specified in the validator.

\section{Related Topics}\label{related-topics-2}

\href{/docs/7-2/frameworks/-/knowledge_base/f/auto-login}{Auto Login}

\href{/docs/7-2/frameworks/-/knowledge_base/f/writing-a-custom-login-portlet}{Writing
a Custom Login Portlet}

\chapter{Writing a Custom Login
Portlet}\label{writing-a-custom-login-portlet}

If you need to customize your users' authentication experience
completely, you can write your own Login Portlet. The mechanics of this
on the macro level are no different from writing any other portlet, so
if you need to familiarize yourself with that, please see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{portlets}.

This tutorial shows only the relevant parts of a
\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlet} that authenticates the user. You'll learn how to call the
\href{/docs/7-2/frameworks/-/knowledge_base/f/password-based-authentication-pipelines}{authentication
pipeline} and then redirect the user to a location of your choice.

\section{Authenticating to Liferay
DXP}\label{authenticating-to-liferay-dxp}

\noindent\hrulefill

\textbf{Note:} When developing a login portlet, set the session timeout
portal property like this:

\begin{verbatim}
 session.timeout.auto.extend.offset=45
\end{verbatim}

This is needed because the default (as of
\href{https://issues.liferay.com/browse/LPS-68543}{LPS-68543}) setting
is \texttt{0}, causing the browser to execute an
\texttt{extend\_session} call. This may force users attempting to log in
to make the attempt twice.

\noindent\hrulefill

It has only one view, which is used for logging in or showing the user
who is already logged in:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b><liferay-ui:message key="myloginportlet_MyLogin.caption"/></b>
</p>

<c:choose>
    <c:when test="<%= themeDisplay.isSignedIn() %>">

        <%
        String signedInAs = HtmlUtil.escape(user.getFullName());

        if (themeDisplay.isShowMyAccountIcon() && (themeDisplay.getURLMyAccount() != null)) {
            String myAccountURL = String.valueOf(themeDisplay.getURLMyAccount());

            signedInAs = "<a class=\"signed-in\" href=\"" + HtmlUtil.escape(myAccountURL) + "\">" + signedInAs + "</a>";
        }
        %>

        <liferay-ui:message arguments="<%= signedInAs %>" key="you-are-signed-in-as-x" translateArguments="<%= false %>" />
    </c:when>
    <c:otherwise>
    
        <%
        String redirect = ParamUtil.getString(request, "redirect");
        %>
    
        <portlet:actionURL name="/login/login" var="loginURL">
            <portlet:param name="mvcRenderCommandName" value="/login/login" />
        </portlet:actionURL>
        
        <aui:form action="<%= loginURL %>" autocomplete='on' cssClass="sign-in-form" method="post" name="loginForm">
        
            <aui:input name="saveLastPath" type="hidden" value="<%= false %>" />
            <aui:input name="redirect" type="hidden" value="<%= redirect %>" />
                    
            <aui:input autoFocus="true" cssClass="clearable" label="email-address" name="login" showRequiredLabel="<%= false %>" type="text" value="">
                <aui:validator name="required" />
            </aui:input>

            <aui:input name="password" showRequiredLabel="<%= false %>" type="password">
                <aui:validator name="required" />
            </aui:input>
            
            <aui:button-row>
                <aui:button cssClass="btn-lg" type="submit" value="sign-in" />
            </aui:button-row>
                
        </aui:form>
    </c:otherwise>
</c:choose>
\end{verbatim}

Note that in the form, authentication by email address (the default
setting) is hard-coded, as this is an example project. The current page
is sent as a hidden field on the form so the portlet can redirect the
user to it, but you can of course set this to any value you want.

The portlet handles all processing of this form using a single Action
Command (imports left out for brevity):

\begin{verbatim}
@Component(
    property = {
        "javax.portlet.name=MyLoginPortlet",
        "mvc.command.name=/login/login"
    },
    service = MVCActionCommand.class
)
public class MyLoginMVCActionCommand extends BaseMVCActionCommand {

    @Override
    protected void doProcessAction(ActionRequest actionRequest,
            ActionResponse actionResponse) throws Exception {

        ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
            WebKeys.THEME_DISPLAY);
        
        HttpServletRequest request = PortalUtil.getOriginalServletRequest(
            PortalUtil.getHttpServletRequest(actionRequest));
        
        HttpServletResponse response = PortalUtil.getHttpServletResponse(
            actionResponse);

        String login = ParamUtil.getString(actionRequest, "login");
        String password = actionRequest.getParameter("password");
        boolean rememberMe = ParamUtil.getBoolean(actionRequest, "rememberMe");
        String authType = CompanyConstants.AUTH_TYPE_EA;
        
        AuthenticatedSessionManagerUtil.login(
            request, response, login, password, rememberMe, authType);
        
        actionResponse.sendRedirect(themeDisplay.getPathMain());
    }

}
\end{verbatim}

The only tricky/unusual code here is the need to grab the
\texttt{HttpServletRequest} and the \texttt{HttpServletResponse}. This
is necessary to call Liferay DXP's API for authentication. At the end of
the Action Command, the portlet sends a redirect that sends the user to
the same page. You can of course make this any page you want.

Implementing your own login portlet gives you complete control over the
authentication process.

\section{Related Topics}\label{related-topics-3}

\href{/docs/7-2/frameworks/-/knowledge_base/f/password-based-authentication-pipelines}{Password-Based
Authentication Pipelines}

\href{/docs/7-2/frameworks/-/knowledge_base/f/auto-login}{Auto Login}

\chapter{Service Access Policies}\label{service-access-policies}

Service access policies provide web service security beyond user
authentication to remote services. Together with
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{permissions},
service access policies limit remote service access by remote client
applications. This forms an additional security layer that protects user
data from unauthorized access and modification.

To connect to a web service, remote clients must authenticate using
credentials in that instance. This grants the remote client the
permissions assigned to those credentials in the Liferay DXP
installation. Service access policies further limit the remote client's
access to the services specified in the policy. Without such policies,
authenticated remote clients are treated like users: they can call any
remote API and read or modify data on behalf of the authenticated user.
Since remote clients are often intended for a specific use case,
granting them access to everything the user has permissions for poses a
security risk.

For example, consider a mobile app (client) that displays a user's
appointments from the Liferay Calendar app. This client app doesn't need
access to the API that updates the user profile, even though the user
has such permissions on the server. The client app doesn't even need
access to the Calendar API methods that create, update, and delete
appointments. It only needs access to the remote service methods for
finding and retrieving appointments. A service access policy on the
server can restrict the client's access to only these service methods.
Since the client doesn't perform other operations, having access to them
is a security risk if the mobile device is lost or stolen or the client
app is compromised by an attacker.

\section{How Service Access Policies
Work}\label{how-service-access-policies-work}

A remote client's request to a web service contains the user's
credentials or an authorization token. An authentication module
recognizes the client based on the credentials/token and grants the
appropriate service access policy to the request. The service access
policy authorization layer then processes all granted policies and lets
the request access the remote service(s) permitted by the policy.

\begin{figure}
\centering
\includegraphics{./images/service-access-policies-arch.png}
\caption{The authorization module maps the credentials or token to the
proper Service Access Policy.}
\end{figure}

Service Access policies are created in the Control Panel by
administrators. If you want to start creating policies yourself, see
\href{/docs/7-2/deploy/-/knowledge_base/d/service-access-policies}{this
article on service access policies} that documents creating them in the
UI.

There may be cases, however, when your server-side Liferay app must use
the service access policies API:

\begin{itemize}
\item
  It uses
  \href{/docs/7-2/frameworks/-/knowledge_base/f/auto-login}{custom
  remote API authentication} (tokens) and require certain services to be
  available for clients using the tokens.
\item
  It requires its services be made available to guest users, with no
  authentication necessary.
\item
  It contains a
  \href{/docs/7-2/frameworks/-/knowledge_base/f/password-based-authentication-pipelines}{remote
  service authorization layer} that needs to drive access to remote
  services based on granted privileges.
\end{itemize}

\section{API Overview}\label{api-overview}

Liferay provides an Interface and a \texttt{ThreadLocal} if you don't
want to roll your own policies. If you want to get low level, an API is
provided that Liferay itself has used to implement
\href{/docs/7-2/user/-/knowledge_base/u/administering-liferay-sync}{Liferay
Sync}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Interface and \texttt{ThreadLocal} are available in the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/package-summary.html}{package
  \texttt{com.liferay.portal.kernel.security.service.access.policy}}.
  This package provides classes for basic access to policies. For
  example, you can use the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyManagerUtil.html}{singleton
  \texttt{ServiceAccessPolicyManagerUtil}} to obtain Service Access
  Policies configured in the system. You can also use the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/service/access/policy/ServiceAccessPolicyThreadLocal.html}{\texttt{ServiceAccessPolicyThreadLocal}
  class} to set and obtain Service Access Policies granted to the
  current request thread.

  At this level, you can get a list of the configured policies to let
  your app/client choose a policy for accessing services. Also, apps
  like OAuth can offer a list of available policies during the
  authorization step in the OAuth workflow and allow the user to choose
  the policy to assign to the remote application. You can also grant a
  policy to a current request thread. When a remote client accesses an
  API, something must tell the Liferay instance which policies are
  assigned to this call. This something is in most cases an
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/security/auth/verifier/AuthVerifier.html}{\texttt{AuthVerifier}
  implementation}. For example, in the case of the OAuth app, an
  \texttt{AuthVerifier} implementation assigns the policy chosen by the
  user in the authorization step.
\item
  The API ships with the product as OSGi modules:
\end{enumerate}

\begin{itemize}
\item
  \texttt{com.liferay.portal.security.service.access.policy.api.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
\item
  \texttt{com.liferay.portal.security.service.access.policy.web.jar}

  These OSGi modules are active by default, and you can use them to
  manage Service Access Policies programmatically. Each module publishes
  a list of packages and services that can be consumed by other OSGi
  modules.
\end{itemize}

You can use both tools to develop a token verification module (a module
that implements custom security token verification for use in
authorizing remote clients) for your app to use. For example, this
module may contain a JSON Web Token implementation for Liferay DXP's
remote API. A custom token verification module must use the Service
Access Policies API during the remote API/web service call to grant the
associated policy during the request. The module

\begin{itemize}
\item
  can use
  \texttt{com.liferay.portal.security.service.access.policy.api.jar} and
  \texttt{com.liferay.portal.security.service.access.policy.service.jar}
  to create policies programmatically.
\item
  should use the method
  \texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName()}
  to grant the associated policy during a web service request.
\item
  can use \texttt{ServiceAccessPolicyManagerUtil} to display list of
  supported policies when authorizing the remote application, to
  associate the token with an existing policy.
\end{itemize}

\section{Service Access Policy
Example}\label{service-access-policy-example}

\href{https://www.liferay.com/supporting-products/liferay-sync}{Liferay
Sync's} \texttt{sync-security} module is a service access policy module.
It uses
\texttt{com.liferay.portal.security.service.access.policy.service} to
create the \texttt{SYNC\_DEFAULT} and \texttt{SYNC\_TOKEN} policies
programmatically. For service calls to Sync's remote API, these policies
grant access to Sync's
\texttt{com.liferay.sync.service.SyncDLObjectService\#getSyncContext}
and \texttt{com.liferay.sync.service.*}, respectively. Here's the code
in the \texttt{sync-security} module that defines and creates these
policies:

\begin{verbatim}
@Component(immediate = true)
public class SyncSAPEntryActivator {

    // Define the policies
    public static final Object[][] SAP_ENTRY_OBJECT_ARRAYS = new Object[][] {
        {
            "SYNC_DEFAULT",
            "com.liferay.sync.service.SyncDLObjectService#getSyncContext", true
        },
        {"SYNC_TOKEN", "com.liferay.sync.service.*", false}
    };

    ...

    // Create the policies
    protected void addSAPEntry(long companyId) throws PortalException {
            for (Object[] sapEntryObjectArray : SAP_ENTRY_OBJECT_ARRAYS) {
                String name = String.valueOf(sapEntryObjectArray[0]);
                String allowedServiceSignatures = String.valueOf(
                    sapEntryObjectArray[1]);
                boolean defaultSAPEntry = GetterUtil.getBoolean(
                    sapEntryObjectArray[2]);

                SAPEntry sapEntry = _sapEntryLocalService.fetchSAPEntry(
                    companyId, name);

                if (sapEntry != null) {
                    continue;
                }

                Map<Locale, String> map = new HashMap<>();

                map.put(LocaleUtil.getDefault(), name);

                _sapEntryLocalService.addSAPEntry(
                    _userLocalService.getDefaultUserId(companyId),
                    allowedServiceSignatures, defaultSAPEntry, true, name, map,
                    new ServiceContext());
            }
    }

    ...

}
\end{verbatim}

This class creates the policies when the module starts. Note that this
module is included and enabled by default. You can access these and
other policies in \emph{Control Panel} → \emph{Configuration} →
\emph{Service Access Policy}.

The \texttt{sync-security} module must then grant the appropriate policy
when needed. Since every authenticated call to Liferay Sync's remote API
requires access to \texttt{com.liferay.sync.service.*}, the module must
grant the \texttt{SYNC\_TOKEN} policy to such calls. The module does
this with the method
\texttt{ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName},
as shown in this code snippet:

\begin{verbatim}
if ((permissionChecker != null) && permissionChecker.isSignedIn()) {
    ServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName(
        String.valueOf(
            SyncSAPEntryActivator.SAP_ENTRY_OBJECT_ARRAYS[1][0]));
}
\end{verbatim}

Now every authenticated call to Sync's remote API, regardless of
authentication method, has access to
\texttt{com.liferay.sync.service.*}. To see the full code example,
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/sync/sync-security/src/main/java/com/liferay/sync/security/servlet/filter/SyncAuthFilter.java}{click
here}.

Nice! Now you know how to integrate your apps with the Service Access
Policies.

\chapter{Frameworks}\label{frameworks}

To make your applications more fully featured and to develop them
faster, you can make use of Liferay's development frameworks. These help
you create commonly used features---like search, tagging, and
comments---without having to develop them from scratch. And since these
features are tried and tested, you can rest assured knowing they're bug
free.

Here are just a few frameworks you'll find here:

\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{\textbf{A
fully-fledged permissions system:}} Implement permissions the way
they're implemented with the applications that ship with Liferay DXP for
a consistent, seamless, and robust experience.

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{\textbf{Assets:}}
Publish data from your application across the system, making it
available to those who need it, and enabling other features like
tagging, categorizing, and comments.

\href{/docs/7-2/frameworks/-/knowledge_base/f/search}{\textbf{Search:}}
If you have a data-driven application, you can add search capabilities
by integrating with Liferay's search indexer.

\href{/docs/7-2/frameworks/-/knowledge_base/f/configurable-applications}{\textbf{A
configuration system with auto-generated or custom UI:}} Are you
providing user-configurable options in your application? Make use of
Liferay's configuration system and provide a clean and consistent
experience for your users.

\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{\textbf{File
management:}} Will your applications work with files? Use Liferay's
Documents and Media API to manage them.

\href{/docs/7-2/frameworks/-/knowledge_base/f/content-publication-management}{\textbf{Import/Export:}}
Use Liferay's import/export system to make your application's data
portable or to stage it for publication to production systems.

\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{\textbf{Web
Fragments:}} Provide your content managers with dynamic chunks of
functionality they can use as building blocks for web pages.

\href{/docs/7-2/frameworks/-/knowledge_base/f/the-workflow-framework}{\textbf{Workflow:}}
Run the data from your application through an approval process.

This really just scratches the surface. From
\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{pop-up list
selectors} to a
\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api}{social
networking API}, as a Liferay developer, you have access to tons of
frameworks that make your life easier.

\chapter{Asset Framework}\label{asset-framework}

The asset framework is behind many of Liferay's most powerful features.
It provides tools for displaying and interacting with various types of
content and data. For example, if you build an event management
application that displays a list of upcoming events, you can use the
asset framework to let users add tags, categories, or comments to make
entries more self-descriptive. Using the asset framework is also the
first step for integrating other important frameworks like Segmentation
and Personalization or Workflow.

As background, the term \emph{asset} refers to any type of content:
text, a file, a URL, an image, documents, blog entries, bookmarks, wiki
pages, or anything you create in your applications.

The asset framework tutorials assume that you've used Liferay's Service
Builder to generate your persistence layer, that you've implemented
permissions on the entities that you're persisting, and that you've
enabled them for search and indexing. You can learn more about Liferay's
Service Builder and how to use it in the
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} tutorial section. After that is completed, you can get started
asset enabling your application.

This section explores how to leverage the asset framework's various
features. Here are some features that you'll give your users as you
implement them in your app:

\begin{itemize}
\tightlist
\item
  Extensively render your assets.
\item
  Associate tags to custom content types. Users can create and assign
  new tags or use existing tags.
\item
  Associate categories to custom content types.
\item
  Manage tags from the Control Panel. Administrators can even merge
  tags.
\item
  Manage categories from the Control Panel. This includes the ability to
  create category hierarchies.
\item
  Relate assets to one another.
\end{itemize}

There are several steps to creating an asset and taking full advantage
of the asset framework.

\section{Persistence Operations for
Assets}\label{persistence-operations-for-assets}

To use Liferay's asset framework with an entity, you must inform the
asset framework about each entity instance you create, modify, and
delete. In this sense, it's similar to informing
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{Liferay's
permissions framework} about a new resource. All you have to do is
invoke a method of the asset framework that associates an
\texttt{AssetEntry} with the entity so Liferay can keep track of the
entity as an asset. When it's time to update the entity, you update the
asset at the same time.

To leverage assets, you must also implement indexers for your portlet's
entities. Liferay's asset framework uses indexers to manage assets.

\section{Rendering an Asset}\label{rendering-an-asset}

Once you add your asset to the framework, you can render the asset using
the Asset Publisher application. The default render, however, only
displays the asset's title and description text. Anything else requires
additional coding. For instance, you might want these additional things:

\begin{itemize}
\tightlist
\item
  An edit feature for modifying an asset.
\item
  View an asset in its original context (e.g., a blog in the Blogs
  application; a post in the Message Boards application).
\item
  Embed images, videos, and audio.
\item
  Restrict access to users who do not have permissions to interact with
  the asset.
\item
  Allow users to comment on the asset.
\end{itemize}

You can dictate your asset's rendering capabilities by providing the
\emph{Asset Renderer} framework. There are two prerequisites for asset
enabling an application:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The application must store asset data. Applications that store a data
  model meet this requirement.
\item
  The application must contain at least one non-instanceable portlet.
  \texttt{Edit} links for the asset cannot be generated without a
  non-instanceable portlet.
\end{enumerate}

Some applications may consist of only one non-instanceable portlet,
while others may consist of a both instanceable and non-instanceable
portlets. If your application does not currently include a
non-instanceable portlet, adding a configuration interface through a
panel app both enhances the usability of the application, and meets the
requirement for adding a non-instanceable portlet to the application.

After you have met all the prerequisites, there are two things you must
do to get your asset renderer functioning properly for your asset:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset renderer for your custom asset.
\item
  Create an asset renderer factory to create an instance of the asset
  renderer for each asset entity.
\end{enumerate}

\section{Asset Features}\label{asset-features}

Once you have done the necessary work to persist your assets and render
them, you can enable Tags, Categories, and Related Assets.

\section{Tags and Categories}\label{tags-and-categories}

Tags and Categories are two ways that you can organize and connect
assets. Tags are simple \emph{ad hoc} groups. Any two assets with the
same tag are connected by that tag. Categories are a form of
hierarchical organization where an administrator can define a number of
categories for organization content, images, or other types of assets
and use those categories to help users find what they're looking for.

\begin{figure}
\centering
\includegraphics{./images/asset-fw-categories-and-tags-options.png}
\caption{Adding category and tag input options lets authors aggregate
and label custom entities.}
\end{figure}

\section{Relating Assets}\label{relating-assets}

Relating assets connects individual pieces of content across your site
or portal. This helps users discover related content, particularly when
there's an abundance of other available content. For example, assets
related to a web content article appear alongside that entry in the
Asset Publisher application.

\begin{figure}
\centering
\includegraphics{./images/asset-related-content-asset-publisher.png}
\caption{You and your users can find it helpful to relate assets to
entities, such as this blogs entry.}
\end{figure}

\section{Implementing Asset Priority}\label{implementing-asset-priority}

The \href{/docs/7-2/user/-/knowledge_base/u/publishing-assets}{Asset
Publisher} lets you order assets by priority. For this to work, however,
users must be able to set the asset's priority when creating or editing
the asset. For example, when creating or editing web content, users can
assign a priority in the Metadata section's Priority field.

\begin{figure}
\centering
\includegraphics{./images/web-content-categorization.png}
\caption{The Priority field lets users set an asset's priority.}
\end{figure}

Ready to implement assets? The rest of the tutorials show you how.

\chapter{Adding, Updating, and Deleting
Assets}\label{adding-updating-and-deleting-assets}

This section shows you how to enable assets for your custom entities and
implement indexes for them. It's time to get started!

\section{Preparing Your Project for the Asset
Framework}\label{preparing-your-project-for-the-asset-framework}

In your project's \texttt{service.xml} file, add an asset entry entity
reference for your custom entity. Add the following \texttt{reference}
tag before your custom entity's closing
\texttt{\textless{}/entity\textgreater{}} tag.

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetEntry" />
\end{verbatim}

Then \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{run
Service Builder.}

Now you're ready to implement adding and updating assets!

\section{Adding and Updating Assets}\label{adding-and-updating-assets}

Your \texttt{-LocalServiceImpl} Java class inherits from its parent base
class an \texttt{AssetEntryLocalService} instance; it's assigned to the
variable \texttt{assetEntryLocalService}. To add your custom entity as a
Liferay asset, you must invoke the \texttt{assetEntryLocalService}'s
\texttt{updateEntry} method.

Here's what the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portlet/asset/service/impl/AssetEntryLocalServiceImpl.html\#updateEntry-long-long-java.util.Date-java.util.Date-java.lang.String-long-java.lang.String-long-long:A-java.lang.String:A-boolean-boolean-java.util.Date-java.util.Date-java.util.Date-java.util.Date-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-int-int-java.lang.Double-}{\texttt{updateEntry}}
method's signature looks like:

\begin{verbatim}
AssetEntry updateEntry(
    long userId, long groupId, Date createDate, Date modifiedDate,
    String className, long classPK, String classUuid, long classTypeId,
    long[] categoryIds, String[] tagNames, boolean listable,
    boolean visible, Date startDate, Date endDate, Date publishDate,
    Date expirationDate, String mimeType, String title,
    String description, String summary, String url, String layoutUuid,
    int height, int width, Double priority)
throws PortalException
\end{verbatim}

Here are descriptions of each of the \texttt{updateEntry} method's
parameters:

\texttt{userId}: identifies the user updating the content.

\texttt{groupId}: identifies the scope of the created content. If your
content doesn't support scopes (extremely rare), pass \texttt{0} as the
value.

\texttt{createDate}: the date the entity was created.

\texttt{modifiedDate}: the date of this change to the entity.

\texttt{className}: identifies the entity's class. The recommended
convention is to use the name of the Java class that represents your
content type. For example, you can pass in the value returned from
\texttt{{[}YourClassName{]}.class.getName()}.

\texttt{classPK}: identifies the specific entity instance,
distinguishing it from other instances of the same type. It's usually
the primary key of the table where the entity is stored.

\texttt{classUuid}: serves as a secondary identifier that's guaranteed
to be universally unique. It correlates entity instances across scopes.
It's especially useful if your content is exported and imported across
separate portals.

\texttt{classTypeId}: identifies the particular variation of this class,
if it has any variations. Otherwise, use \texttt{0}.

\texttt{categoryIds}: represent the categories selected for the entity.
The asset framework stores them for you.

\texttt{tagNames}: represent the tags selected for the entity. The asset
framework stores them for you.

\texttt{listable}: specifies whether the entity can be shown in dynamic
lists of content (such as asset publisher configured dynamically).

\texttt{visible}: specifies whether the entity is approved.

\texttt{startDate}: the entity's publish date. You can use it to specify
when an Asset Publisher should show the entity's content.

\texttt{endDate}: the date the entity is taken down. You can use it to
specify when an Asset Publisher should stop showing the entity's
content.

\texttt{publishDate}: the date the entity will start to be shown.

\texttt{expirationDate}: the date the entity will no longer be shown.

\texttt{mimetype}: the Multi-Purpose Internet Mail Extensions type, such
as
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html\#TEXT_HTML}{ContentTypes.TEXT\_HTML},
used for the content.

\texttt{title}: the entity's name.

\texttt{description}: a \texttt{String}-based textual description of the
entity.

\texttt{summary}: a shortened or truncated sample of the entity's
content.

\texttt{url}: a URL to optionally associate with the entity.

\texttt{layoutUuid}: the universally unique ID of the layout of the
entry's default display page.

\texttt{height}: this can be set to \texttt{0}.

\texttt{width}: this can be set to \texttt{0}.

\texttt{priority}: specifies how the entity is ranked among peer entity
instances. Low numbers take priority over higher numbers.

The following code from Liferay's Wiki application's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/service/impl/WikiPageLocalServiceImpl.java}{\texttt{WikiPageLocalServiceImpl}}
Java class demonstrates invoking the \texttt{updateEntry} method on the
wiki page entity called \texttt{WikiPage}. In your \texttt{add-} method,
you could invoke \texttt{updateEntry} after adding your entity's
resources. Likewise, in your \texttt{update-} method, you could invoke
\texttt{updateEntry} after calling the \texttt{super.update-} method.
The code below is called in the \texttt{WikiPageLocalServiceImpl}
class's \texttt{updateStatus(...)} method.

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.updateEntry(
    userId, page.getGroupId(), page.getCreateDate(),
    page.getModifiedDate(), WikiPage.class.getName(),
    page.getResourcePrimKey(), page.getUuid(), 0,
    assetCategoryIds, assetTagNames, true, true, null, null,
    page.getCreateDate(), null, ContentTypes.TEXT_HTML,
    page.getTitle(), null, null, null, null, 0, 0, null);

Indexer<JournalArticle> indexer = IndexerRegistryUtil.nullSafeGetIndexer(
    WikiPage.class);

indexer.reindex(page);
\end{verbatim}

Immediately after invoking the \texttt{updateEntry} method, you must
update the respective asset and index the entity instance. The above
code calls the indexer to index (or re-index, if updating) the entity.
That's all there is to it.

\noindent\hrulefill

\textbf{Tip:} The current user's ID and the scope group ID are commonly
made available in service context parameters. If the service context you
use contains them, then you can access them in calls like these:

long userId = serviceContext.getUserId(); long groupId =
serviceContext.getScopeGroupId();

\noindent\hrulefill

Next, you'll learn what's needed to delete an entity that's associated
with an asset.

\section{Deleting Assets}\label{deleting-assets}

When deleting your entities, you should delete the associated assets and
indexes at the same time. This cleans up stored asset and index
information, which keeps the Asset Publisher from showing information
for the entities you've deleted.

In your \texttt{-LocalServiceImpl} Java class, open your
\texttt{delete-} method. After the code that deletes the entity's
resource, delete the entity instance's asset entry and index.

Here's some code which deletes an asset entry and an index associated
with a portlet's entity.

\begin{verbatim}
assetEntryLocalService.deleteEntry(
    ENTITY.class.getName(), assetEntry.getEntityId());

Indexer<ENTITY> indexer = IndexerRegistryUtil.nullSafeGetIndexer(ENTITY.class);
indexer.delete(assetEntry);
\end{verbatim}

In your \texttt{-LocalServiceImpl} class, you can write similar code.
Replace the \emph{ENTITY} class name and variable with your entity's
name.

\noindent\hrulefill

\textbf{Important:} For Liferay's Asset Publisher application to show
your entity, the entity must have an Asset Renderer.

Note also that an Asset Renderer is how you show a user the components
of your entity in the Asset Publisher. On deploying your portlet with
asset, indexer, and asset rendering implementations in place, an Asset
Publisher can show your custom entities!

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/basic-asset-in-asset-publisher.png}
\caption{It can be useful to show custom entities, like this wiki page
entity, in a JSP or in an Asset Publisher.}
\end{figure}

Great! Now you know how to add, update, and delete assets in your apps!

\chapter{Creating an Asset Renderer}\label{creating-an-asset-renderer}

In this tutorial, you'll learn how to create an \texttt{Asset\ Renderer}
and associate your JSP templates with it, along with configuring several
other options by studying a Liferay asset: Blogs.

The Blogs application offers many different ways to access and render a
blogs asset. You'll learn how a blogs asset provides an edit feature,
comment section, original context viewing (i.e., viewing an asset from
the Blogs application), workflow, and more. You'll also learn how it
uses JSP templates to display various blog views. The Blogs application
is an extensive example of how an asset renderer can be customized to
fit your needs.

To learn how an asset renderer is created, you'll create the
pre-existing
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/blogs/web/asset/BlogsEntryAssetRenderer.html}{\texttt{BlogsEntryAssetRenderer}}
class, which configures the asset renderer framework for the Blogs
application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing project for your asset-related
  classes. For instance, the \texttt{BlogsEntryAssetRenderer} class
  resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package.
\item
  Create your \texttt{-AssetEntry} class for your application in the new
  \texttt{-.asset} package and have it implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/AssetEntry.html}{\texttt{AssetEntry}}
  interface. Consider the \texttt{BlogsEntryAssetRenderer} class as an
  example:

\begin{verbatim}
public class BlogsEntryAssetRenderer
    extends BaseJSPAssetRenderer<BlogsEntry> implements TrashRenderer {
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} class extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/asset/kernel/model/BaseJSPAssetRenderer.html}{\texttt{BaseJSPAssetRenderer}},
  which is an extension class intended for those who plan on using JSP
  templates to generate their asset's HTML. The
  \texttt{BaseJSPAssetRenderer} class implements the
  \texttt{AssetRenderer} interface. You'll notice the asset renderer
  also implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/trash/TrashRenderer.html}{\texttt{TrashRenderer}}
  interface. This is a common practice for many applications, so they
  can use Liferay DXP's Recycle Bin.
\item
  Define the asset renderer class's constructor, which typically sets
  the asset object to use in the asset renderer class.

\begin{verbatim}
public BlogsEntryAssetRenderer(
    BlogsEntry entry, ResourceBundleLoader resourceBundleLoader) {

    _entry = entry;
    _resourceBundleLoader = resourceBundleLoader;
}
\end{verbatim}

  The \texttt{BlogsEntryAssetRenderer} also sets the resource bundle
  loader, which loads the language keys for a module. You can learn more
  about the resource bundle loader in the
  \href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
  Language Keys} tutorial.

  Also, make sure to define the \texttt{\_entry} and
  \texttt{\_resourceBundleLoader} fields in the class:

\begin{verbatim}
private final BlogsEntry _entry;
private final ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}
\item
  Now that your class declaration and constructor are defined for the
  blogs asset renderer, you must begin connecting your asset renderer to
  your asset. The following getter methods accomplish this:

\begin{verbatim}
@Override
public BlogsEntry getAssetObject() {
    return _entry;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}

@Override
public long getClassPK() {
    return _entry.getEntryId();
}

@Override
public long getGroupId() {
    return _entry.getGroupId();
}

@Override
public String getType() {
    return BlogsEntryAssetRendererFactory.TYPE;
}

@Override
public String getUuid() {
    return _entry.getUuid();
}
\end{verbatim}

  The \texttt{getAssetObject()} method sets the \texttt{BlogsEntry} that
  was set in the constructor as your asset to track. Likewise, the
  \texttt{getType()} method references the blogs asset renderer factory
  for the type of asset your asset renderer renders. Of course, the
  asset renderer type is \texttt{blog}, which you'll set in the factory
  later.
\item
  Your asset renderer must link to the portlet that owns the entity. In
  the case of a blogs asset, its portlet ID should be linked to the
  Blogs application.

\begin{verbatim}
@Override
public String getPortletId() {
    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    return assetRendererFactory.getPortletId();
}
\end{verbatim}

  The \texttt{getPortletId()} method instantiates an asset renderer
  factory for a \texttt{BlogsEntry} and retrieves the portlet ID for the
  portlet used to display blogs entries.
\item
  If you want to enable workflow for your asset, add the following
  method similar to what was done for the Blogs application:

\begin{verbatim}
@Override
public int getStatus() {
    return _entry.getStatus();
}
\end{verbatim}

  This method retrieves the workflow status for the asset.
\item
  Another feature many developers want for their asset is comments. This
  is enabled for the Blogs application with the following method:

\begin{verbatim}
@Override
public String getDiscussionPath() {
    if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
        return "edit_entry_discussion";
    }
    else {
        return null;
    }
}
\end{verbatim}

  A comments section is an available option if it returns a non-null
  value. For the comments section to display for your asset, you must
  enable it in the Asset Publisher's \emph{Options}
  (\includegraphics{./images/icon-options.png}) → \emph{Configuration} →
  \emph{Setup} → \emph{Display Settings} section.
\item
  At a minimum, you should create a title and summary for your asset.
  Here's how the \texttt{BlogsEntryAssetRenderer} does it:

\begin{verbatim}
@Override
public String getSummary(
    PortletRequest portletRequest, PortletResponse portletResponse) {

    int abstractLength = AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH;

    if (portletRequest != null) {
        abstractLength = GetterUtil.getInteger(
            portletRequest.getAttribute(
                WebKeys.ASSET_ENTRY_ABSTRACT_LENGTH),
            AssetUtil.ASSET_ENTRY_ABSTRACT_LENGTH);
    }

    String summary = _entry.getDescription();

    if (Validator.isNull(summary)) {
        summary = HtmlUtil.stripHtml(
            StringUtil.shorten(_entry.getContent(), abstractLength));
    }

    return summary;
}

@Override
public String getTitle(Locale locale) {
    ResourceBundle resourceBundle =
        _resourceBundleLoader.loadResourceBundle(
            LanguageUtil.getLanguageId(locale));

    return BlogsEntryUtil.getDisplayTitle(resourceBundle, _entry);
}
\end{verbatim}

  These two methods return information about your asset, so the asset
  publisher can display it. The title and summary can be anything.

  The \texttt{getSummary(...)} method for Blogs returns the abstract
  description for a blog asset. If the abstract description does not
  exist, the content of the blog is used as an abstract. You'll learn
  more about abstracts and other content specifications later.

  The \texttt{getTitle(...)} method for Blogs uses the resource bundle
  loader you configured in the constructor to load your module's
  resource bundle and return the display title for your asset.
\item
  If you want to provide a unique URL for your asset, you can specify a
  URL title. A URL title is the URL used to access your asset directly
  (e.g., localhost:8080/-/this-is-my-blog-asset). You can do this by
  providing the following method:

\begin{verbatim}
@Override
public String getUrlTitle() {
    return _entry.getUrlTitle();
}
\end{verbatim}
\item
  Insert the \texttt{isPrintable()} method, which enables the Asset
  Publisher's printing capability for your asset.

\begin{verbatim}
@Override
public boolean isPrintable() {
    return true;
}
\end{verbatim}

  This displays a Print icon when your asset is displayed in the Asset
  Publisher. For the icon to appear, you must enable it in the Asset
  Publisher's \emph{Options} → \emph{Configuration} → \emph{Setup} →
  \emph{Display Settings} section.

  \begin{figure}
  \centering
  \includegraphics{./images/asset-publisher-printing.png}
  \caption{Enable printing in the Asset Publisher to display the Print
  icon for your asset.}
  \end{figure}
\item
  If your asset is protected by permissions, you can set permissions for
  the asset via the asset renderer. See the logic below for an example
  used in the \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public long getUserId() {
    return _entry.getUserId();
}

@Override
public String getUserName() {
    return _entry.getUserName();
}

public boolean hasDeletePermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.DELETE);
}

@Override
public boolean hasEditPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.UPDATE);
}

@Override
public boolean hasViewPermission(PermissionChecker permissionChecker) {
    return BlogsEntryPermission.contains(
        permissionChecker, _entry, ActionKeys.VIEW);
}
\end{verbatim}

  Before you can check if a user has permission to view your asset, you
  must use the \texttt{getUserId()} and \texttt{getUserName()} to
  retrieve the entry's user ID and username, respectively. Then there
  are three boolean permission methods that check if the user can view,
  edit, or delete your blogs entry. These permissions are for specific
  entity instances. Global permissions for blog entries are implemented
  in the factory, which you'll do later.
\end{enumerate}

Awesome! You've learned how to set up the blogs asset renderer to

\begin{itemize}
\tightlist
\item
  connect to an asset
\item
  connect to the asset's portlet
\item
  use workflow management
\item
  use a comments section
\item
  retrieve the asset's title and summary
\item
  generate the asset's unique URL
\item
  display a print icon
\item
  check permissions for the asset
\end{itemize}

Now you need to create the templates to render the HTML. The
\texttt{BlogsEntryAssetRenderer} is configured to use JSP templates to
generate HTML for the Asset Publisher. You'll learn more about how to do
this next.

\chapter{Configuring JSP Templates for an Asset
Renderer}\label{configuring-jsp-templates-for-an-asset-renderer}

An asset can be displayed in several different ways in the Asset
Publisher. There are three templates to implement provided by the
\texttt{AssetRenderer} interface:

\begin{itemize}
\tightlist
\item
  \texttt{abstract}
\item
  \texttt{full\_content}
\item
  \texttt{preview}
\end{itemize}

Besides these supported templates, you can also create JSPs for buttons
for direct access and manipulation of the asset. For example,

\begin{itemize}
\tightlist
\item
  Edit
\item
  View
\item
  View in Context
\end{itemize}

The \texttt{BlogsEntryAssetRenderer} customizes the
\texttt{AssetRenderer}'s provided JSP templates and adds a few other
features using JSPs. You'll inspect how the blogs asset renderer is put
together to satisfy JSP template development requirements.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{getJspPath(...)} method to your asset renderer. This
  method should return the path to your JSP, which is rendered inside
  the Asset Publisher. This is how the \texttt{BlogsEntryAssetRenderer}
  uses this method:

\begin{verbatim}
@Override
public String getJspPath(HttpServletRequest request, String template) {
    if (template.equals(TEMPLATE_ABSTRACT) ||
        template.equals(TEMPLATE_FULL_CONTENT)) {

        return "/blogs/asset/" + template + ".jsp";
    }
    else {
        return null;
    }
}
\end{verbatim}

  Blogs assets provide \texttt{abstract.jsp} and
  \texttt{full\_content.jsp} templates. This means that a blogs asset
  can render a blog's abstract description or the blog's full content in
  the Asset Publisher. Those templates are located in the
  \texttt{com.liferay.blogs.web} module's
  \texttt{src/main/resources/META-INF/resources/blogs/asset} folder. You
  could create a similar folder for your JSP templates used for this
  method. The other template provided by the \texttt{AssetRenderer}
  interface, \texttt{preview.jsp}, is not customized by the blogs asset
  renderer, so its default template is implemented.

  You must create a link to display the full content of the asset.
  You'll do this later.
\item
  Now that you've added the path to your JSP, you must include that JSP.
  Since the \texttt{BlogsEntryAssetRenderer} class extends the
  \texttt{BaseJSPAssetRenderer}, it already has an \texttt{include(...)}
  method to render a specific JSP. You must override this method to set
  an attribute in the request to use in the blog's views:

\begin{verbatim}
@Override
public boolean include(
        HttpServletRequest request, HttpServletResponse response,
        String template)
    throws Exception {

    request.setAttribute(WebKeys.BLOGS_ENTRY, _entry);

    return super.include(request, response, template);
}
\end{verbatim}

  The attribute includes the blogs entry object. Adding the blog object
  this way is not mandatory; you could obtain the blog entry directly
  from the view. Using the \texttt{include(...)} method, however,
  follows the best practice for MVC portlets.

  \begin{figure}
  \centering
  \includegraphics{./images/blogs-asset-views.png}
  \caption{The abstract and full content views are rendered differently
  for blogs.}
  \end{figure}
\end{enumerate}

Terrific! You've learned how to apply JSPs supported by the Asset
Publisher for your asset. That's not all you can do with JSP templates,
however! The asset renderer framework provides several other methods
that let you render convenient buttons for your asset.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Blogs assets provide an Edit button for editing the asset. Provide
  this by adding the following method to the
  \texttt{BlogsEntryAssetRenderer} class:

\begin{verbatim}
@Override
public PortletURL getURLEdit(
        LiferayPortletRequest liferayPortletRequest,
        LiferayPortletResponse liferayPortletResponse)
    throws Exception {

    Group group = GroupLocalServiceUtil.fetchGroup(_entry.getGroupId());

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, group, BlogsPortletKeys.BLOGS, 0, 0,
        PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));

    return portletURL;
}
\end{verbatim}

  The Asset Publisher loads the blogs asset using the Blogs application.
  Then the \texttt{edit\_entry.jsp} template generates the HTML for an
  editing UI. Once the necessary edits are made to the asset, it can be
  saved from the Asset Publisher. Pretty cool, right?
\item
  You can specify how to view your asset by providing methods similar to
  the methods outlined below in the \texttt{BlogsEntryAssetRenderer}
  class:

\begin{verbatim}
@Override
public String getURLView(
        LiferayPortletResponse liferayPortletResponse,
        WindowState windowState)
    throws Exception {

    AssetRendererFactory<BlogsEntry> assetRendererFactory =
        getAssetRendererFactory();

    PortletURL portletURL = assetRendererFactory.getURLView(
        liferayPortletResponse, windowState);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/view_entry");
    portletURL.setParameter("entryId", String.valueOf(_entry.getEntryId()));
    portletURL.setWindowState(windowState);

    return portletURL.toString();
}

@Override
public String getURLViewInContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    String noSuchEntryRedirect) {

    return getURLViewInContext(
        liferayPortletRequest, noSuchEntryRedirect, "/blogs/find_entry",
        "entryId", _entry.getEntryId());
}
\end{verbatim}

  The \texttt{getURLView(...)} method generates a URL that displays the
  full content of the asset in the Asset Publisher. This is assigned to
  the clickable asset name. The \texttt{getURLViewInContext(...)} method
  provides a similar URL assigned to the asset name, but the URL
  redirects to the original context of the asset (e.g., viewing a blogs
  asset in the Blogs application). Deciding which view to render is
  configurable by navigating to the Asset Publisher's \emph{Options} →
  \emph{Configuration} → \emph{Setup} → \emph{Display Settings} section
  and choosing between \emph{Show Full Content} and \emph{View in
  Context} for the Asset Link Behavior drop-down menu.
\end{enumerate}

The Blogs application provides \texttt{abstract} and
\texttt{full\_content} JSP templates that override the ones provided by
the \texttt{AssetRenderer} interface. The third template,
\texttt{preview}, could also be customized. You can view the default
\texttt{preview.jsp} template rendered in the \emph{Add} →
\emph{Content} menu.

\begin{figure}
\centering
\includegraphics{./images/preview-template-asset-renderer.png}
\caption{The \texttt{preview} template displays a preview of the asset
in the Content section of the Add menu.}
\end{figure}

You've learned all about implementing the \texttt{AssetRenderer}'s
provided templates and customizing them to fit your needs. Next, you'll
put your asset renderer into action by creating a factory.

\chapter{Creating a Factory for the Asset
Renderer}\label{creating-a-factory-for-the-asset-renderer}

You've successfully created an asset renderer, but you must create a
factory class to generate asset renderers for each asset instance. For
example, the blogs asset renderer factory instantiates
\texttt{BlogsEntryAssetRenderer} for each blogs asset displayed in an
Asset Publisher.

You'll continue the blogs asset renderer example by creating the blogs
asset renderer factory.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{-AssetRenderFactory} class in the same folder as its
  asset renderer class. For blogs, the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/blogs/web/asset/BlogsEntryAssetRendererFactory.html}{\texttt{BlogsEntryAssetRendererFactory}}
  class resides in the \texttt{com.liferay.blogs.web} module's
  \texttt{com.liferay.blogs.web.asset} package. The factory class should
  extend the \texttt{BaseAssetRendererFactory} class and the asset type
  should be specified as its parameter. You can see how this was done in
  the \texttt{BlogsEntryAssetRendererFactory} class below

\begin{verbatim}
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration. This annotation is responsible for registering the
  factory instance for the asset.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"javax.portlet.name=" + BlogsPortletKeys.BLOGS},
    service = AssetRendererFactory.class
)
public class BlogsEntryAssetRendererFactory
    extends BaseAssetRendererFactory<BlogsEntry> {
\end{verbatim}

  There are a few annotation elements you should set:

  \begin{itemize}
  \tightlist
  \item
    The \texttt{immediate} element directs the factory to start in
    Liferay DXP when its module starts.
  \item
    The \texttt{property} element sets the portlet that is associated
    with the asset. The Blogs portlet is specified, since this is the
    Blogs asset renderer factory.
  \item
    The \texttt{service} element should point to the
    \texttt{AssetRendererFactory.class} interface.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're using a Java EE portlet WAR, you must register the asset
 renderer factory in the portlet's `liferay-portlet.xml` file. In an 
 OSGi-based Liferay MVC portlet, the registration
 process is completed automatically by OSGi using the `@Component`
 annotation.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Create a constructor for the factory class that presets private
  attributes of the factory.

\begin{verbatim}
public BlogsEntryAssetRendererFactory() {
    setClassName(BlogsEntry.class.getName());
    setLinkable(true);
    setPortletId(BlogsPortletKeys.BLOGS);
    setSearchable(true);
}
\end{verbatim}

  \texttt{linkable}: other assets can select blogs assets as their
  related assets.

  \texttt{searchable}: blogs can be found when searching for assets.

  Setting the class name and portlet ID links the asset renderer factory
  to the entity.
\item
  Create the asset renderer for your asset. This is done by calling its
  constructor.

\begin{verbatim}
@Override
public AssetRenderer<BlogsEntry> getAssetRenderer(long classPK, int type)
    throws PortalException {

    BlogsEntry entry = _blogsEntryLocalService.getEntry(classPK);

    BlogsEntryAssetRenderer blogsEntryAssetRenderer =
        new BlogsEntryAssetRenderer(entry, _resourceBundleLoader);

    blogsEntryAssetRenderer.setAssetRendererType(type);
    blogsEntryAssetRenderer.setServletContext(_servletContext);

    return blogsEntryAssetRenderer;
}
\end{verbatim}

  For blogs, the asset is retrieved by calling the Blogs application's
  local service. Then the asset renderer is instantiated using the blogs
  asset and resource bundle loader. Next, the type and servlet context
  is set for the asset renderer. Finally, the configured asset renderer
  is returned.

  There are a few variables in the \texttt{getAssetRenderer(...)} method
  you must create. You'll set those variables and learn what they're
  doing next.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    You must get the entry by calling the Blogs application's local
    service. You can instantiate this service by creating a private
    field and setting it using a setter method:
  \end{enumerate}

\begin{verbatim}
@Reference(unbind = "-")
protected void setBlogsEntryLocalService(
    BlogsEntryLocalService blogsEntryLocalService) {

    _blogsEntryLocalService = blogsEntryLocalService;
}

private BlogsEntryLocalService _blogsEntryLocalService;
\end{verbatim}

  The setter method is annotated with the \texttt{@Reference} tag.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{1}
  \tightlist
  \item
    You must specify the resource bundle loader since it was specified
    in the \texttt{BlogsEntryAssetRenderer}'s constructor:
  \end{enumerate}

\begin{verbatim}
@Reference(
    target = "(bundle.symbolic.name=com.liferay.blogs.web)", unbind = "-"
)
public void setResourceBundleLoader(
    ResourceBundleLoader resourceBundleLoader) {

    _resourceBundleLoader = resourceBundleLoader;
}

private ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}

  Make sure the \texttt{osgi.web.symbolicname} in the \texttt{target}
  property of the \texttt{@Reference} annotation is set to the same
  value as the \texttt{Bundle-SymbolicName} defined in the
  \texttt{bnd.bnd} file of the module the factory resides in.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \setcounter{enumii}{2}
  \item
    The asset renderer \texttt{type} integer is set for the asset
    renderer, but why an integer? Liferay DXP needs to differentiate
    when it should display the latest \emph{approved} version of the
    asset, or the latest version, even if it's unapproved (e.g.,
    unapproved versions would be displayed for reviewers of the asset in
    a workflow). For these situations, the asset renderer factory should
    receive either

    \begin{itemize}
    \tightlist
    \item
      \texttt{0} for the latest version of the asset
    \item
      \texttt{1} for the latest approved version of the asset
    \end{itemize}
  \item
    Since the Blogs application provides its own JSPs, it must pass a
    reference of the servlet context to the asset renderer. This is
    always required when using custom JSPs in an asset renderer:
  \end{enumerate}

\begin{verbatim}
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.blogs.web)", unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    _servletContext = servletContext;
}

private ServletContext _servletContext;
\end{verbatim}
\item
  Set the type of asset that the asset factory associates with and
  provide a getter method to retrieve that type. Also, provide another
  getter to retrieve the blogs entry class name, which is required:

\begin{verbatim}
public static final String TYPE = "blog";

@Override
public String getType() {
    return TYPE;
}

@Override
public String getClassName() {
    return BlogsEntry.class.getName();
}
\end{verbatim}
\item
  Set the Lexicon icon for the asset:

\begin{verbatim}
@Override
public String getIconCssClass() {
    return "blogs";
}
\end{verbatim}

  You can find a list of all available Lexicon icons
  \href{https://liferay.design/lexicon/core-components/icons/}{here}.
\item
  Add methods that generate URLs to add and view the asset.

\begin{verbatim}
@Override
public PortletURL getURLAdd(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse, long classTypeId) {

    PortletURL portletURL = PortalUtil.getControlPanelPortletURL(
        liferayPortletRequest, getGroup(liferayPortletRequest),
        BlogsPortletKeys.BLOGS, 0, 0, PortletRequest.RENDER_PHASE);

    portletURL.setParameter("mvcRenderCommandName", "/blogs/edit_entry");

    return portletURL;
}

@Override
public PortletURL getURLView(
    LiferayPortletResponse liferayPortletResponse,
    WindowState windowState) {

    LiferayPortletURL liferayPortletURL =
        liferayPortletResponse.createLiferayPortletURL(
            BlogsPortletKeys.BLOGS, PortletRequest.RENDER_PHASE);

    try {
        liferayPortletURL.setWindowState(windowState);
    }
    catch (WindowStateException wse) {
    }

    return liferayPortletURL;
}
\end{verbatim}

  If you're paying close attention, you may have noticed the
  \texttt{getURLView(...)} method was also implemented in the
  \texttt{BlogsEntryAssetRenderer} class. The asset renderer's
  \texttt{getURLView(...)} method creates a URL for the specific asset
  instance, whereas the factory uses the method to create a generic URL
  that only points to the application managing the assets (e.g., Blogs
  application).
\item
  Set the global permissions for all blogs assets:

\begin{verbatim}
@Override
public boolean hasAddPermission(
        PermissionChecker permissionChecker, long groupId, long classTypeId)
    throws Exception {

    return BlogsPermission.contains(
        permissionChecker, groupId, ActionKeys.ADD_ENTRY);
}

@Override
public boolean hasPermission(
        PermissionChecker permissionChecker, long classPK, String actionId)
    throws Exception {

    return BlogsEntryPermission.contains(
        permissionChecker, classPK, actionId);
}
\end{verbatim}
\end{enumerate}

Great! You've finished creating the Blogs application's asset renderer
factory! Now you have the knowledge to implement an asset renderer and
produce an asset renderer for each asset instance using a factory!

\chapter{Implementing Asset Categorization and
Tagging}\label{implementing-asset-categorization-and-tagging}

Now it's time to get started with Tags and Categories.

\section{Adding Tags and Categories}\label{adding-tags-and-categories}

You can use the following tags in the JSPs you provide for
adding/editing custom entities. Here's what the tags look like in the
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/edit_entry.jsp}{edit\_entry.jsp}
for the Blogs portlet:

\begin{verbatim}
<liferay-ui:asset-categories-error />
<liferay-ui:asset-tags-error />
...
<aui:fieldset-group markupView="lexicon">
    ...
    <aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="categorization">
        <liferay-asset:asset-categories-selector name="categories" type="assetCategories" />

        <liferay-asset:asset-tags-selector name="tags" type="assetTags" />
    </aui:fieldset>
    ...
</aui:fieldset-group>
\end{verbatim}

The \texttt{liferay-asset:asset-categories-selector} and
\texttt{liferay-asset:asset-tags-selector} tags generate form controls
that let users browse/select categories for the entity, browse/select
tags, and/or create new tags to associate with the entity.

The \texttt{liferay-ui:asset-categories-error} and
\texttt{liferay-ui:asset-tags-error} tags show messages for errors
occurring during the asset category or tag input process. The
\texttt{aui:fieldset} tag uses a container that lets users hide or show
the category and tag input options.

For styling purposes, the \texttt{aui:fieldset-group} tag is given the
\texttt{lexicon} markup view.

\section{Displaying Tags and
Categories}\label{displaying-tags-and-categories}

Tags and categories should be displayed with the content of the asset.
Here's how to display the tags and categories:

\begin{verbatim}
<liferay-asset:asset-categories-available
    className="<%= [AssetEntry].class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
>
    <div class="entry-categories">
        <liferay-asset:asset-categories-summary
            className="<%= [AssetEntry].class.getName() %>"
            classPK="<%= entry.getEntryId() %>"
            portletURL="<%= renderResponse.createRenderURL() %>"
        />
    </div>
</liferay-asset:asset-categories-available>

...

<liferay-asset:asset-tags-available
    className="<%= [AssetEntry].class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
>
    <div class="entry-tags">
        <liferay-asset:asset-tags-summary
            className="<%= [AssetEntry].class.getName() %>"
            classPK="<%= entry.getEntryId() %>"
            portletURL="<%= renderResponse.createRenderURL() %>"
        />
    </div>
</liferay-asset:asset-tags-available>
\end{verbatim}

The \texttt{portletURL} parameter is used for both tags and categories.
Each tag that uses this parameter becomes a link containing the
\texttt{portletURL} \emph{and} \texttt{tag} or \texttt{categoryId}
parameter value. To implement this, you must implement the look-up
functionality in your portlet code. Do this by reading the values of
those two parameters and using \texttt{AssetEntryService} to query the
database for entries based on the specified tag or category.

Deploy your changes and add/edit a custom entity in your UI. Your form
shows the categorization and tag input options in a panel that the user
can hide/show.

Great! Now you know how to make category and tag input options available
to your app's content authors.

\chapter{Relating Assets}\label{relating-assets-1}

After you complete
\href{/docs/frameworks/7-2/-/knowledge_base/frameworks/adding-updating-and-deleting-assets}{Adding,
Updating, and Deleting Assets} for your application you can go ahead and
begin relating your assets!

\section{Relating Assets in the Service
Layer}\label{relating-assets-in-the-service-layer}

First, you must make some modifications to your portlet's service layer.
You must implement persisting your entity's asset relationships.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your portlet's \texttt{service.xml}, put the following line of code
  below any finder method elements and then run Service Builder:

\begin{verbatim}
<reference package-path="com.liferay.portlet.asset" entity="AssetLink" />
\end{verbatim}
\item
  Modify the \texttt{add-}, \texttt{delete-}, and \texttt{update-}
  methods in your \texttt{-LocalServiceImpl} to persist the asset
  relationships. You'll use your \texttt{-LocalServiceImpl}'s
  \texttt{assetLinkLocalService} instance variable to execute
  persistence actions.

  For example, consider the Wiki application. When you update wiki
  assets and statuses, both methods utilize the \texttt{updateLinks} via
  your instance variable \texttt{assetLinkLocalService}. Here's the
  \texttt{updateLinks} invocation in the Wiki application's
  \texttt{WikiPageLocalServiceImpl.updateStatus(...)} method:

\begin{verbatim}
assetLinkLocalService.updateLinks(
    userId, assetEntry.getEntryId(), assetLinkEntryIds,
    AssetLinkConstants.TYPE_RELATED);
\end{verbatim}

  To call the \texttt{updateLinks} method, you must pass in the current
  user's ID, the asset entry's ID, the asset link entries' IDs, and the
  link type. Invoke this method after creating the asset entry. If you
  assign to an \texttt{AssetEntry} variable (e.g., one called
  \texttt{assetEntry}) the value returned from invoking
  \texttt{assetEntryLocalService.updateEntry}, you can get the asset
  entry's ID for updating its asset links. Lastly, in order to specify
  the link type parameter, make sure to import
  \texttt{com.liferay.portlet.asset.model.AssetLinkConstants}.
\item
  In your \texttt{-LocalServiceImpl} class' \texttt{delete-} method, you
  must delete the asset's relationships before deleting the asset. For
  example, you could delete your existing asset link relationships by
  using the following code:

\begin{verbatim}
AssetEntry assetEntry = assetEntryLocalService.fetchEntry(
    ENTITY.class.getName(), ENTITYId);

assetLinkLocalService.deleteLinks(assetEntry.getEntryId());
\end{verbatim}
\end{enumerate}

Make sure to replace the \emph{ENTITY} place holders for your custom
\texttt{-delete} method.

Super! Now your portlet's service layer can handle related assets. Even
so, there's still nothing in your portlet's UI that lets your users
relate assets. You'll take care of that in the next step.

\section{Relating Assets in the UI}\label{relating-assets-in-the-ui}

The UI for linking assets should be in the JSP where users create and
edit your entity. This way only content creators can relate other assets
to the entity. Related assets are implemented in the JSP by using the
Liferay UI tag \texttt{liferay-ui:input-asset-links} inside a
collapsible panel. This code is placed inside the \texttt{aui:fieldset}
tags of the JSP.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-asset:input-asset-links} tag to your form.
  Here's how it's added in the Blogs application:

\begin{verbatim}
<aui:fieldset collapsed="<%= true %>" collapsible="<%= true %>" label="related-assets">
        <liferay-asset:input-asset-links
            className="<%= [AssetEntry].class.getName() %>"
            classPK="<%= entryId %>"
        />
</aui:fieldset>
\end{verbatim}

  The following screenshot shows the Related Assets menu for an
  application. Note that it is contained in a collapsible panel titled
  Related Assets.

  \begin{figure}
  \centering
  \includegraphics{./images/related-assets-select-menu.png}
  \caption{Your portlet's entity is now available in the Related Assets
  \emph{Select} menu.}
  \end{figure}
\item
  Unfortunately, the Related Assets menu shows your entity's fully
  qualified class name. To replace it with a simplified name for your
  entity, add a language key with the fully qualified class name for the
  key and the name you want for the value. Put the language key in file
  \texttt{docroot/WEB-INF/src/content/Language.properties} in your
  portlet. You can refer to the
  \href{/docs/frameworks/7-2/-/knowledge_base/frameworks/overriding-language-keys}{Overriding
  Language Keys} tutorial for more documentation on using language
  properties.

  Upon redeploying your portlet, the value you assigned to the fully
  qualified class name in your \texttt{Language.properties} file shows
  in the Related Assets menu.
\end{enumerate}

Awesome! Now content creators and editors can relate the assets of your
application. The next thing you need to do is reveal any such related
assets to the rest of your application's users. After all, you don't
want to give everyone edit access just so they can view related assets!

\section{Showing Related Assets}\label{showing-related-assets}

You can show related assets in your application's view of that entity
or, if you've implemented asset rendering for your custom entity, you
can show related assets in the full content view of your entity for
users to view in an Asset Publisher portlet.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must get the \texttt{AssetEntry} object associated with your
  entity:

\begin{verbatim}
<%
long insultId = ParamUtil.getLong(renderRequest, "insultId");
Insult ins = InsultLocalServiceUtil.getInsult(insultId);
AssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(Insult.class.getName(), ins.getInsultId());
%>
\end{verbatim}
\item
  Use the \texttt{liferay-asset:asset-links} tag to show the entity's
  related assets. For this tag, you retrieve the \texttt{assetEntryId}
  from the \texttt{assetEntry} object, retrieve your asset's
  \texttt{className}, and get the entity's primary key
  (\texttt{classPK}) from the specific \texttt{entry}. The tag then
  retrieves any other assets linked to your asset.

\begin{verbatim}
<liferay-asset:asset-links
    assetEntryId="<%= (assetEntry != null) ? assetEntry.getEntryId() : 0 %>"
    className="<%= [myAssetEntry].class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
/>
\end{verbatim}
\end{enumerate}

Great! Now you have the JSP that lets your users view related assets.
Related assets, if you've created any yet, should be visible near the
bottom of the page.

Excellent! Now you know how to implement related assets in your apps.

\chapter{Implementing Asset
Priority}\label{implementing-asset-priority-1}

This asset priority field isn't enabled when you create an asset. You
must manually add support for it. You'll learn how below.

\section{Add the Priority Field to Your
JSP}\label{add-the-priority-field-to-your-jsp}

In the JSP for adding and editing your asset, add the following input
field that lets users set the asset's priority. This example also
validates the input to make sure the value the user sets is a number
higher than zero:

\begin{verbatim}
<aui:input label="priority" name="assetPriority" type="text" value="<%= priority %>">
    <aui:validator name="number" />

    <aui:validator name="min">[0]</aui:validator>
</aui:input>
\end{verbatim}

That's it for the view layer! Now when users create or edit your asset,
they can enter its priority. Next, you'll learn how to use that value in
your service layer.

\section{Using the Priority Value in Your Service
Layer}\label{using-the-priority-value-in-your-service-layer}

To make the priority value functional, you must retrieve it from the
view and add it to the asset in your database. The priority value is
automatically available in your service layer via the
\texttt{ServiceContext} variable \texttt{serviceContext}. Retrieve it
with \texttt{serviceContext.getAssetPriority()}, and then pass it as the
last argument to the \texttt{assetEntryLocalService.updateEntry} call in
your \texttt{-LocalServiceImpl}. You can see an example of this in
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/service/impl/BlogsEntryLocalServiceImpl.java}{the
\texttt{BlogsEntryLocalServiceImpl} class} of Liferay DXP's Blogs app.
The \texttt{updateAsset} method takes a \texttt{priority} argument,
which it passes as the last argument to its
\texttt{assetEntryLocalService.updateEntry} call:

\begin{verbatim}
@Override
public void updateAsset(
        long userId, BlogsEntry entry, long[] assetCategoryIds,
        String[] assetTagNames, long[] assetLinkEntryIds, Double priority)
    throws PortalException {

    ...

    AssetEntry assetEntry = assetEntryLocalService.updateEntry(
        userId, entry.getGroupId(), entry.getCreateDate(),
        entry.getModifiedDate(), BlogsEntry.class.getName(),
        entry.getEntryId(), entry.getUuid(), 0, assetCategoryIds,
        assetTagNames, true, visible, null, null, null, null,
        ContentTypes.TEXT_HTML, entry.getTitle(), entry.getDescription(),
        summary, null, null, 0, 0, priority);

    ...
}
\end{verbatim}

The \texttt{BlogsEntryLocalServiceImpl} class calls this
\texttt{updateAsset} method when adding or updating a blog entry. Note
that \texttt{serviceContext.getAssetPriority()} retrieves the priority:

\begin{verbatim}
updateAsset(
        userId, entry, serviceContext.getAssetCategoryIds(),
        serviceContext.getAssetTagNames(),
        serviceContext.getAssetLinkEntryIds(),
        serviceContext.getAssetPriority());
\end{verbatim}

Sweet! Now you know how to enable priorities for your app's assets.

\chapter{Back-end Frameworks}\label{back-end-frameworks}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Liferay's powerful back-end frameworks provide essential services behind
the scenes. Here are some of the frameworks:

\begin{itemize}
\tightlist
\item
  \hyperref[portlet-providers]{Portlet Providers}
\item
  \hyperref[data-scopes]{Data Scopes}
\item
  \hyperref[message-bus]{Message Bus}
\end{itemize}

You can use these frameworks to provide important functionality to your
applications.

\section{Portlet Providers}\label{portlet-providers}

Some apps perform the same operations on different entity types. For
example, the Asset Publisher lets users browse, add, preview, and view
various entities as assets including documents, web content, blogs, and
more. The entities vary, but the operations and surrounding business
logic stay the same. Apps like the Asset Publisher rely on the Portlet
Providers framework to fetch portlets to operate on the entities. In
this way, the framework lets you focus on entity operations and frees
you from concern about portlets that carry out those operations.

\section{Portlet Provider Classes}\label{portlet-provider-classes}

Portlet Provider classes are components that implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.html}{\texttt{PortletProvider}}
interface, and are associated with an entity type. Once you've
registered a Portlet Provider, you can invoke the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
class to retrieve the portlet ID or portlet URL from that Portlet
Provider.

As an example, examine the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/wiki/wiki-web/src/main/java/com/liferay/wiki/web/internal/portlet/WikiEditPortletProvider.java}{\texttt{WikiEditPortletProvider}}
class:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "model.class.name=com.liferay.wiki.model.WikiPage",
        "service.ranking:Integer=100"
    },
    service = EditPortletProvider.class
)
public class WikiEditPortletProvider
    extends BasePortletProvider implements EditPortletProvider {

    @Override
    public String getPortletName() {
        return WikiPortletKeys.WIKI;
    }

}
\end{verbatim}

\texttt{WikiEditPortletProvider} extends
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}},
inheriting its \texttt{getPortletURL} methods.
\texttt{WikiEditPortletProvider} must, however, implement
\texttt{PortletProvider}'s \texttt{getPortletName} method, which returns
the portlet's name \texttt{WikiPortletKeys.WIKI}.

\noindent\hrulefill

\textbf{Note:} If you're creating a Portlet Provider for one of
Liferay's portlets, your \texttt{getPortletName} method should return
the portlet name from that portlet's \texttt{*PortletKeys} class, if
such a class exists.

\noindent\hrulefill

The \texttt{@Component} annotation for \texttt{WikiEditPortletProvider}
specifies these elements and properties:

\begin{itemize}
\tightlist
\item
  \texttt{immediate\ =\ true} activates the component immediately upon
  installation.
\item
  \texttt{"model.class.name=com.liferay.wiki.model.WikiPage"} specifies
  the entity type the portlet operates on.
\item
  \texttt{"service.ranking:Integer=100"} sets the component's rank to
  \texttt{100}, prioritizing it above all Portlet Providers that specify
  the same \texttt{model.class.name} value but have a lower rank.
\item
  \texttt{service\ =\ EditPortletProvider.class} reflects the
  subinterface \texttt{PortletProvider} class this class implements
  (\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/EditPortletProvider.html}{\texttt{EditPortletProvider}}).
\end{itemize}

For step-by-step instructions on creating a Portlet Provider class, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-portlet-providers}{Creating
Portlet Providers}. For instructions on using Portlet Providers to
retrieve a portlet, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/retrieving-portlets}{Retrieving
Portlets}.

\section{Data Scopes}\label{data-scopes}

Apps can restrict their data to specific \emph{scopes}. Scopes provide a
context for the application's data.

\textbf{Global:} One data set throughout a portal instance.

\textbf{Site:} One data set for each Site.

\textbf{Page:} One data set for each Page on a Site.

For example, a Site-scoped app has one set of data on one Site and a
completely different set of data for another Site. For a detailed
explanation of scopes, see the user guide article
\href{/docs/7-2/user/-/knowledge_base/u/widget-scope}{Widget Scope}. To
give your applications scope, you must manually add support for it. For
instructions on this, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/enabling-and-accessing-data-scopes}{Enabling
and Accessing Data Scopes}.

\section{Accessing the Site Scope Across
Apps}\label{accessing-the-site-scope-across-apps}

There may be times when you must access a different app's Site-scoped
data from your app that is scoped to a page or the portal. For example,
web content articles can be created in the page, Site, or portal scope.
\href{/docs/7-2/user/-/knowledge_base/u/designing-uniform-content}{Structures
and Templates} for such articles, however, exist only in the Site scope.
Other techniques return your app's scope, which might not be the Site
scope. What a pickle! Never fear, the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}
method \texttt{getSiteGroupId()} is here! This method always gets the
Site scope, no matter your app's current scope. For an example of using
this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/enabling-and-accessing-data-scopes}{Enabling
and Accessing Data Scopes}.

\section{Message Bus}\label{message-bus}

If you must ever do data processing outside the scope of the web's
request/response, look no further than the Message Bus. It's
conceptually similar to Java Messaging Service (JMS) Topics, but
sacrifices transactional, reliable delivery capabilities, making it much
lighter-weight. Liferay DXP uses Message Bus in many places:

\begin{itemize}
\tightlist
\item
  Auditing
\item
  Search engine integration
\item
  Email subscriptions
\item
  Monitoring
\item
  Document Library processing
\item
  Background tasks
\item
  Cluster-wide request execution
\item
  Clustered cache replication
\end{itemize}

You can use it too! Here are some of Message Bus's most important
features:

\begin{itemize}
\tightlist
\item
  publish/subscribe messaging
\item
  request queuing and throttling
\item
  flow control
\item
  multi-thread message processing
\end{itemize}

There are also tools, such as the Java SE's JConsole, that can monitor
Message Bus activities.

\begin{figure}
\centering
\includegraphics{./images/message-bus-jconsole.png}
\caption{JConsole shows statistics on Message Bus messages sent,
messages pending, and more.}
\end{figure}

\chapter{Creating Portlet Providers}\label{creating-portlet-providers}

Follow these steps to create your own
\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#portlet-providers}{Portlet
Provider}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module}.
\item
  Create a \texttt{PortletProvider} class in your module. Use the
  recommended class naming convention:

  \texttt{{[}Entity{]}\ +\ {[}Action{]}\ +\ PortletProvider}

  For example, here's a Portlet Provider class for viewing a
  \texttt{LanguageEntry}:

  \texttt{LanguageEntryViewPortletProvider}
\item
  Extend
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  if you want to use its \texttt{getPortletURL} method implementations.
\item
  Implement one or more
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.html}{\texttt{PortletProvider}}
  subinterfaces that match your action(s):

  \begin{itemize}
  \tightlist
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/AddPortletProvider.html}{\texttt{AddPortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BrowsePortletProvider.html}{\texttt{BrowsePortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/EditPortletProvider.html}{\texttt{EditPortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ManagePortletProvider.html}{\texttt{ManagePortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PreviewPortletProvider.html}{\texttt{PreviewPortletProvider}}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ViewPortletProvider.html}{\texttt{ViewPortletProvider}}
  \end{itemize}
\item
  Make the class an OSGi Component by adding an annotation like this
  one:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "model.class.name=CLASS_NAME",
        "service.ranking:Integer=10"
    },
    service = {INTERFACE_1.class, ...}
)
\end{verbatim}

  The \texttt{immediate\ =\ true} element specifies that the component
  should be activated immediately upon installation.

  Assign to the \texttt{model.class.name} property the fully qualified
  class name of the entity the portlet operates on. Here's an example
  \texttt{model.class.name} property for the \texttt{WikiPage} entity:

\begin{verbatim}
"model.class.name=com.liferay.wiki.model.WikiPage"
\end{verbatim}

  Assign the \texttt{service} element to the \texttt{PortletProvider}
  subinterface(s) you're implementing (e.g.,
  \texttt{ViewPortletProvider.class},
  \texttt{BrowsePortletProvider.class}, etc.). This example sets
  \texttt{service} to \texttt{EditPortletProvider.class}:

\begin{verbatim}
service = EditPortletProvider.class
\end{verbatim}
\item
  If you're overriding an existing Portlet Provider, rank your Portlet
  Provider higher by specifying a \texttt{service.ranking:Integer}
  property with a higher integer value:

\begin{verbatim}
property = {
    ...,
    "service.ranking:Integer=10"
}
\end{verbatim}
\item
  Implement the provider methods you want. Be sure to implement the
  \texttt{PortletProvider} method \texttt{getPortletName}. If you didn't
  extend \texttt{BasePortletProvider}, implement
  \texttt{PortletProvider}'s \texttt{getPortletURL} methods too.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module}.
\end{enumerate}

Now your Portlet Provider is available to return the ID and URL of the
portlet that provides the desired behaviors. For more information on
this, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/retrieving-portlets}{Retrieving
Portlets}.

\section{Related Topics}\label{related-topics-4}

\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#portlet-providers}{Portlet
Providers}

\href{/docs/7-2/frameworks/-/knowledge_base/f/retrieving-portlets}{Retrieving
Portlets}

\chapter{Retrieving Portlets}\label{retrieving-portlets}

When a
\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#portlet-providers}{Portlet
Provider} exists for an entity, you can use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
class to retrieve the ID or URL of the portlet that performs the entity
action you want.

The Portlet Provider framework's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProvider.Action.html}{\texttt{PortletProvider.Action}}
Enum defines these action types:

\begin{itemize}
\tightlist
\item
  \texttt{ADD}
\item
  \texttt{BROWSE}
\item
  \texttt{EDIT}
\item
  \texttt{MANAGE}
\item
  \texttt{PREVIEW}
\item
  \texttt{VIEW}
\end{itemize}

The action type and entity type are key parameters in fetching a
portlet's ID or URL.

\section{Fetching a Portlet ID}\label{fetching-a-portlet-id}

To get the ID of the portlet that performs an action on an entity, pass
that entity and action as arguments to the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}}
method \texttt{getPortletId}. For example, this call gets the ID of a
portlet for viewing Recycle Bin entries:

\begin{verbatim}
String portletId = PortletProviderUtil.getPortletId(
    "com.liferay.portlet.trash.model.TrashEntry", 
    PortletProvider.Action.VIEW);
\end{verbatim}

The \texttt{com.liferay.portlet.trash.model.TrashEntry} entity specifies
Recycle Bin entries, and \texttt{PortletProvider.Action.VIEW} specifies
the view action.

How and where you use the portlet ID depends on your needs---there's no
typical use case or set of steps to follow. One example is how the Asset
Publisher uses the Portlet Provider framework to add a previewed asset
to a page; it adds the asset to a portlet and adds that portlet to the
page. The Asset Publisher uses the \texttt{liferay-asset:asset\_display}
tag library tag whose \texttt{asset\_display/preview.jsp} shows an
\emph{Add} button for adding the portlet. If the previewed asset is a
Blogs entry, for example, the framework returns a blogs portlet ID or
URL for adding the portlet to the current page. Here's the relevant code
from the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/asset/asset-taglib/src/main/resources/META-INF/resources/asset_display/preview.jsp\#L75-L91}{\texttt{asset\_display/preview.jsp}}:

\begin{verbatim}
<%
Map<String, Object> data = new HashMap<String, Object>();

<!-- populate the data map -->

String portletId = PortletProviderUtil.getPortletId(assetEntry.getClassName(), PortletProvider.Action.ADD);

data.put("portlet-id", portletId);

<!-- add more to the data map -->
%>

<c:if test="<%= PortletPermissionUtil.contains(permissionChecker, layout, portletId, ActionKeys.ADD_TO_PAGE) %>">
    <aui:button cssClass="add-button-preview" data="<%= data %>" value="add" />
</c:if>
\end{verbatim}

This code invokes
\texttt{PortletProviderUtil.getPortletId(assetEntry.getClassName(),\ PortletProvider.Action.ADD)}
to get the ID of a portlet that adds and displays the asset of the
underlying entity class.

The JSP puts the portlet ID into the \texttt{data} map:

\begin{verbatim}
data.put("portlet-id", portletId);
\end{verbatim}

Then it passes the \texttt{data} map to a new \emph{Add} button that
adds the portlet to the page:

\begin{verbatim}
<aui:button cssClass="add-button-preview" data="<%= data %>" value="add" />
\end{verbatim}

\section{Fetching a Portlet URL}\label{fetching-a-portlet-url}

To get the URL of the portlet that performs an action on an entity, call
one of
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/PortletProviderUtil.html}{\texttt{PortletProviderUtil}'s}
\texttt{getPortletURL} methods. These methods return a
\texttt{javax.portlet.PortletURL} based on an
\texttt{HttpServletRequest} or \texttt{PortletRequest}. You can also
specify a \texttt{Group}, the entity's class name, and the action.

How you call these methods depends on your use case---there's no typical
set of steps to follow. As an example, when the Asset Publisher is
configured in Manual mode, the user can use an Asset Browser to select
asset entries. The \texttt{asset-publisher-web} module's
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/asset/asset-publisher-web/src/main/resources/META-INF/resources/configuration/asset_entries.jsp\#L123}{\texttt{configuration/asset\_entries.jsp}}
file uses \texttt{PortletProviderUtil}'s \texttt{getPortletURL} method
(at the end of the code below) to generate a corresponding Asset Browser
URL:

\begin{verbatim}
List<AssetRendererFactory<?>> assetRendererFactories = 
    ListUtil.sort(
        AssetRendererFactoryRegistryUtil.getAssetRendererFactories(
            company.getCompanyId()),
            new AssetRendererFactoryTypeNameComparator(locale));

for (AssetRendererFactory<?> curRendererFactory : assetRendererFactories) {
        long curGroupId = groupId;

        if (!curRendererFactory.isSelectable()) {
            continue;
        }

        PortletURL assetBrowserURL = PortletProviderUtil.getPortletURL(
            request, curRendererFactory.getClassName(),
            PortletProvider.Action.BROWSE);
\end{verbatim}

\section{Related Topics}\label{related-topics-5}

\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#portlet-providers}{Portlet
Providers}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-portlet-providers}{Creating
Portlet Providers}

\chapter{Enabling and Accessing Data
Scopes}\label{enabling-and-accessing-data-scopes}

Apps can restrict their data to specific scopes (e.g., Global, Site,
Page). Here, you'll learn how to

\begin{itemize}
\tightlist
\item
  \hyperref[enabling-scoping]{Enable Scoping}
\item
  \hyperref[accessing-your-apps-scope]{Access Your App's Scope}
\item
  \hyperref[accessing-the-site-scope]{Access the Site Scope}
\end{itemize}

For more detailed information about scoping, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#data-scopes}{Data
Scopes}.

\section{Enabling Scoping}\label{enabling-scoping}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Scope your app's entities. In your service layer, your entities must
  have a \texttt{companyId} attribute of type \texttt{long} to enable
  scoping by portal instance, and a \texttt{groupId} attribute of type
  \texttt{long} to enable scoping by Site. Using
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder} is the simplest way to do this. For instructions on this, see
  \href{/docs/7-2/appdev/-/knowledge_base/a/creating-a-service-builder-project}{Service
  Builder Persistence} and
  \href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Business
  Logic with Service Builder}.
\item
  To enable scoping in your app, set the property
  \texttt{"com.liferay.portlet.scopeable=true"} in your portlet class's
  \texttt{@Component} annotation. For example, the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/journal/journal-content-web/src/main/java/com/liferay/journal/content/web/internal/portlet/JournalContentPortlet.java}{Web
  Content Display Portlet's portlet class} sets this component property:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        ...
        "com.liferay.portlet.scopeable=true",
        ...,
    },
    service = Portlet.class
)
public class JournalContentPortlet extends MVCPortlet {
    ...
}
\end{verbatim}
\end{enumerate}

\section{Accessing Your App's Scope}\label{accessing-your-apps-scope}

Users can typically set an app's scope to a page, a Site, or the entire
portal. To handle your app's data, you must access it in its current
scope. Your app's scope is available in these ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Via the \texttt{scopeGroupId} variable injected in JSPs that use the
  \texttt{\textless{}liferay-theme:defineObjects\ /\textgreater{}} tag.
  This variable contains your app's current scope. For example, the
  Liferay Bookmarks app's
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/bookmarks/bookmarks-web/src/main/resources/META-INF/resources/bookmarks/view.jsp\#L122-L125}{\texttt{view.jsp}}
  uses its \texttt{scopeGroupId} to retrieve the bookmarks and total
  number of bookmarks in the current scope:

\begin{verbatim}
...
total = BookmarksEntryServiceUtil.getGroupEntriesCount(scopeGroupId, groupEntriesUserId);

bookmarksSearchContainer.setTotal(total);
bookmarksSearchContainer.setResults(BookmarksEntryServiceUtil.getGroupEntries(scopeGroupId, groupEntriesUserId, bookmarksSearchContainer.getStart(), bookmarksSearchContainer.getEnd()));
...
\end{verbatim}
\item
  By calling the \texttt{getScopeGroupId()} method on the request's
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}.
  This method returns your app's current scope. For example, the Liferay
  Blogs app's
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/portlet/action/EditEntryMVCActionCommand.java\#L350-L362}{\texttt{EditEntryMVCActionCommand}}
  class does this in its \texttt{subscribe} and \texttt{unsubscribe}
  methods:

\begin{verbatim}
protected void subscribe(ActionRequest actionRequest) throws Exception {
    ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
        WebKeys.THEME_DISPLAY);

    _blogsEntryService.subscribe(themeDisplay.getScopeGroupId());
}

protected void unsubscribe(ActionRequest actionRequest) throws Exception {
    ThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(
        WebKeys.THEME_DISPLAY);

    _blogsEntryService.unsubscribe(themeDisplay.getScopeGroupId());
}
\end{verbatim}

  If you know your app always needs the portal instance ID, use
  \texttt{themeDisplay.getCompanyId()}.
\item
  By calling the \texttt{getScopeGroupId()} method on a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html}{\texttt{ServiceContext}}
  object. See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/understanding-servicecontext}{Understanding
  Service Context} for an example and more details. If you know your app
  always needs the portal instance ID, use the \texttt{ServiceContext}
  object's \texttt{getCompanyId()} method.
\end{enumerate}

\section{Accessing the Site Scope}\label{accessing-the-site-scope}

To access the Site scope regardless of your app's current scope, use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}
method \texttt{getSiteGroupId()}. For more information on this use case,
see
\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#accessing-the-site-scope-across-apps}{Accessing
the Site Scope Across Apps}.

For example, the Web Content app's
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/journal/journal-web/src/main/resources/META-INF/resources/edit_feed.jsp\#L40}{\texttt{edit\_feed.jsp}}
uses the \texttt{getSiteGroupId()} method to get the Site ID, which is
required to retrieve Structures:

\begin{verbatim}
ddmStructure = DDMStructureLocalServiceUtil.fetchStructure(themeDisplay.getSiteGroupId(), 
    PortalUtil.getClassNameId(JournalArticle.class), ddmStructureKey, true);
\end{verbatim}

\section{Related Topics}\label{related-topics-6}

\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#data-scopes}{Data
Scopes}

\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/creating-a-service-builder-project}{Service
Builder Project}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Business
Logic with Service Builder}

\chapter{Using the Message Bus}\label{using-the-message-bus}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Here, you'll learn how to use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/back-end-frameworks\#message-bus}{Message
Bus} to send and receive messages in the portal. The following topics
are covered:

\begin{itemize}
\tightlist
\item
  \hyperref[messaging-destinations]{Messaging Destinations}
\item
  \hyperref[message-listeners]{Message Listeners}
\item
  \hyperref[sending-messages]{Sending Messages}
\end{itemize}

\section{Messaging Destinations}\label{messaging-destinations}

In Message Bus, you send messages to destinations. A destination is a
named logical (not physical) location. Sender classes send messages to
destinations, while listener classes wait to receive messages at the
destinations. In this way, the sender and recipient don't need to know
each other---they're loosely coupled.

\section{Destination Configuration}\label{destination-configuration}

Each destination has a name and type and can have several other
attributes. The destination type determines these things:

\begin{itemize}
\tightlist
\item
  Whether there's a message queue.
\item
  The kinds of threads involved with a destination.
\item
  The message delivery behavior to expect at the destination.
\end{itemize}

Here are the primary destination types:

\textbf{Parallel Destination}

\begin{itemize}
\tightlist
\item
  Messages sent here are queued.
\item
  Multiple worker threads from a thread pool deliver each message to a
  registered message listener. There's one worker thread per message per
  message listener.
\end{itemize}

\textbf{Serial Destination}

\begin{itemize}
\tightlist
\item
  Messages sent here are queued.
\item
  Worker threads from a thread pool deliver the messages to each
  registered message listener, one worker thread per message.
\end{itemize}

\textbf{Synchronous Destination}

\begin{itemize}
\tightlist
\item
  Messages sent here are directly delivered to message listeners.
\item
  The thread sending the message here also delivers the message to all
  message listeners.
\end{itemize}

Preconfigured destinations exist for various purposes. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}}
class defines \texttt{String} constants for each. For example,
\texttt{DestinationNames.HOT\_DEPLOY} (value is
\texttt{"liferay/hot\_deploy"}) is for deployment event messages. Since
destinations are tuned for specific purposes, don't modify them.

Destinations are based on
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html}{\texttt{DestinationConfiguration}}
instances. The configuration specifies the destination type, name, and
these destination-related attributes:

\textbf{Maximum Queue Size}: Limits the number of the destination's
queued messages.

\textbf{Rejected Execution Handler}: A
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/concurrent/RejectedExecutionHandler.html}{\texttt{RejectedExecutionHandler}}
instance can take action (e.g., log warnings) regarding rejected
messages when the destination queue is full.

\textbf{Workers Core Size}: Initial number of worker threads for
processing messages.

\textbf{Workers Max Size}: Limits the number of worker threads for
processing messages.

The \texttt{DestinationConfiguration} class provides these static
methods for creating the various types of configurations.

\begin{itemize}
\tightlist
\item
  \texttt{createParallelDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSerialDestinationConfiguration(String\ destinationName)}
\item
  \texttt{createSynchronousDestinationConfiguration(String\ destinationName)}
\end{itemize}

You can also use the \texttt{DestinationConfiguration}
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html\#DestinationConfiguration-java.lang.String-java.lang.String-}{constructor}
to create a configuration for any destination type, even your own.

For instructions on creating your own destination, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-destination}{Creating
a Destination}.

\section{Message Listeners}\label{message-listeners}

If you're interested in messages sent to a destination, you need to
\emph{listen} for them. That is, you must create and register a message
listener for the destination.

To create a message listener, implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageListener.html}{\texttt{MessageListener}}
interface and override its \texttt{receive(Message)} method to process
messages your way.

\begin{verbatim}
public void receive(Message message) {
    // Process messages your way
}
\end{verbatim}

Here are the ways to register your listener with Message Bus:

\textbf{Automatic Registration as a Component}: Publish the listener to
the OSGi registry as a
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services} component that specifies a destination. Message Bus
automatically wires the listener to the destination.

\textbf{Registering via MessageBus}: Obtain and use a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}}
reference to directly register the listener to a destination.

\textbf{Registering Directly to a Destination}: Obtain a reference to a
specific destination and use it to directly register the listener with
that destination.

For instructions on these topics, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/registering-message-listeners}{Registering
Message Listeners}.

\section{Sending Messages}\label{sending-messages}

Message Bus lets you send messages to destinations that have any number
of listening classes. As a message sender you don't need to know the
message recipients. Instead, you focus on creating message content
(payload) and sending messages to destinations.

You can also send messages in a synchronous or asynchronous manner. The
synchronous option waits for a response that the message was received or
that it timed out. The asynchronous option gives you the ``fire and
forget'' behavior; send the message and continue processing without
waiting for a response.

See these topics for instructions on creating and sending messages:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{Creating
  a Message}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/sending-a-message}{Sending
  a Message}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/sending-messages-across-a-cluster}{Sending
  Messages Across a Cluster}
\end{itemize}

\chapter{Creating a Destination}\label{creating-a-destination}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#messaging-destinations}{Message
Bus destinations} are based on destination configurations and registered
as OSGi services. Message Bus detects the destination services and
manages their associated destinations.

Here are the steps for creating a destination. The example configurator
class that follows demonstrates these steps.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{activate(BundleContext)} method in your component.
  Then create a
  \href{https://osgi.org/javadoc/r4v43/core/org/osgi/framework/BundleContext.html}{\texttt{BundleContext}}
  instance variable and set it to the \texttt{activate} method's
  \texttt{BundleContext}:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {

    _bundleContext = bundleContext;

}

private final BundleContext _bundleContext;
\end{verbatim}

  You'll create and register your destination inside this
  \texttt{activate} method. This ensures that the destination is
  available upon service activation. Once the destination is registered,
  Message Bus detects its service and manages the destination.
\item
  Create a destination configuration by using one of
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationConfiguration.html}{\texttt{DestinationConfiguration}'s}
  static \texttt{create*} methods or its constructor. Set any attributes
  that apply to the destinations you'll create with the destination
  configuration.

  For example, this code uses the \texttt{DestinationConfiguration}
  constructor to create a destination configuration for parallel
  destinations. It then sets the destination configuration's maximum
  queue size and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/concurrent/RejectedExecutionHandler.html}{\texttt{RejectedExecutionHandler}}:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    ...

    // Create a DestinationConfiguration for parallel destinations.

    DestinationConfiguration destinationConfiguration =
        new DestinationConfiguration(
            DestinationConfiguration.DESTINATION_TYPE_PARALLEL,
                "myDestinationName");

    // Set the DestinationConfiguration's max queue size and
    // rejected execution handler.

    destinationConfiguration.setMaximumQueueSize(_MAXIMUM_QUEUE_SIZE);

    RejectedExecutionHandler rejectedExecutionHandler =
        new CallerRunsPolicy() {

            @Override
            public void rejectedExecution(
                Runnable runnable, ThreadPoolExecutor threadPoolExecutor) {

                if (_log.isWarnEnabled()) {
                    _log.warn(
                        "The current thread will handle the request " +
                            "because the graph walker's task queue is at " +
                                "its maximum capacity");
                }

                super.rejectedExecution(runnable, threadPoolExecutor);
            }

    };

    destinationConfiguration.setRejectedExecutionHandler(
        rejectedExecutionHandler);

}
\end{verbatim}
\item
  Create the destination by invoking the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationFactory.html}{\texttt{DestinationFactory}}
  method \texttt{createDestination(DestinationConfiguration)}, passing
  in the destination configuration from the previous step.

  For example, this code does so via a \texttt{DestinationFactory}
  reference:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    ...

    Destination destination = _destinationFactory.createDestination(
        destinationConfiguration);

}
...

@Reference
private DestinationFactory _destinationFactory;
\end{verbatim}
\item
  Register the destination as an OSGi service by invoking the
  \texttt{BundleContext} method \texttt{registerService} with these
  parameters:

  \begin{itemize}
  \tightlist
  \item
    The destination class \texttt{Destination.class}.
  \item
    Your \texttt{Destination} object.
  \item
    A \texttt{Dictionary} of properties defining the destination,
    including the \texttt{destination.name}.
  \end{itemize}

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    ...

    Dictionary<String, Object> properties = new HashMapDictionary<>();

    properties.put("destination.name", destination.getName());

    ServiceRegistration<Destination> serviceRegistration =
        _bundleContext.registerService(
            Destination.class, destination, properties);
}
\end{verbatim}
\item
  Manage the destination object and service registration resources using
  a collection such as a
  \texttt{Map\textless{}String,\ ServiceRegistration\textless{}Destination\textgreater{}\textgreater{}}.
  Keeping references to these resources is helpful for when you're ready
  to unregister and destroy them.

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    ...

    _serviceRegistrations.put(destination.getName(), 
        serviceRegistration);

}
...

private final Map<String, ServiceRegistration<Destination>>
    _serviceRegistrations = new HashMap<>();
\end{verbatim}
\item
  Add a \texttt{deactivate} method that unregisters and destroys any
  destinations for this component. This ensures there aren't any active
  destinations for this component when the service deactivates:

\begin{verbatim}
@Deactivate
protected void deactivate() {

    // Unregister and destroy destinations

    for (ServiceRegistration<Destination> serviceRegistration : 
        _serviceRegistrations.values()) {

        Destination destination = _bundleContext.getService(
            serviceRegistration.getReference());

        serviceRegistration.unregister();

        destination.destroy();

    }

    _serviceRegistrations.clear();

}
\end{verbatim}
\end{enumerate}

Here's the full messaging configurator component class that contains the
code in the above steps:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessagingConfigurator.class
)
public class MyMessagingConfigurator {

    @Activate
    protected void activate(BundleContext bundleContext) {

        _bundleContext = bundleContext;

        // Create a DestinationConfiguration for parallel destinations.

        DestinationConfiguration destinationConfiguration =
            new DestinationConfiguration(
                DestinationConfiguration.DESTINATION_TYPE_PARALLEL,
                    "myDestinationName");

        // Set the DestinationConfiguration's max queue size and
        // rejected execution handler.

        destinationConfiguration.setMaximumQueueSize(_MAXIMUM_QUEUE_SIZE);

        RejectedExecutionHandler rejectedExecutionHandler =
            new CallerRunsPolicy() {

                @Override
                public void rejectedExecution(
                    Runnable runnable, ThreadPoolExecutor threadPoolExecutor) {

                    if (_log.isWarnEnabled()) {
                        _log.warn(
                            "The current thread will handle the request " +
                                "because the graph walker's task queue is at " +
                                    "its maximum capacity");
                    }

                    super.rejectedExecution(runnable, threadPoolExecutor);
                }

            };

        destinationConfiguration.setRejectedExecutionHandler(
            rejectedExecutionHandler);

        // Create the destination

        Destination destination = _destinationFactory.createDestination(
            destinationConfiguration);

        // Add the destination to the OSGi service registry

        Dictionary<String, Object> properties = new HashMapDictionary<>();

        properties.put("destination.name", destination.getName());

        ServiceRegistration<Destination> serviceRegistration =
            _bundleContext.registerService(
                Destination.class, destination, properties);

        // Track references to the destination service registrations 

        _serviceRegistrations.put(destination.getName(),    
            serviceRegistration);
    }

    @Deactivate
    protected void deactivate() {

        // Unregister and destroy destinations this component unregistered

        for (ServiceRegistration<Destination> serviceRegistration : 
            _serviceRegistrations.values()) {

            Destination destination = _bundleContext.getService(
                serviceRegistration.getReference());

            serviceRegistration.unregister();

            destination.destroy();

        }

        _serviceRegistrations.clear();

    }

    private final BundleContext _bundleContext;

    @Reference
    private DestinationFactory _destinationFactory;

    private final Map<String, ServiceRegistration<Destination>>
        _serviceRegistrations = new HashMap<>();
}
\end{verbatim}

\section{Related Topics}\label{related-topics-7}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#messaging-destinations}{Message
Bus Destinations}

\chapter{Message Bus Event Listeners}\label{message-bus-event-listeners}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

When
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{using
Message Bus}, you may wish to listen for events that take place within
the Message Bus framework itself, independent of messages. For example,
you can listen for when
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#messaging-destinations}{destinations}
and
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#message-listeners}{message
listeners} are added or removed. Here, you'll learn how.

\section{Listening for Destinations}\label{listening-for-destinations}

Message Bus notifies event listeners when destinations are added and
removed. To register these listeners, publish a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBusEventListener.html}{\texttt{MessageBusEventListener}}
instance to the OSGi service registry (e.g., via an \texttt{@Component}
annotation).

Here's an example implementation of \texttt{MessageBusEventListener}.
Use the \texttt{destinationAdded} and \texttt{destinationDestroyed}
methods to implement any logic that you want to run when a destination
is added or removed, respectively:

\begin{verbatim}
@Component(
    immediate = true,
    service = MessageBusEventListener.class
)
public class MyMessageBusEventListener implements MessageBusEventListener {

    void destinationAdded(Destination destination) {
        ...
    }

    void destinationDestroyed(Destination destination) {
        ...
    }
}
\end{verbatim}

\section{Listening for Message
Listeners}\label{listening-for-message-listeners}

Message Bus notifies
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationEventListener.html}{\texttt{DestinationEventListener}}
instances when message listeners for destinations are either registered
or unregistered. To register an event listener to a destination, publish
a \texttt{DestinationEventListener} service to the OSGi service
registry, making sure to specify the destination's
\texttt{destination.name} property.

\begin{verbatim}
@Component(
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = DestinationEventListener.class
)
public class MyDestinationEventListener implements DestinationEventListener {

    void messageListenerRegistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }

    void messageListenerUnregistered(String destinationName,
                                   MessageListener messageListener) {
        ...
    }
}
\end{verbatim}

\section{Related Topics}\label{related-topics-8}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Using
the Message Bus}

\chapter{Registering Message
Listeners}\label{registering-message-listeners}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

There are three ways to register a
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#message-listeners}{message
listener} with the Message Bus:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[automatic-registration-as-a-component]{Automatic
  Registration as a Component}
\item
  \hyperref[registering-via-a-messagebus-reference]{Registering via a
  MessageBus Reference}
\item
  \hyperref[registering-directly-to-the-destination]{Registering
  Directly to the Destination}
\end{enumerate}

Automatic registration as a component is the preferred way to register
message listeners to destinations. You might want to use the other two
ways if, for example, you want to create some special proxy wrappers.

\noindent\hrulefill

\textbf{Note}: The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/DestinationNames.html}{\texttt{DestinationNames}}
class defines \texttt{String} constants for Liferay DXP's preconfigured
destinations.

\noindent\hrulefill

\section{Automatic Registration as a
Component}\label{automatic-registration-as-a-component}

You can specify a message listener in the
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services} \texttt{@Component} annotation:

\begin{verbatim}
@Component (
    immediate = true,
    property = {"destination.name=myCustom/Destination"},
    service = MessageListener.class
)
public class MyMessageListener implements MessageListener {
    ...

   public void receive(Message message) {
       // Handle the message
   }
}
\end{verbatim}

The Message Bus listens for
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageListener.html}{\texttt{MessageListener}}
service components like this one to publish themselves to the OSGi
service registry. The attribute \texttt{immediate\ =\ true} tells the
OSGi framework to activate the component as soon as its dependencies
resolve. Message Bus wires each registered listener to the destination
its \texttt{destination.name} property specifies. If the destination is
not yet registered, Message Bus queues the listener until the
destination registers.

\section{Registering via a MessageBus
Reference}\label{registering-via-a-messagebus-reference}

You can use a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}}
reference to directly register message listeners to destinations. Here's
a registrator that demonstrates this:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _messageBus.registerMessageListener("myDestinationName",  
            _messageListener);
    }

    @Deactivate
    protected void deactivate() {
        _messageBus.unregisterMessageListener("myDestinationName",  
            _messageListener);
    }

    @Reference
    private MessageBus _messageBus;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_messageBus} field's \texttt{@Reference} annotation binds
it to the \texttt{MessageBus} instance. The \texttt{activate} method
creates the listener and uses the Message Bus to register the listener
to a destination named \texttt{"myDestination"}. When this registrator
component is destroyed, the \texttt{deactivate} method unregisters the
listener.

\section{Registering Directly to the
Destination}\label{registering-directly-to-the-destination}

You can use a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/Destination.html}{\texttt{Destination}}
reference to register a listener to that destination. Here's a
registrator that demonstrates this:

\begin{verbatim}
@Component (
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _messageListener = new MessageListener() {

            public void receive(Message message) {
                // Handle the message
            }
        };

        _destination.register(_messageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_messageListener);
    }

    @Reference(target = "(destination.name=someDestination)")
    private Destination _destination;

    private MessageListener _messageListener;
}
\end{verbatim}

The \texttt{\_destination} field's \texttt{@Reference} annotation binds
it to a destination named \texttt{someDestination}. The
\texttt{activate} method creates the listener and registers it to the
destination. When this registrator component is destroyed, the
\texttt{deactivate} method unregisters the listener.

\section{Related Topics}\label{related-topics-9}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Using
the Message Bus}

\chapter{Creating a Message}\label{creating-a-message}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Before you can
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus\#sending-messages}{send
a message} via the Message Bus, you must first create it. Here's how to
create a message:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Call the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/Message.html}{\texttt{Message}}
  constructor to create a new \texttt{Message}:

\begin{verbatim}
Message message = new Message();
\end{verbatim}
\item
  Populate the message with a \texttt{String} or \texttt{Object}
  payload:

  \begin{itemize}
  \item
    String payload:
    \texttt{message.setPayload("Message\ Bus\ is\ great!")}
  \item
    Object payload: \texttt{message.put("firstName",\ "Joe")}
  \end{itemize}
\item
  To receive responses at a particular location, set both of these
  attributes:

  \begin{itemize}
  \item
    Response destination name:
    \texttt{setResponseDestinationName(String)}
  \item
    Response ID: \texttt{setResponseId(String)}
  \end{itemize}
\end{enumerate}

\section{Related Topics}\label{related-topics-10}

\href{/docs/7-2/frameworks/-/knowledge_base/f/sending-a-message}{Sending
a Message}

\href{/docs/7-2/frameworks/-/knowledge_base/f/sending-messages-across-a-cluster}{Sending
Messages Across a Cluster}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Using
the Message Bus}

\chapter{Sending a Message}\label{sending-a-message}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Once you've
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{created
a message}, there are three ways to send it with the
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Message
Bus}:

\begin{itemize}
\tightlist
\item
  \hyperref[directly-with-messagebus]{Directly with \texttt{MessageBus}}
\item
  \hyperref[asynchronously-with-singledestinationmessagesender]{Asynchronously
  with \texttt{SingleDestinationMessageSender}}
\item
  \hyperref[synchronously-with-synchronousmessagesender]{Synchronously
  with \texttt{SynchronousMessageSender}}
\end{itemize}

\section{Directly with MessageBus}\label{directly-with-messagebus}

To send a message directly with
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageBus.html}{\texttt{MessageBus}},
follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a \texttt{MessageBus} reference:

\begin{verbatim}
@Reference
private MessageBus _messageBus;
\end{verbatim}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{Create
  a message}. For example:

\begin{verbatim}
Message message = new Message();
message.put("myId", 12345);
message.put("someAttribute", "abcdef");
\end{verbatim}
\item
  Call the \texttt{MessageBus} reference's \texttt{sendMessage} method
  with the destination and message:

\begin{verbatim}
_messageBus.sendMessage("myDestinationName", message);
\end{verbatim}
\end{enumerate}

Here's a class that contains this example:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");
        _messageBus.sendMessage("myDestinationName", message);
    }

    @Reference
    private MessageBus _messageBus;
}
\end{verbatim}

\section{Asynchronously with
SingleDestinationMessageSender}\label{asynchronously-with-singledestinationmessagesender}

The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SingleDestinationMessageSender.html}{\texttt{SingleDestinationMessageSender}}
interface wraps the Message Bus to send messages asynchronously. Follow
these steps to use this interface to send asynchronous messages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SingleDestinationMessageSenderFactory.html}{\texttt{SingleDestinationMessageSenderFactory}}
  reference:

\begin{verbatim}
@Reference
private SingleDestinationMessageSenderFactory _messageSenderFactory;
\end{verbatim}
\item
  Create a \texttt{SingleDestinationMessageSender} by calling the
  \texttt{SingleDestinationMessageSenderFactory} reference's
  \texttt{createSingleDestinationMessageSender} method with the
  message's destination:

\begin{verbatim}
SingleDestinationMessageSender messageSender = 
   _messageSenderFactory.createSingleDestinationMessageSender("myDestinationName");
\end{verbatim}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{Create
  a message}. For example:

\begin{verbatim}
Message message = new Message();
message.put("myId", 12345);
message.put("someValue", "abcdef");
\end{verbatim}
\item
  Send the message by calling the
  \texttt{SingleDestinationMessageSender} instance's \texttt{send}
  method with the message:

\begin{verbatim}
messageSender.send(message);
\end{verbatim}
\end{enumerate}

Here's a class that contains this example:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        SingleDestinationMessageSender messageSender = 
           _messageSenderFactory.createSingleDestinationMessageSender("myDestinationName");

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someValue", "abcdef");

        messageSender.send(message);
    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

\section{Synchronously with
SynchronousMessageSender}\label{synchronously-with-synchronousmessagesender}

\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.html}{\texttt{SynchronousMessageSender}}
sends a message to the Message Bus and blocks until receiving a response
or the response times out. A \texttt{SynchronousMessageSender} has these
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SynchronousMessageSender.Mode.html}{operating
modes}:

\texttt{DEFAULT}: Delivers the message in a separate thread and also
provides timeouts, in case the message is not delivered properly.

\texttt{DIRECT}: Delivers the message in the same thread of execution
and blocks until it receives a response.

Follow these steps to send a synchronous message with
\texttt{SynchronousMessageSender}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/sender/SingleDestinationMessageSenderFactory.html}{\texttt{SingleDestinationMessageSenderFactory}}
  reference:

\begin{verbatim}
@Reference
private SingleDestinationMessageSenderFactory _messageSenderFactory;
\end{verbatim}
\item
  Create a \texttt{SingleDestinationSynchronousMessageSender} by calling
  the \texttt{SingleDestinationMessageSenderFactory} reference's
  \texttt{createSingleDestinationSynchronousMessageSender} method with
  the destination and operating mode. Note that this example uses the
  \texttt{DEFAULT} mode:

\begin{verbatim}
SingleDestinationSynchronousMessageSender messageSender = 
    _messageSenderFactory.createSingleDestinationSynchronousMessageSender(
        "myDestinationName", SynchronousMessageSender.Mode.DEFAULT);
\end{verbatim}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{Create
  a message}. For example:

\begin{verbatim}
Message message = new Message();
message.put("myId", 12345);
message.put("someValue", "abcdef");
\end{verbatim}
\item
  Send the message by calling the
  \texttt{SingleDestinationSynchronousMessageSender} instance's
  \texttt{send} method with the message:

\begin{verbatim}
messageSender.send(message);
\end{verbatim}
\end{enumerate}

Here's a class that contains this example:

\begin{verbatim}
@Component(
    immediate = true,
    service = SomeServiceImpl.class
)
public class SomeServiceImpl {
    ...

    public void sendSomeMessage() {

        Message message = new Message();
        message.put("myId", 12345);
        message.put("someAttribute", "abcdef");

        SingleDestinationSynchronousMessageSender messageSender = 
            _messageSenderFactory.createSingleDestinationSynchronousMessageSender(
                "myDestinationName", SynchronousMessageSender.Mode.DEFAULT);

        messageSender.send(message);

    }

    @Reference
    private SingleDestinationMessageSenderFactory _messageSenderFactory;
}
\end{verbatim}

\section{Related Topics}\label{related-topics-11}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-message}{Creating
a Message}

\href{/docs/7-2/frameworks/-/knowledge_base/f/sending-messages-across-a-cluster}{Sending
Messages Across a Cluster}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Using
the Message Bus}

\chapter{Sending Messages Across a
Cluster}\label{sending-messages-across-a-cluster}

To ensure a message sent to a destination is received by all cluster
nodes, you must register a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/messaging/ClusterBridgeMessageListener.html}{\texttt{ClusterBridgeMessageListener}}
at that destination. This bridges the local destination to the cluster
and ensures that messages sent to the destination are distributed across
the cluster's JVMs. You should do this in a registrator class, like
those shown in
\href{/docs/7-2/frameworks/-/knowledge_base/f/registering-message-listeners}{Registering
Message Listeners}.

Follow these steps to create a registrator class that registers a
\texttt{ClusterBridgeMessageListener} to a destination:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the registrator class as an OSGi component:

\begin{verbatim}
@Component(
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...
}
\end{verbatim}
\item
  Create a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/MessageListener.html}{\texttt{MessageListener}}
  variable:

\begin{verbatim}
private MessageListener _clusterBridgeMessageListener;
\end{verbatim}
\item
  Create a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/messaging/Destination.html}{\texttt{Destination}}
  reference and set its \texttt{destination.name} property to your
  destination. For example, this reference is for the destination
  \texttt{liferay/live\_users}:

\begin{verbatim}
@Reference(target = "(destination.name=liferay/live_users)")
private Destination _destination;
\end{verbatim}
\item
  In the registrator's \texttt{activate} method, create a new
  \texttt{ClusterBridgeMessageListener} and set it to the
  \texttt{MessageListener} variable you created earlier. Then set the
  \texttt{ClusterBridgeMessageListener}'s priority and register the
  \texttt{ClusterBridgeMessageListener} to the destination:

\begin{verbatim}
@Activate
protected void activate() {

    _clusterBridgeMessageListener = new ClusterBridgeMessageListener();
    _clusterBridgeMessageListener.setPriority(Priority.LEVEL5)
    _destination.register(_clusterBridgeMessageListener);
}
\end{verbatim}

  The
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cluster/Priority.html}{\texttt{Priority}}
  enum has ten levels (\texttt{Level1} through \texttt{Level10}, with
  \texttt{Level10} being the most important). Each level is a priority
  queue for sending messages through the cluster. This is similar in
  concept to thread priorities: \texttt{Thread.MIN\_PRIORITY},
  \texttt{Thread.MAX\_PRIORITY}, and \texttt{Thread.NORM\_PRIORITY}.
\item
  In the registrator's \texttt{deactivate} method, unregister the
  \texttt{ClusterBridgeMessageListener} from the destination:

\begin{verbatim}
@Deactivate
protected void deactivate() {

    _destination.unregister(_clusterBridgeMessageListener);
}
\end{verbatim}
\end{enumerate}

Here's the full registrator class for this example:

\begin{verbatim}
@Component(
    immediate = true,
    service = MyMessageListenerRegistrator.class
)
public class MyMessageListenerRegistrator {
    ...

    @Activate
    protected void activate() {

        _clusterBridgeMessageListener = new ClusterBridgeMessageListener();
        _clusterBridgeMessageListener.setPriority(Priority.LEVEL5)
        _destination.register(_clusterBridgeMessageListener);
    }

    @Deactivate
    protected void deactivate() {

        _destination.unregister(_clusterBridgeMessageListener);
    }

    @Reference(target = "(destination.name=liferay/live_users)")
    private Destination _destination;

    private MessageListener _clusterBridgeMessageListener;
}
\end{verbatim}

\section{Related Topics}\label{related-topics-12}

\href{/docs/7-2/frameworks/-/knowledge_base/f/registering-message-listeners}{Registering
Message Listeners}

\href{/docs/7-2/frameworks/-/knowledge_base/f/sending-a-message}{Sending
a Message}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-message-bus}{Using
the Message Bus}

\chapter{Cache Configuration}\label{cache-configuration}

Caching makes specified data readily available in memory. It costs
memory but improves performance. You can experiment with cache to
determine what's good for your system. If your site serves lots of web
content articles, for example, you may want to increase the limit on how
many you can cache.

Liferay's cache configuration framework uses
\href{https://www.ehcache.org/}{Ehcache}. It's an independent framework
used by Liferay DXP's data access and template engine components. It
manages two pools:

\textbf{Multi-VM:} Cache is replicated among cluster nodes.
\texttt{EntityCache} and \texttt{FinderCache} (described next) are in
this pool because they must synchronize with data on all nodes.

\textbf{Single-VM:} Cache is managed uniquely per VM and isn't
replicated among nodes. Single-VM cache is for objects and references
that you don't need/want replicated among nodes.

Here are ways you can configure the Ehcache:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/overriding-cache}{Overriding
  Cache}: Tuning existing cache.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/caching-data}{Caching
  Data}: Implementing cache for custom data.
\end{itemize}

Start learning the Liferay cache configuration basics here.

\section{Cache Types}\label{cache-types}

You can cache any classes you like. Conveniently, Liferay DXP caches
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entities}{service
entities} and
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{service
entity finder results} automatically by default.
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} generates their caching code in the
\href{/docs/7-2/appdev/-/knowledge_base/a/understanding-the-code-generated-by-service-builder}{service
persistence layer}. The code operates on these cache types:

\textbf{\texttt{EntityCache}:} Holds service entities by primary keys.
The caching code maps entity primary keys to implementation objects. An
entity's \texttt{*PersistenceImpl.fetchByPrimaryKey} method uses
\texttt{EntityCache}.

\textbf{\texttt{FinderCache}:} Holds parameterized service entity search
results. The caching code associates
\href{/docs/7-2/appdev/-/knowledge_base/a/defining-service-entity-finder-methods}{service
entity finder} query parameter values with matching entity results.
There's code for caching entities, paginated entity lists, and
non-paginated entity lists that match your finder parameters. An
entity's \texttt{fetchByValue}, \texttt{findByValue},
\texttt{countByValue}, \texttt{findAll}, and \texttt{countAll} methods
use the FinderCache.

\section{Cache Configuration}\label{cache-configuration-1}

Liferay DXP designates separate cache configurations for multi-VM and
single-VM environments. Default \texttt{EntityCache} and
\texttt{FinderCache} are specified programmatically, while Liferay's
global cache configuration and custom cache configurations are specified
via files. All configurations adhere to the
\href{http://www.ehcache.org/ehcache.xsd}{Ehcache XSD}.

Liferay's global cache configuration is processed first on startup.
Cache configurations in modules and WARs are processed as they're
deployed after the initial global cache configuration.

\section{Initial Global Cache
Configuration}\label{initial-global-cache-configuration}

Liferay's portal cache implementation LPKG file
(\texttt{Liferay\ {[}version{]}\ Foundation\ -\ Liferay\ {[}version{]}\ Portal\ Cache\ -\ Impl.lpkg})
found in the \texttt{{[}Liferay\_Home{]}/osgi/marketplace} folder
contains the initial global cache configuration. The LPKG file's
\texttt{com.liferay.portal.cache.ehcache.impl-{[}version{]}.jar} holds
the configuration files:

\begin{itemize}
\tightlist
\item
  \texttt{liferay-multi-vm.xml}: Maps to the multi-VM pool.
\item
  \texttt{liferay-single-vm.xml}: Maps to the single-VM pool.
\end{itemize}

\section{Module Cache Configuration}\label{module-cache-configuration}

Modules can configure (add or override) cache using configuration files
in their \texttt{src/main/resources/META-INF} folder:

\begin{itemize}
\tightlist
\item
  \texttt{module-multi-vm.xml}: Maps to the multi-VM cache manager.
\item
  \texttt{module-single-vm.xml}: Maps to the single-VM cache manager.
\end{itemize}

For example, the Liferay DXP Web Experience suite's
\texttt{com.liferay.journal.service} module uses the following
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/journal/journal-service/src/main/resources/META-INF/module-multi-vm.xml}{\texttt{module-multi-vm.xml}}
to create a cache named \texttt{com.liferay.journal.util.JournalContent}
in the multi-VM pool.

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-multi-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <cache
        eternal="false"
        maxElementsInMemory="10000"
        name="com.liferay.journal.util.JournalContent"
        overflowToDisk="false"
        timeToIdleSeconds="600"
    >
    </cache>
</ehcache>
\end{verbatim}

Portlet WARs can configure cache too.

\section{Portlet WAR Cache
Configuration}\label{portlet-war-cache-configuration}

Ehcache configuration in a portlet WAR has these requirements:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The Ehcache configuration XML file must be in the application context
  (e.g., any path under \texttt{WEB-INF/src}).
\item
  The \texttt{portlet.properties} file must specify the cache file
  location. Either of the two properties is used and is assigned the
  cache file path, relative to the application context root (e.g.,
  \texttt{WEB-INF/src}).
\end{enumerate}

\begin{verbatim}
ehcache.single.vm.config.location=path/to/single/vm/config/file
ehcache.multi.vm.config.location=path/to/multi/vm/config/file 
\end{verbatim}

For example, here's the
\href{https://github.com/liferay/liferay-plugins/blob/7.0.x/portlets/test-cache-configuration-portlet}{\texttt{test-cache-configuration-portlet}}
WAR's structure:

\begin{itemize}
\tightlist
\item
  \texttt{docroot/WEB-INF/src/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{ehcache/}

    \begin{itemize}
    \tightlist
    \item
      \href{https://github.com/liferay/liferay-plugins/blob/7.0.x/portlets/test-cache-configuration-portlet/docroot/WEB-INF/src/ehcache/liferay-single-vm-ext.xml}{\texttt{liferay-single-vm-ext.xml}}
    \item
      \href{https://github.com/liferay/liferay-plugins/blob/7.0.x/portlets/test-cache-configuration-portlet/docroot/WEB-INF/src/ehcache/liferay-multi-vm-clustered-ext.xml}{\texttt{liferay-multi-vm-clustered-ext.xml}}
    \end{itemize}
  \item
    \texttt{portlet.properties}
  \end{itemize}
\end{itemize}

The \texttt{portlet.properties} file specifies these properties:

\begin{verbatim}
ehcache.single.vm.config.location=ehcache/liferay-single-vm-ext.xml
ehcache.multi.vm.config.location=ehcache/liferay-multi-vm-clustered-ext.xml
\end{verbatim}

\section{Cache Names and
Registration}\label{cache-names-and-registration}

A cache is identified by its name (e.g.,
\texttt{\textless{}cache\ name="com.liferay.docs.MyClass"\ ...\ /\textgreater{}}).
If a module provides a cache configuration with the name of an existing
cache, the existing cache is overridden. If a module provides a cache
configuration with a new name, a new cache is added.

Here's what happens behind the scenes: Liferay's cache manager checks
the configurations. If a cache with the name already exists, the cache
manager removes it from Ehcache's cache registry and registers a new
Ehcache into Ehcache's cache registry. If the name is new, the Liferay
cache manager just registers a new Ehcache.

Cache names are arbitrary except for \texttt{EntityCache} and
\texttt{FinderCache}.

\section{EntityCache Names}\label{entitycache-names}

\texttt{EntityCache} uses this naming convention:

\texttt{PREFIX\ +\ ENTITY\_IMPL\_CLASS\_NAME}

where the \texttt{PREFIX} is always this:

\begin{verbatim}
com.liferay.portal.kernel.dao.orm.EntityCache.
\end{verbatim}

For example, the cache name for the
\texttt{com.liferay.portal.kernel.model.User} entity starts with the
\texttt{PREFIX} and ends with the implementation class name
\texttt{com.liferay.portal.model.impl.UserImpl}:

\begin{verbatim}
com.liferay.portal.kernel.dao.orm.EntityCache.com.liferay.portal.model.impl.UserImpl
\end{verbatim}

\section{FinderCache Names}\label{findercache-names}

\texttt{FinderCache} uses this naming convention:

\texttt{PREFIX\ +\ ENTITY\_IMPL\_CLASS\_NAME\ +\ {[}".LIST1"\textbar{}".LIST2"{]}}

where the \texttt{PREFIX} is always this:

\begin{verbatim}
com.liferay.portal.kernel.dao.orm.FinderCache.
\end{verbatim}

Here are the \texttt{FinderCache} types and their name patterns.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3889}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pattern
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Entity instances matching query parameters. &
\texttt{PREFIX\ +\ ENTITY\_IMPL\_CLASS\_NAME} &
\texttt{com.liferay.portal.kernel.dao.orm.FinderCache.com.liferay.portal.model.impl.ClassNameImpl} \\
Paginated lists of entity instances matching query parameters. &
\texttt{PREFIX\ +\ ENTITY\_IMPL\_CLASS\_NAME\ +\ ".List1"} &
\texttt{com.liferay.portal.kernel.dao.orm.FinderCache.com.liferay.portal.model.impl.ClassNameImpl.List1} \\
Non-paginated lists of entity instances matching query parameters. &
\texttt{PREFIX\ +\ ENTITY\_IMPL\_CLASS\_NAME\ +\ ".List2"} &
\texttt{com.liferay.portal.kernel.dao.orm.FinderCache.com.liferay.portal.model.impl.ClassNameImpl.List2} \\
\end{longtable}

\noindent\hrulefill

Now that you have a basic understanding of cache in Liferay, continue
with overriding an existing cache configuration or caching custom data.

\chapter{Overriding Cache}\label{overriding-cache}

Liferay DXP pre-configures cache for service entities, service entity
finder results, and cache for several other classes. You can tune
existing cache to meet your needs. For example, it may help to write
cache overflow elements to disk, increase the maximum number of cached
elements, or make other adjustments. Using a module and only one XML
file, you can override cache configurations dynamically.

\noindent\hrulefill

\textbf{Warning:} Modifying an Ehcache element flushes its cache.

\noindent\hrulefill

Here is how to override a cache configuration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the name of the cache you want to override. Existing cache
  configurations and statistics (hit/miss counts and percentages) can be
  examined at runtime through JMX. Using a tool that supports JMX
  analysis, you can examine Liferay DXP's cache configurations in the
  MBean of \texttt{net.sf.ehcache}. Please note that the caches listed
  in the MBean are more than what Liferay DXP's cache configuration
  files specify because some caches are created purely through Java
  code.

  \begin{figure}
  \centering
  \includegraphics{./images/zulu-mission-control.png}
  \caption{Caches configured in Liferay DXP can be examined using JMX
  tools such as Zulu Mission Control (Portal Process → MBean server →
  MBean Browser)}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** See
 [Cache Names and Registration](/docs/7-2/frameworks/-/knowledge_base/f/cache-configuration#cache-names-and-registration)
 to identify `EntityCache` and the different kinds of `FinderCache` instances 
 associated with service entities. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Some cache configurations can also be viewed statically in their deployment
artifacts or source code.

-   `liferay-*-vm.xml` files in the
    `Liferay [version] Foundation - Liferay [version] Portal Cache - Impl.lpkg` file.

-   `module-*-vm.xml` files in modules or Liferay LPKG files.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  If you don't own the existing project that specifies the cache or you
  want to use a different project to configure the cache, create a
  module project. Otherwise, edit the cache in the existing project.
  These instructions demonstrate adding the cache configuration to a new
  module project.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Tip:** create new projects using the
 [API project template](/docs/7-2/reference/-/knowledge_base/r/api-template)
 and remove the Java class generated in the `src/main/java/` folder.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  In the \texttt{src/main/resources/META-INF} folder, add an XML file
  for the type of cache (multi-VM or single-VM) you're overriding.

  \texttt{module-multi-vm.xml} file:

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-multi-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <!-- cache elements go here -->
</ehcache>
\end{verbatim}

  \texttt{module-single-vm.xml} file:

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-single-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <!-- cache elements go here -->
</ehcache>
\end{verbatim}
\item
  In the \texttt{\textless{}ehcache/\textgreater{}} element, add a
  \texttt{\textless{}cache/\textgreater{}} element and set its
  \texttt{name} attribute to the name of the cache you're overriding.
\item
  Specify all existing \texttt{\textless{}cache/\textgreater{}} element
  attributes you want to preserve. Hint: view the attributes in an MBean
  browser, as mentioned earlier.
\item
  Add or modify attributes to meet your needs. The
  \texttt{\textless{}cache/\textgreater{}} element attributes are
  described in the
  \href{http://www.ehcache.org/ehcache.xsd}{ehcache.xsd} and
  \href{http://www.ehcache.org/documentation/2.8/configuration/index.html}{Ehcache
  documentation}.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  the project}.
\end{enumerate}

Congratulations! Your cache modification is in effect.

\section{Related Topics}\label{related-topics-13}

\href{/docs/7-2/frameworks/-/knowledge_base/f/caching-data}{Caching
Data}

\chapter{Caching Data}\label{caching-data}

\href{/docs/7-2/frameworks/-/knowledge_base/f/cache-configuration}{Liferay's
caching framework} helps you use Ehcache to cache any data. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/SingleVMPool.html}{\texttt{SingleVMPool}}
and
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/MultiVMPool.html}{\texttt{MultiVMPool}}
classes use Liferay's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/PortalCache.html}{\texttt{PortalCache}}
utility. Storing and retrieving cached data objects is as easy as using
a hash map: you associate a key with every cache value. The following
steps demonstrate implementing data caching.

\noindent\hrulefill

\textbf{Note:} If you want to modify cache for Service Builder Service
Entities or Entity Finder results, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/overriding-cache}{Overriding
Cache}.

\noindent\hrulefill

\section{Step 1: Determine Cache Pool
Requirements}\label{step-1-determine-cache-pool-requirements}

There are cache pools for single-VM and multi-VM environments. The pool
types and some Ehcache features require using \texttt{Serializable}
values.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Determine whether to create a cache
  \href{/docs/7-2/frameworks/-/knowledge_base/f/cache-configuration}{in
  a single VM or across multiple VMs} (e.g., in a clustered
  environment).
\item
  Determine if it's necessary to serialize the data you're caching.

  \begin{itemize}
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/MultiVMPool.html}{\texttt{MultiVMPool}}
    requires both the cache key and cache value to be
    \href{https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html}{\texttt{Serializable}}.
  \item
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/SingleVMPool.html}{\texttt{SingleVMPool}}
    typically requires only cache keys to be
    \href{https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html}{\texttt{Serializable}}.
    Note that some Ehache features, such as \texttt{overflowToDisk},
    require \texttt{Serializable} values too.
  \end{itemize}
\end{enumerate}

\section{Step 2: Implement a Cache
Key}\label{step-2-implement-a-cache-key}

Cache keys must be unique,
\href{https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html}{\texttt{Serializable}}
objects. They should relate to the values being cached. For example, in
Liferay DXP's \texttt{JournalContentImpl}, a \texttt{JournalContentKey}
instance relates to each cached \texttt{JournalArticleDisplay} object.
Here's the \texttt{JournalContentKey} class:

\begin{verbatim}
private static class JournalContentKey implements Serializable {

    @Override
    public boolean equals(Object obj) {
        JournalContentKey journalContentKey = (JournalContentKey)obj;

        if ((journalContentKey._groupId == _groupId) &&
            Objects.equals(journalContentKey._articleId, _articleId) &&
            (journalContentKey._version == _version) &&
            Objects.equals(
                journalContentKey._ddmTemplateKey, _ddmTemplateKey) &&
            (journalContentKey._layoutSetId == _layoutSetId) &&
            Objects.equals(journalContentKey._viewMode, _viewMode) &&
            Objects.equals(journalContentKey._languageId, _languageId) &&
            (journalContentKey._page == _page) &&
            (journalContentKey._secure == _secure)) {

            return true;
        }

        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = HashUtil.hash(0, _groupId);

        hashCode = HashUtil.hash(hashCode, _articleId);
        hashCode = HashUtil.hash(hashCode, _version);
        hashCode = HashUtil.hash(hashCode, _ddmTemplateKey);
        hashCode = HashUtil.hash(hashCode, _layoutSetId);
        hashCode = HashUtil.hash(hashCode, _viewMode);
        hashCode = HashUtil.hash(hashCode, _languageId);
        hashCode = HashUtil.hash(hashCode, _page);

        return HashUtil.hash(hashCode, _secure);
    }

    private JournalContentKey(
        long groupId, String articleId, double version,
        String ddmTemplateKey, long layoutSetId, String viewMode,
        String languageId, int page, boolean secure) {

        _groupId = groupId;
        _articleId = articleId;
        _version = version;
        _ddmTemplateKey = ddmTemplateKey;
        _layoutSetId = layoutSetId;
        _viewMode = viewMode;
        _languageId = languageId;
        _page = page;
        _secure = secure;
    }

    private static final long serialVersionUID = 1L;

    private final String _articleId;
    private final String _ddmTemplateKey;
    private final long _groupId;
    private final String _languageId;
    private final long _layoutSetId;
    private final int _page;
    private final boolean _secure;
    private final double _version;
    private final String _viewMode;

}
\end{verbatim}

\texttt{JournalContentKey}s constructor populates fields that
collectively define unique keys for each piece of journal content.

Note a cache key's characteristics:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A key instance's field values relate to the cached data and
  distinguish it from other data instances.
\item
  A key follows \texttt{Serializable} class best practices.

  \begin{itemize}
  \tightlist
  \item
    Overrides \texttt{Object}'s \texttt{equals} and \texttt{hashcode}
    methods.
  \item
    Includes a private static final long \texttt{serialVersionUID}
    field. It is to be incremented when a new version of the class is
    incompatible with previous versions.
  \end{itemize}
\end{enumerate}

Your cache key class is ready for caching data values.

\section{Step 3: Implement Cache
Logic}\label{step-3-implement-cache-logic}

When your application creates or requests the data type you're caching,
you must handle getting existing data from cache and putting new/updated
data into the cache. Liferay DXP's caching classes are easy to inject
into a
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{Declarative
Services (DS) Component}, but you can access them using
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{\texttt{ServiceTracker}}s
too. These steps use fictitious key and value classes: \texttt{SomeKey}
and \texttt{SomeValue}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Name your cache. Cache names are arbitrary, but they must be unique in
  the cache pool, and typically identify the data type being cached.
\end{enumerate}

\begin{verbatim}
protected static final String CACHE_NAME = SomeValue.class.getName();
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Access the VM pool you're using.
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/MultiVMPool.html}{\texttt{MultiVMPool}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/SingleVMPool.html}{\texttt{SingleVMPool}}
  are Declarative Service (DS) components. To access a pool from a DS
  component, apply the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}}
  annotation to a pool field (see below). Otherwise, use a
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{\texttt{ServiceTracker}}
  to access the pool.
\end{enumerate}

\begin{verbatim}
@Reference
private MultiVMPool _multiVMPool;
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Declare a private static
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/cache/PortalCache.html}{\texttt{PortalCache}}
  instance.
\end{enumerate}

\begin{verbatim}
private static PortalCache<SomeKey, SomeValue> _portalCache;
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Initialize your \texttt{PortalCache} when your class is being
  activated or initialized. If you're using a DS component, initialize
  the cache in your component's activation method (annotated with
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Activate.html}{\texttt{@Activate}}).
  Get the cache from your VM pool using your cache name. For example,
  this DS component's activation method gets a cache from the multi-VM
  pool.
\end{enumerate}

\begin{verbatim}
@Activate
public void activate() {
    _portalCache =
        (PortalCache<SomeKey, SomeValue>)
            _multiVMPool.getPortalCache(CACHE_NAME);
    ...
}
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Similarly, remove your cache when your class instance is deactivated
  or destroyed. If you're using a DS component, remove the cache in your
  deactivation method (annotated with
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Deactivate.html}{\texttt{@Deactivate}}).
  Use the VM pool to remove the cache.
\end{enumerate}

\begin{verbatim}
@Deactivate
public void deactivate() {
    _multiVMPool.removePortalCache(CACHE_NAME);
}
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  In your code that uses the cached data, implement your caching logic.
  Here's some example code:
\end{enumerate}

\begin{verbatim}
SomeKey key = new SomeKey(...); 

SomeValue value = _portalCache.get(
    key);

if (value == null) {
    value = createSomeValue(...);

    _portalCache.put(key, value);
}

// continue using the data 
...
\end{verbatim}

The code above constructs a key based on the data being used. Then, the
key is used to check the \texttt{PortalCache} for the data. If the cache
doesn't have data associated with the key, data is created and put it
into the cache. The code continues using the cached data. Use similar
logic for the data you are caching.

Configuring the cache and deploying your project is next.

\section{Step 4: Configure the Cache}\label{step-4-configure-the-cache}

It's time to specify your Ehcache configuration.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Depending on the VM pool you're using, start your XML file in one of
  the following ways.
\end{enumerate}

Multi VM file:

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-multi-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <!-- cache elements go here -->
</ehcache>
\end{verbatim}

Single VM file:

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-single-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <!-- cache elements go here -->
</ehcache>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Add a \texttt{\textless{}cache\textgreater{}} element for the cache
  you're creating. Although the cache name is arbitrary, using a
  name-spaced name such as a fully qualified class name is a best
  practice.

  Configure your \texttt{\textless{}cache\textgreater{}} element to fit
  your caching requirements. The
  \href{http://www.ehcache.org/ehcache.xsd}{ehcache.xsd} and
  \href{http://www.ehcache.org/documentation/2.8/configuration/index.html}{Ehcache
  documentation} describe the \texttt{\textless{}cache\textgreater{}}
  attributes.

  For example, the Liferay Web Experience suite's
  \texttt{com.liferay.journal.service} module uses this
  \href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/journal/journal-service/src/main/resources/META-INF/module-multi-vm.xml}{\texttt{module-multi-vm.xml}}
  file to configure its cache named
  \texttt{com.liferay.journal.util.JournalContent}.
\end{enumerate}

\begin{verbatim}
<ehcache
    dynamicConfig="true"
    monitoring="off"
    name="module-multi-vm"
    updateCheck="false"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://www.ehcache.org/ehcache.xsd"
>
    <cache
        eternal="false"
        maxElementsInMemory="10000"
        name="com.liferay.journal.util.JournalContent"
        overflowToDisk="false"
        timeToIdleSeconds="600"
    >
    </cache>
</ehcache>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Deploy your project.
\end{enumerate}

Congratulations! Your data cache is in effect.

\section{Related Topics}\label{related-topics-14}

\href{/docs/7-2/frameworks/-/knowledge_base/f/overriding-cache}{Overriding
Cache}

\chapter{Collaboration}\label{collaboration}

Underlying the
\href{/docs/7-2/user/-/knowledge_base/u/collaboration}{collaboration
suite} is a set of powerful APIs that add collaboration features to your
apps. For example, if your app contains a custom content type, you can
use the collaboration suite's social API to enable comments and ratings
for that content. You can also integrate your app with the Documents and
Media Library, and much more.

Here are a few of the things you can do with the collaboration suite's
APIs.

\chapter{Item Selector}\label{item-selector}

An \emph{Item Selector} is a UI component for selecting entities in a
user-friendly manner. Many Liferay apps use Item Selectors to select
items such as images, videos, audio files, documents, and pages. For
example, the Documents and Media Item Selector selects files.

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-02.png}
\caption{Item Selectors select different kinds of entities.}
\end{figure}

The Item Selector API provides a framework for you to use, extend, and
create Item Selectors in your apps.

Here are some use cases for the Item Selector API:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Selecting entities with an Item Selector.
\item
  Configuring an Item Selector to select your app's custom entity.
\item
  Adding a new \emph{selection view} to customize the selection
  experience.
\end{enumerate}

\chapter{Adaptive Media}\label{adaptive-media}

The
\href{/docs/7-2/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adaptive
Media} app tailors the size and quality of images to the device
displaying them. For example, you can configure Adaptive Media to send
large, high-resolution images only to devices that can display them.
Other devices get images that consume less bandwidth and processing
power.

By default, Adaptive Media integrates with Documents and Media, Blogs,
and Web Content. You can also integrate it with your apps. Adaptive
Media contains a taglib that displays the adapted image matching the
file version you supply. You can also use Adaptive Media's finder API if
you need to get adapted images that match other criteria (e.g., a
specific resolution, a range of attributes, etc.). You can even
customize the image scaling that Adaptive Media uses to produce adapted
images.

\chapter{Social API}\label{social-api}

Users interact with content via Liferay DXP's social features. For
example, users can provide feedback on content, share that content with
others, subscribe to receive notifications, and more. Use the social API
to enable such functionality in your apps.

Here's an example of some functionality you can add to your apps via the
social API:

\textbf{Social Bookmarks:} Share content on social media. You can also
create new social bookmarks if one doesn't exist for your social network
of choice.

\textbf{Comments:} Comment on content.

\textbf{Ratings:} Rate content. Administrators can also change the
rating type (e.g., likes, stars, thumbs, etc.).

\textbf{Flags:} Flag inappropriate content.

\chapter{Documents and Media API}\label{documents-and-media-api}

Users can use, manage, and share files in the Documents and Media
Library. For example, users can embed files in content, organize them in
folders, edit and collaborate on them with other users, and more. See
the
\href{/docs/7-2/user/-/knowledge_base/u/managing-documents-and-media}{user
guide} for more information on the Documents and Media Library's
features.

A powerful API underlies the Documents and Media Library's
functionality. You can leverage this API in your apps. For example, you
could create an app that uploads files to the Documents and Media
Library. Your app could even update, delete, and copy files.

Here's an example of some things you can do with the Documents and Media
API:

\begin{itemize}
\tightlist
\item
  Create files, folders, and shortcuts.
\item
  Delete entities.
\item
  Update entities.
\item
  Check out files for editing, and check them back in.
\item
  Copy and move entities.
\item
  Get entities.
\end{itemize}

\chapter{Item Selector}\label{item-selector-1}

An \emph{Item Selector} is a UI component for selecting entities in a
user-friendly manner.

Here's what you'll learn to do with Item Selectors:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select Entities.
\item
  Create Custom Item Selector Criteria.
\item
  Create Custom Item Selector Views.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/item-selector-dialog-02.png}
\caption{Item Selectors select entities.}
\end{figure}

\chapter{Understanding the Item Selector API's
Components}\label{understanding-the-item-selector-apis-components}

Before working with the Item Selector API, you should learn about its
components. You'll work with these components as you leverage the API in
your apps:

\textbf{Selection View:} A class that shows entities of particular types
from different sources. For example, an Item Selector configured to show
images might show selection views from Documents and Media, a
third-party image provider, or a drag-and-drop UI. Selection views are
the framework's key components.

\textbf{Markup:} A markup file that renders the selection view. You can
choose from JSP, FreeMarker, or even pure HTML and JavaScript.

\textbf{Return Type:} A class that represents the data type that entity
selections return. For example, if users select images and you want to
return the selected image's URL, then you need a URL return type. Each
return type class must implement
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}}.
Such classes are named after the return type's data and suffixed with
\texttt{ItemSelectorReturnType}. For example, the URL return type class
is \texttt{URLItemSelectorReturnType}. The return type class is an API
that connects the return type to the Item Selector's views. The Item
Selector uses the return type class, which is empty and returns no
information, as an identifier. The view ensures that the proper
information is returned. If you create your own return type, you should
specify its data type and format in Javadoc.

\textbf{Criterion:} A class that represents the selected entity. For
example, if users select images, you need an image criterion class. Each
criterion class must implement
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorCriterion.html}{\texttt{ItemSelectorCriterion}}.
Such classes are named for the entity they represent and suffixed with
\texttt{ItemSelectorCriterion}. For example, the criterion class for
images is \texttt{ImageItemSelectorCriterion}. If you create your own
criterion class, extend
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterion.html}{\texttt{BaseItemSelectorCriterion}}.
This base class implements \texttt{ItemSelectorCriterion} and provides
methods that handle the Item Selector's return types. Your criterion
class can therefore be empty, unless you also want to use it to pass
information to the view.

Note that criterion and return types together form an Item Selector's
\emph{criteria}. The Item Selector uses its criteria to decide which
selection views to show.

\noindent\hrulefill

\textbf{Note:} For a list of the criterion classes and return types that
Liferay DXP provides, see
\href{/docs/7-2/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
Selector Criterion and Return Types}.

\noindent\hrulefill

\textbf{Criterion Handler:} A class that gets the appropriate selection
view. Each criterion requires a criterion handler. Criterion handler
classes extend
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterionHandler.html}{\texttt{BaseItemSelectorCriterionHandler}}
with the criterion's entity as a type argument. Criterion handler
classes are named after the criterion's entity and suffixed by
\texttt{ItemSelectorCriterionHandler}. For example, the image criterion
handler class is \texttt{ImageItemSelectorCriterionHandler} and extends
\texttt{BaseItemSelectorCriterionHandler\textless{}ImageItemSelectorCriterion\textgreater{}}.

\begin{figure}
\centering
\includegraphics{./images/item-selector-architecture.png}
\caption{Item Selector views (selection views) are determined by the
return type and criterion, and rendered by the markup.}
\end{figure}

\chapter{Getting an Item Selector}\label{getting-an-item-selector}

To use an Item Selector with your criteria, you must get that Item
Selector's URL. The URL is needed to open the Item Selector dialog in
your UI. To get this URL, you must get an \texttt{ItemSelector}
reference and call its
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelector.html\#getItemSelectorURL-com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory-java.lang.String-com.liferay.item.selector.ItemSelectorCriterion...-}{\texttt{getItemSelectorURL}}
method with the following parameters:

\texttt{RequestBackedPortletURLFactory}: A factory that creates portlet
URLs.

\texttt{ItemSelectedEventName}: A unique, arbitrary JavaScript event
name that the Item Selector triggers when the entity is selected.

\texttt{ItemSelectorCriterion}: The criterion (or an array of criterion
objects) that specifies the type of entities to make available in the
Item Selector.

Keep these points in mind when getting an Item Selector's URL:

\begin{itemize}
\item
  You can invoke the URL object's \texttt{toString} method to get its
  value.
\item
  You can configure an Item Selector to use any number of criterion. The
  criterion can use any number of return types.
\item
  The order of the Item Selector's criteria determines the selection
  view order. For example, if you pass the Item Selector an
  \texttt{ImageItemSelectorCriterion} followed by a
  \texttt{VideoItemSelectorCriterion}, the Item Selector displays the
  image selection views first.
\item
  The return type order is also significant. A view uses the first
  return type it supports from each criterion's return type list.
\end{itemize}

\chapter{Understanding Custom Selection
Views}\label{understanding-custom-selection-views}

The default selection views may provide everything you need for your
app. Custom selection views are required, however, for certain
situations. For example, you must create a custom selection view for
your users to select images from an external image provider.

The selected entity type determines the view the Item Selector presents.
The Item Selector can also render multiple views for the same entity
type. For example, several selection views are available for images.
Each selection view is a tab in the UI that corresponds to the image's
location. An \texttt{*ItemSelectorCriterion} class represents each
selection view.

\begin{figure}
\centering
\includegraphics{./images/item-selector-tabs.png}
\caption{An entity type can have multiple selection views.}
\end{figure}

\section{The Selection View's Class}\label{the-selection-views-class}

The criterion and return types determine the selection view's class.
This class is an \texttt{ItemSelectorView} component class that
implements
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html}{\texttt{ItemSelectorView}}
parameterized with the view's criterion. Remember these things when
creating this class:

\begin{itemize}
\item
  Configure the title by implementing the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getTitle-java.util.Locale-}{\texttt{getTitle}}
  method to return the localized title of the tab to display in the Item
  Selector dialog.
\item
  Configure the search options by implementing the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#isShowSearch--}{\texttt{isShowSearch()}}
  method to return whether your view should show the search field. To
  implement search, this method must return \texttt{true}. The
  \texttt{renderHTML} method indicates whether a user performed a search
  based on the value of the \texttt{search} parameter. You can get the
  user's search keywords as follows:

\begin{verbatim}
String keywords = ParamUtil.getString(request, "keywords");
\end{verbatim}
\item
  Make your view visible by implementing the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#isVisible-com.liferay.portal.kernel.theme.ThemeDisplay-}{\texttt{isVisible()}}
  method to return \texttt{true}. Note that you can use this method to
  add conditional logic to disable the view.
\end{itemize}

\chapter{Selecting Entities with an Item
Selector}\label{selecting-entities-with-an-item-selector}

The steps here show you how to get and use an Item Selector to select
entities in your app. For an explanation of the Item Selector API and
more information on these steps, see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector introduction}.

\section{Get an Item Selector}\label{get-an-item-selector}

First, you must get an Item Selector for your use case. Follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Determine the criterion and return types for the Item Selector. The
  criterion corresponds to the selected entity type, and the return
  types correspond to the data you expect to receive from those
  selections. For a list of the criterion and return types that Liferay
  DXP provides, see
  \href{/docs/7-2/reference/-/knowledge_base/r/item-selector-criterion-and-return-types}{Item
  Selector Criterion and Return Types}. For example, if you need an Item
  Selector that selects images and returns their URLs, use
  \texttt{ImageItemSelectorCriterion} and
  \texttt{URLItemSelectorReturnType}. You can
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-criterion-and-return-types}{create}
  criterion and/or return types if there aren't existing ones for your
  use case.
\item
  Use Declarative Services to get an \texttt{ItemSelector} OSGi Service
  Component:

\begin{verbatim}
import com.liferay.item.selector.ItemSelector;
import org.osgi.service.component.annotations.Reference;

...

@Reference
private ItemSelector _itemSelector
\end{verbatim}

  The component annotations are available in the module
  \href{http://mvnrepository.com/artifact/org.osgi/org.osgi.service.component.annotations}{\texttt{org.osgi.service.component.annotations}}.
\item
  Create the factory you'll use to create the Item Selector's URL. To do
  this, invoke the \texttt{RequestBackedPortletURLFactoryUtil.create}
  method with the current request object. The request can be an
  \texttt{HttpServletRequest} or \texttt{PortletRequest}:

\begin{verbatim}
RequestBackedPortletURLFactory requestBackedPortletURLFactory =
    RequestBackedPortletURLFactoryUtil.create(request);
\end{verbatim}
\item
  Create a list of return types expected for the entity. For example,
  the return types list here consists of
  \texttt{URLItemSelectorReturnType}:

\begin{verbatim}
List<ItemSelectorReturnType> desiredItemSelectorReturnTypes =
    new ArrayList<>();
desiredItemSelectorReturnTypes.add(new URLItemSelectorReturnType());
\end{verbatim}
\item
  Create an object for the criterion. This example creates a new
  \texttt{ImageItemSelectorCriterion}:

\begin{verbatim}
ImageItemSelectorCriterion imageItemSelectorCriterion =
    new ImageItemSelectorCriterion();
\end{verbatim}
\item
  Use the criterion's \texttt{setDesiredItemSelectorReturnTypes} method
  to set the return types list to the criterion:

\begin{verbatim}
imageItemSelectorCriterion.setDesiredItemSelectorReturnTypes(
    desiredItemSelectorReturnTypes);
\end{verbatim}
\item
  Call the Item Selector's \texttt{getItemSelectorURL} method to get an
  Item Selector URL for the criterion. The method requires the URL
  factory, an arbitrary event name, and a series of criterion instances
  (one, in this case):

\begin{verbatim}
PortletURL itemSelectorURL = _itemSelector.getItemSelectorURL(
    requestBackedPortletURLFactory, "sampleTestSelectItem",
    imageItemSelectorCriterion);
\end{verbatim}
\item
  Add the \texttt{itemSelectorURL} to the request to be able to retrieve
  it from the JSP:
  \texttt{\textless{}code/\textgreater{}request.setAttribute("itemSelectorURL",\ itemSelectorURL.toString())\textless{}/code\textgreater{}"}
\end{enumerate}

\section{Using the Item Selector
Dialog}\label{using-the-item-selector-dialog}

To open the Item Selector in your UI, you must use the JavaScript
component \texttt{LiferayItemSelectorDialog} from
\href{http://alloyui.com}{AlloyUI's}
\texttt{liferay-item-selector-dialog} module. The component listens for
the item selected event that you specified for the Item Selector URL.
The event returns the selected element's information according to its
return type.

Follow these steps to use the Item Selector's dialog in a JSP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the AUI tag library:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Define the UI element you'll use to open the Item Selector dialog. For
  example, this creates a \emph{Choose} button with the ID
  \texttt{chooseImage}:

\begin{verbatim}
<aui:button name="chooseImage" value="Choose" />
\end{verbatim}
\item
  Get the Item Selector's URL:

\begin{verbatim}
<%
String itemSelectorURL = GetterUtil.getString(request.getAttribute("itemSelectorURL"));
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and set it to
  use the \texttt{liferay-item-selector-dialog} module:

\begin{verbatim}
<aui:script use="liferay-item-selector-dialog">

</aui:script>
\end{verbatim}
\item
  Inside the \texttt{\textless{}aui:script\textgreater{}} tag, attach an
  event handler to the UI element you created in step two. For example,
  this attaches a click event and a function to the \emph{Choose}
  button:

\begin{verbatim}
<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
    'click',
      function(event) {
        <!-- function logic goes here -->
      }
    );

</aui:script>
\end{verbatim}

  Inside the function, you must create a new instance of the
  \texttt{LiferayItemSelectorDialog} AlloyUI component and configure it
  to use the Item Selector. The next steps walk you through this.
\item
  Create the function's logic. First, create a new instance of the
  Liferay Item Selector dialog:

\begin{verbatim}
var itemSelectorDialog = new A.LiferayItemSelectorDialog(
    {
        ...
    }
);
\end{verbatim}
\item
  Inside the braces of the \texttt{LiferayItemSelectorDialog}
  constructor, first set set the \texttt{eventName} attribute. This
  makes the dialog listen for the item selected event. The event name is
  the Item Selector's event name that you specified in your Java code
  (the code that gets the Item Selector URL):

\begin{verbatim}
eventName: 'ItemSelectedEventName',
\end{verbatim}
\item
  Immediately after the \texttt{eventName} setting, set the \texttt{on}
  attribute to implement a function that operates on the selected item
  change. For example, this function sets its variables for the newly
  selected item. The information available to parse depends on the
  return type(s). As the comment below indicates, you must add the logic
  for using the selected element:

\begin{verbatim}
on: {
        selectedItemChange: function(event) {
            var selectedItem = event.newVal;

            if (selectedItem) {
                var itemValue = JSON.parse(
                selectedItem.value
                );
                itemSrc = itemValue.url;

                <!-- use item as needed -->
            }
        }
},
\end{verbatim}
\item
  Immediately after the \texttt{on} setting, set the \texttt{title}
  attribute to the dialog's title:

\begin{verbatim}
title: '<liferay-ui:message key="select-image" />',
\end{verbatim}
\item
  Immediately after the \texttt{title} setting, set the \texttt{url}
  attribute to the previously retrieved Item Selector URL. This
  concludes the attribute settings inside the
  \texttt{LiferayItemSelectorDialog} constructor:

\begin{verbatim}
url: '<%= itemSelectorURL.toString() %>'
\end{verbatim}
\item
  To conclude the logic of the function from step four, open the Item
  Selector dialog by calling its \texttt{open} method:

\begin{verbatim}
itemSelectorDialog.open();
\end{verbatim}
\end{enumerate}

When the user clicks the \emph{Choose} button, a new dialog opens,
rendering the Item Selector with the views that support the criterion
and return type(s).

Here's the complete example code for these steps:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>

<aui:button name="chooseImage" value="Choose" />

<%
String itemSelectorURL = GetterUtil.getString(request.getAttribute("itemSelectorURL"));
%>

<aui:script use="liferay-item-selector-dialog">

    $('#<portlet:namespace />chooseImage').on(
        'click',
        function(event) {
            var itemSelectorDialog = new A.LiferayItemSelectorDialog(
                {
                    eventName: 'ItemSelectedEventName',
                    on: {
                            selectedItemChange: function(event) {
                                var selectedItem = event.newVal;

                                if (selectedItem) {
                                    var itemValue = JSON.parse(
                                    selectedItem.value
                                    );
                                    itemSrc = itemValue.url;

                                    <!-- use item as needed -->
                                }
                            }
                    },
                    title: '<liferay-ui:message key="select-image" />',
                    url: '<%= itemSelectorURL.toString() %>'
                }
            );
            itemSelectorDialog.open();
        }
    );
</aui:script>
\end{verbatim}

\section{Related Topics}\label{related-topics-15}

\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-criterion-and-return-types}{Creating
Custom Criterion and Return Types}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\chapter{Creating Custom Criterion and Return
Types}\label{creating-custom-criterion-and-return-types}

If an existing criterion or return type doesn't fit your use case, you
can create them. The steps here show you how. For more detailed
information on Item Selector criterion and return types, see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector introduction}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your criterion class by extending
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterion.html}{\texttt{BaseItemSelectorCriterion}}.
  Name the class after the entity it represents and suffix it with
  \texttt{ItemSelectorCriterion}. You can use the class to pass
  information to the view if needed. Otherwise, your criterion class can
  be empty. If you pass information to the view, any fields in your
  criterion class should be serializable and you should expose an empty
  public constructor.

  For example,
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/journal/item/selector/criterion/JournalItemSelectorCriterion.html}{\texttt{JournalItemSelectorCriterion}}
  is the criterion class for \texttt{Journal} entities (Web Content) and
  passes primary key information to the view:

\begin{verbatim}
public class JournalItemSelectorCriterion extends BaseItemSelectorCriterion {

        public JournalItemSelectorCriterion() {
        }

        public JournalItemSelectorCriterion(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        public long getResourcePrimKey() {
                return _resourcePrimKey;
        }

        public void setResourcePrimKey(long resourcePrimKey) {
                _resourcePrimKey = resourcePrimKey;
        }

        private long _resourcePrimKey;

}
\end{verbatim}
\item
  Create a criterion handler by creating an OSGi component class that
  implements
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/BaseItemSelectorCriterionHandler.html}{\texttt{BaseItemSelectorCriterionHandler}}.
  This example creates a criterion handler for the
  \texttt{TaskItemSelectorCriterion} class. The \texttt{@Activate} and
  \texttt{@Override} tokens are required to activate this OSGi
  component:

\begin{verbatim}
@Component(service = ItemSelectorCriterionHandler.class)
public class TaskItemSelectorCriterionHandler extends 
    BaseItemSelectorCriterionHandler<TaskItemSelectorCriterion> {

    public Class <TaskItemSelectorCriterion> getItemSelectorCriterionClass() {
        return TasksItemSelectorCriterionHandler.class;
    }

    @Activate
    @Override
    protected void activate(BundleContext bundleContext) {
            super.activate(bundleContext);
    }

}
\end{verbatim}
\item
  If you need a new return type, create it by implementing
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorReturnType.html}{\texttt{ItemSelectorReturnType}}.
  Name your return type class after the return type's data and suffix it
  with \texttt{ItemSelectorReturnType}. Specify the data and its format
  in Javadoc. Return type classes need no content. For example, here's a
  return type for a task:

\begin{verbatim}
/**
* This return type should return the task ID and the user who
* created the task as a string.
*
* @author Joe Bloggs
*/
public class TaskItemSelectorReturnType implements ItemSelectorReturnType{

}
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-16}

\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-item-selector-views}{Creating
Custom Item Selector Views}

\href{/docs/7-2/frameworks/-/knowledge_base/f/selecting-entities-with-an-item-selector}{Selecting
Entities with an Item Selector}

\chapter{Creating Custom Item Selector
Views}\label{creating-custom-item-selector-views}

You can create your own selection view if an Item Selector doesn't
contain the one you need. The steps here show you how. For more
information on custom selection views and the Item Selector API, see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector introduction}.

\section{Configuring Your Selection View's OSGi
Module}\label{configuring-your-selection-views-osgi-module}

First, you must configure your selection view's OSGi module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add these dependencies to your module's \texttt{build.gradle}:

\begin{verbatim}
dependencies {
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.api", version: "2.0.0"
        compileOnly group: "com.liferay", name: "com.liferay.item.selector.criteria.api", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.impl", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "2.0.0"
        compileOnly group: "com.liferay.portal", name: "com.liferay.util.taglib", version: "2.0.0"
        compileOnly group: "javax.portlet", name: "portlet-api", version: "2.0"
        compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
        compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}
\item
  Add your module's information to the \texttt{bnd.bnd} file. For
  example, this configuration adds the information for a module called
  \texttt{My\ Custom\ View}:

\begin{verbatim}
Bundle-Name: My Custom View
Bundle-SymbolicName: com.liferay.docs.my.custom.view
Bundle-Version: 1.0.0
\end{verbatim}
\item
  Add a \texttt{Web-ContextPath} to your \texttt{bnd.bnd} to point to
  your module's resources:

\begin{verbatim}
Include-Resource:\
        META-INF/resources=src/main/resources/META-INF/resources
Web-ContextPath: /my-custom-view
\end{verbatim}

  If you don't have a \texttt{Web-ContextPath}, your module won't know
  where your resources are. The \texttt{Include-Resource} header points
  to the relative path for the module's resources.
\end{enumerate}

\section{Implementing Your Selection View's
Class}\label{implementing-your-selection-views-class}

Follow these steps to implement your selection view's class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an \texttt{ItemSelectorView} component class that implements
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html}{\texttt{ItemSelectorView}}
  with the criterion as a type argument. In the \texttt{@Component}
  annotation, set the \texttt{item.selector.view.order} property to the
  order you want the view to appear in when displayed alongside other
  selector views (lower values get higher priority).

  This example selector view class is for images, so it implements
  \texttt{ItemSelectorView} with
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/image/criterion/ImageItemSelectorCriterion.html}{\texttt{ImageItemSelectorCriterion}}
  as a type argument. The \texttt{@Component} annotation sets the
  \texttt{item.selector.view.order} property to \texttt{200} and
  registers the class as an \texttt{ItemSelectorView} service:

\begin{verbatim}
@Component(
    property = {"item.selector.view.order:Integer=200"},
    service = ItemSelectorView.class
)
public class SampleItemSelectorView
    implements ItemSelectorView<ImageItemSelectorCriterion> {...
\end{verbatim}
\item
  Create getter methods for the criterion class, servlet context, and
  return types. Do this by implementing the methods
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getItemSelectorCriterionClass--}{\texttt{getItemSelectorCriterionClass()}},
  \texttt{getServletContext()}, and
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#getSupportedItemSelectorReturnTypes--}{\texttt{getSupportedItemSelectorReturnTypes()}},
  respectively:

\begin{verbatim}
@Override
public Class<ImageItemSelectorCriterion> getItemSelectorCriterionClass() 
{
    return ImageItemSelectorCriterion.class;
}

@Override            
public ServletContext getServletContext() {
    return _servletContext;
}

@Override            
public List<ItemSelectorReturnType> getSupportedItemSelectorReturnTypes() {
    return _supportedItemSelectorReturnTypes;
}
\end{verbatim}
\item
  Configure the selection view's title, search options, and visibility
  settings. Here's an example configuration for the
  \texttt{Sample\ Selector} selection view:

\begin{verbatim}
@Override
public String getTitle(Locale locale) {
    return "Sample Selector";
}

@Override
public boolean isShowSearch() {
    return false;
}

@Override
public boolean isVisible(ThemeDisplay themeDisplay) {
    return true;
}
\end{verbatim}

  See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector\#the-selection-views-class}{The
  Selection View's Class} for more information on these methods.
\item
  Implement the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/ItemSelectorView.html\#renderHTML-javax.servlet.ServletRequest-javax.servlet.ServletResponse-T-javax.portlet.PortletURL-java.lang.String-boolean-}{\texttt{renderHTML}}
  method to set your view's render settings and render its markup.

  Here's an example implementation of a \texttt{renderHTML} method that
  points to a JSP file (\texttt{sample.jsp}) to render the view. Note
  that \texttt{itemSelectedEventName} is passed as a request attribute
  so it can be used in the view markup. The view markup is specified via
  the \texttt{ServletContext} method \texttt{getRequestDispatcher}.
  Although this example uses a JSP, you can render the markup in another
  language such as FreeMarker.

\begin{verbatim}
@Override
public void renderHTML(
    ServletRequest request, ServletResponse response,
    ImageItemSelectorCriterion itemSelectorCriterion,
    PortletURL portletURL, String itemSelectedEventName,
    boolean search
)
throws IOException, ServletException {

    request.setAttribute(_ITEM_SELECTED_EVENT_NAME,
        itemSelectedEventName);

    ServletContext servletContext = getServletContext();

    RequestDispatcher requestDispatcher =
        servletContext.getRequestDispatcher("/sample.jsp");

    requestDispatcher.include(request, response);
}
\end{verbatim}
\item
  Use the \texttt{@Reference} annotation to reference your module's
  class for the \texttt{setServletContext} method. In the annotation,
  use the \texttt{target} parameter to specify the available services
  for the servlet context. This example uses the
  \texttt{osgi.web.symbolicname} property to specify the
  \texttt{com.liferay.selector.sample.web} class as the default value.
  You should also use the \texttt{unbind\ =\ \_} parameter to specify
  that there's no unbind method for this module. In the method body, set
  the servlet context variable:

\begin{verbatim}
@Reference(
    target =
    "(osgi.web.symbolicname=com.liferay.item.selector.sample.web)",
    unbind = "-"
)
public void setServletContext(ServletContext servletContext) {
    _servletContext = servletContext;
}
\end{verbatim}
\item
  Define the \texttt{\_supportedItemSelectorReturnTypes} list with the
  return types that this view supports (you referenced this list in step
  two). This example adds
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/URLItemSelectorReturnType.html}{\texttt{URLItemSelectorReturnType}}
  and
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/item/selector/criteria/FileEntryItemSelectorReturnType.html}{\texttt{FileEntryItemSelectorReturnType}}
  to the list of supported return types (you can use more if needed).
  More return types means that the view is more reusable. Also note that
  this example defines its servlet context variable at the bottom of the
  file:

\begin{verbatim}
private static final List<ItemSelectorReturnType>
    _supportedItemSelectorReturnTypes =
    Collections.unmodifiableList(
        ListUtil.fromArray(
            new ItemSelectorReturnType[] {
                new FileEntryItemSelectorReturnType(),
                new URLItemSelectorReturnType()
            }));

 private ServletContext _servletContext;
\end{verbatim}
\end{enumerate}

For a real-world example of a view class, see
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/site-navigation/site-navigation-item-selector-web/src/main/java/com/liferay/site/navigation/item/selector/web/internal/SiteNavigationMenuItemItemSelectorView.java}{\texttt{SiteNavigationMenuItemItemSelectorView}}.

\section{Writing Your View Markup}\label{writing-your-view-markup}

You can write your view markup however you wish---there's no typical or
average case. You can write it with taglibs, AUI components, or even
pure HTML and JavaScript. The markup must do two key things:

\begin{itemize}
\tightlist
\item
  Render the entities for the user to select.
\item
  When an entity is selected, pass the return type information via a
  JavaScript event.
\end{itemize}

The example view class in the previous section passes the JavaScript
event name as a request attribute in the \texttt{renderHTML} method. You
can therefore use this event name in the markup:

\begin{verbatim}
Liferay.fire(
        `<%= {ITEM_SELECTED_EVENT_NAME} %>',

        {
            data:{
                the-data-your-client-needs-according-to-the-return-type
            }
        }
);
\end{verbatim}

For a complete, real-world example, see
\href{https://github.com/liferay/liferay-portal/blob/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web/src/main/resources/META-INF/resources/layouts.jsp}{\texttt{layouts.jsp}}
for the module
\href{https://github.com/liferay/liferay-portal/tree/7.0.x/modules/apps/web-experience/layout/layout-item-selector-web}{\texttt{com.liferay.layout.item.selector.web}}.
Even though this example is for a previous version of Liferay DXP, it
still applies to 7.0. Here's a walkthrough of this \texttt{layouts.jsp}
file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, some variables are defined. Note that
  \texttt{LayoutItemSelectorViewDisplayContext} is an optional class
  that contains additional information about the criteria and view:

\begin{verbatim}
<%
LayoutItemSelectorViewDisplayContext layoutItemSelectorViewDisplayContext = 
    (LayoutItemSelectorViewDisplayContext)request.getAttribute(
    BaseLayoutsItemSelectorView.LAYOUT_ITEM_SELECTOR_VIEW_DISPLAY_CONTEXT);

LayoutItemSelectorCriterion layoutItemSelectorCriterion = 
    layoutItemSelectorViewDisplayContext.getLayoutItemSelectorCriterion();

Portlet portlet = PortletLocalServiceUtil.getPortletById(company.getCompanyId(), 
    portletDisplay.getId());
%>
\end{verbatim}
\item
  This snippet imports a CSS file for styling and places it in the
  \texttt{\textless{}head\textgreater{}} of the page:

\begin{verbatim}
<liferay-util:html-top>
        <link href="<%= PortalUtil.getStaticResourceURL(
        request, application.getContextPath() + "/css/main.css", 
        portlet.getTimestamp()) 
        %>" rel="stylesheet" type="text/css" />
</liferay-util:html-top>
\end{verbatim}

  You can learn more about using the \texttt{liferay-util} taglibs in
  \href{/docs/7-2/reference/-/knowledge_base/r/using-the-liferay-util-taglib}{Using
  the Liferay Util Taglib}.
\item
  This snippet creates the UI to display the layout entities. It uses
  the
  \href{https://docs.liferay.com/dxp/apps/layout/latest/taglibdocs/liferay-layout/layouts-tree.html}{\texttt{liferay-layout:layouts-tree}}
  taglib along with the \href{https://lexicondesign.io/}{Lexicon} design
  language to create
  \href{https://clayui.com/docs/components/cards.html}{cards}:

\begin{verbatim}
<div class="container-fluid-1280 layouts-selector">
    <div class="card-horizontal main-content-card">
            <div class="card-row card-row-padded">
                    <liferay-layout:layouts-tree
                            checkContentDisplayPage="<%= layoutItemSelectorCriterion.isCheckDisplayPage() %>"
                            draggableTree="<%= false %>"
                            expandFirstNode="<%= true %>"
                            groupId="<%= scopeGroupId %>"
                            portletURL="<%= layoutItemSelectorViewDisplayContext.getEditLayoutURL() %>"
                            privateLayout="<%= layoutItemSelectorViewDisplayContext.isPrivateLayout() %>"
                            rootNodeName="<%= layoutItemSelectorViewDisplayContext.getRootNodeName() %>"
                            saveState="<%= false %>"
                            selectedLayoutIds="<%= layoutItemSelectorViewDisplayContext.getSelectedLayoutIds() %>"
                            selPlid="<%= layoutItemSelectorViewDisplayContext.getSelPlid() %>"
                            treeId="treeContainer"
                    />
            </div>
    </div>
</div>
\end{verbatim}

  This renders the following UI:

  \begin{figure}
  \centering
  \includegraphics{./images/layouts-item-selector-view.png}
  \caption{The Layouts Item Selector view uses Lexicon and Liferay
  Layout taglibs to create the UI.}
  \end{figure}
\item
  This portion of the \texttt{aui:script} returns the path for the page:

\begin{verbatim}
<aui:script use="aui-base">
    var LString = A.Lang.String;

    var getChosenPagePath = function(node) {
            var buffer = [];

            if (A.instanceOf(node, A.TreeNode)) {
                    var labelText = LString.escapeHTML(node.get('labelEl').text());

                    buffer.push(labelText);

                    node.eachParent(
                            function(treeNode) {
                                    var labelEl = treeNode.get('labelEl');

                                    if (labelEl) {
                                            labelText = LString.escapeHTML(labelEl.text());

                                            buffer.unshift(labelText);
                                    }
                            }
                    );
            }

            return buffer.join(' > ');
    };
\end{verbatim}
\item
  The following snippet passes the return type data when the layout
  (entity) is selected. Note the \texttt{url} and \texttt{uuid}
  variables retrieve the URL or UUID for the layout:

\begin{verbatim}
var setSelectedPage = function(event) {
        var disabled = true;

        var messageText = '<%= UnicodeLanguageUtil.get(request, "there-is-no-selected-page") %>';

        var lastSelectedNode = event.newVal;

        var labelEl = lastSelectedNode.get('labelEl');

        var link = labelEl.one('a');

        var url = link.attr('data-url');
        var uuid = link.attr('data-uuid');

        var data = {};

        if (link && url) {
                disabled = false;

                data.layoutpath = getChosenPagePath(lastSelectedNode);
\end{verbatim}
\item
  This checks if the return type information is a URL or a UUID. It then
  sets the value for the JSON object's \texttt{data} attribute
  accordingly. The last line adds the \texttt{CKEditorFuncNum} for the
  editor to the JSON object's \texttt{data} attribute:

\begin{verbatim}
        <c:choose>
                <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), URLItemSelectorReturnType.class.getName()) %>">
                        data.value = url;
                </c:when>
                <c:when test="<%= Objects.equals(layoutItemSelectorViewDisplayContext.getItemSelectorReturnTypeName(), UUIDItemSelectorReturnType.class.getName()) %>">
                        data.value = uuid;
                </c:when>
        </c:choose>
}

<c:if test="<%= Validator.isNotNull(layoutItemSelectorViewDisplayContext.getCkEditorFuncNum()) %>">
        data.ckeditorfuncnum: <%= layoutItemSelectorViewDisplayContext.getCkEditorFuncNum() %>;
</c:if>
\end{verbatim}

  The \texttt{data-url} and \texttt{data-uuid} attributes are in the
  HTML for the Layouts Item Selector. The HTML for an instance of the
  Layouts Item Selector is shown here:

  \begin{figure}
  \centering
  \includegraphics{./images/layouts-item-selector-html.png}
  \caption{The URL and UUID can be seen in the \texttt{data-url} and
  \texttt{data-uuid} attributes of the Layout Item Selector's HTML.}
  \end{figure}
\item
  The JavaScript trigger event specified in the Item Selector return
  type is fired, passing the data JSON object with the required return
  type information:

\begin{verbatim}
        Liferay.Util.getOpener().Liferay.fire(
                '<%= layoutItemSelectorViewDisplayContext.getItemSelectedEventName() %>',
                {
                        data: data
                }
        );
};
\end{verbatim}
\item
  Finally, the layout is set to the selected page:

\begin{verbatim}
    var container = A.one('#<portlet:namespace />treeContainerOutput');

    if (container) {
            container.swallowEvent('click', true);

            var tree = container.getData('tree-view');

            tree.after('lastSelectedChange', setSelectedPage);
    }
</aui:script>
\end{verbatim}
\end{enumerate}

Your new selection view is automatically rendered by the Item Selector
in every app that uses the criterion and return types you defined,
without modifying anything in those apps.

\section{Related Topics}\label{related-topics-17}

\href{/docs/7-2/frameworks/-/knowledge_base/f/item-selector}{Item
Selector}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-criterion-and-return-types}{Creating
Custom Criterion and Return Types}

\href{/docs/7-2/frameworks/-/knowledge_base/f/selecting-entities-with-an-item-selector}{Selecting
Entities with an Item Selector}

\chapter{Documents and Media API}\label{documents-and-media-api-1}

A powerful API underlies the
\href{/docs/7-2/user/-/knowledge_base/u/managing-documents-and-media}{Documents
and Media library}. You can leverage this API in your own apps. For
example, you could create an app that lets users upload files to the
Documents and Media library. Your app could even let users update,
delete, and copy files.

Here, you'll learn how to use the Documents and Media library's API.
Note that this is a large API and it may seem daunting at first. To keep
backwards compatibility, the API has different entry points and multiple
methods or classes with similar functionality. Fortunately, you don't
need to learn all of them. The content here focuses on the API's most
useful classes and methods.

Also note that the Documents and Media app is itself a consumer of this
API---Liferay's developers used the API to implement the app's
functionality. Therefore, code from this app is used as an example of
how to use the API.

\chapter{Getting Started with the Documents and Media
API}\label{getting-started-with-the-documents-and-media-api}

Before you start using the Documents and Media API, you must learn these
things:

\hyperref[key-interfaces]{\textbf{Key Interfaces:}} The interfaces
you'll use most while using the API.

\hyperref[getting-a-service-reference]{\textbf{Getting a Service
Reference:}} A service reference is required for calling the API's
services.

\hyperref[specifying-repositories]{\textbf{Specifying Repositories:}}
How to specify which Documents and Media repository to work with.

\hyperref[specifying-folders]{\textbf{Specifying Folders:}} How to
specify which Documents and Media folder to work with.

\chapter{Key Interfaces}\label{key-interfaces}

The Documents and Media API contains several key interfaces:

\textbf{Documents and Media Services:} These interfaces expose all the
available Documents and Media functionality:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppLocalService.html}{\texttt{DLAppLocalService}}:
  The local service.
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}:
  The remote service. This service wraps the local service methods in
  permission checks.

  Note that Liferay used
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder} to create these services. Because the remote service contains
  permission checks, it's a best practice to call it instead of the
  local service. See below for instructions on getting a service
  reference.
\end{itemize}

\textbf{Entity Interfaces:} These interfaces represent entities in the
Documents and Media library. Here are the primary ones you'll use:

\begin{itemize}
\tightlist
\item
  \texttt{FileEntry}: Represents a file.
\item
  \texttt{Folder}: Represents a folder.
\item
  \texttt{FileShortcut}: Represents a shortcut to a file.
\end{itemize}

\chapter{Getting a Service Reference}\label{getting-a-service-reference}

Before you can do anything with the Documents and Media API, you must
get a service reference. If you're using OSGi modules, use the
\texttt{@Reference} annotation to
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{get
a service reference in an OSGi component via Declarative Services}. For
example, this code gets a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}

If you're using a standard web module (WAR file), use a
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{Service
Tracker} to get a reference to the service instead.

Getting the reference this way ensures that you leverage OSGi's
\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{dependency
management} features. If you must use the Documents and Media services
outside of an OSGi component (e.g., in a JSP), then you can use the
services' static \texttt{*Util} classes:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppServiceUtil.html}{\texttt{DLAppServiceUtil}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppLocalServiceUtil.html}{\texttt{DLAppLocalServiceUtil}}
\end{itemize}

\chapter{Specifying Repositories}\label{specifying-repositories}

Many methods in the Documents and Media API contain a
\texttt{repositoryId} parameter that identifies the Documents and Media
repository where the operation is performed. A Site (group) can have
multiple repositories, but only one can be accessed via the portal UI.
This is called the Site repository, which is effectively a Site's
default repository. To access this repository via the API, provide the
group ID as the \texttt{repositoryId}.

You can also get the \texttt{repositoryId} via file
(\texttt{FileEntry}), folder (\texttt{Folder}), and file shortcut
(\texttt{FileShortcut}) entities. Each of these entities has a
\texttt{getRepositoryId} method that gets its repository's ID. For
example, this code gets the repository ID of the \texttt{FileEntry}
object \texttt{fileEntry}:

\begin{verbatim}
long repositoryId = fileEntry.getRepositoryId();
\end{verbatim}

There may also be cases that require a \texttt{Repository} object. You
can get one by creating a \texttt{RepositoryProvider} reference and
passing the repository ID to its \texttt{getRepository} method:

\begin{verbatim}
@Reference
private RepositoryProvider repositoryProvider;

Repository repository = repositoryProvider.getRepository(repositoryId);
\end{verbatim}

Even if you only have an entity ID (e.g., a file or folder ID), you can
still use \texttt{RepositoryProvider} to get a \texttt{Repository}
object. To do so, call the \texttt{RepositoryProvider} method for the
entity type with the entity ID as its argument. For example, this code
gets a folder's \texttt{Repository} by calling the
\texttt{RepositoryProvider} method \texttt{getFolderRepository} with the
folder's ID:

\begin{verbatim}
Repository repository = repositoryProvider.getFolderRepository(folderId);
\end{verbatim}

See the \texttt{RepositoryProvider}
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/RepositoryProvider.html}{Javadoc}
for a list of the methods for other entity types.

Note that there are ways to create repositories programmatically,
including repositories private to specific apps. For simplicity,
however, the examples here access the default site repository.

\chapter{Specifying Folders}\label{specifying-folders}

Many API methods require the ID of a folder that they perform operations
in or on. For example, such methods may contain parameters like
\texttt{folderId} or \texttt{parentFolderId}. Also note that you can use
the constant \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID} to
specify the root folder of your current repository.

\chapter{Creating Files, Folders, and
Shortcuts}\label{creating-files-folders-and-shortcuts}

A primary use case for the Docs \& Media API is to create files,
folders, and file shortcuts in the Documents and Media library.

If you've used other Liferay APIs, the Docs \& Media API follows the
same conventions. In general, methods that do similar things have
similar names. When you must create an entity (whatever it is), look for
methods that follow the pattern \texttt{add{[}ModelName{]}}, where
\texttt{{[}ModelName{]}} is the name of the entity's data model object.
As the
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{intro}
explains, you'll use
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
to access the API. This service object contains the methods for adding
these entities:

\begin{itemize}
\tightlist
\item
  \hyperref[files]{Files}
\item
  \hyperref[folders]{Folders}
\item
  \hyperref[file-shortcuts]{File Shortcuts}
\end{itemize}

\chapter{Files}\label{files}

To create files (\texttt{FileEntry} entities) in the Documents and Media
library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFileEntry} methods. There are three such methods,
and they differ by the data type used to create the file. Click each
method to see a full description of the method and its parameters:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-byte:A-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ byte{[}{]}\ bytes,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.io.File-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ File\ file,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileEntry-long-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.io.InputStream-long-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{addFileEntry(...,\ InputStream\ is,\ long\ size,\ ...)}}
\end{itemize}

Note that the following arguments are optional:

\texttt{sourceFileName}: This keeps track of the uploaded file. It
infers the content type if that file has an extension.

\texttt{mimeType}: Defaults to a binary stream. If omitted, Documents
and Media tries to infer the type from the file extension.

\texttt{description}: The file's description to display in the portal.

\texttt{changeLog}: Descriptions for file versions.

\texttt{is} and \texttt{size}: In the method that takes an
\texttt{InputStream}, you can use \texttt{null} for the \texttt{is}
parameter. If you do this, however, you must use \texttt{0} for the
\texttt{size} parameter.

For step-by-step instructions on creating files with
\texttt{addFileEntry}, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files}{Creating
Files}.

\chapter{Folders}\label{folders}

To create folders (\texttt{Folder} entities) in the Documents and Media
library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFolder} method:

\begin{verbatim}
addFolder(long repositoryId, 
        long parentFolderId, 
        String name, 
        String description, 
        ServiceContext serviceContext)
\end{verbatim}

See this method's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFolder-long-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}
for a description of the parameters. Note that the \texttt{description}
parameter is optional.

For step-by-step instructions on creating folders with
\texttt{addFolder}, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-folders}{Creating
Folders}.

\section{Folders and External
Repositories}\label{folders-and-external-repositories}

By creating a folder that acts as a proxy for an external repository
(e.g., SharePoint), you can effectively mount that repository inside a
Site's default repository. When users enter this special folder, they
see the external repository. These folders are called \emph{mount
points}. You can create one via the API by setting the Service Context's
\texttt{mountPoint} attribute to \texttt{true}, and then using that
Service Context in the \texttt{addFolder} method:

\begin{verbatim}
serviceContext.setAttribute("mountPoint", true);
\end{verbatim}

Note that the \texttt{repositoryId} of such a folder indicates the
external repository the folder points to---not the repository the folder
exists in. Also, mount point folders can only exist in the default Site
repository.

\chapter{File Shortcuts}\label{file-shortcuts}

To create file shortcuts (\texttt{FileShortcut} entities) in the
Documents and Media library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFileShortcut} method:

\begin{verbatim}
addFileShortcut(long repositoryId, 
                long folderId, 
                long toFileEntryId, 
                ServiceContext serviceContext)
\end{verbatim}

See this method's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#addFileShortcut-long-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}
for a description of the parameters. Note that all this method's
parameters are mandatory.

Keep these things in mind when creating shortcuts:

\begin{itemize}
\tightlist
\item
  You can create a shortcut to a file in a different Site, if that file
  and its resulting shortcut are in the same portal instance.
\item
  You can't create folder shortcuts.
\item
  Shortcuts can only exist in the default Site repository. If you try to
  invoke \texttt{addFileShortcut} with an external repository's ID
  (e.g., a SharePoint repository), the operation fails. Because not all
  repositories have the same features, the Documents and Media API only
  supports the common denominators for all repositories: files and
  folders.
\end{itemize}

For step-by-step instructions on creating file shortcuts with
\texttt{addFileShortcut}, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-file-shortcuts}{Creating
File Shortcuts}.

\chapter{Creating Files}\label{creating-files}

To create a file via the Documents and Media API, use one of the
overloaded \texttt{addFileEntry} methods in
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}.
The steps here show you how to do this, using the method that contains
\texttt{InputStream} as an example. For detailed information on this and
other \texttt{addFileEntry} methods, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files-folders-and-shortcuts}{Creating
Files, Folders, and Shortcuts}. For general information on using the
API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to create a file via the Documents and Media API:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{addFileEntry} method's
  arguments. Since it's common to create a file with data submitted by
  the end user, you can extract the data from the request. This example
  does so via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upload/UploadPortletRequest.html}{\texttt{UploadPortletRequest}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(uploadPortletRequest, "repositoryId");
long folderId = ParamUtil.getLong(uploadPortletRequest, "folderId");
String sourceFileName = uploadPortletRequest.getFileName("file");
String title = ParamUtil.getString(uploadPortletRequest, "title");
String description = ParamUtil.getString(uploadPortletRequest, "description");
String changeLog = ParamUtil.getString(uploadPortletRequest, "changeLog");
boolean majorVersion = ParamUtil.getBoolean(uploadPortletRequest, "majorVersion");

try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    String contentType = uploadPortletRequest.getContentType("file");
    long size = uploadPortletRequest.getSize("file");

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileEntry.class.getName(), uploadPortletRequest);
}
\end{verbatim}
\item
  Call the service reference's \texttt{addFileEntry} method with the
  data from the previous step. Note that this example does so inside the
  previous step's try-with-resources statement:

\begin{verbatim}
try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    ...

    FileEntry fileEntry = _dlAppService.addFileEntry(
                        repositoryId, folderId, sourceFileName, contentType, title, 
                        description, changeLog, inputStream, size, serviceContext);
}
\end{verbatim}

  The method returns a \texttt{FileEntry} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-18}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-folders}{Creating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-file-shortcuts}{Creating
File Shortcuts}

\chapter{Creating Folders}\label{creating-folders}

To create folders (\texttt{Folder} entities) in the Documents and Media
library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFolder} method. The steps here show you how to do
this. For more detailed information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files-folders-and-shortcuts}{Creating
Files, Folders, and Shortcuts}. For general information on using the
API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to create a folder with the \texttt{DLAppService}
method \texttt{addFolder}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{addFolder} method's
  arguments. Since it's common to create a folder with data submitted by
  the end user, you can extract the data from the request. This example
  does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(actionRequest, "repositoryId");
long parentFolderId = ParamUtil.getLong(actionRequest, "parentFolderId");
String name = ParamUtil.getString(actionRequest, "name");
String description = ParamUtil.getString(actionRequest, "description");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{addFolder} method with the data
  from the previous step:

\begin{verbatim}
Folder folder = _dlAppService.addFolder(
                        repositoryId, parentFolderId, name, description, 
                        serviceContext);
\end{verbatim}

  The method returns a \texttt{Folder} object, which this example sets
  to a variable for later use. Note, however, that you don't have to do
  this.
\end{enumerate}

You can find the full code for this example in the \texttt{updateFolder}
method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{updateFolder} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\section{Related Topics}\label{related-topics-19}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-folders}{Updating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-folders}{Copying
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Creating File Shortcuts}\label{creating-file-shortcuts}

To create file shortcuts (\texttt{FileShortcut} entities) in the
Documents and Media library, you must use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
interface's \texttt{addFileShortcut} method. The steps here show you how
to do this. For more detailed information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files-folders-and-shortcuts}{Creating
Files, Folders, and Shortcuts}. For general information on using the
API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to create a file shortcut with the
\texttt{DLAppService} method \texttt{addFileShortcut}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{addFileShortcut} method's
  arguments. Since it's common to create a file shortcut with data
  submitted by the end user, you can extract the data from the request.
  This example does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(actionRequest, "repositoryId");
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long toFileEntryId = ParamUtil.getLong(actionRequest, "toFileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
                    DLFileShortcutConstants.getClassName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{addFileShortcut} method with the
  data from the previous step:

\begin{verbatim}
FileShortcut fileShortcut = _dlAppService.addFileShortcut(
                                    repositoryId, folderId, toFileEntryId, 
                                    serviceContext);
\end{verbatim}

  The method returns a \texttt{FileShortcut} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-20}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-file-shortcuts}{Updating
File Shortcuts}

\chapter{Deleting Entities}\label{deleting-entities}

You can delete entities with the Documents and Media API. Note that the
exact meaning of \emph{delete} depends on the portal configuration and
the delete operation you choose. This is because the
\href{/docs/7-2/user/-/knowledge_base/u/restoring-deleted-assets}{Recycle
Bin}, which is enabled by default, can be used to recover deleted items.
Deletions via
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}},
however, are permanent. To send items to the Recycle Bin, you must use
the Capabilities API.

Here, you'll learn about deleting these entities:

\begin{itemize}
\tightlist
\item
  \hyperref[files]{Files}
\item
  \hyperref[file-versions]{File Versions}
\item
  \hyperref[file-shortcuts]{File Shortcuts}
\item
  \hyperref[folders]{Folders}
\end{itemize}

You'll also learn about using the \hyperref[recycle-bin]{Recycle Bin}.

\chapter{Files}\label{files-1}

There are two \texttt{DLAppService} methods you can use to delete files:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileEntry-long-}{\texttt{deleteFileEntry(long\ fileEntryId)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileEntryByTitle-long-long-java.lang.String-}{\texttt{deleteFileEntryByTitle(long\ repositoryId,\ long\ folderId,\ String\ title)}}
\end{itemize}

These methods differ only in how they identify a file for deletion. The
combination of the \texttt{folderId} and \texttt{title} parameters in
\texttt{deleteFileEntryByTitle} uniquely identify a file because it's
impossible for two files in the same folder to share a name. For
step-by-step instructions on using these methods, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}.

\chapter{File Versions}\label{file-versions}

When a file is modified, Documents and Media creates a new file version
and leaves the previous version intact. Over time, old file versions can
accumulate and consume storage space. Fortunately, you can use the
Documents and Media API to delete them. Note, however, that there's no
way to send file versions to the Recycle Bin---once you delete them,
they're gone forever.

You can delete file versions with the \texttt{DLAppService} method
\texttt{deleteFileVersion}:

\begin{verbatim}
deleteFileVersion(long fileEntryId, String version)
\end{verbatim}

See this method's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileVersion-long-java.lang.String-}{Javadoc}
for a description of the parameters. For step-by-step instructions on
using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-versions}{Deleting
File Versions}.

\section{Identifying File Versions}\label{identifying-file-versions}

Since there may be many versions of a file, it's useful to
programmatically identify old versions for deletion. You can do this
with
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/FileVersionVersionComparator.html}{\texttt{FileVersionVersionComparator}}.

The following example creates such a comparator and uses its
\texttt{compare} method to identify old file versions. The code does so
by iterating through each
\href{/docs/7-2/user/-/knowledge_base/u/workflow}{approved} version of
the file (\texttt{fileVersion}). Each iteration uses the
\texttt{compare} method to test that file version
(\texttt{fileVersion.getVersion()}) against the same file's current
version (\texttt{fileEntry.getVersion()}). If this comparison is greater
than \texttt{0}, then the iteration's file version
(\texttt{fileVersion}) is old and is deleted by
\texttt{deleteFileVersion}:

\begin{verbatim}
FileVersionVersionComparator comparator = new FileVersionVersionComparator();

for (FileVersion fileVersion: fileEntry.getVersions(WorkflowConstants.STATUS_APPROVED)) {

    if (comparator.compare(fileEntry.getVersion(), fileVersion.getVersion()) > 0) {

        dlAppService.deleteFileVersion(fileVersion.getFileEntryId(), fileVersion.getVersion());
    }
}
\end{verbatim}

\chapter{File Shortcuts}\label{file-shortcuts-1}

To delete file shortcuts, use the \texttt{DLAppService} method
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFileShortcut-long-}{\texttt{deleteFileShortcut}}
with the ID of the shortcut you want to delete:

\begin{verbatim}
deleteFileShortcut(long fileShortcutId)
\end{verbatim}

For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-shortcuts}{Deleting
File Shortcuts}.

\chapter{Folders}\label{folders-1}

Deleting folders is similar to deleting files. There are two methods you
can use to delete a folder. Click each method to see its Javadoc:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFolder-long-}{\texttt{deleteFolder(long\ folderId)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#deleteFolder-long-long-java.lang.String-}{\texttt{deleteFolder(long\ repositoryId,\ long\ parentFolderId,\ String\ name)}}
\end{itemize}

Which method you use is up to you---they both delete a folder. For
step-by-step instructions on using these methods, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}.

\chapter{Recycle Bin}\label{recycle-bin}

Instead of deleting entities, you can move them to the
\href{/docs/7-2/user/-/knowledge_base/u/restoring-deleted-assets}{Recycle
Bin}. Note that the Recycle Bin isn't part of the Documents and Media
API. Although you can use the Recycle Bin API directly, in the case of
Documents and Media it's better to use the Capabilities API. This is
because some third-party repositories (e.g., SharePoint) don't support
Recycle Bin functionality. The Capabilities API lets you verify that the
repository you're working in supports the Recycle Bin. It's therefore a
best practice to always use the Capabilities API when moving entities to
the Recycle Bin.

For step-by-step instructions on this, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}.

\chapter{Deleting Files}\label{deleting-files}

To delete a file with the Documents and Media API, you must use one of
the two \texttt{deleteFileEntry*} methods discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{Deleting
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to delete a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the arguments of the
  \texttt{deleteFileEntry*} method you wish to use. Since it's common to
  delete a file specified by the end user, you can extract the data you
  need from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish. Also note that this example
  gets only the file entry ID because it uses \texttt{deleteFileEntry}:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
\end{verbatim}

  If you want to use \texttt{deleteFileEntryByTitle} instead, you can
  also get the repository ID, folder ID, and title from the request.
\item
  Call the service reference's \texttt{deleteFileEntry*} method you wish
  to use with the data from the previous step. This example calls
  \texttt{deleteFileEntry} with the file entry's ID:

\begin{verbatim}
_dlAppService.deleteFileEntry(fileEntryId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-21}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files}{Creating
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Deleting File Versions}\label{deleting-file-versions}

To delete a file version with the Documents and Media API, you must use
the \texttt{deleteFileVersion} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{Deleting
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to use \texttt{deleteFileVersion} to delete a file
version:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the file entry ID and version for the file you want to delete.
  Since it's common to delete a file version specified by the end user,
  you can extract these parameters from the request. This example does
  so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can do this any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
String version = ParamUtil.getString(actionRequest, "version");
\end{verbatim}
\item
  Use the service reference to call the \texttt{deleteFileVersion}
  method with the file entry ID and version from the previous step:

\begin{verbatim}
_dlAppService.deleteFileVersion(fileEntryId, version);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-22}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\chapter{Deleting File Shortcuts}\label{deleting-file-shortcuts}

To delete a file shortcut with the Documents and Media API, you must use
the \texttt{deleteFileShortcut} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{Deleting
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to delete a file shortcut:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the file shortcut's ID. Since it's common to delete a file
  shortcut specified by the end user, you can extract its ID from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can do this any way you wish:

\begin{verbatim}
long fileShortcutId = ParamUtil.getLong(actionRequest, "fileShortcutId");
\end{verbatim}
\item
  Use the service reference to call the \texttt{deleteFileShortcut}
  method with the file shortcut ID from the previous step:

\begin{verbatim}
_dlAppService.deleteFileShortcut(fileShortcutId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-23}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-file-shortcuts}{Creating
File Shortcuts}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-file-shortcuts}{Updating
File Shortcuts}

\chapter{Deleting Folders}\label{deleting-folders}

To delete a folder with the Documents and Media API, you must use one of
the two \texttt{deleteFolder} methods discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{Deleting
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to delete a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the arguments of the
  \texttt{deleteFolder} method you wish to use. Since it's common to
  delete a folder specified by the end user, you can extract the data
  you need from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish. Also note that this example
  gets only the folder ID because the next step deletes the folder with
  \texttt{deleteFolder(folderId)}:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");
\end{verbatim}

  If you want to use the other \texttt{deleteFolder} method, you can
  also get the repository ID, parent folder ID, and folder name from the
  request.
\item
  Call the service reference's \texttt{deleteFolder} method you wish to
  use with the data from the previous step. This example calls
  \texttt{deleteFolder} with the folder's ID:

\begin{verbatim}
_dlAppService.deleteFolder(folderId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{deleteFolders} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{deleteFolders} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\section{Related Topics}\label{related-topics-24}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-entities-to-the-recycle-bin}{Moving
Entities to the Recycle Bin}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-folders}{Creating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-folders}{Updating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-folders}{Copying
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}

\chapter{Moving Entities to the Recycle
Bin}\label{moving-entities-to-the-recycle-bin}

Follow these steps to use the Capabilities API to move an entity to the
Recycle Bin. For an explanation of why you should use the Capabilities
API for this, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{Deleting
Entities}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Verify that the repository supports the Recycle Bin. Do this by
  calling the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api\#specifying-repositories}{repository
  object's} \texttt{isCapabilityProvided} method with
  \texttt{TrashCapability.class} as its argument. This example does so
  in \texttt{if} statement's condition:

\begin{verbatim}
if (repository.isCapabilityProvided(TrashCapability.class)) {

    // The code to move the entity to the Recycle Bin
    // You'll write this in the next step
}
\end{verbatim}
\item
  Move the entity to the Recycle Bin if the repository supports it. To
  do this, first get a \texttt{TrashCapability} reference by calling the
  repository object's \texttt{getCapability} method with
  \texttt{TrashCapability.class} as its argument. Then call the
  \texttt{TrashCapability} method that moves the entity to the Recycle
  Bin. For example, this code calls \texttt{moveFileEntryToTrash} to
  move a file to the Recycle Bin:

\begin{verbatim}
if (repository.isCapabilityProvided(TrashCapability.class)) {

    TrashCapability trashCapability = repository.getCapability(TrashCapability.class);
    trashCapability.moveFileEntryToTrash(user.getUserId(), fileEntry);
}
\end{verbatim}

  See the \texttt{TrashCapability}
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/capabilities/TrashCapability.html}{Javadoc}
  for information on the methods you can use to move other types of
  entities to the Recycle Bin.
\end{enumerate}

\section{Related Topics}\label{related-topics-25}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-shortcuts}{Deleting
File Shortcuts}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Updating Entities}\label{updating-entities}

Like
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files-folders-and-shortcuts}{creating}
and
\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-entities}{deleting}
entities, updating entities is a key task when working with Documents
and Media. The methods in the Documents and Media API for creating and
updating entities are similar. There are, however, a few important
differences.

Here, you'll learn about updating these entities:

\begin{itemize}
\tightlist
\item
  \hyperref[files]{Files}
\item
  \hyperref[folders]{Folders}
\item
  \hyperref[file-shortcuts]{File Shortcuts}
\end{itemize}

\chapter{Files}\label{files-2}

Updating a file is a bit more complicated than
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files}{creating
one}. This is due to the way the update operation handles a file's
metadata and content. To update only a file's content, you must also
supply the file's existing metadata. Otherwise, the update operation
could lose the metadata. The opposite, however, isn't true. You can
modify a file's metadata without re-supplying the content. In such an
update, the file's content is automatically copied to the new version of
the file. To make this easier to remember, follow these rules when
updating files:

\begin{itemize}
\tightlist
\item
  Always provide all metadata.
\item
  Only provide the file's content when you want to change it.
\end{itemize}

\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
has three \texttt{updateFileEntry} methods that you can use to update a
file. These methods differ only in the file content's type. Click each
method to see its Javadoc, which contains a full description of its
parameters:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-byte:A-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ byte{[}{]}\ bytes,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-java.io.File-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ File\ file,\ ...)}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileEntry-long-java.lang.String-java.lang.String-java.lang.String-java.lang.String-java.lang.String-boolean-java.io.InputStream-long-com.liferay.portal.kernel.service.ServiceContext-}{\texttt{updateFileEntry(...,\ InputStream\ is,\ long\ size,\ ...)}}
\end{itemize}

Keep these things in mind when using these methods:

\begin{itemize}
\item
  To retain the original file's title and description, you must provide
  those parameters to \texttt{updateFileEntry}. Omitting them deletes
  any existing title and description.
\item
  If you supply \texttt{null} in place of the file's content (e.g.,
  \texttt{bytes}, \texttt{file}, or \texttt{is}), the update
  automatically uses the file's existing content. Do this only if you
  want to update the file's metadata.
\item
  If you use \texttt{false} for the \texttt{majorVersion} parameter, the
  update increments the file version by \texttt{0.1} (e.g., from
  \texttt{1.0} to \texttt{1.1}). If you use \texttt{true} for this
  parameter, the update increments the file version to the next
  \texttt{.0} value (e.g., from \texttt{1.0} to \texttt{2.0},
  \texttt{1.1} to \texttt{2.0}, etc.).
\end{itemize}

For a step-by-step guide on using these \texttt{updateFileEntry}
methods, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}.

\chapter{Folders}\label{folders-2}

You can use the Documents and Media API to
\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-and-moving-entities}{copy
or move} folders to a different location. Options for in-place folder
updates, however, are limited. You can only update a folder's name and
description. You can do this with the \texttt{DLAppService} method
\texttt{updateFolder}:

\begin{verbatim}
updateFolder(long folderId, String name, String description, ServiceContext serviceContext)
\end{verbatim}

All parameters except the description are mandatory. For a full
description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFolder-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-folders}{Updating
Folders}.

\chapter{File Shortcuts}\label{file-shortcuts-2}

You can update a file shortcut (\texttt{FileShortcut} entities) to
change the file it points to or the folder it resides in. Do this via
the \texttt{DLAppService} method \texttt{updateFileShortcut}:

\begin{verbatim}
updateFileShortcut(long fileShortcutId, long folderId, long toFileEntryId, ServiceContext serviceContext)
\end{verbatim}

All of this method's parameters are mandatory. To retain any of the
shortcut's original values, you must provide them to this method. For a
full description of the parameters, see the method's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#updateFileShortcut-long-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-file-shortcuts}{Updating
File Shortcuts}.

\chapter{Updating Files}\label{updating-files}

To update a file with the Documents and Media API, you must use one of
the three \texttt{updateFileEntry} methods discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-entities}{Updating
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Note that the example in these steps uses the \texttt{updateFileEntry}
method that contains \texttt{InputStream}, but you can adapt the example
to the other methods if you wish:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{updateFileEntry} method's
  arguments. Since it's common to update a file with data submitted by
  the end user, you can extract the data from the request. This example
  does so via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upload/UploadPortletRequest.html}{\texttt{UploadPortletRequest}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long repositoryId = ParamUtil.getLong(uploadPortletRequest, "repositoryId");
long folderId = ParamUtil.getLong(uploadPortletRequest, "folderId");
String sourceFileName = uploadPortletRequest.getFileName("file");
String title = ParamUtil.getString(uploadPortletRequest, "title");
String description = ParamUtil.getString(uploadPortletRequest, "description");
String changeLog = ParamUtil.getString(uploadPortletRequest, "changeLog");
boolean majorVersion = ParamUtil.getBoolean(uploadPortletRequest, "majorVersion");

try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    String contentType = uploadPortletRequest.getContentType("file");
    long size = uploadPortletRequest.getSize("file");

    ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileEntry.class.getName(), uploadPortletRequest);
}
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{updateFileEntry} method with the
  data from the previous step. Note that this example does so inside the
  previous step's try-with-resources statement:

\begin{verbatim}
try (InputStream inputStream = uploadPortletRequest.getFileAsStream("file")) {

    ...

    FileEntry fileEntry = _dlAppService.updateFileEntry(
                            fileEntryId, sourceFileName, contentType, title,
                            description, changeLog, majorVersion, inputStream, size,
                            serviceContext);
}
\end{verbatim}

  The method returns a \texttt{FileEntry} object, which this example
  sets to a variable for later use. Note, however, that you don't have
  to do this.
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileEntry} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileEntry} method, as well
as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-26}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-files}{Creating
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-files}{Deleting
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Updating Folders}\label{updating-folders}

To update a folder with the Documents and Media API, you must use the
\texttt{updateFolder} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-entities}{Updating
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to update a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{updateFolder} method's
  arguments. Since it's common to update a folder with data submitted by
  the end user, you can extract the data from the request. This example
  does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");
String name = ParamUtil.getString(actionRequest, "name");
String description = ParamUtil.getString(actionRequest, "description");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{updateFolder} method with the
  data from the previous step:

\begin{verbatim}
_dlAppService.updateFolder(folderId, name, description, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the \texttt{updateFolder}
method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFolderMVCActionCommand.java}{\texttt{EditFolderMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{Folder} actions that the Documents and Media app
supports. Also note that this \texttt{updateFolder} method, as well as
the rest of \texttt{EditFolderMVCActionCommand}, contains additional
logic to suit the specific needs of the Documents and Media app.

\section{Related Topics}\label{related-topics-27}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-folders}{Creating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-folders}{Copying
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Updating File Shortcuts}\label{updating-file-shortcuts}

To update a file shortcut with the Documents and Media API, you must use
the \texttt{updateFileShortcut} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-entities}{Updating
Entities}. The steps here show you how. For general information on using
the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to update a file shortcut:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{updateFileShortcut}
  method's arguments. Since it's common to update a file shortcut with
  data submitted by the end user, you can extract the data from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileShortcutId = ParamUtil.getLong(actionRequest, "fileShortcutId");
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long toFileEntryId = ParamUtil.getLong(actionRequest, "toFileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFileShortcutConstants.getClassName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{updateFileShortcut} method with
  the data from the previous step:

\begin{verbatim}
_dlAppService.updateFileShortcut(
        fileShortcutId, folderId, toFileEntryId, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{updateFileShortcut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileShortcutMVCActionCommand.java}{\texttt{EditFileShortcutMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileShortcut} actions that the Documents and Media app
supports. Also note that this \texttt{updateFileShortcut} method, as
well as the rest of \texttt{EditFileShortcutMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-28}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-file-shortcuts}{Creating
File Shortcuts}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-file-shortcuts}{Deleting
File Shortcuts}

\chapter{File Checkout and Checkin}\label{file-checkout-and-checkin}

Users can
\href{/docs/7-2/user/-/knowledge_base/u/checking-out-and-editing-files}{check
out files} from the Document Library for editing. Only the user who
checked out the file can edit it. This prevents conflicting edits on the
same file from multiple users. The Documents and Media API allows these
checkin/checkout operations:

\begin{itemize}
\tightlist
\item
  \href{file-checkout}{File Checkout}
\item
  \href{file-checkin}{File Checkin}
\item
  \href{canceling-a-checkout}{Canceling a Checkout}
\end{itemize}

\chapter{File Checkout}\label{file-checkout}

Here's what happens when you check out a file:

\begin{itemize}
\item
  A private working copy of the file is created that only you and
  administrators can access. Until you check the file back in or cancel
  your changes, any edits you make are stored in the private working
  copy.
\item
  Other users can't change or edit any version of the file. This state
  remains until you cancel or check in your changes.
\end{itemize}

The main \texttt{DLAppService} method for checking out a file is this
\texttt{checkOutFileEntry} method:

\begin{verbatim}
checkOutFileEntry(long fileEntryId, ServiceContext serviceContext)
\end{verbatim}

If this method throws an exception, then you should assume the checkout
failed and repeat the operation. For a full description of the method
and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#checkOutFileEntry-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-out-files}{Checking
Out Files}.

\section{Fine-tuning Checkout}\label{fine-tuning-checkout}

You can control how the checkout is performed by setting the following
attributes in the \texttt{checkOutFileEntry} method's
\texttt{ServiceContext} parameter:

\begin{itemize}
\item
  \texttt{manualCheckInRequired}: By default, the system automatically
  checks out/in a file when a user edits it. Setting this attribute to
  \texttt{true} prevents this, therefore requiring manual checkout and
  checkin.
\item
  \texttt{existingDLFileVersionId}: The system typically reuses the
  private working copy across different checkout/checkin sequences.
  There's little chance for conflicting edits because only one user at a
  time can access the private working copy. To force the system to
  create a new private working copy each time, omit this attribute or
  set it to \texttt{0}.
\item
  \texttt{fileVersionUuid}: This is used by
  \href{/docs/7-2/user/-/knowledge_base/u/staging}{staging}, but can be
  ignored for normal use. Setting this attribute causes the system to
  create the new private working copy version with the given UUID.
\end{itemize}

To set these attributes, use the \texttt{ServiceContext} method
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html\#setAttribute-java.lang.String-java.io.Serializable-}{\texttt{setAttribute(String\ name,\ Serializable\ value)}}.
Here's an example of setting the \texttt{manualCheckInRequired}
attribute to \texttt{true}:

\begin{verbatim}
serviceContext.setAttribute("manualCheckInRequired", Boolean.TRUE)
\end{verbatim}

\chapter{File Checkin}\label{file-checkin}

After checking out and editing a file, you must check it back in for
other users to see the new version. Once you do so, you can't access the
private working copy. The next time the file is checked out, the private
working copy's contents are overwritten.

The \texttt{DLAppService} method for checking in a file is
\texttt{checkInFileEntry}:

\begin{verbatim}
checkInFileEntry(long fileEntryId, boolean majorVersion, String changeLog, 
                ServiceContext serviceContext)
\end{verbatim}

For a full description of the method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#checkInFileEntry-long-boolean-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
This method uses the private working copy to create a new version of the
file. As
\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files} explains, the \texttt{majorVersion} parameter's setting
determines how the file's version number is incremented.

For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-in-files}{Checking
In Files}.

\chapter{Canceling a Checkout}\label{canceling-a-checkout}

You can also cancel a checkout. Use caution with this operation---it
discards any edits made since checkout. If you're sure you want to
cancel a checkout, do so with the \texttt{DLAppService} method
\texttt{cancelCheckOut}:

\begin{verbatim}
cancelCheckOut(long fileEntryId)
\end{verbatim}

For a full description of this method and its parameter, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#cancelCheckOut-long-}{Javadoc}.
If you invoke this method without error, you can safely assume that it
discarded the private working copy and unlocked the file. Other users
should now be able to check out and edit the file.

For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/canceling-a-checkout}{Canceling
a Checkout}.

\chapter{Checking Out Files}\label{checking-out-files}

To check out a file with the Documents and Media API, use the
\texttt{checkOutFileEntry} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/file-checkout-and-checkin}{File
Checkout and Checkin}. The steps here show you how. For general
information on using the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to check out a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{checkOutFileEntry}
  method's arguments. Since it's common to check out a file in response
  to an action by the end user, you can extract the data from the
  request. This example does so via \texttt{javax.portlet.ActionRequest}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{checkOutFileEntry} method with
  the data from the previous step:

\begin{verbatim}
_dlAppService.checkOutFileEntry(fileEntryId, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{checkOutFileEntries} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{checkOutFileEntries} method, as
well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-29}

\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-in-files}{Checking
In Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/canceling-a-checkout}{Canceling
a Checkout}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}

\chapter{Checking In Files}\label{checking-in-files}

To check in a file with the Documents and Media API, use the
\texttt{checkInFileEntry} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/file-checkout-and-checkin}{File
Checkout and Checkin}. The steps here show you how. For general
information on using the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to use \texttt{checkInFileEntry} to check in a file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{checkInFileEntry} method's
  arguments. Since it's common to check in a file in response to an
  action by the end user, you can extract the data from the request.
  This example does so via \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
boolean majorVersion = ParamUtil.getBoolean(actionRequest, "majorVersion");
String changeLog = ParamUtil.getString(actionRequest, "changeLog");

ServiceContext serviceContext = ServiceContextFactory.getInstance(actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{checkInFileEntry} method with the
  data from the previous step:

\begin{verbatim}
_dlAppService.checkInFileEntry(
        fileEntryId, majorVersion, changeLog, serviceContext);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{checkInFileEntries} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{checkInFileEntries} method, as
well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-30}

\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-out-files}{Checking
Out Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/canceling-a-checkout}{Canceling
a Checkout}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}

\chapter{Canceling a Checkout}\label{canceling-a-checkout-1}

To cancel a checkout with the Documents and Media API, use the
\texttt{cancelCheckOut} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/file-checkout-and-checkin}{File
Checkout and Checkin}. The steps here show you how. For general
information on using the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to cancel a checkout:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the ID of the file whose checkout you want to cancel. Since it's
  common to cancel a checkout in response to a user action, you can
  extract the file ID from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get it any way you wish:

\begin{verbatim}
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");
\end{verbatim}
\item
  Call the service reference's \texttt{cancelCheckOut} method with the
  file's ID:

\begin{verbatim}
_dlAppService.cancelCheckOut(fileEntryId);
\end{verbatim}
\end{enumerate}

You can find the full code for this example in the
\texttt{cancelFileEntriesCheckOut} method of Liferay DXP's
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-web/src/main/java/com/liferay/document/library/web/internal/portlet/action/EditFileEntryMVCActionCommand.java}{\texttt{EditFileEntryMVCActionCommand}}
class. This class uses the Documents and Media API to implement almost
all the \texttt{FileEntry} actions that the Documents and Media app
supports. Also note that this \texttt{cancelFileEntriesCheckOut} method,
as well as the rest of \texttt{EditFileEntryMVCActionCommand}, contains
additional logic to suit the specific needs of the Documents and Media
app.

\section{Related Topics}\label{related-topics-31}

\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-out-files}{Checking
Out Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/checking-in-files}{Checking
In Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-files}{Updating
Files}

\chapter{Copying and Moving Entities}\label{copying-and-moving-entities}

Although the Documents and Media API can copy and move entities, these
operations have some important caveats and limitations. Keep these
things in mind when copying entities:

\begin{itemize}
\tightlist
\item
  There's no way to copy files---you can only copy folders. However,
  copying a folder also copies its contents, which can include files.
\item
  Folders can only be copied within their current repository.
\end{itemize}

The move operation doesn't have these restrictions. It's possible to
move files and folders between different repositories. In general,
however, the move operation is a bit more complicated than the copy
operation. For example, the API's behavior changes depending on whether
you move entities to a different repository or within the same one.

Here, you'll learn about the following:

\begin{itemize}
\tightlist
\item
  \hyperref[copying-folders]{Copying Folders}
\item
  \hyperref[moving-folders-and-files]{Moving Folders and Files}
\end{itemize}

\chapter{Copying Folders}\label{copying-folders}

The Documents and Media API can copy folders within a repository. You
can't, however, copy a folder between different repositories. Note that
copying a folder also copies its contents.

To copy a folder, use the \texttt{DLAppService} method
\texttt{copyFolder}:

\begin{verbatim}
copyFolder(long repositoryId, long sourceFolderId, long parentFolderId, String name, 
        String description, ServiceContext serviceContext)
\end{verbatim}

For a full description of the method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#copyFolder-long-long-long-java.lang.String-java.lang.String-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

For step-by-step instructions on using this method, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-folders}{Copying
Folders}.

\chapter{Moving Folders and Files}\label{moving-folders-and-files}

The move operation is more flexible than the copy operation. Copying
only works with folders, and you can't copy between repositories. The
move operation, however, works with files and folders within or between
repositories.

\noindent\hrulefill

\textbf{Note:} Depending on the repository implementation, you may get
unexpected behavior when moving folders between repositories. Moving a
folder also moves its contents via separate move operations for each
item in the folder. In some repository implementations, if any move
sub-operation fails, the parent move operation also fails. In other
repository implementations, the results of successful sub-operations
remain even if others fail, which leaves a partially complete move of
the whole folder.

\noindent\hrulefill

To move a folder, use the \texttt{DLAppService} method
\texttt{moveFolder}:

\begin{verbatim}
moveFolder(long folderId, long parentFolderId, ServiceContext serviceContext)
\end{verbatim}

For a full description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#moveFolder-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.
This method is similar to \texttt{copyFolder}, but it can't change the
folder's name or description, and it can move folders between
repositories. Folder contents are moved with the folder.

The operation for moving a file is almost identical to moving a folder.
To move a file, use the \texttt{DLAppService} method
\texttt{moveFileEntry}:

\begin{verbatim}
moveFileEntry(long fileEntryId, long newFolderId, ServiceContext serviceContext)
\end{verbatim}

For a full description of this method and its parameters, see its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#moveFileEntry-long-long-com.liferay.portal.kernel.service.ServiceContext-}{Javadoc}.

For step-by-step instructions on using \texttt{moveFolder} and
\texttt{moveFileEntry}, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}.

\chapter{Copying Folders}\label{copying-folders-1}

To copy a folder with the Documents and Media API, use the
\texttt{copyFolder} method discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-and-moving-entities}{Copying
and Moving Entities}. The steps here show you how. For general
information on using the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to use \texttt{copyFolder} to copy a folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the \texttt{copyFolder} method's
  arguments. How you do this depends on your use case. The copy
  operation in this example takes place in the default Site repository
  and retains the folder's existing name and description. It therefore
  needs the folder's group ID (to specify the default site repository),
  name, and description. Also note that because the destination folder
  in this example is the repository's root folder, the parent folder ID
  isn't needed---Liferay DXP supplies a constant for specifying a
  repository's root folder.

  In the following code,
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  gets the folder's ID from the request
  (\texttt{javax.portlet.ActionRequest}), and the service reference's
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFolder-long-}{\texttt{getFolder}}
  method gets the corresponding folder object. The folder's
  \texttt{getGroupId()}, \texttt{getName()}, and
  \texttt{getDescription()} methods then get the folder's group ID,
  name, and description, respectively:

\begin{verbatim}
long folderId = ParamUtil.getLong(actionRequest, "folderId");

Folder folder = _dlAppService.getFolder(folderId);
long groupId = folder.getGroupId();
String folderName = folder.getName();
String folderDescription = folder.getDescription();

ServiceContext serviceContext = ServiceContextFactory.getInstance(
            DLFolder.class.getName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's \texttt{copyFolder} method with the data
  from the previous step. Note that this example uses the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
  constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
  repository's root folder as the destination folder:

\begin{verbatim}
_dlAppService.copyFolder(
        groupId, folderId, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
        folderName, folderDescription, serviceContext);
\end{verbatim}
\end{enumerate}

Note that you can change any of these values to suit your copy
operation. For example, if your copy takes place in a repository other
than the default Site repository, you would specify that repository's ID
in place of the group ID. You could also specify a different destination
folder, and/or change the new folder's name and/or description.

\section{Related Topics}\label{related-topics-32}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-folders}{Creating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/updating-folders}{Updating
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/deleting-folders}{Deleting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/moving-folders-and-files}{Moving
Folders and Files}

\chapter{Moving Folders and Files}\label{moving-folders-and-files-1}

To move folders and files with the Documents and Media API, use the
\texttt{moveFolder} and \texttt{moveFileEntry} methods discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-and-moving-entities}{Copying
and Moving Entities}. The steps here show you how. For general
information on using the API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to use \texttt{moveFolder} and \texttt{moveFileEntry}
to move a folder and a file, respectively. This example does both to
demonstrate the procedures:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
    @Reference
    private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the method arguments. Since moving
  folders and files is typically done in response to a user action, you
  can get the data from the request. This example does so via
  \texttt{javax.portlet.ActionRequest} and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}},
  but you can get the data any way you wish:

\begin{verbatim}
// Get the folder IDs
long folderId = ParamUtil.getLong(actionRequest, "folderId");
long newFolderId = ParamUtil.getLong(actionRequest, "newFolderId");

// Get the file ID
long fileEntryId = ParamUtil.getLong(actionRequest, "fileEntryId");

ServiceContext serviceContext = ServiceContextFactory.getInstance(
        DLFileEntry.class.getName(), actionRequest);
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Call the service reference's method(s). This example calls
  \texttt{moveFolder} to move a folder (\texttt{folderId}) to a
  different folder (\texttt{newFolderId}). It then calls
  \texttt{moveFileEntry} to move a file (\texttt{fileEntryId}) to the
  same destination folder:

\begin{verbatim}
_dlAppService.moveFolder(folderId, newFolderId, serviceContext);

_dlAppService.moveFileEntry(fileEntryId, newFolderId, serviceContext);
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-33}

\href{/docs/7-2/frameworks/-/knowledge_base/f/copying-folders}{Copying
Folders}

\chapter{Getting Entities}\label{getting-entities}

The Documents and Media API contains many methods for getting entities
from a repository. Most methods in \texttt{DLAppService} get single
entities (e.g., a file or folder), a collection of entities that match
certain characteristics, or the number of such entities. Because there
are so many similar methods for getting entities, they aren't all
described here. You can find full descriptions for all
\texttt{DLAppService} methods in its
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{reference
documentation}.

Here, you'll learn about getting these entities:

\begin{itemize}
\tightlist
\item
  \hyperref[files]{Files}
\item
  \hyperref[folders]{Folders}
\item
  \hyperref[multiple-entity-types]{Multiple Entity Types}
\end{itemize}

\chapter{Files}\label{files-3}

Getting files is one of the most common tasks you'll perform with the
Documents and Media API. There are two main method families for getting
files:

\texttt{getFileEntries}: Gets files from a specific repository.

\texttt{getGroupFileEntries}: Gets files from a Site (group), regardless
of repository.

Since these method families are common, their methods share many
parameters:

\texttt{repositoryId}: The ID of the repository to get files from. To
specify the default Site repository, use the \texttt{groupId} (Site ID).

\texttt{folderId}: The ID of the folder to get files from. Note that
these methods don't traverse the folder structure---they only get files
directly from the specified folder. To specify the repository's root
folder, use the constant
\texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}.

\texttt{start} and \texttt{end}: Integers that specify the lower and
upper bounds, respectively, of collection items to include in a page of
results. If you don't want to use pagination, use
\texttt{QueryUtil.ALL\_POS} for these parameters.

\texttt{obc}: The comparator to use to order collection items.
Comparators are
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/OrderByComparator.html}{\texttt{OrderByComparator}}
implementations that sort collection items.

\texttt{fileEntryTypeId}: The ID of the file type to retrieve. Use this
to retrieve files of a specific type.

\texttt{mimeTypes}: The MIME types of the files to retrieve. Use this to
retrieve files of the specified MIME types. You can specify MIME types
via the constants in
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html}{\texttt{ContentTypes}}.

Note that the \texttt{obc} parameter must be an implementation of
\texttt{OrderByComparator}. Although you can implement your own
comparators, Liferay DXP already contains a few useful implementations
in the package
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/package-summary.html}{\texttt{com.liferay.document.library.kernel.util.comparator}}:

\texttt{RepositoryModelCreateDateComparator}: Sorts by creation date.

\texttt{RepositoryModelModifiedDateComparator}: Sorts by modification
date.

\texttt{RepositoryModelReadCountComparator}: Sorts by number of views.

\texttt{RepositoryModelSizeComparator}: Sorts by file size.

\texttt{RepositoryModelTitleComparator}: Sorts by title.

See \href{/docs/7-2/frameworks/-/knowledge_base/f/getting-files}{Getting
Files} for step-by-step instructions on using the above method families.

\chapter{Folders}\label{folders-3}

The Documents and Media API can get folders in a similar way to getting
files. The main difference is that folder retrieval methods may have an
additional argument to tell the system whether to include \emph{mount
folders}. Mount folders are mount points for external repositories
(e.g.~Alfresco or SharePoint) that appear as regular folders in a Site's
default repository. They let users navigate seamlessly between
repositories. To account for this, some folder retrieval methods include
the boolean parameter \texttt{includeMountFolders}. Setting this
parameter to \texttt{true} includes mount folders in the results, while
omitting it or setting it to \texttt{false} excludes them.

For example, to get a list of a parent folder's subfolders from a
repository, including any mount folders, use this
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFolders-long-long-boolean-}{\texttt{getFolders}}
method:

\begin{verbatim}
getFolders(long repositoryId, long parentFolderId, boolean includeMountFolders)
\end{verbatim}

Note that there are several other \texttt{getFolders} methods in
\texttt{DLAppService}. Use the one that best matches your use case. See
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-folders}{Getting
Folders} for step-by-step instructions on using these
\texttt{getFolders} methods.

\chapter{Multiple Entity Types}\label{multiple-entity-types}

There are also methods in the Documents and Media API that retrieve
lists containing several entity types. These methods use many of the
same parameters as those already described for retrieving files and
folders. For example, the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFileEntriesAndFileShortcuts-long-long-int-int-int-}{\texttt{getFileEntriesAndFileShortcuts}}
method gets files and shortcuts from a given repository and folder. Its
\texttt{status} parameter specifies a
\href{/docs/7-2/user/-/knowledge_base/u/workflow}{workflow} status. As
before, the \texttt{start} and \texttt{end} parameters control
pagination of the entities:

\begin{verbatim}
getFileEntriesAndFileShortcuts(long repositoryId, long folderId, int status, int start, int end)
\end{verbatim}

For step-by-step instructions on calling this method and others like it,
see
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-multiple-entity-types}{Getting
Multiple Entity Types}. To see all such methods, see the
\texttt{DLAppService}
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{Javadoc}.

\chapter{Getting Files}\label{getting-files}

To get files with the Documents and Media API, use a method from the
\texttt{getFileEntries} or \texttt{getGroupFileEntries} method families
discussed in
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-entities}{Getting
Entities}. The steps here show you how, using this
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFileEntries-long-long-java.lang.String:A-int-int-com.liferay.portal.kernel.util.OrderByComparator-}{\texttt{getFileEntries}}
method as an example:

\begin{verbatim}
List<FileEntry> getFileEntries(
        long repositoryId, 
        long folderId, 
        String[] mimeTypes, 
        int start, 
        int end, 
        OrderByComparator<FileEntry> obc
)
\end{verbatim}

For general information on using the Documents and Media API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to get a list of files. This example uses the above
\texttt{getFileEntries} method to get all the PNG images from the root
folder of a Site's default repository, sorted by title:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the method's arguments. You can do
  this any way you wish. As the next step describes, Liferay DXP
  provides constants and a comparator for all the arguments this example
  needs besides the group ID. This example gets the group ID by using
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  with the request (\texttt{javax.portlet.ActionRequest}):

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  It's also possible to get the group ID via the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}.
  Calling the \texttt{ThemeDisplay} method \texttt{getScopeGroupId()}
  gets the ID of your app's current site (group):

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(WebKeys.THEME_DISPLAY);
long groupId = themeDisplay.getScopeGroupId();
\end{verbatim}
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Use the data from the previous step to call the service reference
  method you want to use to get the files. This example calls the above
  \texttt{getFileEntries} method with the group ID from the previous
  step, and constants and a comparator for the remaining arguments:

\begin{verbatim}
List<FileEntry> fileEntries = 
        _dlAppService.getFileEntries(
                groupId, 
                DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
                new String[] {ContentTypes.IMAGE_PNG}, 
                QueryUtil.ALL_POS, 
                QueryUtil.ALL_POS, 
                new RepositoryModelTitleComparator<>()
        );
\end{verbatim}

  Here's a description of the arguments used in this example:

  \texttt{groupId}: Using the group ID as the repository ID specifies
  that the operation takes place in the default site repository.

  \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}: Uses the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
  constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
  repository's root folder.

  \texttt{new\ String{[}{]}\ \{ContentTypes.IMAGE\_PNG\}}: Uses the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ContentTypes.html}{\texttt{ContentTypes}}
  constant \texttt{IMAGE\_PNG} to specify PNG images.

  \texttt{QueryUtil.ALL\_POS}: Uses the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/QueryUtil.html}{\texttt{QueryUtil}}
  constant \texttt{ALL\_POS} for the start and end positions in the
  results. This specifies all results, bypassing pagination.

  \texttt{new\ RepositoryModelTitleComparator\textless{}\textgreater{}()}:
  Creates a new
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/util/comparator/RepositoryModelTitleComparator.html}{\texttt{RepositoryModelTitleComparator}},
  which sorts the results by title.
\end{enumerate}

Remember, this is just one of many \texttt{getFileEntries} and
\texttt{getGroupFileEntries} methods. To see all such methods, see the
\texttt{DLAppService}
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{Javadoc}.

\section{Related Topics}\label{related-topics-34}

\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-folders}{Getting
Folders}

\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-multiple-entity-types}{Getting
Multiple Entity Types}

\chapter{Getting Folders}\label{getting-folders}

To get folders with the Documents and Media API, use one of the
\texttt{getFolders} methods in \texttt{DLAppService}. This is discussed
in more detail in
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-entities}{Getting
Entities}. The steps here show you how to call these \texttt{getFolders}
methods. As an example, this method is used to get a parent folder's
subfolders:

\begin{verbatim}
getFolders(long repositoryId, long parentFolderId, boolean includeMountFolders)
\end{verbatim}

For general information on using the Documents and Media API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Follow these steps to call a \texttt{getFolders} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the method's arguments any way you
  wish. This \texttt{getFolders} method needs a repository ID, a parent
  folder ID, and a boolean value that indicates whether to include mount
  folders in the results. To specify the default site repository, you
  can use the group ID as the repository ID. This example gets the group
  ID from the request (\texttt{javax.portlet.ActionRequest}) via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  It's also possible to get the group ID via the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/theme/ThemeDisplay.html}{\texttt{ThemeDisplay}}.
  Calling the \texttt{ThemeDisplay} method \texttt{getScopeGroupId()}
  gets the ID of your app's current Site (group).

\begin{verbatim}
ThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(WebKeys.THEME_DISPLAY);
long groupId = themeDisplay.getScopeGroupId();
\end{verbatim}

  Note that getting the parent folder ID isn't necessary because this
  example uses the root folder, for which Liferay DXP provides a
  constant. Also, the boolean value can be provided directly---it
  doesn't need to be retrieved from somewhere.
\item
  Call the service reference's \texttt{getFolders} method with the data
  from the previous step and any other values you want to provide. Note
  that this example uses
  \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID} to specify the
  repository's root folder as the parent folder. It also uses
  \texttt{true} to include any mount folders in the results:

\begin{verbatim}
_dlAppService.getFolders(groupId, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, true)
\end{verbatim}
\end{enumerate}

This is one of many methods you can use to get folders. The rest are
listed in the \texttt{DLAppService}
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{Javadoc}.

\section{Related Topics}\label{related-topics-35}

\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-files}{Getting
Files}

\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-multiple-entity-types}{Getting
Multiple Entity Types}

\chapter{Getting Multiple Entity
Types}\label{getting-multiple-entity-types}

There are several methods in
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html}{\texttt{DLAppService}}
that get lists containing multiple entity types. This is discussed in
more detail in
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-entities}{Getting
Entities}. The steps here show you how to use the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/service/DLAppService.html\#getFileEntriesAndFileShortcuts-long-long-int-int-int-}{\texttt{getFileEntriesAndFileShortcuts}}
method, but you can apply them to other such methods as well. For
general information on using the Documents and Media API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/documents-and-media-api}{Documents
and Media API}.

Note that the example in these steps gets all the files and shortcuts in
the default Site repository's root folder:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to \texttt{DLAppService}:

\begin{verbatim}
@Reference
private DLAppService _dlAppService;
\end{verbatim}
\item
  Get the data needed to populate the method's arguments any way you
  wish. To specify the default Site repository, you can use the group ID
  as the repository ID. This example gets the group ID from the request
  (\texttt{javax.portlet.ActionRequest}) via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}:

\begin{verbatim}
long groupId = ParamUtil.getLong(actionRequest, "groupId");
\end{verbatim}

  Getting the parent folder ID, workflow status, and start and end
  parameters isn't necessary because Liferay DXP provides constants for
  them. The next step shows this in detail.
\item
  Call the service reference method with the data from the previous step
  and any other values you want to provide. This example calls
  \texttt{getFileEntriesAndFileShortcuts} with the group ID from the
  previous step and constants for the remaining arguments:

\begin{verbatim}
_dlAppService.getFileEntriesAndFileShortcuts(
        groupId, 
        DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, 
        WorkflowConstants.STATUS_APPROVED, 
        QueryUtil.ALL_POS, 
        QueryUtil.ALL_POS
)
\end{verbatim}

  Here's a description of the arguments used in this example:

  \begin{itemize}
  \tightlist
  \item
    \texttt{groupId}: Using the group ID as the repository ID specifies
    that the operation takes place in the default site repository.
  \item
    \texttt{DLFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/document/library/kernel/model/DLFolderConstants.html}{\texttt{DLFolderConstants}}
    constant \texttt{DEFAULT\_PARENT\_FOLDER\_ID} to specify the
    repository's root folder.
  \item
    \texttt{WorkflowConstants.STATUS\_APPROVED}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/workflow/WorkflowConstants.html}{\texttt{WorkflowConstants}}
    constant \texttt{STATUS\_APPROVED} to specify only files/folders
    that have been approved via workflow.
  \item
    \texttt{QueryUtil.ALL\_POS}: Uses the
    \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/orm/QueryUtil.html}{\texttt{QueryUtil}}
    constant \texttt{ALL\_POS} for the start and end positions in the
    results. This specifies all results, bypassing pagination.
  \end{itemize}
\end{enumerate}

\section{Related Topics}\label{related-topics-36}

\href{/docs/7-1/frameworks/-/knowledge_base/frameworks/getting-files}{Getting
Files}

\href{/docs/7-1/frameworks/-/knowledge_base/frameworks/getting-folders}{Getting
Folders}

\chapter{Adaptive Media}\label{adaptive-media-1}

The
\href{/docs/7-2/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adaptive
Media} app tailors the size and quality of images to the device
displaying them. Here, you'll learn about these things:

\begin{itemize}
\tightlist
\item
  \hyperref[the-adaptive-media-taglib]{The Adaptive Media Taglib}
\item
  \hyperref[adaptive-medias-finder-api]{Adaptive Media's Finder API}
\item
  \hyperref[image-scaling-in-adaptive-media]{Image Scaling in Adaptive
  Media}
\end{itemize}

\chapter{The Adaptive Media Taglib}\label{the-adaptive-media-taglib}

To display adapted images in your apps, Adaptive Media offers a
convenient tag library in the module
\href{https://github.com/liferay/com-liferay-adaptive-media/tree/master/adaptive-media-image-taglib}{\texttt{com.liferay.adaptive.media.image.taglib}}.
The only mandatory attribute for the taglib is \texttt{fileVersion}. It
indicates the file version of the adapted image to display. The taglib
uses this file version to query Adaptive Media's finder API and display
the adapted image appropriate for the device making the request. You can
also add as many attributes as needed, such as \texttt{class},
\texttt{style}, \texttt{data-sample}, and so on. Any attributes you add
are then added to the adapted images in the markup the taglib renders.

For step-by-step instructions on using this taglib, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}.

\chapter{Adaptive Media's Finder API}\label{adaptive-medias-finder-api}

If you need more control than the taglib offers for finding adapted
images, you can query Adaptive Media's finder API directly. For example,
if you have an app that needs a specific image in a specific dimension,
it's best to query Adaptive Media's finder API directly. You can then
display the image however you like (e.g., with an HTML
\texttt{\textless{}img\textgreater{}} tag).

Adaptive Media's finder API lets you write queries that get adapted
images based on certain search criteria and filters. For example, you
can get adapted images that match a file version or resolution, or are
ordered by an attribute like image width. You can even get adapted
images that match approximate attribute values.

\section{Calling the API}\label{calling-the-api}

The entry point to Adaptive Media's API is
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/finder/AMImageFinder.html}{\texttt{AMImageFinder}}.
To use it, you must first inject the OSGi component in your class (which
must also be an OSGi component) as follows:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}

This makes an \texttt{AMImageFinder} instance available. It has one
method, \texttt{getAdaptiveMediaStream}, that returns a stream of
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/AdaptiveMedia.html}{\texttt{AdaptiveMedia}}
objects. This method takes a \texttt{Function} that creates an
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/finder/AMQuery.html}{\texttt{AMQuery}}
(the query for adapted images) via
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.html}{\texttt{AMImageQueryBuilder}},
which can search adapted images based on different attributes (e.g.,
width, height, order, etc.). The \texttt{AMImageQueryBuilder} methods
you call depend on the exact query you want to construct.

For example, here's a general \texttt{getAdaptiveMediaStream} call:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.methodToCall(arg).done());
\end{verbatim}

The argument to \texttt{getAdaptiveMediaStream} is a lambda expression
that returns an \texttt{AMQuery} constructed via
\texttt{AMImageQueryBuilder}. Note that \texttt{methodToCall(arg)} is a
placeholder for the \texttt{AMImageQueryBuilder} method you want to call
and its argument. The exact call depends on the criteria you want to use
to select adapted images. The \texttt{done()} call that follows this,
however, isn't a placeholder--it creates and returns the
\texttt{AMQuery} regardless of which \texttt{AMImageQueryBuilder}
methods you call.

For more information on creating \texttt{AMQuery} instances, see the
\texttt{AMImageQueryBuilder}
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.html}{Javadoc}.

For step-by-step instructions on calling Adaptive Media's API, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/finding-adapted-images}{Finding
Adapted Images}.

\section{Adaptive Media API
Constants}\label{adaptive-media-api-constants}

When calling the Adaptive Media API, there are some constants you can
use for specifying common attributes:

\begin{itemize}
\tightlist
\item
  \texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_WIDTH}: image width
\item
  \texttt{AMImageAttribute.AM\_IMAGE\_ATTRIBUTE\_HEIGHT}: image height
\item
  \texttt{AMImageQueryBuilder.SortOrder.ASC}: ascending sort
\item
  \texttt{AMImageQueryBuilder.SortOrder.DESC}: descending sort
\end{itemize}

\section{Approximate Attributes}\label{approximate-attributes}

Adaptive Media also lets you get adapted images that match approximate
attribute values. For example, you can ask for adapted images whose
height is around 200px, or whose size is around 100kb. The API returns a
stream with elements ordered by how close they are to the specified
attribute. For example, imagine that there are four image resolutions
that have adapted images with the heights 150px, 350px, 600px, and
900px. Searching for adapted images whose height is approximately 400px
returns this order in the stream: 350px, 600px, 150px, 900px.

So how close, exactly, is \emph{close}? It depends on the attribute. In
the case of width, height, and length, a numeric comparison orders the
images. In the case of content type, file name, or UUID, the comparison
is more tricky because these attributes are strings and thus delegated
to Java's
\href{https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\#compareTo-java.lang.String-}{\texttt{String.compareTo}}
method.

\chapter{Image Scaling in Adaptive
Media}\label{image-scaling-in-adaptive-media}

As described in
\href{/docs/7-2/user/-/knowledge_base/u/adapting-your-media-across-multiple-devices}{Adaptive
Media's user guide}, Adaptive Media scales images to match the image
resolutions defined by the Liferay DXP administrator. The default
scaling is usually suitable, but Adaptive Media contains an extension
point that lets you replace the way it scales images. The
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/scaler/AMImageScaler.html}{\texttt{AMImageScaler}}
interface defines Adaptive Media's image scaling logic. Out of the box,
Adaptive Media provides two implementations of this interface:

\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMDefaultImageScaler.java}{\texttt{AMDefaultImageScaler}}:
The default image scaler. It's always enabled and uses \texttt{java.awt}
for its image processing and scaling.

\href{https://github.com/liferay/com-liferay-adaptive-media/blob/master/adaptive-media-image-impl/src/main/java/com/liferay/adaptive/media/image/internal/scaler/AMGIFImageScaler.java}{\texttt{AMGIFImageScaler}}:
A scaler that works only with GIF images. It depends on the installation
of the external tool \href{https://www.lcdf.org/gifsicle/}{gifsicle} in
the Liferay DXP instance. This scaler is disabled by default.
Administrators can enable it in \emph{Control Panel} → \emph{System
Settings}.

You must register image scalers in Liferay DXP's OSGi container using
the \texttt{AMImageScaler} interface. Each scaler must also set the
\texttt{mime.type} property to the MIME type it handles. For example, if
you set a scaler's MIME type to \texttt{image/jpeg}, then that scaler
can only handle \texttt{image/jpeg} images. If you specify the special
MIME type \texttt{*}, the scaler can process any image. Note that
\texttt{AMDefaultImageScaler} is registered using \texttt{mime.type=*},
while \texttt{AMGIFImageScaler} is registered using
\texttt{mime.type=image/gif}. Both scalers, like all scalers, implement
\texttt{AMImageScaler}.

You can add as many image scalers as you need, even for the same MIME
type. However, Adaptive Media uses only one scaler per image, using this
process to determine the best one:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select only the image scalers registered with the same MIME type as
  the image.
\item
  Select the enabled scalers from those selected in the first step (the
  \texttt{AMImageScaler} method \texttt{isEnabled()} returns
  \texttt{true} for enabled scalers).
\item
  Of the scalers selected in the second step, select the one with the
  highest \texttt{service.ranking}.
\end{enumerate}

If these steps return no results, they're repeated with the special MIME
type \texttt{*}. Also note that if an image scaler is registered for
specific MIME types and has a higher \texttt{service.ranking}, it's more
likely to be chosen than if it's registered for the special MIME type
\texttt{*} or has a lower \texttt{service.ranking}.

For step-by-step instructions on creating your own image scaler, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-image-scaler}{Creating
an Image Scaler}.

\chapter{Displaying Adapted Images in Your
App}\label{displaying-adapted-images-in-your-app}

Follow these steps to display adapted images in your app with the
Adaptive Media
\href{https://github.com/liferay/com-liferay-adaptive-media/tree/master/adaptive-media-image-taglib}{taglib}.
For more information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media\#the-adaptive-media-taglib}{The
Adaptive Media Taglib}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Include the taglib dependency in your project. For example, if you're
  using Gradle you must add the following line in your project's
  \texttt{build.gradle} file:

\begin{verbatim}
provided group: "com.liferay", name: "com.liferay.adaptive.media.image.taglib", version: "1.0.0"
\end{verbatim}
\item
  Declare the taglib in your JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/adaptive-media-image" prefix="liferay-adaptive-media" %>
\end{verbatim}
\item
  Use the taglib wherever you want the adapted image to appear in your
  app's JSP files:

\begin{verbatim}
<liferay-adaptive-media:img class="img-fluid" fileVersion="<%= fileEntry.getFileVersion() %>" />
\end{verbatim}

  For example, this \texttt{view.jsp} uses the taglib to display the
  adapted images in a grid with the \texttt{col-md-6}
  \href{/docs/7-2/frameworks/-/knowledge_base/f/layout-templates-intro}{column
  container class}:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<div class="container">

<%
String[] mimeTypes = {"image/bmp", "image/gif", "image/jpeg", "image/pjpeg", "image/png", "image/tiff", "image/x-citrix-jpeg", "image/x-citrix-png", "image/x-ms-bmp", "image/x-png", "image/x-tiff"};

List<FileEntry> fileEntries = DLAppServiceUtil.getFileEntries(scopeGroupId, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID, mimeTypes);

int columns = 0;

for (FileEntry fileEntry : fileEntries) {
        boolean row = ((columns % 2) == 0);
%>

        <c:if test="<%= row %>">
                <c:if test="<%= columns != 0 %>">
                        </div>
                </c:if>

                <div class="row">
        </c:if>

        <div class="col-md-6">
                <liferay-adaptive-media:img class="img-fluid" fileVersion="<%= fileEntry.getFileVersion() %>" />
        </div>

        <%
        columns++;
}
%>

</div>
\end{verbatim}
\end{enumerate}

Looking at the generated markup, you can see that it uses the
\texttt{\textless{}picture\textgreater{}} tag as described in
\href{/docs/7-2/user/-/knowledge_base/u/creating-content-with-adapted-images}{Creating
Content with Adapted Images}.

\begin{figure}
\centering
\includegraphics{./images/adaptive-media-sample.png}
\caption{The Adaptive Media Samples app shows all the site's adapted
images.}
\end{figure}

\section{Related Topics}\label{related-topics-37}

\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media}{Adaptive
Media}

\href{/docs/7-2/frameworks/-/knowledge_base/f/finding-adapted-images}{Finding
Adapted Images}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-image-scaler}{Creating
an Image Scaler}

\chapter{Finding Adapted Images}\label{finding-adapted-images}

If you need more control than the
\href{/docs/7-2/frameworks/-/knowledge_base/f/displaying-adapted-images-in-your-app}{Adaptive
Media taglib} offers for finding adapted images to display in your app,
you can query Adaptive Media's finder API directly. The steps here show
you how for these scenarios:

\begin{itemize}
\tightlist
\item
  \hyperref[getting-adapted-images-for-file-versions]{Getting Adapted
  Images for File Versions}
\item
  \hyperref[getting-the-adapted-images-for-a-specific-image-resolution]{Getting
  the Adapted Images for a Specific Image Resolution}
\item
  \hyperref[getting-adapted-images-in-a-specific-order]{Getting Adapted
  Images in a Specific Order}
\item
  \hyperref[using-approximate-attributes]{Using Approximate Attributes}
\item
  \hyperref[using-the-adaptive-media-stream]{Using the Adaptive Media
  Stream}
\end{itemize}

For background information on these topics, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media\#adaptive-medias-finder-api}{Adaptive
Media's Finder API}.

\section{Getting Adapted Images for File
Versions}\label{getting-adapted-images-for-file-versions}

Follow these steps to get adapted images for file versions. Note that
the method calls here only return adapted images for
\href{/docs/7-2/user/-/knowledge_base/u/managing-image-resolutions}{enabled
image resolutions}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an \texttt{AMImageFinder} reference:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}
\item
  To get adapted images for a specific file version, call the
  \href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.html}{\texttt{AMImageQueryBuilder}}
  method \texttt{forFileVersion} with a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileVersion.html}{\texttt{FileVersion}}
  object as an argument:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion).done());
\end{verbatim}
\item
  To get the adapted images for the latest approved file version, use
  the \texttt{forFileEntry} method with a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/repository/model/FileEntry.html}{\texttt{FileEntry}}
  object:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileEntry(fileEntry).done());
\end{verbatim}
\end{enumerate}

To get adapted images regardless of status (enabled/disabled image
resolutions), invoke the \texttt{withConfigurationStatus} method with
the constant \texttt{AMImageQueryBuilder.ConfigurationStatus.ANY}:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY).done());
\end{verbatim}

Use the constant
\texttt{AMImageQueryBuilder.ConfigurationStatus.DISABLED} to get adapted
images for only disabled image resolutions.

\section{Getting the Adapted Images for a Specific Image
Resolution}\label{getting-the-adapted-images-for-a-specific-image-resolution}

By providing an image resolution's UUID to \texttt{AMImageFinder}, you
can get that resolution's adapted images. This UUID is defined when
\href{/docs/7-2/user/-/knowledge_base/u/adding-image-resolutions}{adding
the resolution} in the Adaptive Media app. To get a resolution's adapted
images, you must pass that resolution's UUID to the
\texttt{forConfiguration} method.

Follow these steps to get adapted images for an image resolution:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an \texttt{AMImageFinder} reference:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}
\item
  Call the
  \href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/image/finder/AMImageQueryBuilder.ConfigurationStep.html}{\texttt{AMImageQueryBuilder.ConfigurationStep}}
  method \texttt{forConfiguration} with the image resolution's UUID. For
  example, this code gets the adapted images that match a file version,
  and belong to an image resolution with the UUID
  \texttt{hd-resolution}. It returns the adapted images regardless of
  whether the resolution is enabled or disabled:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(fileVersion)
            .forConfiguration("hd-resolution").done());
\end{verbatim}
\end{enumerate}

\section{Getting Adapted Images in a Specific
Order}\label{getting-adapted-images-in-a-specific-order}

It's also possible to define the order in which
\texttt{getAdaptiveMediaStream} returns adapted images. Follow these
steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an \texttt{AMImageFinder} reference:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}
\item
  Call the \texttt{orderBy} method with your sort criteria just before
  calling the \texttt{done()} method. The \texttt{orderBy} method takes
  two arguments: the first specifies the image attribute to sort by
  (e.g., width/height), while the second specifies the sort order (e.g.,
  ascending/descending). The Adaptive Media API provides
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media\#adaptive-media-api-constants}{constants}
  that you can use for these arguments.

  For example, this code gets all the adapted images regardless of
  whether the image resolution is enabled, and puts them in ascending
  order by image width:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .withConfigurationStatus(AMImageQueryBuilder.ConfigurationStatus.ANY)
            .orderBy(AMImageAttribute.AM_IMAGE_ATTRIBUTE_WIDTH, AMImageQueryBuilder.SortOrder.ASC)
            .done());
\end{verbatim}
\end{enumerate}

\section{Using Approximate
Attributes}\label{using-approximate-attributes}

You can use the API to get adapted images that match approximate
attribute values. Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an \texttt{AMImageFinder} reference:

\begin{verbatim}
@Reference
private AMImageFinder _amImageFinder;
\end{verbatim}
\item
  Call the \texttt{with} method with your search criteria just before
  calling the \texttt{done()} method. The \texttt{with} method takes two
  arguments: the image attribute and that attribute's approximate value.
  For example, this code gets adapted images whose height is
  approximately 400px:

\begin{verbatim}
Stream<AdaptiveMedia<AMImageProcessor>> adaptiveMediaStream =
    _amImageFinder.getAdaptiveMediaStream(
        amImageQueryBuilder -> amImageQueryBuilder.forFileVersion(_fileVersion)
            .with(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT, 400).done());
\end{verbatim}
\end{enumerate}

\section{Using the Adaptive Media
Stream}\label{using-the-adaptive-media-stream}

The Adaptive Media stream flows like a babbling brook through the sands
of time. Just kidding; it's not like that at all. Once you have the
\href{https://docs.liferay.com/dxp/apps/adaptive-media/latest/javadocs/com/liferay/adaptive/media/AdaptiveMedia.html}{\texttt{AdaptiveMedia}}
stream, you can get the information you need from it. For example, this
code prints the URI for each adapted image:

\begin{verbatim}
adaptiveMediaStream.forEach(
    adaptiveMedia -> {
        System.out.println(adaptiveMedia.getURI());
    }
);
\end{verbatim}

You can also get other values and attributes from the
\texttt{AdaptiveMedia} stream. Here are a few examples:

\begin{verbatim}
// Get the InputStream 
adaptiveMedia.getInputStream()

// Get the content length
adaptiveMedia.getValueOptional(AMAttribute.getContentLengthAMAttribute())

// Get the image height
adaptiveMedia.getValueOptional(AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT)
\end{verbatim}

\section{Related Topics}\label{related-topics-38}

\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media}{Adaptive
Media}

\href{/docs/7-2/frameworks/-/knowledge_base/f/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-image-scaler}{Creating
an Image Scaler}

\chapter{Creating an Image Scaler}\label{creating-an-image-scaler}

Adaptive Media scales images to match the image resolutions defined by
the Liferay DXP administrator. The default scaling is usually suitable,
but you can customize it by creating an image scaler. The steps here
show you how. For detailed information on these steps, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media\#image-scaling-in-adaptive-media}{Image
Scaling in Adaptive Media}.

Follow these steps to create a custom image scaler. The example scaler
in these steps customizes the scaling of PNG images:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create your scaler class to implement \texttt{AMImageScaler}. You must
  also annotate your scaler class with \texttt{@Component}, setting
  \texttt{mime.type} properties for each of the scaler's MIME types, and
  registering an \texttt{AMImageScaler} service. If there's more than
  one scaler for the same MIME type, you must also set the
  \texttt{@Component} annotation's \texttt{service.ranking} property.
  For your scaler to take precedence over other scalers of the same MIME
  type, its service ranking property must be higher than that of the
  other scalers. If \texttt{service.ranking} isn't set, it defaults to
  \texttt{0}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `service.ranking` property isn't set for the image scalers 
 included with Adaptive Media (`AMDefaultImageScaler` and 
 `AMGIFImageScaler`). Their service ranking therefore defaults to `0`. To 
 replace either scaler, you must set your scaler to the same MIME type and 
 give it a service ranking higher than `0`. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
This example image scaler scales PNG and x-PNG images and has a service 
ranking of `100`: 

```java
@Component(
    immediate = true,
    property = {"mime.type=image/png", "mime.type=image/x-png", "service.ranking:Integer=100"},
    service = {AMImageScaler.class}
)
public class SampleAMPNGImageScaler implements AMImageScaler {...
```

This requires these imports: 

```java
import com.liferay.adaptive.media.image.scaler.AMImageScaler;
import org.osgi.service.component.annotations.Component;
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Implement the \texttt{isEnabled()} method to return \texttt{true} when
  you want to enable the scaler. In many cases, you always want the
  scaler enabled, so you can simply return \texttt{true} in this method.
  This is the case with the image scaler in this example:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return true;
}
\end{verbatim}

  This method gets more interesting when the scaler depends on other
  tools or features. For example, the \texttt{isEnabled()} method in
  \texttt{AMGIFImageScaler} determines whether gifsicle is enabled. This
  scaler must only be enabled when the tool it depends on, gifsicle, is
  also enabled:

\begin{verbatim}
@Override
public boolean isEnabled() {
    return _amImageConfiguration.gifsicleEnabled();
}
\end{verbatim}
\item
  Implement the \texttt{scaleImage} method. This method contains the
  scaler's business logic and must return an \texttt{AMImageScaledImage}
  instance. For example, the \texttt{scaleImage} implementation in this
  example uses \texttt{AMImageConfigurationEntry} to get the maximum
  height and width values for the scaled image, and \texttt{FileVersion}
  to get the image to scale. The scaling is done via a private inner
  class, assuming that the methods \texttt{\_scalePNG},
  \texttt{\_getScalePNGHeight}, \texttt{\_getScalePNGWidth}, and
  \texttt{\_getScalePNGSize} implement the actual scaling:

\begin{verbatim}
@Override
public AMImageScaledImage scaleImage(FileVersion fileVersion,
    AMImageConfigurationEntry amImageConfigurationEntry) {

    Map<String, String> properties = amImageConfigurationEntry.getProperties();

    int maxHeight = GetterUtil.getInteger(properties.get("max-height"));
    int maxWidth = GetterUtil.getInteger(properties.get("max-width"));

    try {
        InputStream inputStream = 
            _scalePNG(fileVersion.getContentStream(false), maxHeight, maxWidth);

        int height = _getScalePNGHeight();
        int width = _getScalePNGWidth();
        long size = _getScalePNGSize();

        return new AMImageScaledImageImpl(inputStream, height, width, size);
    }
    catch (PortalException pe) {
        throw new AMRuntimeException.IOException(pe);
    }
}

private class AMImageScaledImageImpl implements AMImageScaledImage {

    @Override
    public int getHeight() {
        return _height;
    }

    @Override
    public InputStream getInputStream() {
        return _inputStream;
    }

    @Override
    public long getSize() {
        return _size;
    }

    @Override
    public int getWidth() {
        return _width;
    }

    private AMImageScaledImageImpl(InputStream inputStream, int height, 
        int width, long size) {

        _inputStream = inputStream;
        _height = height;
        _width = width;
        _size = size;
    }

    private final int _height;
    private final InputStream _inputStream;
    private final long _size;
    private final int _width;

}
\end{verbatim}

  This requires these imports:

\begin{verbatim}
import com.liferay.adaptive.media.exception.AMRuntimeException;
import com.liferay.adaptive.media.image.configuration.AMImageConfigurationEntry;
import com.liferay.adaptive.media.image.scaler.AMImageScaledImage;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.repository.model.FileVersion;
import com.liferay.portal.kernel.util.GetterUtil;
import java.io.InputStream;
import java.util.Map;
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-39}

\href{/docs/7-2/frameworks/-/knowledge_base/f/adaptive-media}{Adaptive
Media}

\href{/docs/7-2/frameworks/-/knowledge_base/f/displaying-adapted-images-in-your-app}{Displaying
Adapted Images in Your App}

\href{/docs/7-2/frameworks/-/knowledge_base/f/finding-adapted-images}{Finding
Adapted Images}

\chapter{Social API}\label{social-api-1}

You can use the social API to integrate Liferay DXP's social features
with your apps. Here, you'll learn about the following topics:

\begin{itemize}
\tightlist
\item
  \hyperref[social-bookmarks]{Social Bookmarks}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-comments-to-your-app}{Adding
  Comments to Your App}
\item
  \hyperref[ratings]{Ratings}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/flagging-inappropriate-asset-content}{Flagging
  Inappropriate Asset Content}
\end{itemize}

\chapter{Social Bookmarks}\label{social-bookmarks}

To apply social bookmarks to your app's content, you must use the
\texttt{liferay-social-bookmarks} taglib. This taglib contains the
\texttt{liferay-social-bookmarks:bookmarks} tag, which adds the social
bookmarks component. This tag contains these attributes:

\texttt{className}: The entity's class name.

\texttt{classPK}: The entity's primary key.

\texttt{displayStyle}: The social bookmarks' display style. Possible
values are \texttt{inline}, which displays them in a row, and
\texttt{menu}, which hides them in a menu.

\texttt{title}: A title for the content being shared. This attribute is
often populated by calling the entity's \texttt{getTitle()} method (or
other method that retrieves the title).

\texttt{types}: A comma-delimited list of the social media services to
use (e.g., \texttt{facebook,twitter}). To use every social media service
available in the portal, omit this attribute or use
\texttt{\textless{}\%=\ null\ \%\textgreater{}} for its value.

\texttt{url}: A URL to the portal content being shared. The
\texttt{PortalUtil} method \texttt{getCanonicalURL} is often called to
populate this attribute. This method constructs an SEO-friendly URL from
the page's full URL. For more information, see the method's
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/PortalUtil.html\#getCanonicalURL-java.lang.String-com.liferay.portal.kernel.theme.ThemeDisplay-com.liferay.portal.kernel.model.Layout-}{Javadoc}.

For instructions on using this tag, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/applying-social-bookmarks}{Applying
Social Bookmarks}. For instructions on creating your own social
bookmarks, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-social-bookmarks}{Creating
Social Bookmarks}.

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-inline.png}
\caption{With \texttt{displayStyle} set to \texttt{inline}, the first
three social bookmarks appear in a row and the rest appear in a menu.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-menu.png}
\caption{With \texttt{displayStyle} set to \texttt{menu}, all social
bookmarks appear in the \emph{Share} menu.}
\end{figure}

\chapter{Ratings}\label{ratings}

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{The asset
framework} supports a content rating system. This feature appears in
many of Liferay DXP's built-in apps. For example, users can rate
articles published in the Blogs app. There are three different rating
types:

\begin{itemize}
\tightlist
\item
  Likes
\item
  Stars (five, by default)
\item
  Thumbs (up/down)
\end{itemize}

To enable ratings in your app, you must use the
\texttt{liferay-ui:ratings} tag and set its \texttt{type} attribute to
the rating type (\texttt{like}, \texttt{stars}, or \texttt{thumbs}). For
instructions on this, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Rating
Assets}.

\section{Rating Type Selection}\label{rating-type-selection}

Admins can select the rating type for an app's entities via the Control
Panel and Site Administration. Portal admins can set the default rating
type for the portal, while Site admins can override the default rating
type for their Site.

A ratings-enabled app must define its rating type in an OSGi component
that implements the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/definition/PortletRatingsDefinition.html}{\texttt{PortletRatingsDefinition}}
interface. This class declares the usage of ratings (specifying the
portlet and the entity) and the default rating type (that can be
overridden by portal and site admins). This interface has two methods
that you must implement:

\texttt{getDefaultRatingsType}: Returns the entity's default rating
type, which portal and site admins can override. You can do this via the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/RatingsType.html}{\texttt{RatingsType}}
enum, which contains \texttt{LIKE}, \texttt{STARS}, or \texttt{THUMBS}.

\texttt{getPortletId}: Returns the portlet ID of the main portlet that
uses the entity. You can do this via the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/PortletKeys.html}{\texttt{PortletKeys}}
enum, which defines many constants that correspond to the portlet IDs of
the built-in portlets.

To add support for rating type selection in your app, follow the
instructions in
\href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-rating-type-selection}{Implementing
Rating Type Selection}. Once you've done so, you can configure the
default rating type via the Control Panel at \emph{Configuration} →
\emph{Instance Settings} → \emph{Social}. To override the default values
for a site, go to Site Administration (your Site's menu) →
\emph{Configuration} → \emph{Site Settings} → \emph{Social}.

\section{Rating Value Transformation}\label{rating-value-transformation}

The database stores normalized rating values. This permits switching
between rating types without modifying the underlying data. When
administrators change an entity's rating type, its best match is
computed. Here's a list of the default transformations between rating
types:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When changing from stars to:

  \textbf{Like:} A value of 3, 4, or 5 stars is considered a like; a
  value of 1 or 2 stars is omitted.

  \textbf{Thumbs up/down:} A value of 3, 4, or 5 stars is considered a
  thumbs up; a value of 1 or 2 stars is considered a thumbs down.
\item
  When changing from thumbs up/down to:

  \textbf{Like:} A like is considered a thumbs up.

  \textbf{Stars:} A thumbs down is considered 1 star; a thumbs up is
  considered 5 stars.
\item
  When changing from like to:

  \textbf{Stars:} A like is considered 5 stars.

  \textbf{Thumbs up/down:} A like is considered a thumbs up.
\end{enumerate}

There may be some cases, however, where you want to apply different
criteria to determine the new rating values. A mechanism exists that
permits this, but it modifies the stored rating values. To define such
transformations, create an OSGi component that implements
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/transformer/RatingsDataTransformer.html}{\texttt{RatingsDataTransformer}}.

\noindent\hrulefill

\textbf{Note:} The portal doesn't provide a default
\texttt{RatingsDataTransformer} implementation. Unless you provide such
an implementation, the stored rating values always remain the same while
the portal interprets existing values for the selected rating type.

\noindent\hrulefill

When implementing \texttt{RatingsDataTransformer}, implement the
\texttt{transformRatingsData} method to transform the data. This
method's arguments include the \texttt{RatingsType} variables
\texttt{fromRatingsType} and \texttt{toRatingsType}, which contain the
rating type to transform from and to, respectively. These values let you
write your custom transformation's logic. You can write this logic by
implementing the interface
\texttt{ActionableDynamicQuery.PerformActionMethod} as an anonymous
inner class in the \texttt{transformRatingsData} method, implementing
the \texttt{performAction} method with your transformation's logic.

For instructions on implementing \texttt{RatingsDataTransformer}, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-rating-value-transformation}{Customizing
Rating Value Transformation}.

\chapter{Applying Social Bookmarks}\label{applying-social-bookmarks}

When you enable social bookmarks, icons for sharing on Twitter,
Facebook, and LinkedIn appear below your app's content. Taglibs provide
the markup you need to add this feature to your app.

\begin{figure}
\centering
\includegraphics{./images/social-bookmarks-inline.png}
\caption{These social bookmarks are in the inline display style.}
\end{figure}

Follow these steps to add social bookmarks to your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{asset
  enabled}.
\item
  In your project's \texttt{build.gradle} file, add a dependency to the
  module
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.social.bookmarks.taglib/}{\texttt{com.liferay.social.bookmarks.taglib}}:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.social.bookmarks.taglib", version: "1.0.0"
\end{verbatim}
\item
  Choose a view in which to show the social bookmarks. For example, you
  can display them in one of your app's views. However, note that you
  don't need to implement social bookmarks in your app's
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-asset-renderer}{asset
  renderers}. The Asset Publisher displays social bookmarks in asset
  renderers by default.
\item
  In your view's JSP, include the \texttt{liferay-social-bookmarks}
  taglib declaration:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/social-bookmarks" prefix="liferay-social-bookmarks" %>
\end{verbatim}
\item
  Get an instance of your entity. You can do this however you wish. This
  example uses
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  to get the entity's ID from the render request, then uses the entity's
  \texttt{-LocalServiceUtil} class to create an entity object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the \texttt{liferay-social-bookmarks:bookmarks} tag to add the
  social bookmarks component. See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#social-bookmarks}{Social
  Bookmarks} for information on this tag's attributes. Here's an example
  of using this tag to add social bookmarks for a blog entry in the
  Blogs app:

\begin{verbatim}
<liferay-social-bookmarks:bookmarks
        className="<%= BlogsEntry.class.getName() %>"
        classPK="<%= entry.getEntryId() %>"
        displayStyle="inline"
        title="<%= entry.getTitle() %>"
        types="facebook,twitter"
        url="<%= PortalUtil.getCanonicalURL(bookmarkURL.toString(), themeDisplay, layout) %>"
/>
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-40}

\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#social-bookmarks}{Social
Bookmarks}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-social-bookmarks}{Creating
Social Bookmarks}

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework}

\chapter{Creating Social Bookmarks}\label{creating-social-bookmarks}

By default, Liferay DXP contains social bookmarks for Twitter, Facebook,
and LinkedIn. You can also create your own social bookmark by
registering a component that implements the
\href{https://docs.liferay.com/dxp/apps/social/latest/javadocs/com/liferay/social/bookmarks/SocialBookmark.html}{\texttt{SocialBookmark}}
interface from the module \texttt{com.liferay.social.bookmarks.api}. The
steps here show you how to do this.

\section{Implementing the SocialBookmark
Interface}\label{implementing-the-socialbookmark-interface}

Follow these steps to implement the \texttt{SocialBookmark} interface:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create your \texttt{*SocialBookmark} class and register a component
  that defines the \texttt{social.bookmarks.type} property. This
  property's value is what you enter for the
  \texttt{liferay-social-bookmarks:bookmarks} tag's \texttt{type}
  attribute when you use your social bookmark.

  For example, here's the definition for a Twitter social bookmark
  class:

\begin{verbatim}
@Component(immediate = true, property = "social.bookmarks.type=twitter")
public class TwitterSocialBookmark implements SocialBookmark {...
\end{verbatim}
\item
  Create a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ResourceBundleLoader.html}{\texttt{ResourceBundleLoader}}
  reference to help localize the social bookmark's name.

\begin{verbatim}
@Reference(
        target = "(bundle.symbolic.name=com.liferay.social.bookmark.twitter)"
)
private ResourceBundleLoader _resourceBundleLoader;
\end{verbatim}
\item
  Implement the \texttt{getName} method to return the social bookmark's
  name as a string. This method takes a
  \href{https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html}{\texttt{Locale}}
  object that you can use for localization via
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/language/LanguageUtil.html}{\texttt{LanguageUtil}}
  and
  \href{https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html}{\texttt{ResourceBundle}}:

\begin{verbatim}
@Override
public String getName(Locale locale) {
    ResourceBundle resourceBundle = _resourceBundleLoader.loadResourceBundle(locale);

    return LanguageUtil.get(resourceBundle, "twitter");
}
\end{verbatim}
\item
  Implement the \texttt{getPostURL} method to return the share URL. This
  method constructs the share URL from a title and URL, and uses
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/URLCodec.html}{\texttt{URLCodec}}
  to encode the title in the URL:

\begin{verbatim}
@Override
public String getPostURL(String title, String url) {
    return String.format(
        "https://twitter.com/intent/tweet?text=%s&tw_p=tweetbutton&url=%s", 
        URLCodec.encodeURL(title), url);
}
\end{verbatim}
\item
  Create a \texttt{ServletContext} reference:

\begin{verbatim}
@Reference(
        target = "(osgi.web.symbolicname=com.liferay.social.bookmark.twitter)"
)
private ServletContext _servletContext;
\end{verbatim}
\item
  Implement the \texttt{render} method, which is called when the inline
  display style is selected. Typically, this method renders a link to
  the share URL (e.g., a share button), but you can use it for whatever
  you need. To keep a consistent look and feel with the default social
  bookmarks, you can use a
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-icons}{Clay icon}.

  This example gets a \texttt{RequestDispatcher} for the JSP that
  contains a Clay icon (\texttt{page.jsp}), and then includes that JSP
  in the response:

\begin{verbatim}
@Override
public void render(
                String target, String title, String url, HttpServletRequest request,
                HttpServletResponse response)
        throws IOException, ServletException {

        RequestDispatcher requestDispatcher =
                _servletContext.getRequestDispatcher("/page.jsp");

        requestDispatcher.include(request, response);
}
\end{verbatim}
\end{enumerate}

\section{Creating Your JSP}\label{creating-your-jsp}

The \texttt{page.jsp} file referenced in the above
\texttt{SocialBookmark} implementation uses
\href{/docs/7-2/reference/-/knowledge_base/r/clay-labels-and-links}{a
Clay link} (\texttt{clay:link}) to specify and style the Twitter icon
included with Clay. Follow these steps to create a JSP for your own
social bookmark:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{clay} and \texttt{liferay-theme} taglib declarations:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/clay" prefix="clay" %>
<%@ taglib uri="http://liferay.com/tld/theme" prefix="liferay-theme" %>
\end{verbatim}
\item
  Import
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/GetterUtil.html}{\texttt{GetterUtil}}
  and \texttt{SocialBookmark}:

\begin{verbatim}
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
<%@ page import="com.liferay.social.bookmarks.SocialBookmark" %>
\end{verbatim}
\item
  From the request, get a \texttt{SocialBookmark} instance and the
  social bookmark's title and URL:

\begin{verbatim}
<%
SocialBookmark socialBookmark = (SocialBookmark)request.getAttribute("liferay-social-bookmarks:bookmark:socialBookmark");
String title = GetterUtil.getString((String)request.getAttribute("liferay-social-bookmarks:bookmark:title"));
String url = GetterUtil.getString((String)request.getAttribute("liferay-social-bookmarks:bookmark:url"));
%>
\end{verbatim}

  The title and URL are set via the \texttt{liferay-social-bookmarks}
  taglib when
  \href{/docs/7-2/frameworks/-/knowledge_base/f/applying-social-bookmarks}{applying
  the social bookmark}.
\item
  Add the Clay link. See the \texttt{clay:link}
  \href{https://clayui.com/docs/components/link.html}{documentation} for
  a full description of its attributes.

\begin{verbatim}
<clay:link
        buttonStyle="secondary"
        elementClasses="btn-outline-borderless btn-sm lfr-portal-tooltip"
        href="<%= socialBookmark.getPostURL(title, url) %>"
        icon="twitter"
        title="<%= socialBookmark.getName(locale) %>"
/>
\end{verbatim}

  This example sets the following \texttt{clay:link} attributes:

  \texttt{buttonStyle}: This example renders the
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-buttons}{button's
  type} as a secondary button.

  \texttt{elementClasses}: The custom CSS to use for styling the button
  (optional).

  \texttt{href}: The button's URL. You should specify this by calling
  your \texttt{SocialBookmark} instance's \texttt{getPostURL} method.

  \texttt{icon}: The button's icon. This example specifies the Twitter
  icon included in Clay (\texttt{twitter}).

  \texttt{title}: The button's title. This example uses the
  \texttt{SocialBookmark} instance's \texttt{getName} method.
\end{enumerate}

To see a complete, real-world example of a social bookmark
implementation, see
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/social/social-bookmark-twitter}{Liferay's
Twitter social bookmark code}.

\section{Related Topics}\label{related-topics-41}

\href{/docs/7-2/frameworks/-/knowledge_base/f/applying-social-bookmarks}{Applying
Social Bookmarks}

\href{/docs/7-2/reference/-/knowledge_base/r/using-the-clay-taglib-in-your-portlets}{Using
the Clay Taglib in Your Portlets}

\chapter{Adding Comments to Your App}\label{adding-comments-to-your-app}

Liferay provides taglibs that enable comments on your app's content.
Here, you'll learn how to use these taglibs, using a sample Guestbook
app as an example.

Follow these steps to enable commenting on your app's content:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity you want to enable comments on.
  You can display the comments component in your app's view, or if
  you've
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-asset-renderer}{implemented
  asset rendering} you can display it in the full content view in the
  Asset Publisher app.
\item
  Include the \texttt{liferay-ui}, \texttt{liferay-comment}, and
  \texttt{portlet} taglib declarations in your JSP:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
<%@ taglib prefix="liferay-comment" uri="http://liferay.com/tld/comment" %>
<%@ taglib prefix="portlet" uri="http://java.sun.com/portlet_2_0" %>
\end{verbatim}
\item
  Use
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  to get the entity's ID from the render request. Then create an entity
  object using the \texttt{-LocalServiceUtil} class. Here's an example
  that does this for a guestbook entry in the example Guestbook app:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Create a collapsible panel for the comments using the
  \texttt{liferay-ui:panel-container} and \texttt{liferay-ui:panel}
  tags. This lets users hide the discussion area:

\begin{verbatim}
<liferay-ui:panel-container extended="<%=false%>"
  id="guestbookCollaborationPanelContainer" persistState="<%=true%>">
  <liferay-ui:panel collapsible="<%=true%>" extended="<%=true%>"
    id="guestbookCollaborationPanel" persistState="<%=true%>"
    title="Collaboration">
\end{verbatim}
\item
  Create a URL for the discussion using the \texttt{portlet:actionURL}
  tag:

\begin{verbatim}
<portlet:actionURL name="invokeTaglibDiscussion" var="discussionURL" />
\end{verbatim}
\item
  Use the \texttt{liferay-comment:discussion} tag to add the discussion.
  To let the user return to the JSP after making a comment, set the
  tag's \texttt{redirect} attribute to the current URL. You can use
  \texttt{PortalUtil.getCurrentURL((renderRequest))} to get the current
  URL from the \texttt{request} object. In this example, the current URL
  was earlier set to the \texttt{currentURL} variable:

\begin{verbatim}
    <liferay-comment:discussion className="<%=Entry.class.getName()%>"
      classPK="<%=entry.getEntryId()%>"
      formAction="<%=discussionURL%>" formName="fm2"
      ratingsEnabled="<%=true%>" redirect="<%=currentURL%>"
      userId="<%=entry.getUserId()%>" />

  </liferay-ui:panel>
</liferay-ui:panel-container>
\end{verbatim}
\end{enumerate}

If you haven't already connected your portlet's view to the JSP for your
entity, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-jsp-templates-for-an-asset-renderer}{Configuring
JSP Templates for an Asset Renderer}.

\section{Related Topics}\label{related-topics-42}

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework}

\href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Rating
Assets}

\chapter{Rating Assets}\label{rating-assets}

In only a few lines of code, you can use a taglib to enable ratings for
your app's content. The steps here show you how. For more information on
this taglib and ratings in general, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#ratings}{Ratings}.

\begin{figure}
\centering
\includegraphics{./images/social-ratings-thumbs.png}
\caption{Users can rate content to let others know how they really feel
about it.}
\end{figure}

Follow these steps to enable ratings in your app. Note that these steps
use a sample Guestbook app as an example. This app lets users leave
simple messages in a guestbook.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity for which you want to enable
  ratings. You can display ratings in one of your portlet's views, or if
  you've
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-asset-renderer}{implemented
  asset rendering} you can display them in the full content view in the
  Asset Publisher app.
\item
  In the JSP, include the \texttt{liferay-ui} taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-ui" uri="http://liferay.com/tld/ui" %>
\end{verbatim}
\item
  Use
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  to get the entity's ID from the render request. Then create an entity
  object using the \texttt{-LocalServiceUtil} class. Here's an example
  that does this for a guestbook entry in the example Guestbook app:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the \texttt{liferay-ui:ratings} tag to add the ratings component
  for the entity. This example uses the stars rating type:

\begin{verbatim}
<liferay-ui:ratings className="<%=Entry.class.getName()%>"
    classPK="<%=entry.getEntryId()%>" type="stars" />
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-43}

\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#ratings}{Ratings}

\href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-rating-type-selection}{Implementing
Rating Type Selection}

\href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-rating-value-transformation}{Customizing
Rating Value Transformation}

\chapter{Implementing Rating Type
Selection}\label{implementing-rating-type-selection}

For administrators to change your app's rating type (e.g.~likes, stars,
thumbs), you must implement rating type selection. The steps here show
you how. For a detailed explanation of these steps and rating type
selection, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#rating-type-selection}{Rating
Type Selection}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/definition/PortletRatingsDefinition.html}{\texttt{PortletRatingsDefinition}}
  interface, registering the class as an OSGi component. In the
  \texttt{@Component} annotation, set the \texttt{model.class.name}
  property to the fully qualified name of the class that will use this
  rating definition. This example rating definition is for a blog entry,
  so the \texttt{model.class.name} property is set to
  \texttt{com.liferay.portlet.blogs.model.BlogsEntry}:

\begin{verbatim}
@Component(
    property = {
        "model.class.name=com.liferay.portlet.blogs.model.BlogsEntry"
    }
)
public class BlogsPortletRatingsDefinition implements PortletRatingsDefinition {...
\end{verbatim}
\item
  Implement the \texttt{PortletRatingsDefinition} methods
  \texttt{getDefaultRatingsType} and \texttt{getPortletId} to return the
  entity's default rating type and the portlet ID of the main portlet
  that uses the entity, respectively. In this example, the rating type
  is thumbs and the portlet ID is for the Blogs portlet:

\begin{verbatim}
@Override
public RatingsType getDefaultRatingsType() {
    return RatingsType.THUMBS;
}

@Override
public String getPortletId() {
    return PortletKeys.BLOGS;
}
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-44}

\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#rating-type-selection}{Rating
Type Selection}

\href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Rating
Assets}

\href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-rating-value-transformation}{Customizing
Rating Value Transformation}

\chapter{Customizing Rating Value
Transformation}\label{customizing-rating-value-transformation}

To customize rating value transformation, you must create an OSGi
component that implements
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/transformer/RatingsDataTransformer.html}{\texttt{RatingsDataTransformer}}.
The steps here show you how. For a detailed explanation of these steps
and rating value transformation, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#rating-value-transformation}{Rating
Value Transformation}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi component class that implements
  \texttt{RatingsDataTransformer}:

\begin{verbatim}
@Component
public class DummyRatingsDataTransformer implements RatingsDataTransformer {...
\end{verbatim}
\item
  In this class, implement the \texttt{transformRatingsData} method.
  Note that it contains the \texttt{RatingsType} variables
  \texttt{fromRatingsType} and \texttt{toRatingsType}:

\begin{verbatim}
@Override
public ActionableDynamicQuery.PerformActionMethod transformRatingsData(
        final RatingsType fromRatingsType, final RatingsType toRatingsType)
    throws PortalException {

}
\end{verbatim}
\item
  In the \texttt{transformRatingsData} method, implement the interface
  \texttt{ActionableDynamicQuery.PerformActionMethod} as an anonymous
  inner class:

\begin{verbatim}
return new ActionableDynamicQuery.PerformActionMethod() {

};
\end{verbatim}
\item
  In the anonymous \texttt{ActionableDynamicQuery.PerformActionMethod}
  implementation, implement the \texttt{performAction} method to perform
  your transformation:

\begin{verbatim}
@Override
public void performAction(Object object)
    throws PortalException {

    if (fromRatingsType.getValue().equals(RatingsType.LIKE) &&
        toRatingsType.getValue().equals(RatingsType.STARS)) {

        RatingsEntry ratingsEntry = (RatingsEntry) object;

        ratingsEntry.setScore(0);

        RatingsEntryLocalServiceUtil.updateRatingsEntry(
            ratingsEntry);
    }
}
\end{verbatim}

  This example irreversibly transforms the rating type from likes to
  stars, resetting the value to \texttt{0}. The \texttt{if} statement
  uses the \texttt{fromRatingsType} and \texttt{toRatingsType} values to
  specify that the transformation only occurs when going from likes to
  stars. The transformation is performed via \texttt{RatingsEntry} and
  its \texttt{-LocalServiceUtil}. After getting a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/model/RatingsEntry.html}{\texttt{RatingsEntry}}
  object, its \texttt{setScore} method sets the rating score to
  \texttt{0}. The
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/ratings/kernel/service/RatingsEntryLocalServiceUtil.html}{\texttt{RatingsEntryLocalServiceUtil}}
  method \texttt{updateRatingsEntry} then updates the
  \texttt{RatingsEntry} in the database.
\end{enumerate}

Here's the complete class for this example:

\begin{verbatim}
@Component
public class DummyRatingsDataTransformer implements RatingsDataTransformer {
    @Override
    public ActionableDynamicQuery.PerformActionMethod transformRatingsData(
            final RatingsType fromRatingsType, final RatingsType toRatingsType)
        throws PortalException {

        return new ActionableDynamicQuery.PerformActionMethod() {

            @Override
            public void performAction(Object object)
                throws PortalException {

                if (fromRatingsType.getValue().equals(RatingsType.LIKE) &&
                    toRatingsType.getValue().equals(RatingsType.STARS)) {

                    RatingsEntry ratingsEntry = (RatingsEntry) object;

                    ratingsEntry.setScore(0);

                    RatingsEntryLocalServiceUtil.updateRatingsEntry(
                        ratingsEntry);
                }
            }
        };
    }

}
\end{verbatim}

\section{Related Topics}\label{related-topics-45}

\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api\#rating-value-transformation}{Rating
Value Transformation}

\href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-rating-type-selection}{Implementing
Rating Type Selection}

\href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Rating
Assets}

\chapter{Flagging Inappropriate Asset
Content}\label{flagging-inappropriate-asset-content}

The asset framework supports a system for flagging inappropriate content
in apps. The steps here show you how to enable it in your app.

\begin{figure}
\centering
\includegraphics{./images/social-flags.png}
\caption{Users can flag objectionable content.}
\end{figure}

Follow these steps to enable content flagging in your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity is
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{asset
  enabled}.
\item
  Choose a read-only view of the entity you want to enable flags on. You
  can display flags in one of your app's views, or if you've
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-asset-renderer}{implemented
  asset rendering} you can display it in the full content view in the
  Asset Publisher app.
\item
  In your JSP, include the \texttt{liferay-flags} taglib declaration:

\begin{verbatim}
<%@ taglib prefix="liferay-flags" uri="http://liferay.com/tld/flags" %>
\end{verbatim}
\item
  Use
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ParamUtil.html}{\texttt{ParamUtil}}
  to get the entity's ID from the render request. Then use your
  \texttt{-LocalServiceUtil} class to create an entity object:

\begin{verbatim}
<%
long entryId = ParamUtil.getLong(renderRequest, "entryId");
entry = EntryLocalServiceUtil.getEntry(entryId);
%>
\end{verbatim}
\item
  Use the
  \href{https://docs.liferay.com/dxp/apps/collaboration/latest/taglibdocs/liferay-flags/flags.html}{\texttt{liferay-flags:flags}}
  tag to add the flags component:

\begin{verbatim}
<liferay-flags:flags
    className="<%= Entry.class.getName() %>"
    classPK="<%= entry.getEntryId() %>"
    contentTitle="<%= title %>"
    message="flag-this-content"
    reportedUserId="<%= reportedUserId %>"
/>
\end{verbatim}

  The \texttt{reportedUserId} attribute specifies the ID of the user who
  flagged the asset.
\end{enumerate}

\section{Related Topics}\label{related-topics-46}

\href{/docs/7-2/frameworks/-/knowledge_base/f/rating-assets}{Rating
Assets}

\href{/docs/7-2/frameworks/-/knowledge_base/f/social-api}{Social API}

\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework}

\chapter{Configurable Applications}\label{configurable-applications}

Many applications must be configurable, whether by end users or
administrators. A configuration solution must support use cases ranging
from setting a location for a weather display to more complex cases like
settings for a mail or time sheet application.

The Portlet standard's portlet preferences API can be used for portlet
configuration, but it's intended for storing user preferences. This
limits its usefulness for enabling administrator configuration; plus it
can only be used with portlets. Instead, application developers tend to
create ad hoc configuration methods. But this isn't necessary.

Liferay DXP's configuration API is easy to use and is not limited to
portlets. When you define configuration options in a Java interface,
Liferay's configuration framework auto-generates a UI, sparing you the
trouble of developing an interface for your users to select
configuration options.

\noindent\hrulefill

\textbf{Note:} To see a working application configuration, deploy the
\texttt{configuration-action}
\href{https://github.com/liferay/liferay-blade-samples/tree/master/gradle/apps/configuration-action}{Blade
sample} and navigate to System Settings (\emph{Control Panel} →
\emph{Configuration} → \emph{System Settings}). In the Platorm section's
Third Party category, click the \emph{Message display configuration}
entry.

Add the \emph{Blade Message Portlet} to a page to test your
configuration choices.

\noindent\hrulefill

Complete these three high level tasks to integrate your application with
the configuration framework:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Provide a way to set configurations in the UI.
\item
  Set the scope where the application is configured.
\item
  Read configuration values in your business logic.
\end{enumerate}

\section{Using a Configuration
Interface}\label{using-a-configuration-interface}

You can take care of the first two steps by
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-configuration-interface}{Creating
A Configuration Interface}. This Java interface does a number of things:

\begin{itemize}
\item
  Just by existing, it gives you a UI in \emph{System Settings}, so you
  don't have to write one yourself. Score!
\item
  It defines the configuration options that will appear in the UI.
\item
  It defines the type \{\texttt{int}, \texttt{String}, etc.) of values
  each configuration takes.
\item
  It defines the scope of your configuration. Bonus in 7.0: if your
  configuration is scoped to anything other than \texttt{SYSTEM}, you
  get an additional UI generated for you in \emph{Instance Settings}.
  More on scope in a minute.
\item
  It categorizes your configuration screen so that it can be easily
  found in \emph{System Settings} and \emph{Instance Settings}. If you
  skip this the screen will be put in a default location.
\end{itemize}

A few things you need to know:

\begin{description}
\tightlist
\item[\textbf{Typed Configuration}]
The method described here uses \emph{typed} configuration. The
application configuration isn't just a list of key-value pairs. Values
can have types, like \texttt{Integer}, a list of \texttt{Strings}, a
URL, etc. You can even use your own types, although that's beyond the
scope of this tutorial. Typed configurations are easier to use than
untyped configurations, and they prevent many programmatic errors.
Configuration options should be programmatically explicit, so developers
can use autocomplete in modern IDEs to find out all configuration
options of a given application or one of its components.
\item[\textbf{Configuration Scope}]
Scope defines where a configuration value applies. Here are the most
common configuration scopes:
\end{description}

\begin{itemize}
\item
  \texttt{SYSTEM}: Configuration values apply throughout the system.
\item
  \texttt{COMPANY}: One set of configuration values is stored for each
  virtual instance, so each instance can be configured individually.
\item
  \texttt{GROUP}: Each group can be configured individually.
\item
  \texttt{PORTLET\_INSTANCE}: this refers to apps that can be placed on
  a page as a widget. Each widget can be configured individually.
\end{itemize}

\textbf{Configuration UIs} : When you create a configuration interface
of any sort, a UI is generated for you in \emph{System Settings}. If
your configuration is scoped to \texttt{COMPANY}, \texttt{GROUP}, or
\texttt{PORTLET\_INSTANCE}, an additional UI is generated in
\emph{Instance Settings}. Note that while \texttt{GROUP} and
\texttt{PORTLET\_INSTANCE} configurations appear in the Instance
Settings UI, they can only be used to set defaults for the current
instance. No corresponding UI is auto-generated to configure the app at
the Site or Portlet level.

\noindent\hrulefill

\textbf{Note:} An Instance Settings UI is not currently generated for
factory configurations. You can track the progress of this issue
\href{https://issues.liferay.com/browse/LPS-94490}{here}.

\noindent\hrulefill

\begin{description}
\tightlist
\item[\textbf{Default Configurations}]
Default values for any scoped configuration can be set at any wider
scope. For example, if your configuration is scoped to the
\texttt{GROUP}, you can set a system-wide default in \emph{System
Settings, an instance-wide default in }Instance Settings*, or both. Any
configuration at a narrower scope will always override a configuration
at a wider scope.
\end{description}

Read more about configuration scope
\href{/docs/7-2/user/-/knowledge_base/u/system-settings\#configuration-scope}{here}.

When you complete your configuration interface, you're done with steps 1
and 2 above.

\section{Reading Configuration
Values}\label{reading-configuration-values}

The final step is to make your app read the configuration values that
users enter. There are a number of ways to do that:

If your configuration is scoped to \texttt{COMPANY} or \texttt{GROUP}
you must use
\href{/docs/7-2/frameworks/-/knowledge_base/f/reading-scoped-configuration-values}{\texttt{ConfigurationProvider}}
This allows your app to read different configuration values from each
site, virtual instance, or whatever the configuration is scoped to.

If your configuration is scoped to \texttt{PORTLET\_INSTANCE}, you can
still use \texttt{ConfigurationProvider}, but using
\texttt{PortletDisplay} is simpler and more convenient. See
\href{/docs/7-2/frameworks/-/knowledge_base/f/reading-scoped-configuration-values\#accessing-the-portlet-instance-configuration-through-the-portletdisplay}{\texttt{PortletDisplay}}.

If you only want your app to be configurable at the \texttt{SYSTEM}
scope, you have a few options. \texttt{ConfigurationProvider} will work
fine, but there are alternatives that---since they don't need to query
multiple sources---can yield modest performance benefits. Which one you
use depends on what kind of class you're using to read configuration
values. Here are your options:

\begin{itemize}
\item
  Read with an
  \href{/docs/7-2/frameworks/-/knowledge_base/f/reading-unscoped-configuration-values-from-an-mvc-portlet\#accessing-the-configuration-from-a-jsp}{MVC
  portlet's JSP}
\item
  With an
  \href{/docs/7-2/frameworks/-/knowledge_base/f/reading-unscoped-configuration-values-from-an-mvc-portlet\#accessing-the-configuration-from-the-portlet-class}{MVC
  Portlet's Portlet Class}
\item
  With any other
  \href{/docs/7-2/frameworks/-/knowledge_base/f/reading-unscoped-configuration-values-from-a-component}{Component
  Class}
\end{itemize}

\section{Further Customization}\label{further-customization}

At this point you may be asking, ``But what if I don't \emph{like} the
auto-generated UI?'' Relax. There are a number of ways you can customize
it, or even suppress it entirely so you can put your own UI in its
place.

\begin{itemize}
\item
  Implement the \texttt{ConfigurationFormRenderer}
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuration-form-renderer}{interface}
  to customize the auto-generated UI in system settings.
\item
  If you need more flexibility---perhaps your app needs multiple
  configuration screens, or maybe you've already written a configuration
  UI and just want to insert it without bothering to write a
  configuration interface---implement the \texttt{ConfigurationScreen}
  interface to implement your own.
\item
  If you're using a configuration interface but you don't want a UI to
  be generated---maybe you're using a \texttt{ConfigurationScreen}
  implementation instead, or maybe you just want configuration to be
  handled programatically or by
  \href{/docs/7-2/user/-/knowledge_base/u/understanding-system-configuration-files}{.config
  file} ---you can
  \href{/docs/frameworks/-/knowledge_base/7-2/customizing-the-system-settings-user-interface\#excluding-a-configuration-ui-from-system-settings}{just
  leave it out}.
\item
  If you want the UI to render only under certain circumstances, you can
  write logic to
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-the-configuration-user-interface\#excluding-a-configuration-ui}{do
  that, too}.
\end{itemize}

Enough conceptual stuff. You're ready to get started with some code. If
you already have an app that was configurable under an earlier version
of Liferay DXP, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/upgrading-a-legacy-app}{Upgrading
a Legacy App}.

\chapter{Creating A Configuration
Interface}\label{creating-a-configuration-interface}

First, you'll learn how to create a configuration with no scope
declaration. This automatically scopes your configuration to
\texttt{SYSTEM}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Java interface to represent the configuration and its default
  values. Using a Java interface allows for an advanced type system for
  each configuration option. Here is the configuration interface for the
  Liferay Forms application:

\begin{verbatim}
@Meta.OCD(
    id = "com.liferay.dynamic.data.mapping.form.web.configuration.DDMFormWebConfiguration",
    localization = "content/Language", name = "ddm-form-web-configuration-name"
)
public interface DDMFormWebConfiguration {

    @Meta.AD(
        deflt = "1", description = "autosave-interval-description",
        name = "autosave-interval-name", required = false
    )
    public int autosaveInterval();

    @Meta.AD(
        deflt = "descriptive", name = "default-display-view",
        optionLabels = {"Descriptive", "List"},
        optionValues = {"descriptive", "list"}, required = false
    )
    public String defaultDisplayView();


}
\end{verbatim}

  This defines two configuration options, the autosave interval (with a
  default of one minute) and the default display view, which can be
  descriptive or list, but defaults to descriptive. Here's what the two
  Java annotations in the above snippet do:

  \textbf{Meta.OCD:} Registers this class as a configuration with a
  specific id. \textbf{The ID must be the fully qualified configuration
  class name.}

  \textbf{Meta.AD:} Specifies
  \href{http://bnd.bndtools.org/chapters/210-metatype.html}{optional
  metadata} about the field, such as whether it's a required field or if
  it has a default value. Note that if you set a field as required and
  don't specify a default value, the system administrator must specify a
  value in order for your application to work properly. Use the
  \texttt{deflt} property to specify a default value.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can dynamically populate select field options with the 
 [`ConfigurationFieldsOptionProvider` interface](/docs/7-2/frameworks/-/knowledge_base/f/dynamically-populating-select-list-fields-in-the-configuration-ui)
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The fully-qualified name of the `Meta` class above is
`aQute.bnd.annotation.metatype.Meta`. For more information about this class and
the `Meta.OCD` and `Meta.AD` annotations, please refer to the 
[bndtools documentation](http://bnd.bndtools.org/chapters/210-metatype.html).
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  To use the \texttt{Meta.OCD} and \texttt{Meta.AD} annotations in your
  modules, you must
  \href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{specify
  a dependency} on the bnd library. We recommend using bnd version 3.
  Here's an example of how to include this dependency in a Gradle
  project:

\begin{verbatim}
dependencies {
    compile group: "biz.aQute.bnd", name: "biz.aQute.bndlib", version: "3.1.0"
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The annotations \texttt{@Meta.OCD} and \texttt{@Meta.AD}
are part of the bnd library, but as of OSGi standard version R6, they're
included in the OSGi core under the names
\texttt{@ObjectClassDefinition} and \texttt{@AttributeDefinition}. The
OSGi annotations can be used for simple cases like the one described in
this tutorial. However, a key difference between the two libraries is
that the bnd annotations are available at runtime, while the OSGi
annotations are not. Because runtime availability is necessary for some
of the Liferay-specific features described below, we recommend
defaulting to the bnd annotations.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Also Note:} Your project depends on a \texttt{-metatype:\ *}
declaration in its metadata. If you're in a
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace}(or otherwise applying the
\href{/docs/7-2/reference/-/knowledge_base/r/gradle-plugins}{workspace
plugin to your build}), it's added automatically at build time.
Otherwise, add it manually in your module's \texttt{bnd.bnd}. It's
required to provide information about your app's configuration options
so that a configuration UI can be generated.

\noindent\hrulefill

When you register a configuration interface, a UI is auto-generated for
it in \emph{System Settings} → \emph{Platform} → \emph{Third Party}.
That's the default location; read the next section to learn how to move
it somewhere more intuitive.

\chapter{Categorizing the
Configuration}\label{categorizing-the-configuration}

By default, the configuration UI for your app is generated in
\emph{System Settings} → \emph{Platform} → \emph{Third Party}. You
probably don't really want it there; by categorizing your configuration
you can place it somewhere intuitive and easy to find.

\noindent\hrulefill

\textbf{Note:} If you
\href{/docs/7-2/frameworks/-/knowledge_base/f/scoping-configurations}{scope}
your configuration so that a UI is generated in Instance Settings as
well, your categorization will apply to that UI also.

\noindent\hrulefill

You have two options: 1) locate your configuration UI in an existing
category and section, or 2) create your own.

Here are the default System Settings sections. All available categories
are nested beneath these sections:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Content and Data
\item
  Platform
\item
  Security
\item
  Commerce
\item
  Other
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Sections appear if they contain at least one
configuration category. Categories appear if they contain at least one
configuration. The visible sections and categories depend on the
deployed modules.

\noindent\hrulefill

\section{Specifying a Configuration
Category}\label{specifying-a-configuration-category}

Specify the category for your UI by placing an
\texttt{@ExtendedObjectClassDefinition} annotation in your configuration
interface. This example, which appears right before the interface's
\texttt{@Meta.OCD} annotation, places the UI in the
\texttt{dynamic-data-mapping} category in the Content management
section:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "dynamic-data-mapping",
    scope = ExtendedObjectClassDefinition.Scope.GROUP
)
\end{verbatim}

This annotation does two things:

\begin{itemize}
\item
  Specifies the \texttt{dynamic-data-mapping} category in the Content
  Management section.
\item
  Sets the scope of the configuration. You'll learn more about this
  \href{/docs/7-2/frameworks/-/knowledge_base/f/scoping-configurations}{next}.
\end{itemize}

The fully qualified class name of the
\texttt{@ExtendedObjectClassDefinition} class is
\texttt{com.liferay.portal.configuration.metatype.annotations.ExtendedObjectClassDefinition}.

Note: The infrastructure used by System Settings assumes the
\texttt{configurationPid} is the same as the fully qualified class name
of the interface. If they don't match, it can't provide any information
through \texttt{ExtendedObjectClassConfiguration}.

The \texttt{@ExtendedObjectClassDefinition} annotation is distributed
through the \texttt{com.liferay.portal.configuration.metatype} module,
which you can
\href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{configure
as a dependency}.

\section{Creating New Sections and
Categories}\label{creating-new-sections-and-categories}

If you don't like the default sections and categories, you can create
your own by implementing the \texttt{ConfigurationCategory} interface.

Here's code that creates the \emph{Content and Data} section and the
\emph{Dynamic Data Mapping} category:

\begin{verbatim}
@Component(service = ConfigurationCategory.class)
public class DynamicDataMappingConfigurationCategory
    implements ConfigurationCategory {

    @Override
    public String getCategoryIcon() {
        return _CATEGORY_ICON;
    }

    @Override
    public String getCategoryKey() {
        return _CATEGORY_KEY;
    }

    @Override
    public String getCategorySection() {
        return _CATEGORY_SECTION;
    }

    private static final String _CATEGORY_ICON = "dynamic-data-mapping";

    private static final String _CATEGORY_KEY = "dynamic-data-mapping";

    private static final String _CATEGORY_SECTION = "content-and-data";

}
\end{verbatim}

The \texttt{getCategorySection} method returns the String with the new
section's key. Similarly, \texttt{getCategoryKey} returns the key for
the new category. Provide localized values for these keys in your
module's \texttt{src/main/resources/content/Language.properties} file.

\noindent\hrulefill

\textbf{Note:} the language keys for categories and sections must follow
a specific format. Prefix each section language key with
\texttt{category-section.} and each category language key with
\texttt{category.} For example:

\texttt{category-section.content-and-data=Content\ and\ Data}
\texttt{category.dynamic-data-mapping=Dynamic\ Data\ Mapping}

\noindent\hrulefill

Next you'll specify the scope of your application's configuration.

\chapter{Scoping Configurations}\label{scoping-configurations}

Here's how to scope a configuration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set the scope in the configuration interface.
\item
  Enable the configuration for scoped retrieval by creating a
  configuration bean declaration.
\end{enumerate}

\section{Step 1: Setting the Configuration
Scope}\label{step-1-setting-the-configuration-scope}

Use the \texttt{@ExtendedObjectClassDefinition} annotation to specify
the configuration's scope. The scope you choose must match how the
configuration object is retrieved through the
\href{/docs/7-2/frameworks/-/knowledge_base/f/reading-scoped-configuration-values}{configuration
provider}. Pass one of these valid scope options to
\texttt{@ExtendedObjectClassDefinition}:

\texttt{Scope.SYSTEM}: for system scope \texttt{Scope.COMPANY}: for
virtual instance scope \texttt{Scope.GROUP}: for site scope
\texttt{Scope.PORTLET\_INSTANCE}: for the portlet instance scope

Here is an example:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "dynamic-data-mapping",
    scope = ExtendedObjectClassDefinition.Scope.GROUP
)
@Meta.OCD(
    id = "com.liferay.dynamic.data.mapping.form.web.configuration.
        DDMFormWebConfiguration",
    localization = "content/Language", 
    name = "ddm-form-web-configuration-name"
)

public interface DDMFormWebConfiguration {
\end{verbatim}

\section{Step 2: Enabling the Configuration for Scoped
Retrieval}\label{step-2-enabling-the-configuration-for-scoped-retrieval}

To create a configuration bean declaration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Register the configuration class by implementing
  \texttt{ConfigurationBeanDeclaration}.

\begin{verbatim}
@Component
public class JournalGroupServiceConfigurationBeanDeclaration
    implements ConfigurationBeanDeclaration {
\end{verbatim}
\item
  This class has one method that returns the class of the configuration
  interface you created. It enables the system to keep track of
  configuration changes as they happen, making requests for the
  configuration very fast.

\begin{verbatim}
@Override
public Class<?> getConfigurationBeanClass() {
    return JournalGroupServiceConfiguration.class;
}
\end{verbatim}
\end{enumerate}

That's all there is to it. Now the configuration is scoped and supports
scoped retrieval via \texttt{ConfigurationProvider}. See the next
section for details on retrieval.

\chapter{Reading Scoped Configuration
Values}\label{reading-scoped-configuration-values}

If your configuration is scoped to anything other than \texttt{SYSTEM},
you have two options for reading configuration values.

\begin{itemize}
\item
  Use \texttt{ConfigurationProvider}. This works for any kind of
  configuration, and is the only way to read configuration values at the
  \texttt{COMPANY} and \texttt{GROUP} scopes.
\item
  Use \texttt{PortletDisplay}. This is the recommended approach for
  configurations at the \texttt{PORTLET\_INSTANCE} scope, but only works
  at that scope.
\end{itemize}

\section{Using the Configuration
Provider}\label{using-the-configuration-provider}

When using the Configuration Provider, instead of receiving the
configuration directly, the class that wants to access it must

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Receive a \texttt{ConfigurationProvider} to obtain the configuration.
\item
  Be registered with a \texttt{ConfigurationBeanDeclaration}.
\end{enumerate}

The tutorial on
\href{/docs/7-2/frameworks/-/knowledge_base/f/scoping-configurations}{scoping
configurations} demonstrates how to register the configuration with a
\texttt{ConfigurationBeanDeclaration}.

After registering with a \texttt{ConfigurationBeanDeclaration}, you're
ready to use a \texttt{ConfigurationProvider} to retrieve the scoped
configuration. Here's how you obtain a reference to it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Here's the approach for components:

\begin{verbatim}
@Reference(unbind = "-")
protected void setConfigurationProvider(ConfigurationProvider configurationProvider) {
    _configurationProvider = configurationProvider;
}
\end{verbatim}
\item
  Here's the approach for Service Builder services:

\begin{verbatim}
@ServiceReference(type = ConfigurationProvider.class)
protected ConfigurationProvider configurationProvider;
\end{verbatim}
\item
  For Spring beans, it is possible to use the same mechanism as for
  Service Builder services (\texttt{@ServiceReference}).
\item
  For anything else, call the same methods from the utility class,
  \texttt{ConfigurationProviderUtil}. Be sure you call the utility
  methods in contexts where the portal is guaranteed to be initialized
  prior to the method call. This class is useful in the
  \href{/docs/7-2/user/-/knowledge_base/u/running-scripts-from-the-script-console}{scripting
  console}, for example. Here's an example method that uses the utility
  class. It comes from the export-import service, which is only called
  during the import and export of content from a running portal:

\begin{verbatim}
protected boolean isValidateLayoutReferences() throws PortalException {
    long companyId = CompanyThreadLocal.getCompanyId();

    ExportImportServiceConfiguration exportImportServiceConfiguration =
        ConfigurationProviderUtil.getCompanyConfiguration(
            ExportImportServiceConfiguration.class, companyId);

    return exportImportServiceConfiguration.validateLayoutReferences();
}
\end{verbatim}
\end{enumerate}

To retrieve the configuration, use one of the following methods of the
provider:

\begin{description}
\tightlist
\item[\texttt{getCompanyConfiguration()}]
Used when you want to support different configurations per virtual
instance. In this case, the configuration is usually entered by an admin
through \emph{Control Panel} → \emph{Configuration} → \emph{Instance
Settings}.
\item[\texttt{getGroupConfiguration()}]
Used when you want to support different configurations per site (or, if
desired, per page scope). Usually this configuration is specified by an
admin through the Configuration menu option in an app accessing through
the site administration menu. That UI is developed as a portlet
configuration view.
\item[\texttt{getPortletInstanceConfiguration()}]
Used to obtain the configuration for a specific portlet instance. Most
often you should not be using this directly. Use the convenience method
in \texttt{PortletDisplay} instead as shown below.
\item[\texttt{getSystemConfiguration}]
Used to obtain the configuration for the system scope. These settings
are specified by an admin via the System Settings application or with an
OSGi configuration file.
\end{description}

Here are a couple real world examples from Liferay's source code:

\begin{verbatim}
JournalGroupServiceConfiguration configuration =
    configurationProvider.getGroupConfiguration(
        JournalGroupServiceConfiguration.class, groupId);

MentionsGroupServiceConfiguration configuration =
  _configurationProvider.getCompanyConfiguration(
     MentionsGroupServiceConfiguration.class, entry.getCompanyId());
\end{verbatim}

Next, you'll learn a nifty way to to access a portlet instance
configuration from a JSP.

\section{\texorpdfstring{Accessing the Portlet Instance Configuration
Through the
\texttt{PortletDisplay}}{Accessing the Portlet Instance Configuration Through the PortletDisplay}}\label{accessing-the-portlet-instance-configuration-through-the-portletdisplay}

Often you must access portlet instance settings from a JSP or from a
Java class that isn't an OSGi component. To read the settings in these
cases, a method was added to \texttt{PortletDisplay}, which is available
as a request object. Here is an example of how to use it:

\begin{verbatim}
RSSPortletInstanceConfiguration rssPortletInstanceConfiguration =
    portletDisplay.getPortletInstanceConfiguration(
        RSSPortletInstanceConfiguration.class);
\end{verbatim}

As you can see, it knows how to find the values and returns a typed bean
containing them just by passing the configuration class.

\chapter{Reading Unscoped Configuration Values from an MVC
Portlet}\label{reading-unscoped-configuration-values-from-an-mvc-portlet}

If your configuration is scoped to \texttt{SYSTEM} or is unscoped (which
amounts to the same thing), you have a couple of options for reading
configuration values. There are two ways to do this:

\begin{itemize}
\item
  Add a configuration to the request and read it from the view layer
  (commonly a JSP).
\item
  Read values directly from the portlet class.
\end{itemize}

This tutorial uses dummy code from a portlet we'll call the Example
Configuration Portlet. The import statements are included in the code
snippets so that you can see the fully qualified class names (FQCNs) of
all the classes that are used.

\section{Accessing the Configuration Object in the Portlet
Class}\label{accessing-the-configuration-object-in-the-portlet-class}

Whether you need the configuration values in the portlet class or the
JSPs, the first step is to get access to the configuration object in the
\texttt{*Portlet} class.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Imports first:

\begin{verbatim}
package com.liferay.docs.exampleconfig;

import java.io.IOException;
import java.util.Map;

import javax.portlet.Portlet;
import javax.portlet.PortletException;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;

import com.liferay.portal.kernel.portlet.bridges.mvc.MVCPortlet;

import com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil;
\end{verbatim}
\item
  MVC Portlet classes are Component classes. If you have a Bean Portlet
  or PortletMVC4Spring class, the configuration below goes in
  \texttt{portlet.xml} and \texttt{liferay-portlet.xml}. To mate the
  configuration with the Component, provide the
  \texttt{configurationPid} property with the FQCN of the configuration
  class.

\begin{verbatim}
@Component(
    configurationPid = "com.liferay.docs.exampleconfig.ExampleConfiguration",
    immediate = true,
    property = {
        "com.liferay.portlet.display-category=category.sample",
        "com.liferay.portlet.instanceable=true",
        "javax.portlet.security-role-ref=power-user,user",
        "javax.portlet.init-param.template-path=/",
        "javax.portlet.init-param.view-template=/view.jsp",
        "javax.portlet.resource-bundle=content.Language"
    },
    service = Portlet.class
)
public class ExampleConfigPortlet extends MVCPortlet {
\end{verbatim}

  Note that you can specify more than one configuration PID here by
  enclosing the values in curly braces (\texttt{\{\}}) and placing
  commas between each PID.
\item
  Write an \texttt{activate} method annotated with \texttt{@Activate}
  and \texttt{@Modified}. This ensures that the method is invoked when
  the Component is started, and again whenever the configuration is
  changed.

\begin{verbatim}
@Activate
@Modified
protected void activate(Map<String, Object> properties) {
    _configuration = ConfigurableUtil.createConfigurable(
    ExampleConfiguration.class, properties);
}

private volatile ExampleConfiguration _configuration;
\end{verbatim}
\end{enumerate}

A volatile field \texttt{\_configuration} is created by the
\texttt{createConfigurable} method. Now the field can be used to
retrieve configuration values or to set the values in the request, so
they can be retrieved in the application's JSPs.

\section{Accessing the Configuration from a
JSP}\label{accessing-the-configuration-from-a-jsp}

In the case of reading from a JSP, add the configuration object to the
request object so its values can be read from the JSPs that comprise the
application's view layer.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the configuration object to the request. Here's what it looks like
  in a simple portlet's \texttt{doView} method:

\begin{verbatim}
@Override
public void doView(RenderRequest renderRequest,
    RenderResponse renderResponse) throws IOException, PortletException {

    renderRequest.setAttribute(
        ExampleConfiguration.class.getName(), _configuration);

    super.doView(renderRequest, renderResponse);
}
\end{verbatim}

  The main difference between this example and the component class
  covered in the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/reading-unscoped-configuration-values-from-a-component}{next
  section} is that this class is a portlet class and it sets the
  configuration object as a request attribute in its \texttt{doView()}
  method.
\item
  Read configuration values from a JSP. First add these imports to the
  top of your \texttt{view.jsp} file:

\begin{verbatim}
<%@ page import="com.liferay.docs.exampleconfig.ExampleConfiguration" %>
<%@ page import="com.liferay.portal.kernel.util.GetterUtil" %>
\end{verbatim}
\item
  In the JSP, obtain the configuration object from the request object
  and read the desired configuration value from it. Here's a
  \texttt{view.jsp} file that does this:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<p>
    <b>Hello from the Example Configuration portlet!</b>
</p>

<%
ExampleConfiguration configuration = (ExampleConfiguration) GetterUtil.getObject(
    renderRequest.getAttribute(ExampleConfiguration.class.getName()));

String favoriteColor = configuration.favoriteColor();
%>

<p>Favorite color: <span style="color: <%= favoriteColor %>;"><%= favoriteColor %></span></p
\end{verbatim}
\end{enumerate}

The example code here would make the application display a message like
this:

\begin{verbatim}
Favorite color: blue
\end{verbatim}

The word \emph{blue} is written in blue text. Note that \emph{blue} is
displayed by default since you specified it as the default in your
\texttt{ExampleConfiguration} interface. If you go to \emph{Control
Panel} → \emph{Configuration} → \emph{System Settings} → \emph{Platform}
→ \emph{Third Party} and click on the \emph{Example configuration} link,
you can find the \texttt{Favorite\ color} setting and change its value.
The JSP reads the configuration, and refreshing the UI reflects this
update.

\section{Accessing the Configuration from the Portlet
Class}\label{accessing-the-configuration-from-the-portlet-class}

Now that you've seen a detailed example of accessing the configuration
values in a JSP, there's not much more to cover when accessing the
configuration directly in the \texttt{-Portlet} class. Wherever you
require the value of a configuration property, call
\texttt{\_configuration.propertyName} and you have access to the
currently configured value. For example, this code compares the
\texttt{favoriteColor} configuration value with a
\texttt{userFavoriteColor} that's fetched from the request object:

\begin{verbatim}
public boolean isFavoriteColorMatched {

    String userFavoriteColor = ParamUtil.getString(request, "userFavoriteColor");

    if (_configuration.favoriteColor() == userFavoriteColor) {

        SessionMessages.add(request, "congratulateUser");

        return true;
    }

    return false;
}
\end{verbatim}

It returns true and adds a success message if the two Strings match each
other, but you can do anything that makes sense for your application's
controller logic.

That's all there is to reading configuration values in a Portlet. The
next section covers reading configuration values from an OSGi Component
class that is not part of a portlet.

\chapter{Reading Unscoped Configuration Values from a
Component}\label{reading-unscoped-configuration-values-from-a-component}

Follow these steps to read \texttt{SYSTEM} scoped or unscoped
configuration values from a Component that isn't part of a portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First set the \texttt{configurationPid} Component property as the
  fully qualified class name of the configuration class:

\begin{verbatim}
@Component(configurationPid = "com.liferay.dynamic.data.mapping.form.web.configuration.DDMFormWebConfiguration")
\end{verbatim}
\item
  Then provide an \texttt{activate} method, annotated with
  \texttt{@Activate} to ensure the method is invoked as soon as the
  Component is started, and \texttt{@Modified} so it's invoked whenever
  the configuration is modified.

\begin{verbatim}
@Activate
@Modified
protected void activate(Map<String, Object> properties) {
    _formWebConfiguration = ConfigurableUtil.createConfigurable(
        DDMFormWebConfiguration.class, properties);
}

private volatile DDMFormWebConfiguration _formWebConfiguration;
\end{verbatim}

  The \texttt{activate()} method calls the method
  \texttt{ConfigurableUtil.createConfigurable()} to convert a map of the
  configuration's properties to a typed class, which is easier to
  handle. The configuration is stored in a \texttt{volatile} field.
  Don't forget to make it \texttt{volatile} to prevent thread safety
  problems.
\item
  Once the activate method is set up, retrieve particular properties
  from the configuration wherever they're needed:

\begin{verbatim}
public void orderCar(String model) {
    order("car", model, _configuration.favoriteColor());
}
\end{verbatim}

  This is dummy code: don't try to find it in the Liferay source code.
  The String configuration value of \texttt{favoriteColor} is passed to
  the \texttt{order} method call, presumably so that whatever model car
  is ordered gets ordered in the configured favorite color.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} The bnd library also provides a class called
\texttt{aQute.bnd.annotation.metatype.Configurable} with a
\texttt{createConfigurable()} method. You can use that instead of
Liferay's
\texttt{com.liferay.portal.configuration.metatype.bnd.util.ConfigurableUtil}
without any problems. Liferay's developers created the
\texttt{ConfigurableUtil} class to improve the performance of bnd's
implementation, and it's used in internal code. Feel free to use
whichever method you prefer.

\noindent\hrulefill

With very few lines of code, you have a configurable application that
dynamically changes its configuration, has an auto-generated UI, and
uses a simple API to access the configuration.

\chapter{Customizing the Configuration User
Interface}\label{customizing-the-configuration-user-interface}

There are three ways to customize a configuration UI.

\begin{itemize}
\item
  Provide a custom form for a configuration object. This modifies the
  auto-generated UI.
\item
  Write a completely custom configuration UI. This is useful especially
  if you aren't using the Configuration Admin service or any of
  Liferay's Configuration APIs.
\item
  Exclude a configuration object. You'll want this option if you're
  using a configuration interface but don't wan't a UI generated for
  you.
\end{itemize}

\section{Providing Custom Configuration
Forms}\label{providing-custom-configuration-forms}

Customize your auto-generated UI by implementing the
\texttt{ConfigurationFormRender} interface. To write this interface, you
must refer to your configuration interface. For this example, refer to
this configuration interface from Liferay's Currency Converter
application:

\begin{verbatim}
@ExtendedObjectClassDefinition(category = "localization")
@Meta.OCD(
    id = "com.liferay.currency.converter.web.configuration.CurrencyConverterConfiguration",
    localization = "content/Language",
    name = "currency-converter-configuration-name"
)
public interface CurrencyConverterConfiguration {

    @Meta.AD(deflt = "GBP|CNY|EUR|JPY|USD", name = "symbols", required = false)
    public String[] symbols();
}
\end{verbatim}

This example defines one configuration option, \texttt{symbols}, which
takes an array of values.

Implement \texttt{ConfigurationFormRenderer}'s three methods:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{getPid}: Return the configuration object's ID. This is defined
  in the \texttt{id} property in the \texttt{*Configuration} class's
  \texttt{@Meta.OCD} annotation.
\item
  \texttt{getRequestParameters}: Read the parameters sent by the custom
  form and put them in a Map whose keys should be the method names of
  the Configuration interface.
\item
  \texttt{render}: Render the custom form's fields, using your desired
  method (for example, JSPs or another template mechanism). The
  \texttt{\textless{}form\textgreater{}} tag itself is provided
  automatically and shouldn't be included in the
  \texttt{ConfigurationFormRenderer}.
\end{enumerate}

Here's a complete \texttt{ConfigurationFormRenderer} implementation:

\begin{verbatim}
@Component(immediate = true, service = ConfigurationFormRenderer.class)
public class CurrencyConverterConfigurationFormRenderer
    implements ConfigurationFormRenderer {

    @Override
    public String getPid() {
        return "com.liferay.currency.converter.web.configuration.CurrencyConverterConfiguration";
    }

    @Override
    public void render(HttpServletRequest request, HttpServletResponse response)
            throws IOException {
            
        String formHtml = "<input name=\"mysymbols\" />";

        PrintWriter writer = response.getWriter();

        writer.print(formHtml);

    }

    @Override
    public Map<String, Object> getRequestParameters(
            HttpServletRequest request) {

        Map<String, Object> params = new HashMap<>();

        String[] mysymbols = ParamUtil.getParameterValues(request, "mysymbols");

        params.put("symbols", mysymbols);

        return params;
    }
}
\end{verbatim}

The above example generates a custom rendering (HTML) for the form in
the \texttt{render()} method and reads the information entered in the
custom form in the \texttt{getRequestParameters()} method.

To see a complete demonstration, including JSP markup, read the
dedicated tutorial on creating a
\href{/docs/7-2/frameworks/-/knowledge_base/f/configuration-form-renderer}{configuration
form renderer}.

\section{Creating a Completely Custom Configuration
UI}\label{creating-a-completely-custom-configuration-ui}

You get more flexibility if you create a completely custom UI using a
\texttt{ConfigurationScreen} implementation.

At a high level you must

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a Component that declares itself an implementation of the
  \texttt{ConfigurationScreen} interface.
\item
  Implement \texttt{ConfigurationScreen}'s methods.
\item
  Create the UI by hand.
\end{enumerate}

Here's an example implementation:

\begin{verbatim}
@Component(immediate = true, service = ConfigurationScreen.class) 
public class SampleConfigurationScreen implements ConfigurationScreen {
\end{verbatim}

First declare the class an implementation of
\texttt{ConfigurationScreen}.

\begin{verbatim}
@Override 
public String getCategoryKey() { 

    return "third-party"; 

}

@Override 
public String getKey() { 

    return "sample-configuration-screen"; 

}

@Override 
public String getName(Locale locale) { 

    return "Sample Configuration Screen"; 

}
\end{verbatim}

Second, set the category key, the configuration entry's key, and its
localized name. This example puts the configuration entry, keyed
\texttt{sample-configuration-screen}, into the \texttt{third-party}
System Settings section. The String that appears in System Settings is
\emph{Sample Configuration Screen}.

\begin{verbatim}
@Override 
public String getScope() { 

    return "system"; 

}
\end{verbatim}

Third, set the
\href{/docs/7-2/frameworks/-/knowledge_base/f/scoping-configurations}{configuration
scope}.

\begin{verbatim}
@Override 
public void render(HttpServletRequest request, HttpServletResponse response) 
        throws IOException {

    _jspRenderer.renderJSP( _servletContext, request, response,
    "/sample_configuration_screen.jsp"); 

}

@Reference private JSPRenderer _jspRenderer;

@Reference(
    target ="(osgi.web.symbolicname=com.liferay.currency.converter.web)", 
    unbind = "-")
private ServletContext _servletContext;
\end{verbatim}

The most important step is to write the \texttt{render} method. This
example relies on the \texttt{JSPRenderer} service to delegate rendering
to a JSP.

It's beyond the scope of this tutorial to write the JSP markup. A
separate tutorial will provide a complete demonstration of the
\texttt{ConfigurationScreen} and implementation and the JSP markup to
demonstrate its usage.

\section{Excluding a Configuration
UI}\label{excluding-a-configuration-ui}

If you don't want a UI to be generated for you, you have two options.

\begin{itemize}
\item
  If you don't want a UI generated no matter what, use the
  \texttt{generateUI} property.
\item
  If you only want the UI to render under specific circumstances
  (defined by logic you'll write yourself), use the configuration
  visibility SPI.
\end{itemize}

\section{\texorpdfstring{Using
\texttt{generateUI}}{Using generateUI}}\label{using-generateui}

To turn off auto-generating at all scopes, include the
\texttt{ExtendedObjectClassDefinition} annotation property
\texttt{generateUI} in your configuration interface. The property
defaults to \texttt{true}; here is an example setting it to
\texttt{false}:

\begin{verbatim}
@ExtendedObjectClassDefinition(generateUI=false)
@Meta.OCD(
  id = "com.foo.bar.LowLevelConfiguration",
)
public interface LowLevelConfiguration {

  public String[] foo();
  public String bar();

}
\end{verbatim}

Now no UI is auto-generated for this configuration. You can still manage
the configuration via a \texttt{ConfigurationScreen} implementation, a
\href{/docs/7-2/user/-/knowledge_base/u/understanding-system-configuration-files}{.config
file}, or programmatically.

\section{Using the Configuration Visibility
SPI}\label{using-the-configuration-visibility-spi}

The configuration visibility SPI involves implementing a single
interface, \texttt{ConfigurationVisibilityController}. You can see the
whole interface
\href{https://github.com/liferay/liferay-portal/blob/48cd71b35a2d3b66e88f47685be7186cb7c52075/modules/apps/configuration-admin/configuration-admin-api/src/main/java/com/liferay/configuration/admin/display/ConfigurationVisibilityController.java}{here}.

To implement the interface, you must identify your configuration
interface using an \texttt{@Component} property, then write your own
logic for the interface's only method, \texttt{isVisible}. Here is a
sample implementation from Liferay's source code:

\begin{verbatim}
@Component(
    immediate = true,
    property = "configuration.pid=com.liferay.sharing.internal.configuration.SharingCompanyConfiguration",
    service = ConfigurationVisibilityController.class
)
public class SharingCompanyConfigurationVisibilityController
    implements ConfigurationVisibilityController {

    @Override
    public boolean isVisible(
        ExtendedObjectClassDefinition.Scope scope, Serializable scopePK) {

        SharingConfiguration systemSharingConfiguration =
            _sharingConfigurationFactory.getSystemSharingConfiguration();

        return systemSharingConfiguration.isEnabled();
    }

    @Reference
    private SharingConfigurationFactory _sharingConfigurationFactory;

}
\end{verbatim}

Note that the property \texttt{configuration.pid} identifies the
configuration interface of the UI to be hidden. In this example, the
configuration UI only renders when
\texttt{systemSharingConfiguration.isEnabled} returns \texttt{true}.

\chapter{Configuration Form Renderer}\label{configuration-form-renderer}

To replace an application's auto-generated configuration screen with a
form built from scratch, you follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use a \texttt{DisplayContext} class to transfer data between back-end
  code and the desired JSP markup.
\item
  Implement the \texttt{ConfigurationFormRenderer} interface.
\item
  Render the configuration form. This tutorial demonstrates the use of a
  JSP and the previously created \texttt{DisplayContext} class.
\end{enumerate}

A generalized discussion on System Settings UI customization is found in
a
\href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-the-configuration-user-interface}{separate
section}.

This article demonstrates replacing the configuration UI for the
\emph{Language Template} System Settings entry, found in \emph{Control
Panel} → \emph{Configuration} → \emph{System Settings} →
\emph{Localization} → \emph{Language Template}. The same steps apply
when replacing your custom application's auto-generated UI.

\begin{figure}
\centering
\includegraphics{./images/sys-settings-lang-template-default.png}
\caption{The auto-generated UI for the Language Template configuration
screen is sub-optimal. A select list with more human readable options is
preferable.}
\end{figure}

Specifically, the text input field labeled \emph{DDM Template Key} in
the auto-generated UI is replaced with a select list field type called
\emph{Language Selection Style}, populated with all possible DDM
Template Keys.

\section{\texorpdfstring{Creating a
\texttt{DisplayContext}}{Creating a DisplayContext}}\label{creating-a-displaycontext}

A \texttt{DisplayContext} class is a POJO that simplifies and minimizes
the use of Java logic in JSPs. Display context usage isn't required, but
it's a nice convention to follow. It's a kind of data transfer object,
where the \texttt{DisplayContext}'s setters are called from the Java
class providing the render logic (in this case the
\texttt{ConfigurationFormRenderer}'s \texttt{render} method), and the
getters are called from the JSP, removing the need for Java logic to be
written inside the JSP itself.

For this example, create a
\texttt{LanguageTemplateConfigurationDisplayContext} class with these
contents:

\begin{verbatim}
public class LanguageTemplateConfigurationDisplayContext {

    public void addTemplateValue(
        String templateKey, String templateDisplayName) {

        _templateValues.add(new String[] {templateKey, templateDisplayName});
    }

    public String getCurrentTemplateName() {
        return _currentTemplateName;
    }

    public String getFieldLabel() {
        return _fieldLabel;
    }

    public List<String[]> getTemplateValues() {
        return _templateValues;
    }

    public void setCurrentTemplateName(String currentTemplateName) {
        _currentTemplateName = currentTemplateName;
    }

    public void setFieldLabel(String fieldLabel) {
        _fieldLabel = fieldLabel;
    }

    private String _currentTemplateName;
    private String _fieldLabel;
    private final List<String[]> _templateValues = new ArrayList<>();

}
\end{verbatim}

Next implement the \texttt{ConfigurationFormRenderer}.

\section{\texorpdfstring{Implementing a
\texttt{ConfigurationFormRenderer}}{Implementing a ConfigurationFormRenderer}}\label{implementing-a-configurationformrenderer}

First create the component and class declarations. Set the
\texttt{service} property to \texttt{ConfigurationFormRenderer.class}:

\begin{verbatim}
@Component(
    configurationPid = "com.liferay.site.navigation.language.web.configuration.SiteNavigationLanguageWebTemplateConfiguration",
    immediate = true, service = ConfigurationFormRenderer.class
)
public class LanguageTemplateConfigurationFormRenderer
    implements ConfigurationFormRenderer {
\end{verbatim}

Next, write an \texttt{activate} method (decorated with
\texttt{@Activate} and \texttt{@Modified}) to convert a map of the
configuration's properties to a typed class. The configuration is stored
in a volatile field. Don't forget to make it volatile to prevent thread
safety problems. See the article on
\href{/docs/7-2/frameworks/-/knowledge_base/f/reading-unscoped-configuration-values-from-a-component}{reading
configuration values from a component class} for more information.

\begin{verbatim}
@Activate
@Modified
public void activate(Map<String, Object> properties) {
    _siteNavigationLanguageWebTemplateConfiguration =
        ConfigurableUtil.createConfigurable(
            SiteNavigationLanguageWebTemplateConfiguration.class,
            properties);
}

private volatile SiteNavigationLanguageWebTemplateConfiguration
    _siteNavigationLanguageWebTemplateConfiguration;
\end{verbatim}

Next override the \texttt{getPid} and \texttt{getRequestParameters}
methods:

\begin{verbatim}
@Override
public String getPid() {
    return "com.liferay.site.navigation.language.web.configuration." +
        "SiteNavigationLanguageWebTemplateConfiguration";
}
\end{verbatim}

Return the full configuration ID, as specified in the
\texttt{*Configuration} class's \texttt{@Meta.OCD} annotation.

\begin{verbatim}
@Override
public Map<String, Object> getRequestParameters(
    HttpServletRequest request) {

    Map<String, Object> params = new HashMap<>();

    String ddmTemplateKey = ParamUtil.getString(request, "ddmTemplateKey");

    params.put("ddmTemplateKey", ddmTemplateKey);

    return params;
}
\end{verbatim}

In the \texttt{getRequestParameters} method, map the parameters sent by
the custom form (obtained from the request) to the keys of the fields in
the Configuration interface.

Provide the render logic via the overridden \texttt{render} method. The
rendering approach demonstrated here uses a JSP. Recall that it's backed
by a \texttt{DisplayContext} class set into the request object. The
values set from this \texttt{render} method are available in the JSP via
the \texttt{DisplayContext} object's getters.

Loop through the DDM Template Keys for the given \texttt{groupId} and
set them into the display context with the \texttt{addTemplateKey}
method. Then set the other necessary values that the JSP needs. In this
case, set the title, the field label, and the redirect URL. Finally,
call \texttt{renderJSP} and pass in the \texttt{servletContext},
request, response, and the path to the JSP:

\begin{verbatim}
@Override
public void render(HttpServletRequest request, HttpServletResponse response)
    throws IOException {

    Locale locale = request.getLocale();

    LanguageTemplateConfigurationDisplayContext
        languageTemplateConfigurationDisplayContext =
            new LanguageTemplateConfigurationDisplayContext();

    languageTemplateConfigurationDisplayContext.setCurrentTemplateName(
        _siteNavigationLanguageWebTemplateConfiguration.ddmTemplateKey());

    long groupId = 0;

    long companyId = _portal.getCompanyId(actionRequest);

    Group group = _groupLocalService.fetchCompanyGroup(companyId);

    if (group != null) {
        groupId = group.getGroupId();
    }

    List<DDMTemplate> ddmTemplates = _ddmTemplateLocalService.getTemplates(
        groupId, _portal.getClassNameId(LanguageEntry.class));

    for (DDMTemplate ddmTemplate : ddmTemplates) {
        languageTemplateConfigurationDisplayContext.addTemplateValue(
            ddmTemplate.getTemplateKey(), ddmTemplate.getName(locale));
    }

    languageTemplateConfigurationDisplayContext.setFieldLabel(
        LanguageUtil.get(
            ResourceBundleUtil.getBundle(
                locale, LanguageTemplateConfigurationFormRenderer.class),
            "language-selection-style"));

    request.setAttribute(
        LanguageTemplateConfigurationDisplayContext.class.getName(),
        languageTemplateConfigurationDisplayContext);

    _jspRenderer.renderJSP(
        _servletContext, request, response,
        "/configuration/site_navigation_language_web_template.jsp");
}
\end{verbatim}

Specify the required service references at the bottom of the class. Be
careful to target the proper servlet context, passing the
\texttt{bundle-SymbolicName} of the module (found in its
\texttt{bnd.bnd} file) into the \texttt{osgi.web.symbolicname} property
of the reference target:

\begin{verbatim}
@Reference
private DDMTemplateLocalService _ddmTemplateLocalService;

@Reference
private GroupLocalService _groupLocalService;

@Reference
private JSPRenderer _jspRenderer;

@Reference
private Portal _portal;

@Reference(
    target = "(osgi.web.symbolicname=com.liferay.site.navigation.language.web)",
    unbind = "-"
)
private ServletContext _servletContext;
\end{verbatim}

Once the configuration form renderer is implemented, you can write the
JSP markup for the form.

\section{Writing the JSP Markup}\label{writing-the-jsp-markup}

Now write the JSP:

\begin{verbatim}
<%@ include file="/init.jsp" %>

<%
LanguageTemplateConfigurationDisplayContext
    languageTemplateConfigurationDisplayContext = (LanguageTemplateConfigurationDisplayContext)request.getAttribute(LanguageTemplateConfigurationDisplayContext.class.getName());

Admin: Instance Settings    String currentTemplateName = languageTemplateConfigurationDisplayContext.getCurrentTemplateName();
%>

<aui:select label="<%= HtmlUtil.escape(languageTemplateConfigurationDisplayContext.getFieldLabel()) %>" name="ddmTemplateKey" value="<%= currentTemplateName %>">

    <%
    for (String[] templateValue : languageTemplateConfigurationDisplayContext.getTemplateValues()) {
    %>

        <aui:option label="<%= templateValue[1] %>" selected="<%= currentTemplateName.equals(templateValue[0]) %>" value="<%= templateValue[0] %>" />

    <%
    }
    %>

</aui:select>
\end{verbatim}

The opening scriptlet gets the display context object from the request
so that all its getters are invoked whenever information from the
back-end is required. Right away, the \texttt{getCurrentTemplateName}
method is called, since the current template name is needed for the
first option's \texttt{ddmTemplateKey} display value as soon as the form
is rendered. This happens in the
\texttt{\textless{}aui:select\textgreater{}} tag. There's just a bit of
logic used to create an option for each of the available DDM templates
that can be chosen.

So what does this example look like when all is said and done?

\begin{figure}
\centering
\includegraphics{./images/sys-settings-lang-template-custom.png}
\caption{A select list provides a more user friendly configuration
experience than a text field.}
\end{figure}

Now, administrators encountering the Language Template entry in System
Settings won't be handicapped by not knowing the available DDM Template
Keys. Providing the available values in a select field wildly enhances
the user experience.

\chapter{Using DDM Form Annotations in Configuration
Forms}\label{using-ddm-form-annotations-in-configuration-forms}

The auto-generated configuration form you get by just creating a
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-configuration-interface}{configuration
interface} can be too simplistic for some configurations. To enhance it,
use the Dynamic Data Mapping (DDM) Form Annotations.

To use DDM Annotations in configuration forms,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Configure the module dependencies.
\item
  Write a \texttt{ConfigurationForm} class, including just the fields
  that you want to leverage the enhanced forms capability. This is
  similar to the configuration interface, but with field annotations
  from the Liferay
  \href{https://github.com/liferay/liferay-portal/tree/7.2.0-ga1/modules/apps/dynamic-data-mapping/dynamic-data-mapping-api/src/main/java/com/liferay/dynamic/data/mapping/annotations}{Dynamic
  Data Mapping API} rather than the bndtools metatype specification. The
  fields here must match fields defined in the configuration interface.
\item
  Implement a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/configuration-admin/configuration-admin-api/src/main/java/com/liferay/configuration/admin/definition/ConfigurationDDMFormDeclaration.java}{\texttt{ConfigurationDDMFormDeclaration}}
  to mark your configuration as having a \texttt{ConfigurationForm}.
\end{enumerate}

This article assumes you already have an auto-generated configuration
UI.

Note that the example code here splits up the Configuration interface
and the Configuration Form interface. If you'd rather mash these
together into one class, you can. This approach might make sense if you
have a small number of fields in your configuration and a simple form to
create. If you have numerous configuration fields and/or a complex form
to create, or if you're taking an existing configuration and extending
it to use the DDM Form annotations, you can consider separating the
classes, as shown here.

\section{Step 1: Declare the
Dependencies}\label{step-1-declare-the-dependencies}

In the \texttt{build.gradle} file, add \texttt{compileOnly} dependencies
on the \texttt{dynamic-data-mapping-api} and
\texttt{configuration-admin-api} module artifacts:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.dynamic.data.mapping.api", version: "5.2.0"
compileOnly group: "com.liferay", name: "com.liferay.configuration.admin.api", version: "2.0.2"
\end{verbatim}

\section{Step 2: Write the Configuration
Form}\label{step-2-write-the-configuration-form}

This step requires annotating the class with \texttt{@DDMForm} to set up
the form, and annotating each method with \texttt{@DDMFormField}. Begin
by creating the class body, annotating each configuration field
(interface method) with \texttt{@DDMFormField}:

\begin{verbatim}
public interface MyFooConfigurationForm {

    @DDMFormField(
        label = "%label-key-for-field-1",
        tip = "%description-key-for-field-1",
        properties = {

            "placeholder=%enter-a-value",
            "tooltip=%some-tooltip-text"
        }
    )
    public String[] textArrayValues();

    @DDMFormField(
        label = "%date",
        tip = "%date-description",
        type = "date")
    public String date();

    @DDMFormField(
        label = "%select",
        optionLabels = {"%foo", "%bar"},
        optionValues = {"foo", "bar"},
        type = "select")
    public String select();

    @DDMFormField(
        label = "%numeric",
        properties = {
            "placeholder=%milliseconds",
            "tooltip=%enter-an-integer-between-1000-and-30000"
        },
        validationErrorMessage = "%please-enter-an-integer-between-1000-and-30000-milliseconds",
        validationExpression = "(numeric >= 1000) && (numeric <= 30000)",
        type = "numeric")
    public String numeric();

    @DDMFormField(
        label = "%checkbox",
        properties = "showAsSwitcher=true")
    public boolean checkbox();

}
\end{verbatim}

Once the field annotations are in place, lay out the form itself, right
above the class declaration. This example shows the layout of the
\texttt{UserFileUploadsConfigurationForm}, so that you can see the
resulting form via the below screenshot:

\begin{verbatim}
@DDMForm
@DDMFormLayout(
    paginationMode = com.liferay.dynamic.data.mapping.model.DDMFormLayout.SINGLE_PAGE_MODE,
    value = {
        @DDMFormLayoutPage(
            {
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 12,
                            value = {
                                "imageCheckToken", "imageDefaultUseInitials",
                                "imageMaxSize"
                            }
                        )
                    }
                ),
                @DDMFormLayoutRow(
                    {
                        @DDMFormLayoutColumn(
                            size = 6, value = "imageMaxHeight"
                        ),
                        @DDMFormLayoutColumn(size = 6, value = "imageMaxWidth")
                    }
                )
            }
        )
    }
)
public interface MyFooConfigurationForm {
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/configuration-ddm-form.png}
\caption{The DDM annotations are used to lay out this configuration
form.}
\end{figure}

Next, you must make sure the configuration framework knows about your
slick form.

\section{Step 3: Write the Form
Declaration}\label{step-3-write-the-form-declaration}

Create a new implementation of \texttt{ConfigurationDDMFormDeclaration}
to register your new configuration form class:

\begin{verbatim}
package com.liferay.docs.my.foo.configuration.definition;

import com.liferay.configuration.admin.definition.ConfigurationDDMFormDeclaration;
import org.osgi.service.component.annotations.Component;
...

@Component(
    immediate = true,
    property = "configurationPid=com.liferay.docs.my.foo.configuration.MyFooConfiguration",
    service = ConfigurationDDMFormDeclaration.class
)
public class MyFooConfigurationDDMFormDeclaration
    implements ConfigurationDDMFormDeclaration {

    @Override
    public Class<?> getDDMFormClass() {
        return MyFooConfigurationForm.class;
    }

}
\end{verbatim}

The \texttt{configurationPid} must match the fully qualified class name
of the configuration interface.

Now your configuration class is backed by the form-building power of
Liferay's native \href{/docs/7-2/user/-/knowledge_base/u/forms}{Forms
application}.

To see how this is done for one of Liferay's own configurations, check
out all of the configuration classes for the User Images configuration
(Control Panel → Configuration → System Settings → User Images):

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/users-admin/users-admin-api/src/main/java/com/liferay/users/admin/configuration/definition/UserFileUploadsConfigurationForm.java}{\texttt{UserFileUploadsConfigurationForm}}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/users-admin/users-admin-api/src/main/java/com/liferay/users/admin/configuration/UserFileUploadsConfiguration.java}{\texttt{UserFileUploadsConfiguration.java}}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/users-admin/users-admin-web/src/main/java/com/liferay/users/admin/web/internal/configuration/definition/UserFileUploadsConfigurationBeanDeclaration.java}{\texttt{UserFileUploadsConfigurationBeanDeclaration.java}}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/users-admin/users-admin-web/src/main/java/com/liferay/users/admin/web/internal/configuration/definition/UserFileUploadsConfigurationDDMFormDeclaration.java}{\texttt{UserFileUploadsConfigurationDDMFormDeclaration.java}}

\chapter{Upgrading a Legacy App}\label{upgrading-a-legacy-app}

If you have an app that was made configurable under an earlier version
of Liferay DXP, you can upgrade without having to reconfigure any of
your app's instances.

If you have an app that was configurable using the mechanisms of Liferay
Portal 6.2 and before, refer to
\href{/docs/7-0/tutorials/-/knowledge_base/t/transitioning-from-portlet-preferences-to-the-configuration-api}{Transitioning
from Portlet Preferences to the Configuration API}.

If you have an app with a configuration interface scoped to anything
other than \texttt{SYSTEM} and a custom UI for saving configuration
values to \texttt{PortletPreferences}, you have two options:

\begin{itemize}
\item
  Keep using your custom UI. Deactivate the auto-generated UI in
  \emph{Instance Settings} by setting the scope in your configuration
  interface to \texttt{SYSTEM}. This is quick and easy, but won't make
  your code easier to maintain in the long term.

  For other ways to disable the auto-generated UI, see
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-the-configuration-user-interface\#excluding-a-configuration-ui}{Excluding
  a Configuration UI}
\item
  Write an Upgrade Process to convert your configuration values in
  \texttt{PortletPreferences} to an instance-scoped OSGi configuration,
  using the \texttt{saveCompanyConfiguration} method in the
  \texttt{ConfigurationProvider} interface.
\end{itemize}

\noindent\hrulefill

You don't have to use \texttt{saveCompanyConfiguration}, but doing so
meets all the necessary requirements for an upgrade process: it must be
a factory instance with a factory PID of
\texttt{Unknown\ macro:{[}base-pid{]}.scoped}, and it must contain a
\texttt{companyId} property.

\noindent\hrulefill

Then remove your custom UI. If you're reading configuration values using
\texttt{ConfigurationProvider}'s \texttt{getCompanyConfiguration}
method, the auto-generated UI picks up where you left off, with no need
to reconfigure anything.

\chapter{Dynamically Populating Select List Fields in the Configuration
UI}\label{dynamically-populating-select-list-fields-in-the-configuration-ui}

You've always been able to provide a select list for your configuration
options by entering each label and value directly in the
\texttt{@Meta.AD} annotation of the
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-configuration-interface}{Configuration
interface}.

\begin{verbatim}
@Meta.AD(
    deflt = "enabled-with-warning", name = "csv-export",
    optionLabels = {"enabled", "enabled-with-warning", "disabled"},
    optionValues = {"enabled", "enabled-with-warning", "disabled"},
    required = false
)
public String csvExport();
\end{verbatim}

Now, thanks to the
\href{https://docs.liferay.com/dxp/apps/configuration-admin/latest/javadocs/com/liferay/configuration/admin/definition/ConfigurationFieldOptionsProvider.html}{\texttt{ConfigurationFieldOptionsProvider}
interface}, you can populate select list configurations dynamically,
using custom logic.

Follow these steps to populate the select list fields dynamically in
your configuration UI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use an \texttt{@Component} annotation to register the
  \texttt{ConfigurationFieldOptionsProvider.class} service and include
  two properties:

  \texttt{configuration.field.name}: The name of the attribute in the
  configuration interface

  \texttt{configuration.pid}: The ID of the corresponding configuration
  interface (usually the fully qualified class name)

  For example,

\begin{verbatim}
@Component(
    property = {
        "configuration.field.name=enabledClassNames",
        "configuration.pid=com.liferay.asset.auto.tagger.google.cloud.natural.language.internal.configuration.GCloudNaturalLanguageAssetAutoTaggerCompanyConfiguration",
        "configuration.pid=com.liferay.asset.auto.tagger.opennlp.internal.configuration.OpenNLPDocumentAssetAutoTaggerCompanyConfiguration"
    },
    service = ConfigurationFieldOptionsProvider.class
)
\end{verbatim}
\item
  Implement the \texttt{ConfigurationFieldOptionsProvider} interface:

\begin{verbatim}
public class MyConfigurationFieldOptionsProvider implements 
ConfigurationFieldOptionsProvider {
    ..
}
\end{verbatim}
\item
  The \texttt{getOptions} method returns a list of \texttt{Option}s
  consisting of the label and value fields. The labels provided here are
  translated to \texttt{optionLabels}, and the values as
  \texttt{optionValues}, in the configuration interface.

\begin{verbatim}
public List<Option> getOptions() {
    List<AssetRendererFactory<?>> assetRendererFactories =
        AssetRendererFactoryRegistryUtil.getAssetRendererFactories(
            CompanyThreadLocal.getCompanyId());

    Stream<AssetRendererFactory<?>> stream =
        assetRendererFactories.stream();

    return stream.filter(
        assetRendererFactory -> {
            TextExtractor textExtractor =
                _textExtractorTracker.getTextExtractor(
                    assetRendererFactory.getClassName());

            return textExtractor != null;
        }
    ).map(
        assetRendererFactory -> new Option() {

            @Override
            public String getLabel(Locale locale) {
                return assetRendererFactory.getTypeName(locale);
            }

            @Override
            public String getValue() {
                return assetRendererFactory.getClassName();
            }

        }
    ).collect(
        Collectors.toList()
    );
}
\end{verbatim}

  This code gets a list of \texttt{AssetRendererFactory} objects and
  iterates through the list, populating a new list of \texttt{Option}s,
  using the asset's type name as the label and the class name as the
  value. It comes from the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/asset/asset-auto-tagger-service/src/main/java/com/liferay/asset/auto/tagger/internal/configuration/admin/definition/EnabledClassNamesConfigurationFieldOptionsProvider.java}{\texttt{EnabledClassNamesConfigurationFieldOptionsProvider}},
  which populates the configuration field labeled \emph{Enable Google
  Cloud Natural Language Text Auto Tagging For} with all the asset types
  that have registered a \texttt{TextExtractor}.

  \begin{figure}
  \centering
  \includegraphics{./images/configuration-field-options-provider.png}
  \caption{The select list in the Google Cloud Natural Language Text
  Auto Tagging entry is populated programmatically, using the
  \texttt{ConfigurationFieldOptionsProvider}.}
  \end{figure}
\end{enumerate}

The \texttt{ConfigurationFieldOptionsProvider} allows you to populate
select lists with configuration options defined by your custom logic.

\chapter{Content Publication
Management}\label{content-publication-management}

Managing content publication is primarily controlled by two frameworks:

\begin{itemize}
\tightlist
\item
  \hyperref[exportimport]{Export/Import}
\item
  \hyperref[staging]{Staging}
\end{itemize}

These features give you the power to plan page publication and manage
content. You can leverage the APIs offered by these frameworks to manage
your app's publication process.

The Export/Import and Staging frameworks are closely tied together. They
both implement the same interfaces and share the same extension points.
By implementing one of these frameworks in your app, you automatically
leverage the other. There are a few simple configurations that can be
set to customize them separately. You'll learn about this later.

Export/Import can be viewed as the base feature with Staging built on
top of it (although they're implemented together). You can visit the
\href{/docs/7-2/frameworks/-/knowledge_base/f/export-import}{Export/Import}
framework's articles for the base APIs that both it and the Staging
frameworks share. You must implement these to implement Staging.
Reference the
\href{/docs/7-2/frameworks/-/knowledge_base/f/staging}{Staging}
framework's articles for additional configuration pertaining only to it.

Here are a few of the things you can do with the Export/Import and
Staging APIs.

\section{Export/Import}\label{exportimport}

The Export/Import feature adds another dimension to your application by
providing a framework for producing reusable content and importing
content from other places. By creating
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-archive-lar-file}{LAR
files (Liferay ARchive)}, you can export your data, import it to another
system, or even use this feature to back up your content.

\begin{figure}
\centering
\includegraphics{./images/export-import-preview.png}
\caption{Leveraging the Export/Import feature in your app is useful for
sharing content.}
\end{figure}

Export/Import is a default feature for many of Liferay DXP's
out-of-the-box apps. It offers an intuitive GUI for managing
export/import processes and tracking the history of previous
export/imports. You can also easily pick subsets of data to export based
on content type, date range, and configurations. Importing content is
done using a modern drag-and-drop interface or by selecting the LAR file
from your file system.

\section{Staging}\label{staging}

Staging gives you a test environment where you can modify your site and
test different configurations without changing your live site. When you
implement Staging in your app, its content can be tracked by the staged
environment, allowing users to stage your app's data before releasing it
to the world.

Here's an example of some functionality you can add to your app with
Staging's APIs:

\begin{itemize}
\tightlist
\item
  Local Staging environment tracking
\item
  Remote Staging environment tracking
\item
  Single asset publishing
\item
  Content tracking on page variations
\end{itemize}

Continue on to learn more about the frameworks that bring content
publication management to life!

\chapter{Export/Import}\label{exportimport-1}

The Export/Import feature exports content from the portal and imports
external content into the portal. Your application is much more site
administrator-friendly if users can export/import your application's
assets. For example, if you want to export your application's assets to
use on another installation or you must clear its data but save a copy,
you can implement the export feature. Implementing the import feature
lets you bring your assets/data back into your application.

Here's what you'll learn to do with the Export/Import framework:

\begin{itemize}
\tightlist
\item
  Create Staged Models
\item
  Develop Portlet Data Handlers
\item
  Develop Staged Model Data Handlers
\item
  Provide entity-specific local services for Export/Import framework
\item
  Listen to export/import events
\item
  Initiate new export/import processes programmatically
\end{itemize}

\section{Staged Models}\label{staged-models}

To track an entity of an application with the Export/Import framework,
you must implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{\texttt{StagedModel}}
interface in the app's model classes. It provides the behavior contract
for entities during the Export/Import and Staging processes. There are
two ways to create staged models for your application's entities:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/generating-staged-models-using-service-builder}{Generate
  them using Service Builder}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-models-manually}{Implement
  the appropriate interfaces manually}
\end{itemize}

Using Service Builder to generate your staged models is the easiest way
to create staged models for your app. You define the necessary columns
in your \texttt{service.xml} file and set the \texttt{uuid} attribute to
\texttt{true}. Then you run Service Builder, which generates the
required code for your new staged models.

Implementing the necessary staged model logic \emph{manually} should be
done if you \textbf{don't} want to extend your model with special
attributes only required to generate Staging logic (i.e., not needed by
your business logic). In this case, you should adapt your business logic
to meet the Staging framework's needs.

See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models}{Developing
Staged Models} section for more information on the Staged Model
architecture.

\section{Data Handlers}\label{data-handlers}

You must implement Data Handlers to use the Export/Import framework to
process
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-archive-lar-file}{LAR
files} in your application. There are two types of data handlers:

\begin{itemize}
\tightlist
\item
  Portlet Data Handlers
\item
  Staged Model Data Handlers
\end{itemize}

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes query and coordinate between staged model data
handlers. They also configure the Export/Import and Staging UI options.

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defining a display name for the
UI, deleting an entity, etc. It also exports referenced content.

Visit the
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-data-handlers}{Developing
Data Handlers} section for more information.

\section{Provide Entity Specific Local
Services}\label{provide-entity-specific-local-services}

When creating data handlers, you must leverage your app's local services
to perform Export/Import and Staging related tasks for its entities.
When these frameworks operate on entities (i.e., staged models), it
often cannot manage important information from the entity's local
services alone; instead, you're forced to reinvent basic functionality
so the framework can access it. This is caused by services not sharing a
common ancestor (i.e., interface or base class).

The \emph{Staged Model Repository} framework removes this barrier by
linking an app's staged model to a local service.

\begin{figure}
\centering
\includegraphics{./images/staged-model-repository.png}
\caption{Staged Model Repositories provide a Staging-specific layer of
functionality for your local services.}
\end{figure}

This lets the Staging framework call a staged model repository
independently based on the entity being processed. This gives you access
to entity-specific methods tailored specifically for the staged model
data you're handling.

\section{Export/Import Event
Listeners}\label{exportimport-event-listeners}

The \texttt{ExportImportLifecycleListener} framework is for listening
for certain staging or export/import events (like export successes and
import failures) during the publication process so you can take some
action. You can also listen for processes comprised of many events and
take action when these processes are initiated. For example, you can
listen for when

\begin{itemize}
\tightlist
\item
  Staging has started
\item
  A portlet export has failed
\item
  An entity export has succeeded
\end{itemize}

After an event is triggered, you can take an action like these:

\begin{itemize}
\tightlist
\item
  Print information about the event to your console
\item
  When an import process has completed, clear the cache.
\end{itemize}

For a complete list of events you can listen for, see
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/ExportImportLifecycleConstants.html}{\texttt{ExportImportLifecycleConstants}}.

You must extend one of the two Base listener classes:

\begin{itemize}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseExportImportLifecycleListener.html}{\texttt{BaseExportImportLifecycleListener}}:
  listens for specific \emph{events} during a lifecycle. For example, if
  a layout export fails, you might take some action.
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseProcessExportImportLifecycleListener.html}{\texttt{BaseProcessExportImportLifecycleListener}}:
  listens for \emph{processes} during a lifecycle. A process usually
  consists of many individual events. For example, if a site publication
  fails, you might take some action. Methods provided by this base class
  are only run once when the desired process action occurs.
\end{itemize}

What's the difference between events and processes?

\textbf{Events:} particular actions that occur during processing
(example event listener:
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/CacheExportImportLifecycleListener.html}{\texttt{CacheExportImportLifecycleListener}}).

\textbf{Processes:} longer running groups of events (example process
listener:
\href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/ExportImportProcessCallbackLifecycleListener.html}{\texttt{ExportImportProcessCallbackLifecycleListener}}).

Use the listener type that is most appropriate for your use case.

\section{Export/Import Processes}\label{exportimport-processes}

You can start the process programmatically instead of through the UI.
This lets you provide new interfaces or mimic the functionality of these
features in your own application.

To initiate an export/import or staging process, you must pass in an
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/model/ExportImportConfiguration.html}{\texttt{ExportImportConfiguration}}
object. This object encapsulates many parameters and settings that are
required while the export/import is running. Having one single object
with all your necessary data makes executing these frameworks quick and
easy.

For example, when implementing export, you must call services offered by
the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportService.html}{\texttt{ExportImportService}}
interface. All the methods in this interface require an
\texttt{ExportImportConfiguration} object. You can generate these
configuration objects, so you can easily pass them in your service
methods.

There are three factory classes that are useful to create an
\texttt{ExportImportConfiguration} object:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationSettingsMapFactory.html}{\texttt{ExportImportConfigurationSettingsMapFactory}}:
  provides many \texttt{build} methods to create settings maps for
  various scenarios like importing, exporting, and publishing layouts
  and portlets. For example, you can reference
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/service/impl/UserGroupLocalServiceImpl.html\#exportLayouts-long-java.util.Map-}{\texttt{UserGroupLocalServiceImpl.exportLayouts(...)}}
  and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/service/impl/GroupLocalServiceImpl.html\#addDefaultGuestPublicLayoutsByLAR-com.liferay.portal.kernel.model.Group-java.io.File-}{\texttt{GroupLocalServiceImpl.addDefaultGuestPublicLayoutsByLAR(...)}}.
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationFactory.html}{\texttt{ExportImportConfigurationFactory}}:
  This factory builds \texttt{ExportImportConfiguration} objects used
  for default local/remote publishing.
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationParameterMapFactory.html}{\texttt{ExportImportConfigurationParameterMapFactory}}:
  This factory builds parameter maps, which are required during
  export/import and publishing.
\end{itemize}

There are two important service interfaces that primarily use
\texttt{ExportImportConfiguration} objects for exporting, importing, and
staging:
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportLocalService.html}{\texttt{ExportImportLocalService}}
and
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/StagingLocalService.html}{\texttt{StagingLocalService}}.

\noindent\hrulefill

\textbf{Note:} If you're not calling the export/import or staging
service methods from an OSGi module, you should not use the interface.
The Liferay OSGi container automatically handles interface referencing,
which is why using the interface is permitted for modules. If you're
calling export/import or staging service methods outside of a module,
you should use their service Util classes (e.g.,
\texttt{ExportImportLocalServiceUtil}).

\noindent\hrulefill

It's also important to know that \texttt{ExportImportConfiguration} is a
Liferay DXP entity, similar to \texttt{User} or \texttt{Group}. This
means that the \texttt{ExportImportConfiguration} framework offers local
and remote services, models, persistence classes, and more.

\chapter{Developing Staged Models}\label{developing-staged-models}

To track an entity of an application with the Export/Import framework,
you must implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{\texttt{StagedModel}}
interface in the app's model classes. It provides the behavior contract
for entities during the Staging process. For example, the Bookmarks
application manages
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntry.html}{\texttt{BookmarksEntry}}s
and
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksFolder.html}{\texttt{BookmarksFolder}}s,
and both implement the \texttt{StagedModel} interface. Once you've
configured your staged models, you can create staged model data
handlers, which supply information about a staged model (entity) and its
referenced content to the Export/Import and Staging frameworks. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-data-handlers}{Developing
Data Handlers} section for more information.

There are two ways to create staged models for your application's
entities:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/generating-staged-models-using-service-builder}{Using
  Service Builder to generate the required Staging implementations}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-models-manually}{Implementing
  the required Staging interfaces manually}
\end{itemize}

You can follow step-by-step procedures for creating staged models for
your entities by visiting their respective articles.

Continue on to learn more about Staged Models!

\section{Staged Model Interfaces}\label{staged-model-interfaces}

The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedModel.html}{\texttt{StagedModel}}
interface must be implemented by your app's model classes, but this is
typically done through inheritance by implementing one of the interfaces
that extend the base interface:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedAuditedModel.html}{\texttt{StagedAuditedModel}}
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/StagedGroupedModel.html}{\texttt{StagedGroupedModel}}
\end{itemize}

You must implement these when you want to use certain features of the
Staging framework like automatic group mapping or entity level
\emph{Last Publish Date} handling. So how do you choose which is right
for you?

The \texttt{StagedAuditedModel} interface provides all the audit fields
to the model that implements it. You can check the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/AuditedModel.html}{\texttt{AuditedModel}}
interface for the specific audit fields provided. The
\texttt{StagedAuditedModel} interface is for models that function
independently from the group concept (sometimes referred to as company
models). If your model is a group model, you should not implement the
\texttt{StagedAuditedModel} interface.

The \texttt{StagedGroupedModel} interface must be implemented for group
models. For example, if your application requires the \texttt{groupId}
column, your model is a group model. If your model satisfies both the
\texttt{StagedGroupModel} and \texttt{StagedAuditedModel} requirements,
it should implement \texttt{StagedGroupedModel}. Your model should only
implement the \texttt{StagedAuditedModel} if it doesn't fulfill the
grouped model needs, but does fulfill the audited model needs. If your
model does not fulfill either the \texttt{StagedAuditedModel} or
\texttt{StagedGroupedModel} requirements, you should implement the base
\texttt{StagedModel} interface.

As an example for extending your model class, you can visit the
\href{https://docs.liferay.com/dxp/apps/collaboration/latest/javadocs/com/liferay/bookmarks/model/BookmarksEntryModel.html}{\texttt{BookmarksEntryModel}}
class, which extends the \texttt{StagedGroupedModel} interface; this is
done because bookmark entries are group models.

\begin{verbatim}
public interface BookmarksEntryModel extends BaseModel<BookmarksEntry>,
    ShardedModel, StagedGroupedModel, TrashedModel, WorkflowedModel {
\end{verbatim}

Those are the differences between staged model interfaces.

\section{Staged Model Attributes}\label{staged-model-attributes}

One of the most important attributes used by the Staging framework is
the UUID (Universally Unique Identifier). This attribute must be set to
\texttt{true} in your \texttt{service.xml} file for Service Builder to
recognize your model as an eligible staged model. The UUID
differentiates entities between environments. Because the UUID always
remains the same, it's unique across multiple systems. Why is this so
important?

Suppose you're using
\href{/docs/7-2/user/-/knowledge_base/u/enabling-remote-live-staging}{remote
staging} and you create a new entity on your local staging site and
publish it to your remote live site. When you go back to modify the
entity on your local site and want to publish those changes, the UUID
shows that the local and remote entities are the same. The Staging
framework can thus recognize the original entity on the remote site and
update it. The UUID provides that.

In addition to the UUID, there are several columns that must be defined
in your \texttt{service.xml} file for Service Builder to define your
model as a staged model:

\begin{itemize}
\tightlist
\item
  \texttt{companyId}
\item
  \texttt{createDate}
\item
  \texttt{modifiedDate}
\end{itemize}

If you want a staged grouped model, also include the \texttt{groupId}
and \texttt{lastPublishDate} columns. If you want a staged audited
model, include the \texttt{userId} and \texttt{userName} columns.

\section{Adapting Your Business Logic to Build Staged
Models}\label{adapting-your-business-logic-to-build-staged-models}

What if you don't want to extend your model with special attributes your
business logic doesn't need (removing the ability to leverage Service
Builder's auto-generation of staged models)? In this case, you should
adapt your business logic to meet the Staging framework's needs. Liferay
provides the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{\texttt{ModelAdapterBuilder}}
framework, which lets you adapt your model classes to staged models.

As an example, assume you have a completed app and you want it to work
with Staging. Your app, however, does not require a UUID for any of its
entities, and therefore, does not provide them. Instead of configuring
your app to handle UUIDs just for the sake of generating staged models,
you can leverage the Model Adapter Builder to build your staged models.

Another example for building staged models from scratch is for
applications that use REST services instead of the database to access
their attributes. Since this kind of app pulls its attributes from a
remote system, it is more convenient to build your staged models
yourself instead of relying on Service Builder, which is database
driven.

To adapt your model classes to staged models, follow the steps outlined
below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{Staged{[}Entity{]}} interface that extends the
  model-specific interface (e.g., \texttt{{[}Entity{]}}) and the
  appropriate staged model interface (e.g., \texttt{StagedModel}). This
  class serves as the Staged Model Adapter.
\item
  Create a \texttt{Staged{[}Entity{]}Impl} class that implements the
  \texttt{Staged{[}Entity{]}} interface and provides necessary logic for
  your entity model to be recognized as a staged model.
\item
  Create a \texttt{Staged{[}Entity{]}ModelAdapterBuilder} class that
  implements
  \texttt{ModelAdapterBuilder\textless{}{[}Entity{]},\ Staged{[}Entity{]}\textgreater{}}.
  This class adapts the original model to the newly created Staged Model
  Adapter.
\item
  Adapt your existing model and call one of the provided APIs to export
  or import the entity automatically.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/staged-model-adapter-diagram.png}
\caption{The Staged Model Adapter class extends your entity and staged
model interfaces.}
\end{figure}

\begin{figure}
\centering
\includegraphics{./images/model-adapter-builder-diagram.png}
\caption{The Model Adapter Builder gets an instance of the model and
outputs a staged model.}
\end{figure}

To step through the process for leveraging the Model Adapter Builder for
an existing app, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-models-manually}{Creating
Staged Models Manually}.

\chapter{Generating Staged Models Using Service
Builder}\label{generating-staged-models-using-service-builder}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Instead of having to create staged models for your app manually, you can
leverage
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} to generate the necessary staged model logic for you. If your
app doesn't use Liferay's Service Builder, you must configure it in your
project. This tutorial assumes you have a Service Builder project with
\texttt{*api} and \texttt{*service} modules. If you want to follow along
with this tutorial, download the staged-model-example Service Builder
project (Gradle-based).

You'll track the Service Builder-generated changes applied to an entity
model file to observe how staged models are assigned to your entity.
Keep in mind the specific
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models\#staged-model-attributes}{staged
attributes} necessary for each staged model. Depending on the attributes
defined in your \texttt{service.xml} file, Service Builder assigns your
entity model to a specific staged model type.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your project's \texttt{*service} module at the command
  line. Run Service Builder (e.g., \texttt{gradlew\ buildService}) to
  generate your project's models based on the current
  \texttt{service.xml} configuration.
\item
  Open your project's \texttt{{[}Entity{]}Model.java} interface and
  observe the inherited interfaces.

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel, StagedModel {
\end{verbatim}

  Your model was generated as a staged model! This is because the
  \texttt{service.xml} file sets the UUID to \texttt{true} and defines
  the \texttt{companyId}, \texttt{createDate}, and \texttt{modifiedDate}
  columns. There is much more logic generated for your app behind the
  scenes, but this shows that Service Builder deemed your entity
  eligible for the Staging and Export/Import frameworks.
\item
  Add the \texttt{userId} and \texttt{userName} columns to your
  \texttt{service.xml} file:

\begin{verbatim}
<column name="userId" type="long" />
<column name="userName" type="String" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, GroupedModel, ShardedModel,
    StagedAuditedModel {
\end{verbatim}

  Your model is now a staged audited model!
\item
  Add the \texttt{lastPublishDate} column to your \texttt{service.xml}
  file:

\begin{verbatim}
<column name="lastPublishDate" type="Date" />
\end{verbatim}
\item
  Rerun Service Builder and observe your \texttt{{[}Entity{]}Model.java}
  interface again:

\begin{verbatim}
public interface FooModel extends BaseModel<Foo>, ShardedModel,
    StagedGroupedModel {
\end{verbatim}

  Your model is now a staged grouped model! The \texttt{groupId} column
  is also required to extend the \texttt{StagedGroupedModel} interface,
  but it was already defined in the original \texttt{service.xml} file.
\end{enumerate}

Fantastic! You've witnessed firsthand how easy it is to generate staged
models using Service Builder.

\chapter{Creating Staged Models
Manually}\label{creating-staged-models-manually}

There are times when using
\href{/docs/7-2/frameworks/-/knowledge_base/f/generating-staged-models-using-service-builder}{Service
Builder to generate your staged models} is not practical. In these
cases, you should create your staged models manually. Make sure to read
the
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models\#adapting-your-business-logic-to-build-staged-models}{Adapting
Your Business Logic to Build Staged Models} section to determine if
creating staged models manually is beneficial for your use case.

In this tutorial, you'll explore how the Asset Link framework (a Liferay
DXP framework used for
\href{/docs/7-2/user/-/knowledge_base/u/defining-content-relationships}{relating
assets}) manually creates staged models. This framework is separate from
Export/Import and is referenced solely as an example for how to leverage
the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
framework, which lets you adapt your model classes to staged models.

Follow the steps below to leverage the Model Adapter Builder in your
app.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new interface that extends one of the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models\#staged-model-interfaces}{staged
  model interfaces} and your model specific interface. For example,

\begin{verbatim}
public interface StagedAssetLink extends AssetLink, StagedModel {

}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Staged model interfaces typically follow the `Staged[Entity]`
 naming convention. The Asset Link framework uses a generic entity called
 `AssetLink`.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Define methods required for your model to qualify as a staged model.
  For asset links, methods for retrieving entry UUIDs (among others) are
  defined:

\begin{verbatim}
public String getEntry1Uuid();

public String getEntry2Uuid();
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Asset links do not provide UUIDs by default; however, they still
 need to be tracked in the Staging and Export/Import frameworks. Therefore,
 they require staged models. Since they don't provide a UUID, Service
 Builder cannot generate staged models for asset links. The Asset Link
 framework has to create staged models differently using the Model Adapter
 Builder.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
These will be implemented by a new implementation class later. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Create an implementation class that implements your new
  \texttt{Staged{[}Entity{]}}. For example, the Asset Link framework
  does this:

\begin{verbatim}
public class StagedAssetLinkImpl implements StagedAssetLink {

}
\end{verbatim}

  This class provides necessary logic for your entity model to be
  recognized as a staged model. Below is a subset of logic in the
  example \texttt{StagedAssetLinkImpl} class used to populate UUIDs for
  asset link entries:

\begin{verbatim}
public StagedAssetLinkImpl(AssetLink assetLink) {
     _assetLink = assetLink;

    ...

     populateUuid();
}

@Override
public String getEntry1Uuid() {
    if (Validator.isNotNull(_entry1Uuid)) {
        return _entry1Uuid;
    }

    populateEntry1Attributes();

    return _entry1Uuid;
}

@Override
public String getEntry2Uuid() {
    if (Validator.isNotNull(_entry2Uuid)) {
            return _entry2Uuid;
    }

    populateEntry2Attributes();

    return _entry2Uuid;
}

protected void populateEntry1Attributes() {

    ...

    AssetEntry entry1 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId1());

    ...

    _entry1Uuid = entry1.getClassUuid();
}

protected void populateEntry2Attributes() {

    ...

    AssetEntry entry2 = AssetEntryLocalServiceUtil.fetchAssetEntry(
        _assetLink.getEntryId2());

    ...

    _entry2Uuid = entry2.getClassUuid();
}

protected void populateUuid() {

    ...

    String entry1Uuid = getEntry1Uuid();
    String entry2Uuid = getEntry2Uuid();

    ...

    _uuid = entry1Uuid + StringPool.POUND + entry2Uuid;
        }
}

private AssetLink _assetLink;
private String _entry1Uuid;
private String _entry2Uuid;
private String _uuid;
\end{verbatim}

  This logic retrieves asset link entries and populates UUIDs for them
  usable by the Staging and Export/Import frameworks. With the newly
  generated UUIDs, asset link model classes can be converted to staged
  models.
\item
  Create a Model Adapter Builder class and implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/builder/ModelAdapterBuilder.html}{ModelAdapterBuilder}
  interface. You should define the entity type and your Staged Model
  Adapter class when implementing the interface:

\begin{verbatim}
public class StagedAssetLinkModelAdapterBuilder
    implements ModelAdapterBuilder<AssetLink, StagedAssetLink> {

    @Override
    public StagedAssetLink build(AssetLink assetLink) {
        return new StagedAssetLinkImpl(assetLink);
    }

}
\end{verbatim}

  For the \texttt{StagedAssetLinkModelAdapterBuilder}, the entity type
  is \texttt{AssetLink} and the Staged Model Adapter is
  \texttt{StagedAssetLink}. Your app should follow a similar design. The
  Model Adapter Builder outputs a new instance of the
  \texttt{Staged{[}Entity{]}Impl} object.
\item
  Now you need to adapt your existing business logic to call the
  provided APIs. You can call the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/model/adapter/ModelAdapterUtil.html}{ModelAdapterUtil}
  class to create an instance of your Staged Model Adapter:

\begin{verbatim}
StagedAssetLink stagedAssetLink = ModelAdapterUtil.adapt(
    assetLink, AssetLink.class, StagedAssetLink.class);
\end{verbatim}

  Once you've created
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-model-data-handlers}{Staged
  Model Data Handlers}, you can begin exporting/importing your now
  Staging-compatible entities:

\begin{verbatim}
StagedModelDataHandlerUtil.exportStagedModel(
    portletDataContext, stagedAssetLink);
\end{verbatim}
\end{enumerate}

Awesome! You've successfully adapted your business logic to build staged
models!

\chapter{Developing Data Handlers}\label{developing-data-handlers}

A common requirement for data driven applications is to import and
export data. This \emph{could} be accomplished by accessing your
database directly and running SQL queries to export/import data;
however, this has several drawbacks:

\begin{itemize}
\tightlist
\item
  Working with different database vendors might require customized SQL
  scripts.
\item
  Access to the database may be tightly controlled, restricting the
  ability to export/import on demand.
\item
  You'd have to come up with your own means of storing and parsing the
  data.
\end{itemize}

Liferay provides data handlers as a convenient and reliable way to
export/import your data (as a LAR file).

There are two types of data handlers:

\begin{itemize}
\tightlist
\item
  Portlet Data Handlers
\item
  Staged Model Data Handlers
\end{itemize}

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes only have the role of querying and coordinating
between staged model data handlers. For example, the Bookmarks
application's portlet data handler tracks system events dealing with
Bookmarks entities. It also configures the Export/Import UI options for
the Bookmarks application.

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defining a display name for the
UI, deleting an entity, and exporting referenced content. For example,
if a Bookmarks entry resides in a Bookmarks folder, the
\texttt{BookmarksEntry} staged model data handler invokes the export of
the \texttt{BookmarksFolder}.

\begin{figure}
\centering
\includegraphics{./images/data-handler-diagram.png}
\caption{The Data Handler framework uses portlet data handlers and
staged model data handlers to track and export/import portlet and staged
model information, respectively.}
\end{figure}

You're not required to implement a staged model data handler for every
entity in your application, but they're necessary for any entity you
want to export/import or have the staging framework track.

\noindent\hrulefill

\textbf{Note:} Creating data handlers for your app means it's
automatically tracked by the Staging framework. You can further
customize how Staging handles your app, but creating staged models and
data handlers is what registers your app for Staging.

\noindent\hrulefill

Before implementing data handlers, make sure your application is ready
for the Export/Import and Staging frameworks by creating
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models}{staged
models}.

\section{\texorpdfstring{Understanding the \texttt{PortletDataHandler}
Interface}{Understanding the PortletDataHandler Interface}}\label{understanding-the-portletdatahandler-interface}

A Portlet Data Handler imports/exports portlet specific data to a LAR
file. These classes query and coordinate between
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-model-data-handlers}{staged
model data handlers}.

To create a portlet data handler for your staged model, you must
implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{\texttt{PortletDataHandler}}
interface by extending the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BasePortletDataHandler.html}{\texttt{BasePortletDataHandler}}
class. Visit the API reference documentation for this interface/class
for useful information on the methods provided.

Some guidelines for implementing the \texttt{PortletDataHandler}
interface are provided below:

The \texttt{@Component} annotation section above the implementation
class's declaration registers the class as a portlet data handler in the
OSGi service registry. There are a few annotation attributes you should
set:

\texttt{immediate}: activates the component immediately once its
provided module has started.

\texttt{property}: sets various properties for the component service.
You must associate the portlet you wish to handle with this service so
they function properly in the export/import environment. You should have
one portlet data handler for each portlet (e.g., Bookmarks and Bookmarks
Admin).

\texttt{service}: points to the \texttt{PortletDataHandler.class}
interface.

The \texttt{activate} method sets what the portlet data handler
controls. It also configures the portlet's Export/Import and Staging UI.
This method is called during initialization of the component by the
\href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Activate.html}{\texttt{@Activate}}
annotation; it's invoked after dependencies are set and before services
are registered. Five callable \texttt{set} methods are described below:

\texttt{setDataPortletPreferences}: sets portlet preferences your app
should handle.

\texttt{setDeletionSystemEventStagedModelTypes}: sets the staged model
deletions that the portlet data handler should track. For example, the
Bookmarks app tracks Bookmark entries and folders.

\texttt{setPublishToLiveByDefault}: controls whether your app is
selected to publish on the Publication screen by default.

\texttt{setExportControls}: adds fine grained controls over
export/import behavior rendered in the Export/Import UI. This also sets
the \texttt{setImportControls} method. For example, the Bookmarks app
adds a checkbox to select Bookmarks content (entries) to export.

\texttt{setStagingControls}: adds fine-grained controls over staging
behavior rendered in the Staging UI. For example, this enables your
app's checkboxes in the Content section displayed during publication.

The \texttt{doExportData} method checks if anything should be exported.
For example, the Bookmarks app uses this method to check if the user
selected Bookmarks entries for export by leveraging the
\texttt{portletDataContext}. Later, the
\texttt{ExportImportActionableDynamicQuery} framework runs a query
against bookmarks folders and entries to find ones which should be
exported to the LAR file.

The \texttt{-ActionableDynamicQuery} classes are generated automatically
by Service Builder and are available in an app's local services. It
queries the database searching for certain Export/Import-specific
parameters (e.g., \texttt{createDate} and \texttt{modifiedDate}), and
based on those parameters, finds a list of exportable records from the
staged model data handler.

The \texttt{doImportData} method queries for entity data in the imported
LAR file that should be added to the database. This is done by
extracting XML elements from the LAR file by using utility methods in
the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandlerUtil.html}{\texttt{StagedModelDataHandlerUtil}}
class. The extracted elements tell Liferay DXP what data to import from
the LAR file.

The \texttt{doPrepareManifestSummary} method calculates the number of
affected entities based on the current export or staging process.

You must retrieve and manage the schema version. This is done with the
\texttt{getSchemaVersion} and \texttt{validateSchemaVersion} methods.
The schema version is used to perform component related validation
before importing data. It's added to the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-archive-lar-file}{LAR
file} for each application being processed. During import, the
environment's schema version is compared to the LAR file's schema
version. Validating the schema version avoids broken data when
importing. See the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html\#getSchemaVersion--}{\texttt{PortletDataHandler.getSchemaVersion()}}
method's Javadoc for more information.

Next you'll learn about the \texttt{StagedModelDataHandler} interface.

\section{\texorpdfstring{Understanding the
\texttt{StagedModelDataHandler}
Interface}{Understanding the StagedModelDataHandler Interface}}\label{understanding-the-stagedmodeldatahandler-interface}

A Staged Model Data Handler supplies information about a staged model
(entity) to the Export/Import framework, defines a display name for the
UI, deletes entities, etc. It's also responsible for exporting
referenced content. For example, if a Bookmarks entry resides in a
Bookmarks folder, the \texttt{BookmarksEntry} staged model data handler
invokes the export of the \texttt{BookmarksFolder}.

To create a staged model data handler for your staged model, you must
implement the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{\texttt{StagedModelDataHandler}}
interface. This is typically done by extending the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BaseStagedModelDataHandler.html}{\texttt{BaseStagedModelDataHandler}}
class. Visit the API reference documentation for this interface/class
for useful information on the methods provided.

Additional implementation details for the
\texttt{StagedModelDataHandler} interface is provided below:

The \texttt{@Component} annotation section above the implementation
class's declaration registers the class as a staged model data handler
in the OSGi service registry. There are two annotation attributes you
should set:

\texttt{immediate}: activates the component immediately once its
provided module has started.

\texttt{service}: points to the \texttt{StagedModelDataHandler.class}
interface.

The \texttt{getClassNames} method provides the class names of the models
the data handler tracks. As a best practice, you should have one staged
model data handler per staged model. It's possible to use multiple class
types, but this is not recommended.

The \texttt{getDisplayName} method retrieves the staged model's display
name. This is used in the Export/Import UI.

The \texttt{doExportStagedModel} method retrieves your app entity's data
element from the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataContext.html}{\texttt{PortletDataContext}}
and then adds the class model characterized by that data element to the
\texttt{PortletDataContext}. The \texttt{PortletDataContext} data
populates the LAR file with your application's data during the export
process.

\noindent\hrulefill

\textbf{Note:} A staged model data handler should ensure everything
required for its operation is also exported. For example, in the
Bookmarks application, an entry requires its folder to keep the folder
structure intact. Therefore, the folder should be exported first
followed by the entry. Note that once an entity has been exported,
subsequent calls to the export method don't repeat the export process
multiple times, ensuring optimal performance.

\noindent\hrulefill

The \texttt{doImportStagedModel} method imports the staged model data.
An important feature of the import process is that all exported
reference elements are automatically imported when needed. The method
must therefore only find the new assigned ID for the folder before
importing the entry.

The \texttt{PortletDataContext} keeps the data up-to-date during the
import process. The old ID and new ID mapping can be reached by using
the \texttt{portletDataContext.getNewPrimaryKeysMap()} method. This
method also checks the import mode (e.g., \emph{Copy As New} or
\emph{Mirror}) and, depending on the process configuration and existing
environment, adds or updates the entry.

The \texttt{doImportMissingReference} method maps the existing staged
model to the old ID in the reference element. When a reference is
exported as missing, the Data Handler framework calls this method during
the import process and updates the new primary key map in the portlet
data context.

When importing a LAR (i.e., publishing to the live Site), the import
process expects all of an entity's references to be available and
validates their existence.

For example, if you republish an updated bookmarks folder to the live
Site and did not include some of its existing entries in the
publication, these entries are considered missing references.

Since you have references from two separate Sites with differing IDs,
the system can't match them during publication. Suppose you export a
bookmark entry as a missing reference with a primary key (ID) of
\texttt{1}. When importing that information, the LAR only provides the
ID but not the entry itself. Therefore, during the import process, the
Data Handler framework searches for the entry to replace by its UUID,
but the entry to replace has a different ID (primary key) of \texttt{2}.
You must provide a way to handle these missing references.

To do this, you must add a method that maps the missing reference's
primary key from the export to the existing primary key during import.
Since the reference's UUID is consistent across systems, it's used to
complete the mapping of differing primary keys. Note that a reference
can only be missing on the live Site if it has already been published
previously. Therefore, when publishing a bookmarks folder for the first
time, the system doesn't check for missing references.

Continue in the section to learn how to develop data handlers for your
app.

\chapter{Creating Portlet Data
Handlers}\label{creating-portlet-data-handlers}

In this tutorial, you'll create the
\texttt{BookmarksPortletModelDataHandler} class used for the Bookmarks
application. The Bookmarks application's portlet data handler tracks
system events dealing with Bookmarks entities. It also configures the
Export/Import and Staging UI options for the Bookmarks application.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing Service Builder project for your
  data handler classes. For instance, the Bookmarks application's data
  handler classes reside in the \texttt{bookmarks-service} module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package.
\item
  Create your \texttt{-PortletDataHandler} class for your application in
  the new \texttt{-exportimport.data.handler} package and have it
  implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataHandler.html}{PortletDataHandler}
  interface by extending the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BasePortletDataHandler.html}{BasePortletDataHandler}
  class. For example,

\begin{verbatim}
public class BookmarksPortletDataHandler extends BasePortletDataHandler {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BookmarksPortletKeys.BOOKMARKS
    },
    service = PortletDataHandler.class
)
\end{verbatim}
\item
  Set what the portlet data handler controls and the portlet's
  Export/Import and Staging UIs by adding an \texttt{activate} method:

\begin{verbatim}
@Activate
protected void activate() {
    setDataPortletPreferences("rootFolderId");
    setDeletionSystemEventStagedModelTypes(
        new StagedModelType(BookmarksEntry.class),
        new StagedModelType(BookmarksFolder.class));
    setExportControls(
        new PortletDataHandlerBoolean(
            NAMESPACE, "entries", true, false, null,
            BookmarksEntry.class.getName()));
    setStagingControls(getExportControls());
}
\end{verbatim}

  \begin{figure}
  \centering
  \includegraphics{./images/export-import-controls.png}
  \caption{You can select the content types you'd like to export/import
  in the UI.}
  \end{figure}
\item
  For the Bookmarks portlet data handler to reference its entry and
  folder staged models successfully, you must set them in your class:

\begin{verbatim}
@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksFolderLocalService(
    BookmarksFolderLocalService bookmarksFolderLocalService) {

    _bookmarksFolderLocalService = bookmarksFolderLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
private BookmarksFolderLocalService _bookmarksFolderLocalService;
\end{verbatim}

  The \texttt{set} methods must be annotated with the
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{@Reference}
  annotation.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its portlet data handler; instead, it uses the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{\texttt{StagedModelRepository}}
  framework. This is a new framework, but is a viable option when
  setting up your portlet data handlers. For more information on this,
  see the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/providing-entity-specific-local-services-for-export-import}{Providing
  Entity-Specific Local Services for Staging} tutorial section. Since
  local services are more widely used in custom apps, this tutorial
  covers those instead.
\item
  You must create a namespace for your entities so the Export/Import
  framework can identify your application's entities from other entities
  in Liferay DXP. The Bookmarks application's namespace declaration
  looks like this:

\begin{verbatim}
public static final String NAMESPACE = "bookmarks";
\end{verbatim}

  You'll see how this namespace is used later.
\item
  Your portlet data handler should retrieve the data related to its
  staged model entities so it can properly export/import it. Add this
  functionality by inserting the following methods:

\begin{verbatim}
@Override
protected String doExportData(
        final PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences)
    throws Exception {

    Element rootElement = addExportDataRootElement(portletDataContext);

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return getExportDataRootElementString(rootElement);
    }

    portletDataContext.addPortletPermissions(
        BookmarksConstants.RESOURCE_NAME);

    rootElement.addAttribute(
        "group-id", String.valueOf(portletDataContext.getScopeGroupId()));

    ExportActionableDynamicQuery folderActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderActionableDynamicQuery.performActions();

    ActionableDynamicQuery entryActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryActionableDynamicQuery.performActions();

    return getExportDataRootElementString(rootElement);
}

@Override
protected PortletPreferences doImportData(
        PortletDataContext portletDataContext, String portletId,
        PortletPreferences portletPreferences, String data)
    throws Exception {

    if (!portletDataContext.getBooleanParameter(NAMESPACE, "entries")) {
        return null;
    }

    portletDataContext.importPortletPermissions(
        BookmarksConstants.RESOURCE_NAME);

    Element foldersElement = portletDataContext.getImportDataGroupElement(
        BookmarksFolder.class);

    List<Element> folderElements = foldersElement.elements();

    for (Element folderElement : folderElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, folderElement);
    }

    Element entriesElement = portletDataContext.getImportDataGroupElement(
            BookmarksEntry.class);

    List<Element> entryElements = entriesElement.elements();

    for (Element entryElement : entryElements) {
        StagedModelDataHandlerUtil.importStagedModel(
            portletDataContext, entryElement);
    }

    return null;
}
\end{verbatim}
\item
  Add a method that counts the number of affected entities based on the
  current export or staging process:

\begin{verbatim}
@Override
protected void doPrepareManifestSummary(
        PortletDataContext portletDataContext,
        PortletPreferences portletPreferences)
    throws Exception {

    if (ExportImportDateUtil.isRangeFromLastPublishDate(
            portletDataContext)) {

        _staging.populateLastPublishDateCounts(
            portletDataContext,
            new StagedModelType[] {
                new StagedModelType(BookmarksEntry.class.getName()),
                new StagedModelType(BookmarksFolder.class.getName())
            });

            return;
        }

    ActionableDynamicQuery entryExportActionableDynamicQuery =
        _bookmarksEntryLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    entryExportActionableDynamicQuery.performCount();

    ActionableDynamicQuery folderExportActionableDynamicQuery =
        _bookmarksFolderLocalService.
            getExportActionableDynamicQuery(portletDataContext);

    folderExportActionableDynamicQuery.performCount();
}
\end{verbatim}

  This number is displayed in the Export and Staging UI. Note that since
  the Staging framework traverses the entity graph during export, the
  built-in components provide an approximate value in some cases.

  \begin{figure}
  \centering
  \includegraphics{./images/manifest-summary-count.png}
  \caption{The number of modified Bookmarks entities are displayed in
  the Export UI.}
  \end{figure}
\item
  Set the XML schema version for the XML files included in your exported
  LAR file:

\begin{verbatim}
public static final String SCHEMA_VERSION = "1.0.0";

@Override
public String getSchemaVersion() {
    return SCHEMA_VERSION;
}

@Override
public boolean validateSchemaVersion(String schemaVersion) {
    return _portletDataHandlerHelper.validateSchemaVersion(
        schemaVersion, getSchemaVersion());
}
\end{verbatim}
\end{enumerate}

Awesome! You've set up your portlet data handler and your application
can now support the Export/Import framework and display a UI for it. Be
sure to also implement staged model data handlers for your staged
models. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-staged-model-data-handlers}{Creating
Staged Model Data Handlers} for more information.

\chapter{Creating Staged Model Data
Handlers}\label{creating-staged-model-data-handlers}

In this tutorial, you'll create the
\texttt{BookmarksStagedModelDataHandler} class used for the Bookmarks
application. The Bookmarks application has two staged models: entries
and folders. Creating data handlers for these two entities is similar,
so you'll examine how this is done for Bookmark entries. This tutorial
assumes you've already created
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models}{staged
models}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new package in your existing Service Builder project for your
  data handler classes. For instance, the Bookmarks application's data
  handler classes reside in the \texttt{bookmarks-service} module's
  \texttt{com.liferay.bookmarks.internal.exportimport.data.handler}
  package.
\item
  Create a \texttt{-StagedModelDataHandler} class in the
  \texttt{-exportimport.data.handler} package. The staged model data
  handler class should extend the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/BaseStagedModelDataHandler.html}{\texttt{BaseStagedModelDataHandler}}
  class and the entity type should be specified as its parameter. You
  can see how this was done for the
  \texttt{BookmarksEntryStagedModelDataHandler} class below:

\begin{verbatim}
public class BookmarksEntryStagedModelDataHandler
    extends BaseStagedModelDataHandler<BookmarksEntry> {
\end{verbatim}
\item
  Create an \texttt{@Component} annotation section above the class
  declaration.

\begin{verbatim}
@Component(immediate = true, service = StagedModelDataHandler.class)
\end{verbatim}
\item
  Create a getter and setter method for the local service of the staged
  model for which you want to provide a data handler:

\begin{verbatim}
@Override
protected BookmarksEntryLocalService getBookmarksEntryLocalService() {
    return _bookmarksEntryLocalService;
}

@Reference(unbind = "-")
protected void setBookmarksEntryLocalService(
    BookmarksEntryLocalService bookmarksEntryLocalService) {

    _bookmarksEntryLocalService = bookmarksEntryLocalService;
}

private BookmarksEntryLocalService _bookmarksEntryLocalService;
\end{verbatim}

  These methods are used to link this data handler with the staged model
  for bookmark entries.

  \textbf{Important:} Liferay DXP's official Bookmarks app does not use
  local services in its staged model data handlers; instead, it uses the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{\texttt{StagedModelRepository}}
  framework. This is a new framework, but is a viable option when
  setting up your staged model data handlers. For more information on
  this, see the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/providing-entity-specific-local-services-for-export-import}{Providing
  Entity-Specific Local Services for Staging} tutorial section. Since
  local services are more widely used in custom apps, this tutorial
  covers those instead.
\item
  Provide the class names of the models the data handler tracks. You can
  do this by overriding the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/StagedModelDataHandler.html}{\texttt{StagedModelDataHandler}}'s
  \texttt{getClassnames()} method:

\begin{verbatim}
public static final String[] CLASS_NAMES = {BookmarksEntry.class.getName()};

@Override
public String[] getClassNames() {
    return CLASS_NAMES;
}
\end{verbatim}
\item
  Add a method that retrieves the staged model's display name:

\begin{verbatim}
@Override
public String getDisplayName(BookmarksEntry entry) {
    return entry.getName();
}
\end{verbatim}

  The display name is presented with the progress bar during the
  export/import process.

  \begin{figure}
  \centering
  \includegraphics{./images/staged-model-display-name.png}
  \caption{Your staged model data handler provides the display name in
  the Export/Import UI.}
  \end{figure}
\item
  Add methods that import and export your staged model and its
  references.

\begin{verbatim}
@Override
protected void doExportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    if (entry.getFolderId() !=
            BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {

        StagedModelDataHandlerUtil.exportReferenceStagedModel(
            portletDataContext, entry, entry.getFolder(),
            PortletDataContext.REFERENCE_TYPE_PARENT);
    }

    Element entryElement = portletDataContext.getExportDataElement(entry);

    portletDataContext.addClassedModel(
        entryElement, ExportImportPathUtil.getModelPath(entry), entry);
}

@Override
protected void doImportStagedModel(
        PortletDataContext portletDataContext, BookmarksEntry entry)
    throws Exception {

    Map<Long, Long> folderIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksFolder.class);

    long folderId = MapUtil.getLong(
        folderIds, entry.getFolderId(), entry.getFolderId());

    ServiceContext serviceContext =
        portletDataContext.createServiceContext(entry);

    BookmarksEntry importedEntry = null;

    if (portletDataContext.isDataStrategyMirror()) {

        BookmarksEntry existingEntry =
            _bookmarksEntryLocalService. fetchBookmarksEntryByUuidAndGroupId(
                entry.getUuid(), portletDataContext.getScopeGroupId());

        if (existingEntry == null) {

            serviceContext.setUuid(entry.getUuid());
            importedEntry = _bookmarksEntryLocalService.addEntry(                   
              userId, portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(), serviceContext);
        }
        else {
            importedEntry = _bookmarksEntryLocalService.updateEntry(
                userId, existingEntry.getEntryId(), portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
        }
    }
    else {
        importedEntry = _bookmarksEntryLocalService.addEntry(userId, portletDataContext.getScopeGroupId(), folderId,entry.getName(), entry.getUrl(), entry.getDescription(),    serviceContext);
    }

    portletDataContext.importClassedModel(entry, importedEntry);
}
\end{verbatim}
\item
  Add the \texttt{doImportMissingReference} method to your class:

\begin{verbatim}
@Override
protected void doImportMissingReference(
        PortletDataContext portletDataContext, String uuid, long groupId,
        long entryId)
    throws Exception {

    BookmarksEntry existingEntry = fetchMissingReference(uuid, groupId);

    if (existingEntry == null) {
        return;
    }

    Map<Long, Long> entryIds =
        (Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(
            BookmarksEntry.class);

    entryIds.put(entryId, existingEntry.getEntryId());
}
\end{verbatim}
\end{enumerate}

Fantastic! You've created a data handler for your staged model. The
Export/Import framework can now track your entity's behavior and data.
Be sure to also implement a portlet data handler to manage portlet
specific data. See the
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-portlet-data-handlers}{Creating
Portlet Data Handlers} article to do this for the Bookmarks app.

\chapter{Providing Entity-Specific Local Services for
Export/Import}\label{providing-entity-specific-local-services-for-exportimport}

Data handlers must often call your app's local services to perform
Export/Import-related tasks for its entities. When the Export/Import
framework operates on entities (i.e., staged models), it often cannot
manage important information from the entity's local services alone. The
\emph{Staged Model Repository} framework removes this barrier by linking
an app's staged model to a local service. This gives you access to
entity-specific methods tailored specifically for the staged model data
you're handling.

What kind of \emph{entity-specific} methods are we talking about here?
Your data handlers only expose a specific set of actions, like export
and import methods. The Staged Model Repository framework provides CRUD
operations for a specific staged model that local services don't expose.

The staged model repository does not avoid using your app's local
services. It only provides an additional layer that provides
Export/Import-specific functionality. Here's how this works:

\begin{itemize}
\tightlist
\item
  \texttt{*StagedModelDataHandler}: de-serializes the provided
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-archive-lar-file}{LAR
  file's} XML into a model.
\item
  \texttt{*StagedModelRepository}: updates the model based on the
  environment and business logic, providing entity-specific CRUD
  operations for Staging purposes (e.g., UUID manipulation).
\item
  Local services are called from the \texttt{*StagedModelRepository} and
  handle the remainder of the process.
\end{itemize}

Pretty cool, right? The first thing you must do is implement the
\texttt{StagedModelRepository} interface. You'll explore this next.

\section{\texorpdfstring{Understanding the
\texttt{StagedModelRepository}
Interface}{Understanding the StagedModelRepository Interface}}\label{understanding-the-stagedmodelrepository-interface}

Providing specialized local services for your app's staging
functionality lets you abstract the additional staging-specific
information away from your data handlers. Before you can begin using the
Staged Model Repository framework in your app, you must implement it.

The first important task is adding an \texttt{@Component} annotation
section above the implementation class's declaration. This registers the
class as a staged model repository in the OSGi service registry. There
are a few annotation attributes you should set:

\begin{itemize}
\tightlist
\item
  \texttt{immediate}: activates the component immediately once its
  provided module has started.
\item
  \texttt{property}: sets various properties for the component service.
  You must associate the model class you wish to handle with this
  service so it's recognized by the data handlers leveraging it. This
  property must set the fully qualified model class name like this:
  \texttt{property\ =\ \ \ "model.class.name=FULLY\_QUALIFIED\_MODEL\_CLASS"}.
\item
  \texttt{service}: points to the \texttt{StagedModelRepository.class}
  interface.
\end{itemize}

Next, you must implement the \texttt{StagedModelRepository} interface.
Implementations vary greatly based on the app you're implementing it
for. There are two common cases you'll experience when implementing its
methods:

\begin{itemize}
\tightlist
\item
  Methods that require additional Export/Import information injected
  before calling the local service.
\item
  Methods that can call the local service directly.
\end{itemize}

The
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-a1/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/internal/exportimport/staged/model/repository/BookmarksEntryStagedModelRepository.java\#L51-L71}{\texttt{BookmarksEntryStagedModelRepository.addStagedModel(...)}}
method is an example where only calling the local service would not
satisfy the staged model data handler's needs (i.e., its UUID
requirement). With the staged model repository layer, however, you can
add export/import specific requirements on top of the present local
services to serve your data handlers' needs.

The method does this:

\begin{itemize}
\tightlist
\item
  Sets the user ID and service context based on the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/PortletDataContext.html}{\texttt{PortletDataContext}}
  (used to populate the LAR file with your application's data during the
  export process).
\item
  Sets the UUID, which is required to differentiate staged content
  between Sites.
\item
  Calls the entity's local service.
\end{itemize}

Not every method implementation requires additional export/import
information. For example, deleting Bookmarks Entries and deleting
Bookmarks Entry staged models are functionally the same, so your staged
model repository's method would call the local service directly (e.g.,
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-a1/modules/apps/bookmarks/bookmarks-service/src/main/java/com/liferay/bookmarks/internal/exportimport/staged/model/repository/BookmarksEntryStagedModelRepository.java\#L73-L78}{\texttt{BookmarksEntryStagedModelRepository.deleteStagedModel(...)}}).

Next you'll learn about using a Staged Model Repository.

\section{Using a Staged Model
Repository}\label{using-a-staged-model-repository}

You can leverage a staged model repository by

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Creating a getter and setter method to make a
  \texttt{StagedModelRepository} object available to your entity.
\item
  Calling the \texttt{StagedModelRepository} object to leverage its
  specialized export/import logic.
\end{enumerate}

The getter and setter methods instantiate a
\texttt{StagedModelRepository} object that the staged model data handler
can use to access your entity's CRUD operations. The setter method
should have an \texttt{@Reference} annotation listed above its method
signature. This injects the component service of the
\texttt{*StagedModelRepository} into the staged model repository object.
The component service was created when you set the \texttt{@Component}
annotation in the implementation class.

Once you have access to the \texttt{StagedModelRepository} object, call
it to use its specialized export/import logic. Now that you have access
to CRUD operations via the \texttt{StagedModelRepository} object, you
can skip the headache of providing a slew of parameters and additional
functionality in the local service to do simple things like add a
Bookmarks entry. The staged model repository abstracts these
requirements away from the data handler.

Continue in the section to learn how to develop staged model
repositories for your app.

\chapter{Implementing the Staged Model Repository
Framework}\label{implementing-the-staged-model-repository-framework}

In this article, you'll step through a quick example that demonstrates
implementing the \texttt{StagedModelRepository} interface to use for a
staged model. This example references Liferay's Bookmarks app and
Bookmarks Entry entities.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your app's \texttt{-service} bundle, create a package that holds
  your Staged Model Repository classes (e.g.,
  \texttt{com.liferay.bookmarks.exportimport.staged.model.repository}).
  If you do not have a \texttt{-service} bundle, visit the
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder} articles for info on generating an app's services. You must
  have them to leverage most Export/Import and Staging features.
\item
  Create your \texttt{-StagedModelRepository} class in the new package
  and implement the \texttt{StagedModelRepository} interface in the
  class' declaration. For example,

\begin{verbatim}
public class BookmarksEntryStagedModelRepository
    implements StagedModelRepository<BookmarksEntry> {
\end{verbatim}

  Be sure also to include the staged model type parameter for this
  repository (e.g., \texttt{BookmarksEntry}).
\item
  Add an \texttt{@Component} annotation for your staged model repository
  class that looks like this:

\begin{verbatim}
@Component(
    immediate = true,
    property = "model.class.name=com.liferay.bookmarks.model.BookmarksEntry",
    service = StagedModelRepository.class
)
\end{verbatim}
\item
  Implement the \texttt{StagedModelRepository} interface's methods in
  your staged model repository. You can reference the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/staged/model/repository/StagedModelRepository.html}{Javadoc}
  for this interface to learn what each method is intended for.

  As an example, you'll set a couple method implementations to get a
  taste for how it works.
\item
  Implement the \texttt{addStagedModel(...)} method. The Bookmarks entry
  example looks like this:

\begin{verbatim}
@Override
public BookmarksEntry addStagedModel(
        PortletDataContext portletDataContext,
        BookmarksEntry bookmarksEntry)
    throws PortalException {

    long userId = portletDataContext.getUserId(
        bookmarksEntry.getUserUuid());

    ServiceContext serviceContext = portletDataContext.createServiceContext(
        bookmarksEntry);

    if (portletDataContext.isDataStrategyMirror()) {
        serviceContext.setUuid(bookmarksEntry.getUuid());
    }

    return _bookmarksEntryLocalService.addEntry(
        userId, bookmarksEntry.getGroupId(), bookmarksEntry.getFolderId(),
        bookmarksEntry.getName(), bookmarksEntry.getUrl(),
        bookmarksEntry.getDescription(), serviceContext);
}
\end{verbatim}

  This provides the UUID for the local service.
\item
  Not every method implementation requires additional staging
  information. Implementing the \texttt{deleteStagedModels} method calls
  the local service directly.

\begin{verbatim}
@Override
public void deleteStagedModels(PortletDataContext portletDataContext)
    throws PortalException {

    _bookmarksEntryLocalService.deleteEntries(
        portletDataContext.getScopeGroupId(),
        BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID);
}
\end{verbatim}
\item
  Finish implementing the \texttt{StagedModelRepository} so it's usable
  in your data handlers.
\end{enumerate}

Awesome! You've implemented the Staged Model Repository framework for
your app! If you're interested in leveraging this framework after the
implementation process, see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-staged-model-repository-framework}{Using
the Staged Model Repository Framework} article.

\chapter{Using the Staged Model Repository
Framework}\label{using-the-staged-model-repository-framework}

Leveraging the Staged Model Repository framework in your app is easy
once you've
\href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-the-staged-model-repository-framework}{created
staged model repository implementation classes}.

You'll step through a quick example to demonstrate leveraging the
\texttt{StagedModelRepository} interface in a staged model data handler.
The code snippets originate from Liferay's Bookmarks app and Bookmarks
Entries.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a getter and setter method to make a
  \texttt{StagedModelRepository} object available for the
  \texttt{BookmarksEntry} entity:

\begin{verbatim}
@Override
protected StagedModelRepository<BookmarksEntry> getStagedModelRepository() {
    return _stagedModelRepository;
}

@Reference(
    target = "(model.class.name=com.liferay.bookmarks.model.BookmarksEntry)",
    unbind = "-"
)
protected void setStagedModelRepository(
    StagedModelRepository<BookmarksEntry> stagedModelRepository) {

    _stagedModelRepository = stagedModelRepository;
}

private StagedModelRepository<BookmarksEntry> _stagedModelRepository;
\end{verbatim}
\item
  Call your \texttt{\_stagedModelRepository} object to leverage its
  specialized export/import logic. For example,

\begin{verbatim}
newEntry = _stagedModelRepository.updateStagedModel(portletDataContext, importedEntry);
\end{verbatim}

  Without the staged model repository logic, you would've called your
  local service like this:

\begin{verbatim}
serviceContext.setUuid(entry.getUuid());

newEntry = _bookmarksEntryLocalService.addEntry(
    userId, portletDataContext.getScopeGroupId(), folderId, entry.getName(), entry.getUrl(), entry.getDescription(), serviceContext);
\end{verbatim}

  The large number of parameters and UUID setter the local service
  method requires aren't needed when leveraging the staged model
  repository.
\end{enumerate}

Great! You've successfully leveraged your staged model repository from a
data handler!

\chapter{Using the Export/Import Lifecycle Listener
Framework}\label{using-the-exportimport-lifecycle-listener-framework}

In this tutorial, you'll learn how to use the
\texttt{ExportImportLifecycleListener} framework to listen for
processes/events during the staging and export/import lifecycles.

To begin creating your lifecycle listener, you must create a module.
Follow the steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module}.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, begin the class name with the entity or action name
  you're processing, followed by \emph{ExportImportLifecycleListener}
  (e.g., \texttt{LoggerExportImportLifecycleListener}).
\item
  You must extend one of the two Base classes provided with the
  Export/Import Lifecycle Listener framework:
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseExportImportLifecycleListener.html}{BaseExportImportLifecycleListener}
  (event listener) or
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lifecycle/BaseProcessExportImportLifecycleListener.html}{BaseProcessExportImportLifecycleListener}
  (process listener). To choose, you'll need to consider what parts of a
  lifecycle you want to listen for (event or process).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = ExportImportLifecycleListener.class)
\end{verbatim}

  This annotation declares the implementation class of the component and
  specifies that the portal should start the module immediately.
\item
  Specify the methods you want to implement in your class. As an
  example, you'll step through the
  \href{https://docs.liferay.com/dxp/apps/web-experience/latest/javadocs/com/liferay/exportimport/lifecycle/LoggerExportImportLifecycleListener.html}{LoggerExportImportLifecycleListener}.
  This listener extends the \texttt{BaseExportImportLifecycleListener},
  so you immediately know that it deals with lifecycle events.
\item
  Add the \texttt{getStagedModelLogFragment(...)} method:

\begin{verbatim}
protected String getStagedModelLogFragment(StagedModel stagedModel) {
    StringBundler sb = new StringBundler(8);

    sb.append(StringPool.OPEN_CURLY_BRACE);
    sb.append("class: ");
    sb.append(ExportImportClassedModelUtil.getClassName(stagedModel));

    if (stagedModel instanceof StagedGroupedModel) {
        StagedGroupedModel stagedGroupedModel =
            (StagedGroupedModel)stagedModel;

        sb.append(", groupId: ");
        sb.append(stagedGroupedModel.getGroupId());
    }

    sb.append(", uuid: ");
    sb.append(stagedModel.getUuid());
    sb.append(StringPool.CLOSE_CURLY_BRACE);

    return sb.toString();
}
\end{verbatim}

  This retrieves the staged model's log fragment, which is the lifecycle
  listener's logging information on events.
\item
  Add the \texttt{isParallel()} method:

\begin{verbatim}
@Override
public boolean isParallel() {
    return false;
}
\end{verbatim}

  This determines whether your listener should run in parallel with the
  import/export process, or if the calling method should stop, execute
  the listener, and return to where the event was fired after the
  listener has finished.
\item
  Add the \texttt{onExportImportLifecycleEvent(...)} method:

\begin{verbatim}
@Override
public void onExportImportLifecycleEvent(
        ExportImportLifecycleEvent exportImportLifecycleEvent)
    throws Exception {

    if (!_log.isDebugEnabled()) {
        return;
    }

    super.onExportImportLifecycleEvent(exportImportLifecycleEvent);
}
\end{verbatim}

  This consumes the lifecycle event and passes it through the base
  class's method (as long as Debug mode is not enabled).
\item
  Each remaining method is called to print logging information for the
  user. For example, when a layout export fails, logging information
  directly related to that event is printed:

\begin{verbatim}
@Override
protected void onLayoutExportFailed(
        PortletDataContext portletDataContext, Throwable throwable)
    throws Exception {

    if (!_log.isDebugEnabled()) {
        return;
    }

    _log.debug(
        "Layout export failed for group " + portletDataContext.getGroupId(),
        throwable);
}
\end{verbatim}

  In summary, the \texttt{LoggerExportImportLifecycleListener} uses the
  lifecycle listener framework to print messages to the log when an
  export/import event occurs. You can view the other logging methods
  implemented for this class
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-m2/modules/apps/export-import/export-import-service/src/main/java/com/liferay/exportimport/lifecycle/LoggerExportImportLifecycleListener.java}{here}.
\item
  Once you've successfully created your export/import lifecycle listener
  module, generate the module's JAR file and copy it to Liferay DXP's
  \texttt{osgi/modules} folder.

  Once your module is installed and activated in your instance's service
  registry, your lifecycle listener is ready for use in your Portal
  instance.
\end{enumerate}

Terrific! You learned about the Export/Import Lifecycle Listener
framework, and you've learned how to create your own listener for
events/processes that occur during export/import of your portal's
content.

\chapter{Initiating New Export/Import
Processes}\label{initiating-new-exportimport-processes}

In this tutorial, you'll learn about the
\texttt{ExportImportConfiguration} framework and how you can take
advantage of provided services and factories to create these controller
objects. Once they're created, you can easily implement whatever
import/export functionality you need.

Your first step is to create an \texttt{ExportImportConfiguration}
object and use it to initiate your custom export/import or staging
process.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/configuration/ExportImportConfigurationSettingsMapFactory.html}{\texttt{ExportImportConfigurationSettingsMapFactory}}
  class to create a layout export settings map:

\begin{verbatim}
Map<String, Serializable> exportLayoutSettingsMap =
    ExportImportConfigurationSettingsMapFactory.
        buildExportLayoutSettingsMap(...);
\end{verbatim}
\item
  Create the \texttt{ExportImportConfiguration} object by using an
  \emph{add} method in the entity's local service. The map created
  previously is used as a parameter to create the
  \texttt{ExportImportConfiguration} object.

\begin{verbatim}
ExportImportConfiguration exportImportConfiguration =
    exportImportConfigurationLocalService.
        addDraftExportImportConfiguration(
            user.getUserId(),
            ExportImportConfigurationConstants.TYPE_EXPORT_LAYOUT,
            exportLayoutSettingsMap);
\end{verbatim}

  The
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/service/ExportImportConfigurationLocalService.html}{ExportImportConfigurationLocalService}
  provides several useful methods to create and modify your custom
  \texttt{ExportImportConfiguration}.
\item
  Call the appropriate service using your newly created
  \texttt{ExportImportConfiguration} object to initiate an export/import
  or staging process. For example,

\begin{verbatim}
files[0] = exportImportLocalService.exportLayoutsAsFile(
    exportImportConfiguration);
\end{verbatim}

  Notice that your \texttt{ExportImportConfiguration} object is the only
  needed parameter in the method. Your configuration object holds all
  the required parameters and settings necessary to export your layouts
  from Liferay DXP.
\end{enumerate}

It's that easy! To start your own export/import or staging process, you
must create an \texttt{ExportImportConfiguration} object using a
combination of the three provided \texttt{ExportImportConfiguration}
factories (outlined
\href{/docs/7-2/frameworks/-/knowledge_base/f/export-import\#exportimport-processes}{here}).
Once you have your configuration object, provide it as a parameter in
one of the many service methods available to you by the Export/Import or
Staging interfaces to begin your desired process.

\chapter{Staging}\label{staging-1}

\href{docs/7-2/user/-/knowledge_base/u/staging-content-for-publication}{Staging}
lets users change a Site without affecting the live Site and then
publish all the changes in one fell swoop. If you include staging
support in your application, your users can stage its content until it's
ready.

For example, if your application uses the Staging framework and provides
information intended only during a specific holiday, users can save your
application's assets specific for that holiday. They reside in the
Staging environment until they're ready for publishing.

Staging and Export/Import share the same base framework. When publishing
your staged content to the live Site, you're essentially importing
content from the staged Site and exporting it to the live Site. This
means that implementing Staging in your app is \emph{almost} the same as
implementing the Export/Import framework. You can visit the
\href{/docs/7-2/frameworks/-/knowledge_base/f/export-import}{Export/Import}
framework's articles for the base APIs that both it and the Staging
frameworks share.

If your app supports Export/Import, its entities
(\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-staged-models}{staged
models}) are automatically tracked by Staging with the use of
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-data-handlers}{data
handlers}. There are some Staging-specific configurations you can add
that are not shared by Export/Import. Some Staging-specific actions you
can complete include

\begin{itemize}
\tightlist
\item
  Control Staging UI settings
\item
  Filter Staging-specific processes
\item
  Check for Staging-specific states
\end{itemize}

You'll learn about these next.

\section{Controlling Staging's UI
Settings}\label{controlling-stagings-ui-settings}

You can control most of Staging's UI from your portlet data handler.
This can be done several ways; first, you can configure predefined
setter methods in the portlet data handler's \texttt{activate()} method:

\begin{itemize}
\tightlist
\item
  \texttt{setStagingControls}: adds fine grained controls over staging
  behavior that is rendered in the Staging UI. For example, this enables
  your app's checkboxes in the Content section of the Publication
  screen. This is usually set like this:
  \texttt{setStagingControls(getExportControls());}. The staging UI
  typically provides the same content as the export UI (i.e., the
  Content section for selecting what to publish/export), so it leverages
  its UI. You can set the Staging UI differently by configuring the
  \texttt{setStagingControls} method differently. See the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/asset/asset-tags-service/src/main/java/com/liferay/asset/tags/internal/exportimport/data/handler/AssetTagsPortletDataHandler.java\#L82-L84}{\texttt{AssetTagsPortletDataHandler}}
  class for an example of not copying the Export UI for the Staging UI.
\item
  \texttt{setDataAlwaysStaged}: defines whether you can enable/disable
  your app's content staging (i.e., selectable from the Publication
  screen). For example, setting this method to \texttt{true}
  automatically stages your app's content. Users can no longer choose
  whether its content should be staged.
\end{itemize}

Other setter methods are available that control both Export/Import and
Staging settings. You can reference them by visiting the
\href{/docs/7-2/frameworks/-/knowledge_base/f/developing-data-handlers\#understanding-the-portletdatahandler-interface}{Understanding
the \texttt{PortletDataHandler} Interface} section.

You can also control whether your app is enabled on the Staged Content
screen by adding this method to your portlet data handler:

\begin{verbatim}
@Override
public boolean isConfigurationEnabled() {
    return false;
}
\end{verbatim}

When this is set to \texttt{false}, your app is disabled on the Staged
Content screen. This is set to \texttt{true} by default.

\begin{figure}
\centering
\includegraphics{./images/staged-content-screen.png}
\caption{There are many apps available to select from the Staged Content
screen.}
\end{figure}

The majority of Staging-specific configurations are completed in a
portlet data handler. The staged model data handler does come into play
when you want to filter for certain staging processes/states. You'll
learn about this next.

\section{Filtering Staging-Specific Processes and
States}\label{filtering-staging-specific-processes-and-states}

You can filter for certain staging-specific processes/states and
complete actions based on the returned status. You can do this by
leveraging the following classes from a staged model data handler:

\begin{itemize}
\tightlist
\item
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/exportimport/kernel/lar/ExportImportThreadLocal.html}{\texttt{ExportImportThreadLocal}}
\item
  \href{https://docs.liferay.com/dxp/apps/staging/latest/javadocs/com/liferay/staging/StagingGroupHelper.html}{\texttt{StagingGroupHelper}}
\end{itemize}

The \texttt{ExportImportThreadLocal} class provides boolean methods that
return whether a specific process is in progress. Use this to check for
events affecting the entire site. For example, you can check if the
following processes are in progress:

\begin{itemize}
\tightlist
\item
  Local Staging
\item
  Remote Staging
\item
  Layout Validation
\item
  Portlet Staging
\item
  etc.
\end{itemize}

The \texttt{StagingGroupHelper} interface provides utility methods that
return the staging state in your app. This is intended to check for
events only affecting your app. For example, you can check if your app
is in these states:

\begin{itemize}
\tightlist
\item
  Resides in Local Staging group
\item
  Resides in Remote Live group
\item
  Is a staged portlet
\item
  etc.
\end{itemize}

A real example filtering for a staging process and state can be found in
the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-b2/modules/apps/asset/asset-list-service/src/main/java/com/liferay/asset/list/internal/exportimport/data/handler/AssetListEntryStagedModelDataHandler.java\#L215-L222}{\texttt{AssetListEntryStagedModelDataHandler}}
class:

\begin{verbatim}
if ((assetRendererFactory != null) &&
    ExportImportThreadLocal.isStagingInProcess() &&
    !_stagingGroupHelper.isStagedPortlet(
        assetEntry.getGroupId(),
        assetRendererFactory.getPortletId())) {

    continue;
}
\end{verbatim}

The staged model data handler uses the
\texttt{ExportImportThreadLocal.isStagingInProcess()} method to verify
that a staging process is running. It also checks whether the app is
staged by executing \texttt{!\_stagingGroupHelper.isStagedPortlet(...)}.

Excellent! You can now filter for staging-specific processes and states.

\chapter{Dependency Injection}\label{dependency-injection}

When you're using a object based on its interface, you don't have to
concern yourself with the implementation because it's abstracted from
you. At runtime, the implementation used depends on your environment and
your app's configuration. Liferay DXP offers several standard ways to
register implementations and inject them into your applications.

\textbf{Contexts and Dependency Injection (CDI):} Is the Java EE
standard dependency injection mechanism. Liferay DXP's CDI bean
container makes an application's concrete classes available as beans.
Bean classes can user other beans by way of injecting them into their
fields that have the \texttt{@Inject} annotation.

\textbf{OSGi Declarative Services:} Liferay DXP's OSGi runtime framework
allows components to register as service provides and other components
can call on the registry to bind the services to their fields that have
the \texttt{@Reference} annotation. Liferay DXP's services and services
you create using
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} are available as OSGi Declarative Services.

\textbf{Spring DI:} The Spring framework includes inversion of control
(IoC) and dependency injection. It's available to applications that
configure the Spring framework.

As an added bonus, Liferay DXP provides
\href{/docs/7-2/frameworks/-/knowledge_base/f/osgi-cdi-integration}{OSGi
CDI integration}. It lets you publish CDI beans as OSGi services and
consume OSGi services in your CDI beans. Which dependency injection
mechanism will you use? Read on to learn more about them.

\chapter{CDI Dependency Injection}\label{cdi-dependency-injection}

Portlet 3.0 (see \href{https://jcp.org/en/jsr/detail?id=362}{JSR 362})
supports Contexts and Dependency Injection (CDI) so you can create and
use injectable classes (CDI beans) in your portlet. It also provides
injectable portlet artifacts called
\href{/docs/7-2/reference/-/knowledge_base/r/cdi-portlet-predefined-beans}{Portlet
Predefined Beans}. They give a portlet's CDI beans access to the portlet
configuration, preferences, requests, responses, and more. Here's how to
create and use CDI beans and Portlet Predefined Beans:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a portlet WAR project, if you haven't created one already.

  \begin{itemize}
  \tightlist
  \item
    Any project that has a class that implements the
    \href{https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/Portlet.html}{\texttt{javax.portlet.Portlet}}
    interface, either directly or indirectly.
  \end{itemize}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're developing a portlet JAR, such as a
 [Liferay MVC Portlet](/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet),
 use CDI via
 [OSGi CDI Integration](/docs/7-2/frameworks/-/knowledge_base/f/osgi-cdi-integration).
\end{verbatim}

\noindent\hrulefill

\noindent\hrulefill

\begin{verbatim}
 **Note:**
 Liferay DXP exports the packages provided by the Portlet API and CDI API.
 Liferay project templates typically include them as transitive
 dependencies. If you must explicitly depend on the portlet API and CDI
 artifacts, add them as `compileOnly` (Gradle) or `provided` (Maven)
 dependencies.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  If your portlet WAR project isn't a Bean Portlet, add this
  \texttt{src/main/webapp/WEB-INF/beans.xml} file to it. This file tells
  CDI to scan the project for CDI annotations.

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee" bean-discovery-mode="all" version="1.2"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd">
    <!-- This file is necessary in order to inform CDI that scanning should occur for CDI annotations. -->
</beans>
\end{verbatim}
\item
  Add the
  \href{https://docs.oracle.com/javaee/7/api/javax/enterprise/context/ApplicationScoped.html}{\texttt{@ApplicationScoped}}
  annotation to your portlet class.

\begin{verbatim}
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class MyPortlet ... {
    ...
}
\end{verbatim}
\item
  Make sure all concrete classes you want to make injectable have the
  default constructor. These classes are now CDI beans.
\item
  Add a scope to each CDI bean.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Bean Scope              | Description      |
 ----------------------- | ---------------- |
 [`@ApplicationScoped`](https://docs.oracle.com/javaee/7/api/javax/enterprise/context/ApplicationScoped.html) | Shares the bean's state across all users' interactions with the portlet. |
 [`@Dependent`](https://docs.oracle.com/javaee/7/api/javax/enterprise/context/Dependent.html) | (default scope) Designates the bean to be for the client bean and share the client bean's lifecycle. |
 [`@PortletRequestScoped`](https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/PortletRequestScoped.html) | Associates the bean with the portlet request. |
 [`@PortletSessionScoped`](https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/PortletSessionScoped.html) | Places the bean in the portlet session. |
 [`@RenderStateScoped`](https://docs.liferay.com/portlet-api/3.0/javadocs/javax/portlet/annotations/RenderStateScoped.html) | Stores the bean as part of the portlet's render state. **Important:** The bean must implement the `PortletSerializable` interface. |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\item
  Use the \href{https://jcp.org/en/jsr/detail?id=330}{JSR 330}
  \href{https://docs.oracle.com/javaee/7/api/javax/inject/Inject.html}{\texttt{@Inject}}
  annotation in a CDI bean to inject another CDI bean into it. For
  example, this code informs Liferay DXP's CDI bean container to inject
  a \texttt{GuestBook} CDI bean into this \texttt{guestbook} field.

\begin{verbatim}
@Inject
private GuestBook guestbook;
\end{verbatim}
\item
  Inject any
  \href{/docs/7-2/reference/-/knowledge_base/r/cdi-portlet-predefined-beans}{Portlet
  Predefined Beans} (portlet request scoped or dependent scoped beans)
  into your \texttt{@PortletRequestScoped} CDI beans.

\begin{verbatim}
@PortletRequestScoped
public class RequestProcessor ... {

    @Inject
    private PortletRequest portletRequest;
    ...
}
\end{verbatim}
\item
  Inject any
  \href{/docs/7-2/reference/-/knowledge_base/r/cdi-portlet-predefined-beans}{dependent
  scoped Portlet Predefined Beans} into your \texttt{ApplicationScoped}
  or \texttt{@Dependent} scoped CDI beans. For example,

\begin{verbatim}
@ApplicationScoped
public class MyPortlet ... {

    @Inject
    private PortletConfig portletConfig;
    ...
}
\end{verbatim}
\item
  Use bean EL names to reference any
  \href{/docs/7-2/reference/-/knowledge_base/r/cdi-portlet-predefined-beans}{portlet
  redefined \emph{named beans}} in your JSP or JSF pages.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy}
  your project.
\end{enumerate}

Congratulations! You have created and used CDI beans and Portlet
Predefined Beans in your portlet.

\section{Related Topics}\label{related-topics-47}

\href{/docs/7-2/reference/-/knowledge_base/r/cdi-portlet-predefined-beans}{CDI
Portlet Predefined Beans}

\href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}

\chapter{OSGi CDI Integration}\label{osgi-cdi-integration}

Liferay DXP's runtime environment consists of services (OSGi services).
The OSGi service registry and Service Component Runtime (SCR) facilitate
providing and consuming services.
\href{http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html}{Contexts and
Dependency Injection (CDI)} is a Java SE and EE standard for lifecycle
events, stateful objects, and dependency injection.
\href{https://osgi.org/specification/osgi.enterprise/7.0.0/service.cdi.html}{OSGi
CDI Integration} brings features and capabilities of CDI to OSGi and
makes OSGi services available to CDI beans. Here you'll learn how to

\begin{itemize}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/publishing-cdi-beans-as-osgi-services}{Publish
  CDI beans as OSGi services}: Register CDI beans as services you can
  use to customize Liferay DXP components.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-osgi-services-in-a-bean}{Use
  OSGi services in beans}: Leverage any OSGi service published on
  Liferay DXP in any bean.
\end{itemize}

The following use cases provide more detail.

\section{Use Case: Registering a CDI bean as an OSGi
service}\label{use-case-registering-a-cdi-bean-as-an-osgi-service}

Liferay DXP extension points are implemented as OSGi services. If
there's a piece of functionality you must customize, you don't have to
learn OSGi to do it: you can write your extension/override as a CDI bean
instead and use OSGi CDI integration to publish your bean as an OSGi
service.

By implementing the service in your CDI bean class and adding the
integration's \texttt{@org.osgi.service.cdi.annotations.Service}
annotation to it, your bean registers as providing that OSGi service. In
this way, service consumers can use your service implementation (i.e.,
your CDI bean).

For example, the Service Registry in figure 1 shows two implementations
of an OSGi service called \texttt{S1}:

\begin{figure}
\centering
\includegraphics{./images/injecting-bean-osgi-service.png}
\caption{OSGi Service Component Runtime (SCR) finds \texttt{MyBean} as
the best (highest ranked) \texttt{S1} service provider and binds it to
consumer component \texttt{C1}.}
\end{figure}

\begin{itemize}
\item
  \texttt{MyBean} is a CDI bean whose service rank is \texttt{1000}.
\item
  \texttt{MySvcImpl} has a service rank of \texttt{0}.
\end{itemize}

The Service Component Runtime (\texttt{SCR}) finds the matching, highest
ranked \texttt{S1} service provider and binds it to consumer
\texttt{C1}. The fact that \texttt{MyBean} is a CDI bean is transparent
to the SCR.

Once a CDI bean is registered as a service, components can use it as
they would any other OSGi service.

\section{Use Case: Using an OSGi service in a
bean}\label{use-case-using-an-osgi-service-in-a-bean}

Liferay DXP contains many development frameworks for all of its
constructs, such as Users, Sites, Documents, Comments, and the APIs for
these assets are all implemented as OSGi services. When developers write
new applications using Liferay's development frameworks, new assets
become available and integrated with the rest of the system. OSGi CDI
integration enables your beans to access these OSGi services.

\begin{figure}
\centering
\includegraphics{./images/using-a-service-in-a-bean.png}
\caption{Here how Liferay's \texttt{UserLocalService} is injected into a
bean.}
\end{figure}

In figure 2, for example, CDI bean \texttt{SomeBean} uses the OSGi CDI
integration annotation
\texttt{@org.osgi.service.cdi.annotations.Reference} (along with CDI
annotation \texttt{@Inject}) to inject the OSGi service
\texttt{UserLocalService}. The Service Component Runtime (\texttt{SCR})
finds the \texttt{UserLocalService} in the Service Registry and binds it
to \texttt{SomeBean}'s field \texttt{userSvc}.

These are the most common use cases, but you might have more. Now you
can get started using OSGi CDI integration to
\href{/docs/7-2/frameworks/-/knowledge_base/f/publishing-cdi-beans-as-osgi-services}{publish
CDI beans as OSGi services}!

\chapter{Publishing CDI Beans as OSGi
Services}\label{publishing-cdi-beans-as-osgi-services}

You can publish CDI beans as OSGi services, making them accessible via
the Liferay's OSGi service registry. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a project dependency on the OSGi CDI Integration artifact. For
  example, here's the dependency to use in a Maven \texttt{pom.xml}
  file:

\begin{verbatim}
<dependency>
    <groupId>org.osgi</groupId>
    <artifactId>org.osgi.service.cdi</artifactId>
    <version>1.0.0</version>
</dependency>
\end{verbatim}
\item
  Make your CDI bean implement the service interface you're providing.
  For example, \texttt{ShopImpl} provides the \texttt{Shop} service by
  implementing that interface.

\begin{verbatim}
package my.package;

public class ShopImpl implements Shop {
    ...
}
\end{verbatim}
\item
  Annotate your CDI bean class with
  \texttt{@org.osgi.service.cdi.annotations.Service}.

\begin{verbatim}
package my.package;

import org.osgi.service.cdi.annotations.Service;

@Service 
public class ShopImpl implements Shop {
    ...
}
\end{verbatim}
\item
  Deploy the API that defines the service interface, if you haven't
  deployed it already.
\item
  Build and deploy your service project bundle.
\end{enumerate}

Once your bundle installs and activates, your bean's service
implementation is available. You can use Gogo Shell commands can verify
that the service registered.

For example, here are steps for verifying that a bundle
\texttt{com.liferay.portal.samples.cdi.jar.portlet} registers a service
called \texttt{org.apache.portals.samples.Users}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to \emph{Control Panel} → \emph{Configuration} → \emph{Gogo
  Shell}.
\item
  Use the \texttt{lb} Gogo command and \texttt{grep} (pass in the
  bundle's symbolic name) to find your bundle (and its ID).

  Example command:

\begin{verbatim}
g!: lb | grep com.liferay.portal.samples.cdi.jar.portlet
\end{verbatim}

  Results:

\begin{verbatim}
924|Active     |   10|com.liferay.portal.samples.cdi.jar.portlet (0.0.1.201901252134)|0.0.1.201901252134
\end{verbatim}

  The first column contains the bundle ID.
\item
  Use the \texttt{b} Gogo command with your bundle ID to list your
  bundle's details and verify the bundle includes your service as one of
  its registered services.

  Example command:

\begin{verbatim}
g!: b 924
\end{verbatim}

  Results:

\begin{verbatim}
com.liferay.portal.samples.cdi.jar.portlet_0.0.1.201901252134 [924]
Id=924, Status=ACTIVE      Data Root=C:\git\bundles\osgi\state\org.eclipse.osgi\924\data
"Registered Services"
  ...
  {org.apache.portals.samples.Users}={osgi.command.scope=cdiportlet, service.id=4232, service.bundleid=924, service.scope=singleton, osgi.command.function=[getUsersCount], component.name=com.liferay.portal.samples.cdi.jar.portlet, component.id=1}
  ...
\end{verbatim}
\end{enumerate}

Congratulations on publishing your CDI bean as an OSGi service!

\chapter{Using OSGi Services in a
Bean}\label{using-osgi-services-in-a-bean}

Any bean can use the
\texttt{@org.osgi.service.cdi.annotations.Reference} annotation to
inject OSGi services. It's the easiest way for a bean to access an OSGi
service. Here's how:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a project dependency on the OSGi CDI Integration artifact. For
  example, here's the dependency to use in a Maven \texttt{pom.xml}
  file:

\begin{verbatim}
<dependency>
    <groupId>org.osgi</groupId>
    <artifactId>org.osgi.service.cdi</artifactId>
    <version>1.0.0</version>
</dependency>
\end{verbatim}
\item
  Obtain and inject the OSGi service by using the
  \texttt{@org.osgi.service.cdi.annotations.Reference} and
  \texttt{@javax.inject.Inject} annotations respectively. Here's an
  example of injecting a service of type \texttt{ProductStore}.

\begin{verbatim}
import javax.inject.Inject;

import org.osgi.service.cdi.annotations.Reference;

import package.path.ProductStore;

public class MyBean {

    @Inject
    @Reference
    ProductStore productStore;

    ...
}
\end{verbatim}
\item
  Deploy your bean project to Liferay DXP.
\end{enumerate}

Congratulations on injecting an OSGi service into your bean! Now your
bean uses the OSGi service you injected.

\chapter{Declarative Services}\label{declarative-services}

Liferay DXP's OSGi framework registers objects as \emph{services}. Each
service offers functionality and can leverage functionality other
services provide. The OSGi Services model supports a collaborative
environment for objects.

Declarative Services (DS) provides a service component model on top of
OSGi Services. DS service components are marked with the
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
annotation and implement or extend a service class. Service components
can refer to and use each other's services. The Service Component
Runtime (SCR) registers component services and handles binding them to
other components that reference them.

Here's how the ``magic'' happens:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Service registration:} On installing a module that contains a
  service component, the SCR creates a component configuration that
  associates the component with its specified service type and stores it
  in a service registry.
\item
  \textbf{Service reference handling:} On installing a module whose
  service component references another service type, the SCR searches
  the registry for a component configuration that matches the service
  type and on finding a match binds an instance of that service to the
  referring component.
\end{enumerate}

It's publish, find, and bind at its best!

How do you use DS to register and bind services? Does it involve
creating XML files? No, it's much easier than that. You use two
annotations: \texttt{@Component} and \texttt{@Reference}.

\begin{itemize}
\item
  \href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}:
  Add this annotation to a class definition to make the class a
  component--a service provider.
\item
  \href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}}:
  Add this annotation to a field to inject it with a service that
  matches the field's type.
\end{itemize}

The
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}
annotation makes the class an OSGi component. Setting the annotation's
\texttt{service} attribute to a particular service type allows other
components to reference the service component by that service type.

For example, the following class is a service component of type
\texttt{SomeApi.class}.

\begin{verbatim}
@Component(
    service = SomeApi.class
)
public class Service1 implements SomeApi {
   ...
}
\end{verbatim}

On deploying this class's module, the SCR creates a component
configuration that associates the class with the service type
\texttt{SomeApi}.

Specifying a service reference is easy too. Applying the
\href{https://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}}
annotation to a field marks it to be injected with a service matching
the field's type.

\begin{verbatim}
@Reference
SomeApi _someApi;
\end{verbatim}

On deploying this class's module, the SCR finds a component
configuration of the class type \texttt{SomeApi} and binds the service
to this referencing component class's field \texttt{SomeApi\ \_someApi}.

\noindent\hrulefill

\textbf{Note:} The \texttt{@Reference} annotation can only be used in a
class that is annotated with \texttt{@Component} (i.e, a Declarative
Services component ) or a bean class that uses OSGi CDI integration.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} At build time in modules created from
\href{/docs/7-1/reference/-/knowledge_base/r/project-templates}{Liferay
project templates}, bnd creates a \emph{component description} file for
each module's components automatically. The file specifies the
component's services, dependencies, and activation characteristics. On
module deployment, the OSGi framework reads the component description to
create the component and manage its dependency on other components.

\noindent\hrulefill

The SCR stands ready to pair service components with each other. For
each referencing component, the SCR binds an instance of the targeted
service to it.

As an improvement over dependency injection with Spring, OSGi
Declarative Services supports dynamic dependency injection. You can
create and publish service components for other classes to use. You can
update the components and even publish alternative component
implementations for a service. This kind of dynamism is a powerful part
of Liferay DXP.

\chapter{Service Trackers for OSGi
Services}\label{service-trackers-for-osgi-services}

In an OSGi runtime ecosystem, you must consider how your apps can rely
on OSGi services in other modules for functionality. It's possible for
service implementations to be swapped out or removed entirely, and your
app must not just survive but thrive in this environment.

If you want to
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{call
OSGi services from an OSGi Declarative Services \texttt{@Component}}
classes, it's easy: you just use a
\href{https://osgi.org/specification/osgi.cmpn/7.0.0/service.component.html}{Declarative
Services (DS)} annotation,
\href{ttps://osgi.org/javadoc/r6/residential/org/osgi/service/component/annotations/Reference.html}{\texttt{@Reference}},
to inject the service. The component activates when the referenced
service is available.

\noindent\hrulefill

\textbf{Note:} The \texttt{@Reference} annotation can only be used in a
class that is annotated with
\href{https://docs.osgi.org/javadoc/osgi.cmpn/7.0.0/org/osgi/service/component/annotations/Component.html}{\texttt{@Component}}.
That is, only a Declarative Services component can use
\texttt{@Reference} to bind to an OSGi service.

\noindent\hrulefill

If you want to call an OSGi service from a bean, use
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-osgi-services-in-a-bean}{OSGi
CDI integration}.

DS \texttt{@Reference} with \texttt{@Component}s and OSGi CDI
integration with beans manage much of the complexity of service dynamism
for you transparently. If you can use either of them, you should.
Otherwise, read
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{implement
a Service Tracker} to look up services in the service registry.

\chapter{Using a Service Tracker}\label{using-a-service-tracker}

Your non-OSGi and non-bean classes can access any service registered in
the OSGi runtime using a Service Tracker. It lets you access any OSGi
services including your own
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder services} and the services published by Liferay's modules (like
the popular \texttt{UserLocalService}).

You can create a service tracker in two ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a service tracker where you need it.
\item
  Create a class that extends
  \texttt{org.osgi.util.tracker.ServiceTracker}.
\item
  Create a service tracker that tracks service events using a callback
  handler.
\end{enumerate}

Both ways depend on \texttt{org.osgi.core}, whose packages Liferay DXP
exports by default. Configure it as \texttt{compileOnly} (Gradle) or
\texttt{provided} (Maven). See the
\href{/docs/7-1/reference/-/knowledge_base/r/third-party-packages-portal-exports}{Third
Party Packages Portal Exports} for more information.

\noindent\hrulefill

\textbf{Note:} The static utility classes (e.g.,
\texttt{UserLocalServiceUtil}) that were useful in Liferay Portal 6.2
(and earlier) exist for compatibility but should not be called, if
possible. Static utility classes cannot account for the OSGi runtime's
dynamic environment. If you use a static class, you might attempt
calling a stopped service or one that hasn't been deployed or started.
This could cause unrecoverable runtime errors. Service Trackers,
however, help you make OSGi-friendly service calls.

\noindent\hrulefill

\section{Creating a New Service Tracker Where You Need
It}\label{creating-a-new-service-tracker-where-you-need-it}

To create it directly, do this:

\begin{verbatim}
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;
import org.osgi.util.tracker.ServiceTracker;

Bundle bundle = FrameworkUtil.getBundle(this.getClass());
BundleContext bundleContext = bundle.getBundleContext();
ServiceTracker<SomeService, SomeService> serviceTracker =
    new ServiceTracker(bundleContext, SomeService.class, null);
serviceTracker.open();
SomeService someService = serviceTracker.waitForService(500);
\end{verbatim}

\section{Create a Class That Extends
ServiceTracker}\label{create-a-class-that-extends-servicetracker}

A better way is to create a class that extends
\texttt{org.osgi.util.tracker.ServiceTracker}, because this simplifies
your code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class like this one that extends \texttt{ServiceTracker}:

\begin{verbatim}
public class SomeServiceTracker
    extends ServiceTracker<SomeService, SomeService> {

    public SomeServiceTracker(Object host) {
        super(
            FrameworkUtil.getBundle(host.getClass()).getBundleContext(),
            SomeService.class, null);
    }
}
\end{verbatim}
\item
  Construct a new instance of your service tracker where you need it.
  The \texttt{Object\ host} parameter obtains your own bundle context
  and must be an object from your own bundle in order to give accurate
  results.

\begin{verbatim}
ServiceTracker<SomeService, SomeService> someServiceTracker =
    new SomeServiceTracker(this);
\end{verbatim}
\item
  When you want to use the service tracker, open it, typically as early
  as you can.

\begin{verbatim}
someServiceTracker.open();
\end{verbatim}
\item
  Before attempting to use a service, use the Service Tracker to
  interrogate the service's state. For example, check whether the
  service is \texttt{null}:

\begin{verbatim}
SomeService someService = someServiceTracker.getService();

if (someService == null) {
    _log.warn("The required service 'SomeService' is not available.");
}
else {
    someService.doSomethingCool();
}
\end{verbatim}
\end{enumerate}

Note, service trackers have several other utility functions for
introspecting tracked services.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Later when your application is being destroyed or undeployed, close
  the service tracker.

\begin{verbatim}
someServiceTracker.close();
\end{verbatim}
\end{enumerate}

If you need to track multiple services or their events, implement a
service tracker that uses callback handlers.

\section{Creating a Service Tracker that Tracks Service Events Using a
Callback
Handler}\label{creating-a-service-tracker-that-tracks-service-events-using-a-callback-handler}

If there's a strong possibility the service might not be available or if
you need to track multiple services, the Service Tracker API provides a
callback mechanism that operates on service \emph{events}. To use this,
override \texttt{ServiceTracker}'s \texttt{addingService} and
\texttt{removedService} methods. Their \texttt{ServiceReference}
parameter references an active service object.

Here's an example \texttt{ServiceTracker} implementation from the
\href{https://osgi.org/specification/osgi.core/7.0.0/util.tracker.html\#d0e51991}{OSGi
Alliance's OSGi Core Release 7 specification}:

\begin{verbatim}
new ServiceTracker<HttpService, MyServlet>(context, HttpService.class, null) {

    public MyServlet addingService(ServiceReference<HttpService> reference) {
        HttpService httpService = context.getService(reference);
        MyServlet myServlet = new MyServlet(httpService);
        return myServlet;
    }

    public void removedService(
        ServiceReference<HttpService> reference, MyServlet myServlet) {
        myServlet.close();
        context.ungetService(reference);
    }
}
\end{verbatim}

When the \texttt{HttpService} is added to the OSGi registry, this
\texttt{ServiceTracker} creates a new wrapper class, \texttt{MyServlet},
which uses the newly added service. When the service is removed from the
registry, the \texttt{removedService} method cleans up related
resources.

As an alternative to directly overloading \texttt{ServiceTracker}
methods, create a
\texttt{org.osgi.util.tracker.ServiceTrackerCustomizer}:

\begin{verbatim}
class MyServiceTrackerCustomizer 
    implements ServiceTrackerCustomizer<SomeService, MyWrapper> {
    
    private final BundleContext bundleContext;
    
    MyServiceTrackerCustomizer(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }
    
    @Override
    public MyWrapper addedService(
        ServiceReference<SomeService> serviceReference) {
        
        // Determine if the service is one that's interesting to you.
        // The return type of this method is the `tracked` type. Its type 
        // is what is returned from `getService*` methods; useful for wrapping 
        // the service with your own type (e.g., MyWrapper).
        if (isInteresting(serviceReference)) {
            MyWrapper myWrapper = new MyWrapper(
                serviceReference, bundleContext.getService());
            
            // trigger the logic that requires the available service(s)
            triggerServiceAddedLogic(myWrapper);
            
            return myWrapper;
        }
        
        // If the return is null, the tracker is effectively ignoring any further
        // events for the service reference
        return null;
    }

    @Override
    public void modifiedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {
        // handle the modified service
    }

    @Override
    public void removedService(
        ServiceReference<SomeService> serviceReference, MyWrapper myWrapper) {

        // finally, trigger logic when the service is going away
        triggerServiceRemovedLogic(myWrapper);
    }

}
\end{verbatim}

Register the \texttt{ServiceTrackerCustomizer} by passing it as the
\texttt{ServiceTracker} constructor's third parameter.

\begin{verbatim}
ServiceTrackerCustomizer<SomeService, MyWrapper> serviceTrackerCustomizer =
    new MyServiceTrackerCustomizer();

ServiceTracker<SomeService, MyWrapper> serviceTracker = 
    new ServiceTracker<>(
        bundleContext, SomeService.class, serviceTrackerCustomizer);
\end{verbatim}

Using service trackers requires producing some boilerplate code, but now
you can look up services in the service registry, even if your plugins
can't take advantage of the Declarative Services component model.

\chapter{Friendly URLs}\label{friendly-urls}

This is a story of two URLs who couldn't be more different. One was full
of himself and always wanted to show everyone (users and SEO services
alike) just how smart he was by openly displaying all the parameters he
carried. He was happiest when he could tell people he met were
intimidated and confused by him.

\begin{verbatim}
http://localhost:8080/group/guest/~/control_panel/manage?p_p_id=com_liferay_blogs_web_portlet_BlogsAdminPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName=%2Fblogs%2Fedit_entry&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_redirect=http%3A%2F%2Flocalhost%3A8080%2Fgroup%2Fguest%2F~%2Fcontrol_panel%2Fmanage%3Fp_p_id%3Dcom_liferay_blogs_web_portlet_BlogsAdminPortlet%26p_p_lifecycle%3D0%26p_p_state%3Dmaximized%26p_p_mode%3Dview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_mvcRenderCommandName%3D%252Fblogs%252Fview%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderBycol%3Dtitle%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_orderByType%3Dasc%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entriesNavigation%3D%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_cur%3D1%26_com_liferay_blogs_web_portlet_BlogsAdminPortlet_delta%3D20&_com_liferay_blogs_web_portlet_BlogsAdminPortlet_entryId=30836
\end{verbatim}

The other was just, well, friendly. She was less concerned about looking
smart and more concerned about those she interacted with, so she shared
only the important things about her. She didn't need to look fancy and
complicated. She aspired to be simple and kind to all the users and SEO
services she encountered.

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

If you want your application to be friendly to your users and to SEO
services, make your URLs friendlier. It only takes a couple steps, after
all.

\chapter{Friendly URLs}\label{friendly-urls-1}

Follow these steps to create friendly URLs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create friendly URL routes. Create a \texttt{routes.xml} file in your
  application's web module. Liferay's pattern puts it in a
  \texttt{src/main/resources/META-INF/friendly-url-routes/} folder.
\item
  Add friendly URL routes, using as many
  \texttt{\textless{}route\textgreater{}} tags as you need friendly
  URLs, like this:

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE routes PUBLIC "-//Liferay//DTD Friendly URL Routes 7.2.0//EN" "http://www.liferay.com/dtd/liferay-friendly-url-routes_7_2_0.dtd">

<routes>
    <route>
        <pattern></pattern>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">normal</implicit-parameter>
    </route>
    <route>
        <pattern>/maximized</pattern>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">maximized</implicit-parameter>
    </route>
    <route>
        <pattern>/{entryId:\d+}</pattern>
        <implicit-parameter name="categoryId"></implicit-parameter>
        <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
        <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
        <implicit-parameter name="p_p_state">normal</implicit-parameter>
        <implicit-parameter name="tag"></implicit-parameter>
    </route>
    ...
</routes>
\end{verbatim}

  Use \texttt{\textless{}pattern\textgreater{}} tags to define
  placeholder values for the parameters that normally appear in the
  generated URL. This is just a mask. The beastly URL\\
  still lurks beneath it.

  The \texttt{pattern} value \texttt{/\{entryId:\textbackslash{}d+\}}
  matches a \texttt{/} followed by an \texttt{entryId} variable that
  matches the
  \href{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}{Java
  regular expression} \texttt{\textbackslash{}d+}---one or more numeric
  digits. For example, a URL \texttt{/entryId}, where the
  \texttt{entryId} value is \texttt{123} results in a URL value
  \texttt{/123}, which matches the pattern.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Warning:** Make sure your `pattern` values don't end in a slash `/`. A
 trailing slash character prevents the request from identifying the correct
 route.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
**Important:** If your portlet is instanceable, you must use a variant of 
the `instanceId` in the `pattern` value. If the starting value is 
`render-it`, for example, use one of these patterns:

```xml
<pattern>/{userIdAndInstanceId}/render-it</pattern>
```

or

```xml
<pattern>/{instanceId}/render-it</pattern>
```

or

```xml
<pattern>/{p_p_id}/render-it</pattern>
```

Use `<implicit-parameter>` tags to define parameters that are always the 
same for the URL. For example, for a render URL, you can be certain that the 
`p_p_lifecycle` parameter is always `0`. You don't have to define these 
types of implicit parameters, but it's a best practice because if you don't, 
they still appear in your URL. 

The implicit parameters with the name `mvcRenderCommandName` are very 
important. If you're using an `MVCPortlet` with `MVCRenderCommand` classes, 
that parameter comes from the `mvc.command.name` property in the 
`@Component` of your `MVCRenderCommand` implementation. This determines the 
page that's rendered (for example, `view.jsp`). 

<!--Add link back for 'using an `MVCPortlet` with `MVCRenderCommand` classes' 
once mvc-render-command article is available-->

```java
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS, "mvc.command.name=/",
        "mvc.command.name=/blogs/view"
    },
    service = MVCRenderCommand.class
)
```

The [DTD file](https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-friendly-url-routes_7_2_0.dtd.html)
completely defines the `routes.xml` file. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Provide an implementation of the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/FriendlyURLMapper.html}{\texttt{FriendlyURLMapper}
  service}. Create a component that specifies a
  \texttt{FriendlyURLMapper} service, with two properties:

  \begin{itemize}
  \item
    A \texttt{com.liferay.portlet.friendly-url-routes} property sets the
    path to your \texttt{routes.xml} file.
  \item
    A \texttt{javax.portlet.name} property, which you probably have
    already, specifies your portlet's name.
  \end{itemize}

\begin{verbatim}
@Component(
    property = {
        "com.liferay.portlet.friendly-url-routes=META-INF/friendly-url-routes/routes.xml",
        "javax.portlet.name=" + BlogsPortletKeys.BLOGS
    },
    service = FriendlyURLMapper.class
)
\end{verbatim}
\item
  Implement the \texttt{FriendlyURLMapper} service. For your
  convenience, the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/DefaultFriendlyURLMapper.html}{\texttt{DefaultFriendlyURLMapper}
  class} provides a default implementation. If you extend
  \texttt{DefaultFriendlyURLMapper} you must only override one method,
  \texttt{getMapping()}. Return a String that defines the first part of
  your Friendly URLs. It's smart to name it after your application.
  Here's what it looks like for Liferay's Blogs application:

\begin{verbatim}
public class BlogsFriendlyURLMapper extends DefaultFriendlyURLMapper {

    @Override
    public String getMapping() {
        return _MAPPING;
    }

    private static final String _MAPPING = "blogs";

}
\end{verbatim}
\end{enumerate}

All friendly URLs in Blogs begin with the String set here
(\texttt{blogs}). Let's look at one of these Friendly URLs in action.
Add a blog entry and then click on the entry's title. Look at the URL:

\begin{verbatim}
http://localhost:8080/web/guest/home/-/blogs/lunar-scavenger-hunt
\end{verbatim}

As specified in the friendly URL mapper class, \texttt{blogs} is the
first part of the friendly URL that comes after the Liferay part of the
URL. The next part is determined by a specific URL route in
\texttt{routes.xml}:

\begin{verbatim}
<route>
    <pattern>/{urlTitle}</pattern>
    <implicit-parameter name="categoryId"></implicit-parameter>
    <implicit-parameter name="mvcRenderCommandName">/blogs/view_entry</implicit-parameter>
    <implicit-parameter name="p_p_lifecycle">0</implicit-parameter>
    <implicit-parameter name="p_p_state">normal</implicit-parameter>
    <implicit-parameter name="tag"></implicit-parameter>
</route>
\end{verbatim}

The \texttt{urlTitle} is generated from the blog post's title. Since
it's already a parameter in the URL (see below), it's available for use
in the friendly URL.

\begin{verbatim}
<portlet:renderURL var="viewEntryURL">
    <portlet:param name="mvcRenderCommandName" value="/blogs/view_entry" />
    <portlet:param name="urlTitle" value="<%= entry.getUrlTitle() %>" />
</portlet:renderURL>
\end{verbatim}

When the render URL is invoked, the String defined in the friendly URL
mapper teams up with the \texttt{pattern} tag in your friendly URL
routes file, and you get a very friendly URL indeed, instead of some
nasty, conceited, unfriendly URL that's despised by users and SEO
services alike.

Great! Now you know how to make your URLS friendly.

\section{Related Topics}\label{related-topics-48}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/dependency-injection}{Dependency
  Injection}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
  Framework}
\end{itemize}

\chapter{Front-End Development}\label{front-end-development}

You have complete front-end development freedom. You can use Liferay
DXP's front-end frameworks, along with the front-end technologies you
love the most:

\begin{itemize}
\tightlist
\item
  EcmaScript ES2015+
\item
  React, Angular, Vue, etc.
\item
  \href{https://metaljs.com/}{Metal.js} (developed by Liferay)
\item
  \href{https://alloyui.com/}{AlloyUI} (developed by Liferay)
\item
  jQuery (included)
\item
  Lodash (included,
  \href{https://github.com/liferay/liferay-portal/blob/master/readme/BREAKING_CHANGES.markdown\#lodash-is-no-longer-included-by-default}{but
  disabled by default})
\end{itemize}

To load modules, you must know when they are needed, where they are at
build time, whether they should be bundled together or loaded
independently, and you must assemble them at runtime. Liferay's Loaders
(YUI/AUI, AMD, and npm in AMD format) handle loading for you. All you
must do is provide a small bit of information about your module.

The Liferay JS Bundle Toolkit(the
\href{https://web.liferay.com/marketplace/-/mp/application/115542926}{JS
Portlet Extender},
\href{https://www.npmjs.com/package/generator-liferay-bundle}{Liferay
Bundle Generator}, and
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-npm-bundler}{\texttt{liferay-npm-bundler}}
) has the tools you need to create and develop JavaScript portlets with
pure JavaScript tooling. You can use the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-npm-bundler}{\texttt{liferay-npm-bundler}}
to bundle npm packages in your applications. It even has several presets
for common module types (AMD, React, Angular JS, etc.) to save you time.
It creates an OSGi bundle for you, extracts all npm dependencies, and
transpiles your code for the Liferay AMD Loader.

While developing JavaScript applications, you may need to access Liferay
DXP-specific information or web services. The \texttt{Liferay} global
JavaScript Object
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-javascript-apis}{exposes
this information for you}, to use in your JavaScript applications.

\section{Lexicon and Clay}\label{lexicon-and-clay}

Liferay uses its own design language, called
\href{https://liferay.design/lexicon}{Lexicon}, to provide a common
framework for building consistent UIs and user experiences across the
Liferay product ecosystem. The web implementation of Lexicon (CSS, JS,
and HTML) is called \href{https://clayui.com/}{Clay}. It is
automatically available to application developers through a set of CSS
classes or our
\href{/docs/7-2/reference/-/knowledge_base/r/using-the-clay-taglib-in-your-portlets}{tag
library}.

\section{Templates}\label{templates}

For templating, you can use Java EE's JSP, FreeMarker, or whatever else
you like.

\section{Themes}\label{themes}

Themes use the standard components (CSS, JavaScript, and HTML) along
with FreeMarker templates. Although the default themes are nice, you may
wish to create your own look and feel for your site. The
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{Liferay
JS Theme Toolkit} has all the tools you need to create and develop
themes, but you can use the tools you prefer.

From the
\href{/docs/7-2/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
Builder Gradle Plugin}, to the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}, to
\href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}'s
\href{/docs/7-2/reference/-/knowledge_base/r/theme-template}{Theme
Template}, you can choose the development tools you like best, so you
can focus on creating a well designed theme.

\section{Front-End Extensions}\label{front-end-extensions}

Liferay DXP's modularity has many benefits for the front-end developer,
in the form of development customizations and extension points. These
extensions assure the stability, conformity, and future evolution of
your applications.

Below are some of the available front-end extensions:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/packaging-independent-ui-resources-for-your-site}{Theme
  Contributors}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/injecting-additional-context-variables-and-functionality-into-your-theme-templates}{Context
  Contributors}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/dynamic-includes}{Dynamic
  Includes}
\end{itemize}

See
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components}{Theme
Components} and
\href{/docs/7-2/customization/-/knowledge_base/c/understanding-the-page-structure}{Understanding
the Page Structure} for more information.

\chapter{Themes}\label{themes-1}

Themes customize the default look and feel of your site. You can inject
your own flavor and personality and represent the visual identity of
your brand or company.

You'll learn these things:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-themes}{Developing
  Themes}: Learn how to use Liferay DXP's tools and features to develop
  your theme.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/extending-themes}{Extending
  Themes}: Learn how to use Liferay DXP's theme extension mechanisms and
  features to add to your theme.
\end{itemize}

Themes use the standard components (CSS, JS, and HTML) along with
FreeMarker templates for rendering. There are several
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components\#theme-templates}{default
FreeMarker templates} that each handle a key piece of functionality for
the page. There are also
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components\#theme-template-utilities}{theme
template utilities} that let you use portlets, taglibs, theme objects,
and more in your theme templates.
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components\#css-frameworks-and-extensions}{CSS
extensions and patterns} come out-of-the-box, and support SASS, and
multiple JavaScript frameworks. Several mechanisms are available for
customizing, developing, and extending themes.

\chapter{Theme Workflow}\label{theme-workflow}

Themes are built on top of one of the following base themes:

\begin{itemize}
\tightlist
\item
  \textbf{Unstyled:} provides basic markup, functions, and images
\item
  \textbf{Styled:} inherits from the Unstyled base theme and adds some
  styling on top
\end{itemize}

Themes can be built with your choice of tooling. Liferay also offers its
own set of tools to get your themes up and running quickly.

The following Liferay tools help you build themes:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Theme
  Builder Gradle Plugin}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
  Theme Generator}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}'s
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-template}{Theme
  Template}.
\end{itemize}

Depending on the tool you choose (
\href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{Theme
Generator},
\href{/docs/7-2/reference/-/knowledge_base/r/theme-builder-gradle-plugin}{Gradle},
\href{/docs/7-2/reference/-/knowledge_base/r/theme-template}{Blade CLI},
\href{/docs/7-2/reference/-/knowledge_base/r/theme-template}{Maven}, or
\href{/docs/7-2/reference/-/knowledge_base/r/theme-template}{Dev Studio}
), the theme anatomy can be different. The overall development process
is the same:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Mirror the structure of the files you want to modify. Most of the
  time, you'll modify these files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{portal\_normal.ftl}: main theme markup
  \item
    \texttt{\_custom.scss}: custom CSS styling
  \item
    \texttt{main.js}: the theme's JavaScript
  \end{itemize}
\item
  Build and deploy the theme.
\item
  Apply the theme
  \href{/docs/7-2/user/-/knowledge_base/u/page-set-look-and-feel}{through
  the Look and Feel menu} by selecting your
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-thumbnail-preview-for-your-theme}{theme's
  thumbnail}.
\end{enumerate}

The finished theme is bundled as a WAR (Web application ARchive) file.

\noindent\hrulefill

\textbf{Note:} While developing your theme, you should enable
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Developer
Mode}. This disables the JavaScript minifier and caching for CSS and
FreeMarker template files, which makes debugging easier.

\noindent\hrulefill

If you've built your theme with the Liferay Theme Generator, you can use
some helpful Gulp tasks to streamline the process:

\begin{itemize}
\tightlist
\item
  \textbf{build:} builds your theme's files based on the specified base
  theme. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/building-your-themes-files}{gulp
  build tutorial} for more information.
\item
  \textbf{extend:} sets the base theme or themelet to extend. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/changing-your-base-theme}{gulp
  extend tutorial} for more information.
\item
  \textbf{init:} specifies the app server to deploy your theme to
  (automatically run during the initial creation of the theme). See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/updating-your-themes-app-server}{gulp
  init tutorial} for more information.
\item
  \textbf{kickstart:} copies files from an existing theme into your
  theme to help kickstart it. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/copying-an-existing-themes-files}{gulp
  kickstart tutorial} for more information.
\item
  \textbf{status:} lists the base theme/themelets that your theme
  extends. See the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/listing-your-themes-extensions}{gulp
  status tutorial} for more information.
\item
  \textbf{watch:} watches for changes to your theme's files and
  automatically deploys them to the server when a change is made. See
  the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-deploying-theme-changes}{gulp
  watch tutorial} for more information.
\end{itemize}

See
\href{/docs/7-2/customization/-/knowledge_base/c/theme-components}{Theme
Components} and
\href{/docs/7-2/customization/-/knowledge_base/c/understanding-the-page-structure}{Understanding
the Page Structure} to get a top-level overview of how themes work.

\chapter{Developing Themes}\label{developing-themes}

Theme projects created using the
\href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{Liferay
Theme Generator} have access to several
\href{https://www.npmjs.com/package/gulp}{gulp} tasks you can execute to
manage and develop your theme. This section covers the available actions
that these tasks provide, as well as other information you may find
useful while developing your theme.

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Using liferay theme tasks (build, deploy, extend, init, kickstart,
  status, and watch)
\item
  Using Developer Mode
\item
  Creating thumbnail previews for your theme
\item
  Creating color schemes for your theme
\item
  Making configurable theme settings
\end{itemize}

While developing your theme, you may notice that your theme's CSS and JS
files are minified. This optimizes performance, but it can make
debugging difficult during development. Developer Mode, disabled by
default, optimizes development instead. For instance, it loads CSS and
JS files individually for easier debugging. Also, you don't have to
reboot the server as often in Developer Mode. Here is a list of
Developer Mode's key behavior changes and the
\href{https://docs.liferay.com/portal/7.2-latest/propertiesdoc/portal.properties.html}{Portal
Property} override settings that trigger them (if applicable):

\begin{itemize}
\tightlist
\item
  CSS files are loaded individually rather than being combined and
  loaded as a single CSS file (\texttt{theme.css.fast.load=false}).
\item
  Layout template caching is disabled
  (\texttt{layout.template.cache.enabled=false}).
\item
  The server does not launch a browser when starting
  (\texttt{browser.launcher.url=}).
\item
  FreeMarker Templates for themes and web content are not cached, so
  changes are applied immediately (via the system setting in your
  Liferay DXP instance).
\item
  Minification of CSS and JavaScript resources is disabled
  (\texttt{minifier.enabled=false}).
\end{itemize}

Individual file loading of your styling and behaviors, combined with
disabled caching for layout and FreeMarker templates, lets you see your
changes more quickly. These developer settings are defined in the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-impl/src/portal-developer.properties}{\texttt{portal-developer.properties}
file}. See
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Using
Developer Mode with Themes} to learn how to enable Developer Mode in
your app server. You can also use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-deploying-theme-changes}{Gulp
Watch task} to test theme changes on a proxy port before deploying your
theme to your server.

\chapter{Using Developer Mode with
Themes}\label{using-developer-mode-with-themes}

This article shows how to enable Developer Mode in your app server
manually and through Dev Studio DXP, as well as how to configure other
settings that may benefit you during development. Each topic is
explained in the relevant section below.

\section{Enabling Developer Mode
Manually}\label{enabling-developer-mode-manually}

Follow these steps to enabled Developer Mode in your app server
manually:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portal-ext.properties} file in your server's root
  folder if it doesn't exist.
\item
  Add the line below to it:

\begin{verbatim}
include-and-override=portal-developer.properties
\end{verbatim}

  Alternatively, add the properties from the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-impl/src/portal-developer.properties}{portal-developer.properties}
  file to your \texttt{portal-ext.properties} file that you want to use.
\item
  Start your app server to apply the changes.
\end{enumerate}

Read the next section to learn how to enable Developer Mode in Dev
Studio DXP.

\section{Setting Developer Mode in Dev Studio
DXP}\label{setting-developer-mode-in-dev-studio-dxp}

Follow these steps to enable Developer Mode for your app server in Dev
Studio DXP:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Double-click on your server in the \emph{Servers} window and open the
  \emph{Liferay Launch} section.
\item
  Select \emph{Custom Launch Settings} and check the \emph{Use developer
  mode} option.
\item
  Save the changes and start your server.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/developer-mode-ide.png}
\caption{The \emph{Use developer mode} option lets you enable Developer
Mode for your server in Dev Studio DXP.}
\end{figure}

\noindent\hrulefill

\textbf{Warning:} Only change the Server settings from the runtime
environment's Liferay Launch section.

\noindent\hrulefill

\section{Configuring FreeMarker System
Settings}\label{configuring-freemarker-system-settings}

By default, FreeMarker theme templates and web content templates are
cached. You can change this behavior through System Settings with the
steps below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel and go to \emph{Configuration} → \emph{System
  Settings}.
\item
  Select \emph{Template Engines} under the \emph{PLATFORM} heading.
\item
  By default, the \emph{Resource modification check} (the time in
  milliseconds that the template is cached) is set to \texttt{60000}.
  Set this value to \texttt{0} to disable caching.
\end{enumerate}

Your FreeMarker templates are ready for development. Next you can learn
how to improve JavaScript file loading for development.

\section{JavaScript Fast Loading}\label{javascript-fast-loading}

By default, JavaScript fast loading is enabled in Developer Mode
(\texttt{javascript.fast.load=true}). This loads the packed version of
files listed in the
\href{https://docs.liferay.com/portal/7.2-latest/propertiesdoc/portal.properties.html\#JavaScript}{Portal
Properties} \texttt{javascript.barebone.files} or
\texttt{javascript.everything.files}. You can, however, disable
JavaScript fast loading for easier debugging for development. Just set
\texttt{javascript.fast.load} to \texttt{false} in your
\texttt{portal.properties}, or you can disable fast loading by setting
the URL parameter \texttt{js\_fast\_load} to \texttt{0}.

\noindent\hrulefill

\textbf{Note:} JavaScript fast loading is retrieved from one of three
places: the request (determined by the current URL:
\texttt{http://localhost:8080/web/guest/home?js\_fast\_load=1}(on) or
\texttt{...?js\_fast\_load=0}(off)), the Session, or the Portal Property
(\texttt{javascript.fast.load=true}). Preference is given in the order
of request, session, and then Portal Properties. This lets you change
\texttt{js\_fast\_load}'s value from the default in
\texttt{portal.properties} without having to manually re-enter
\texttt{js\_fast\_load} into the URL upon every new page load.

\noindent\hrulefill

Great! You've set up your server for Developer Mode. Now, when you
modify your theme's file directly in your bundle, you can see your
changes applied immediately on redeploying your theme!

\section{Related Topics}\label{related-topics-49}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Generating
  Layout Templates with the Theme Generator}
\end{itemize}

\chapter{Building Your Theme's Files}\label{building-your-themes-files}

Follow these steps to build your theme's files with the Build task. Note
that this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ build}.
\item
  The \texttt{gulp\ build} task generates the base theme files (in the
  \texttt{build} folder), compiles Sass into CSS, and compresses all
  theme files into a \texttt{.war} file (in the \texttt{dist} folder),
  that you can deploy to your server. Copy any of these files and
  folders to your theme's \texttt{src} folder to modify them.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploy}
  the \texttt{war} file to your app server to make it available.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/theme-dev-building-themes-gulp-build.png}
\caption{Run the \texttt{gulp\ build} task to build your theme's files.}
\end{figure}

\section{Related Topics}\label{related-topics-50}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-deploying-theme-changes}{Automatically
  Deploying Theme Changes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/copying-an-existing-themes-files}{Copying
  an Existing Theme's Files}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploying
  and Applying Themes}
\end{itemize}

\chapter{Deploying and Applying
Themes}\label{deploying-and-applying-themes}

Follow these steps to deploy your theme with the Deploy task. Note that
this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

Follow these steps to deploy your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Navigate to your theme's root folder and run \texttt{gulp\ deploy}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're running the 
 [Felix Gogo shell](/docs/7-2/customization/-/knowledge_base/c/using-the-felix-gogo-shell), 
 you can also deploy your theme using the `gulp deploy:gogo` command.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Your server's log displays that the OSGi bundle is started.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-deploying-themes-server-log.png}
  \caption{Your server's log notifies you when the theme's bundle has
  started.}
  \end{figure}
\item
  Apply your theme through the \emph{Build} → \emph{Pages} menu in the
  Control Menu. Select the \emph{Configure} option for your site pages,
  and click the \emph{Change Current Theme} button to apply your theme.
\end{enumerate}

Wonderful! Your theme is deployed to your server and applied to your
site.

\section{Related Topics}\label{related-topics-51}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-deploying-theme-changes}{Automatically
  Deploying Theme Changes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/copying-an-existing-themes-files}{Copying
  an Existing Theme's Files}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Creating
  Themelets with the Theme Generator}
\end{itemize}

\chapter{Updating Your Theme's App
Server}\label{updating-your-themes-app-server}

Follow these steps to update the configuration for your theme's app
server with the Init task. Note that this task only works for themes
that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ init}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-server-configuration-gulp-init.png}
  \caption{Run the \texttt{gulp\ init} task to update your app server
  configuration.}
  \end{figure}
\item
  Enter the updated path to your app server and site.
\item
  Your theme's \texttt{liferay-theme.json} file contains the updated
  server configuration information:

\begin{verbatim}
{
  "LiferayTheme": {
    "deploymentStrategy": "LocalAppServer",
    "appServerPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\liferay-ce-portal-7.2.0\\tomcat-9.0.10",
    "deployPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\liferay-ce-portal-7.2.0\\deploy",
    "url": "http://localhost:8080",
    "appServerPathPlugin": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\liferay-ce-portal-7.2.0\\tomcat-9.0.10\\webapps\\my-new72theme-theme",
    "deployed": true,
    "pluginName": "my-new72theme-theme"
  }
}
\end{verbatim}
\end{enumerate}

Awesome! Now you can
\href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{deploy
your theme} to the proper server.

\section{Related Topics}\label{related-topics-52}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-deploying-theme-changes}{Automatically
  Deploying Theme Changes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/changing-your-base-theme}{Changing
  Your Base Theme}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/listing-your-themes-extensions}{Listing
  Your Theme's Extensions}
\end{itemize}

\chapter{Automatically Deploying Theme
Changes}\label{automatically-deploying-theme-changes}

Follow these steps to automatically preview your theme's changes with
the Watch task. Note that this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Navigate to your theme's root folder and run \texttt{gulp\ watch}.
  This sets up a proxy for your app server and opens it in a new window
  in the browser.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Live changes are only viewable on port `9080` 
 (`http://localhost:9080`). Live changes **are not viewable** on your app 
 server (e.g. `http://localhost:8080`).
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ Run the `gulp watch` task to automatically deploy any changes to your theme.](./images/theme-dev-watching-themes-gulp-watch-startup.png)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Make a change to your theme and save the file. The updated files are
  built, compiled, and copied directly to the proxy port
  (e.g.~\texttt{9080}). CSS changes are deployed live, so no page reload
  is needed.
\item
  Once you're happy with the changes,
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{re-deploy}
  your theme to apply the changes to your site on your app server.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-dev-watching-themes-gulp-watch-auto-deploy.png}
  \caption{The watch task notifies you that the changes are deployed.}
  \end{figure}
\end{enumerate}

\section{Related Topics}\label{related-topics-53}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/updating-your-themes-app-server}{Configuring
  Your Theme's App Server}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/copying-an-existing-themes-files}{Copying
  an Existing Theme's Files}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploying
  and Applying Themes}
\end{itemize}

\chapter{Creating a Thumbnail Preview for Your
Theme}\label{creating-a-thumbnail-preview-for-your-theme}

When you apply a theme to your site pages, you have to choose from the
list of available themes in the site selector. The only identification
for each theme is the theme's name, along with a small thumbnail preview
image that gives a brief impression of the theme. This is even more
important when developing color schemes for a theme, since names are not
displayed for color schemes.

This article shows how to create a thumbnail preview for your theme so
users can identify it.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-theme-thumbnail-default.png}
\caption{Your theme thumbnail is displayed with the rest of the
available themes.}
\end{figure}

Your first step in creating a thumbnail preview for your theme is taking
a screenshot of your theme. Once you have a screenshot that you like,
follow the steps below to create a thumbnail preview for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Resize the screenshot to 270 pixels high by 480 pixels wide. Your
  thumbnail \emph{must be} these exact dimensions to display properly.
\item
  Save the image as a \texttt{.png} file named \texttt{thumbnail.png}
  and place it in the theme's \texttt{src/images} folder (create this
  folder if it doesn't already exist).
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The
 [Theme Builder Gradle plugin](/docs/7-2/reference/-/knowledge_base/r/theme-builder-gradle-plugin)
 doesn't recognize a `thumbnail.png` file. If you're using this plugin to
 build your theme instead, you must create a `screenshot.png` file in your
 theme's `images` folder that is 1080 pixels high by 864 pixels wide. The
 thumbnail is automatically generated from the screenshot for you when the
 theme is built.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Redeploy the theme. The file is displayed as the theme's thumbnail.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/theme-dev-theme-thumbnail-custom.png}
\caption{Your theme thumbnail is displayed with the rest of the
available themes.}
\end{figure}

\section{Related Topics}\label{related-topics-54}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Installing
  the Theme Generator and Creating a Theme}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Creating
  Themelets with the Theme Generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-color-schemes-for-your-theme}{Creating
  Color Schemes for Your Theme}
\end{itemize}

\chapter{Creating Color Schemes for Your
Theme}\label{creating-color-schemes-for-your-theme}

Color schemes give your theme additional color palettes. With just a
small amount of changes to your theme's CSS, you can subtly change the
look of your theme, while maintaining the same design and feel to it.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-color-schemes.png}
\caption{Color schemes give administrators some choices for your theme's
look.}
\end{figure}

Follow these steps to create color schemes for your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the theme's \texttt{WEB-INF/liferay-look-and-feel.xml} file and
  follow the pattern below to add the default color scheme. If your
  default styles are in \texttt{\_custom.scss}, use the \texttt{default}
  \texttt{\textless{}css-class\textgreater{}} as shown in the example
  below. See the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-look-and-feel_7_2_0.dtd.html\#color-scheme}{liferay-look-and-feel
  DTD} for an explanation of each of the elements used below:

\begin{verbatim}
<theme id="my-theme-id" name="My Theme Name">
   <color-scheme id="01" name="My Default Color Scheme Name">
       <default-cs>true</default-cs>
       <css-class>default</css-class>

       <color-scheme-images-path>
           ${images-path}/my_color_schemes_folder_name/${css-class}
       </color-scheme-images-path>
   </color-scheme>
   ...
</theme>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Color schemes are sorted alphabetically by `name` rather than 
 `id`. For example, a color scheme named `Clouds` and `id` `02` would be 
 selected by default over a color scheme named `Day` with `id` `01`. The 
 `<default-cs>` element overrides the alphabetical sorting and sets the 
 color scheme that is selected by default when the theme is chosen.  
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Add the remaining color schemes below the default color scheme, using
  the pattern below. Note that the IDs, names, and CSS classes must be
  unique for each color scheme.

\begin{verbatim}
<color-scheme id="id-number" name="Color Scheme Name">
   <css-class>color-scheme-css-class</css-class>
</color-scheme>
\end{verbatim}

  An example \texttt{liferay-look-and-feel.xml} configuration is shown
  below:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>7.2.0+</version>
    </compatibility>
    <theme id="my-great-theme" name="My Great Theme">
        <template-extension>ftl</template-extension>
        <color-scheme id="01" name="Default">
                <default-cs>true</default-cs>
                <css-class>default</css-class>
                <color-scheme-images-path>
                        ${images-path}/color_schemes/${css-class}
                </color-scheme-images-path>
        </color-scheme>
        <color-scheme id="02" name="Dark">
            <css-class>dark</css-class>
        </color-scheme>
        <color-scheme id="03" name="Light">
            <css-class>light</css-class>
        </color-scheme>
        <portlet-decorator ...>
            ...
    </theme>
</look-and-feel>
\end{verbatim}
\item
  Create a folder for your color schemes (\texttt{color\_schemes} for
  example) in the theme's \texttt{css} folder, and add a \texttt{.scss}
  file to it for each color scheme your theme supports, excluding the
  default color scheme since those styles are included in
  \texttt{\_custom.scss}.
\item
  The color scheme class is added to the theme's
  \texttt{\textless{}body\textgreater{}} element when the color scheme
  is applied, so add the class to the color scheme's styles to target
  the proper color scheme. The example below specifies styles for a
  color scheme with the class \texttt{day}:

\begin{verbatim}
body.day { background-color: #DDF; }
.day a { color: #66A; }
\end{verbatim}
\item
  Import the color scheme \texttt{.scss} files into the theme's
  \texttt{\_custom.scss} file. The example below imports
  \texttt{\_day.scss} and \texttt{\_night.scss} files:

\begin{verbatim}
@import "color_schemes/day";
@import "color_schemes/night";
\end{verbatim}
\item
  Create a folder for each color scheme in your theme's \texttt{images}
  folder, and add
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-thumbnail-preview-for-your-theme}{a
  thumbnail preview} for them. The folder name \emph{must match} the
  color scheme's CSS class name.
\end{enumerate}

There you have it. Now you can go color scheme crazy with your themes!

\section{Related Topics}\label{related-topics-55}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Generating
  Layout Templates}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-thumbnail-preview-for-your-theme}{Creating
  a Thumbnail Preview for Your Theme}
\end{itemize}

\chapter{Making Configurable Theme
Settings}\label{making-configurable-theme-settings}

If you have an aspect of a theme that you want an Administrator to
configure without having to manually update and redeploy the theme, you
can create a \emph{theme setting} for it. Theme settings are very
versatile and can be customized to meet your needs.

\begin{figure}
\centering
\includegraphics{./images/theme-dev-configurable-theme-settings.png}
\caption{Here are examples of configurable settings for the site Admin.}
\end{figure}

Follow the steps below to create theme settings:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your theme's \texttt{WEB-INF/liferay-look-and-feel.xml} file, and
  follow the pattern below to nest a
  \texttt{\textless{}setting/\textgreater{}} element inside the parent
  \texttt{\textless{}settings\textgreater{}} element for each setting
  you want to add:

\begin{verbatim}
<look-and-feel>
    <compatibility>
        <version>7.2.0+</version>
    </compatibility>
    <theme id="your-theme-name" name="Your Theme Name">
        <template-extension>ftl</template-extension>
    <settings>
      <setting configurable="true" key="theme-setting-key"
      options="true,false" type="select" value="true" />
      <setting configurable="true" key="theme-setting-key"
      type="text" value="My placeholder text" />
    </settings>
    <portlet-decorator>
      portlet decorators...
        </portlet-decorator>
    </theme>
</look-and-feel>
\end{verbatim}

  The example below adds a text input setting for a custom hex code:

\begin{verbatim}
<settings>
  <setting configurable="true" key="my-hex-code" type="text" value="blue" />
</settings>
\end{verbatim}

  See the \texttt{liferay-look-and-feel.xml}'s
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-look-and-feel_7_2_0.dtd.html\#settings}{DTD
  docs} for an explanation of the setting's configuration options.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can modify theme settings with JavaScript to provide a more 
 custom experience. The example below modifies the theme setting, changing 
 its `type` to `color`, to provide a color picker for the user:  

 ```xml
 <setting configurable="true" key="user-color"
 type="text" value="#993300"  
 >
 <![CDATA[  
      AUI().ready('node',function(A) {
           A.one("#[@NAMESPACE@]user-color").setAttribute("type", "color");    
           A.one("#[@NAMESPACE@]user-color").setAttribute("style", "height: 35px; width: 200px");    
       });
 ]]>
 </setting>
 ```
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Create a file called \texttt{init\_custom.ftl} in your theme's
  \texttt{templates} folder if it doesn't already exist, and follow the
  patterns in the table below to define your theme setting variables in
  it:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Return Type | Description | Pattern |
 --- | --- | --- |
 Boolean | a select box with the options `true` and `false` or a checkbox with values `yes` and `no` | `<#assign my_variable_name = getterUtil.getBoolean(themeDisplay.getThemeSetting("theme-setting-key"))/>` |
 String | a text input or text area input | `<#assign my_variable_name = getterUtil.getString(themeDisplay.getThemeSetting("theme-setting-key"))/>` |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The example below adds a custom hex code setting:

    <#assign my_hex_code = 
    getterUtil.getString(themeDisplay.getThemeSetting("my-hex-code"))/>
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Add your theme setting variables to the theme template. The example
  below prints \texttt{my\_hex-code}'s value as the value of the
  header's \texttt{style} attribute:

  \texttt{portal\_normal.ftl}:

\begin{verbatim}
<header style="background-color:${my_hex_code}">
\end{verbatim}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploy
  the theme} to apply the changes. To set the theme setting for a Public
  or Private page set, click the \emph{Gear icon} next to the page set
  you want to configure and update the setting under the \emph{Look and
  Feel} tab. Alternatively, you can set the theme setting for an
  individual page by opening the \emph{Actions menu} next to the page
  and selecting \emph{Configure} and choosing the \emph{Define a
  Specific look and feel for this page} option.
\end{enumerate}

Great! You've created configurable settings for your theme.

\section{Related Topics}\label{related-topics-56}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Creating
  Themelets with the Theme Generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/listing-your-themes-extensions}{Listing
  Your Theme's Extensions}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/importing-resources-with-a-theme}{Importing
  Resources with a Theme}
\end{itemize}

\chapter{Using Font Awesome and Glyph Icons in Your
Theme}\label{using-font-awesome-and-glyph-icons-in-your-theme}

By default, \href{https://fontawesome.com/v3.2.1/}{Font Awesome v3.2.1}
and \href{https://getbootstrap.com/docs/3.3/components/}{Bootstrap 3
Glyphicons} are enabled globally in Liferay DXP via a system setting.
This means that you can use them in your themes to create social media
links, for example. A Site Administrator can disable this to improve
performance, if they choose.

\section{Disabling Enabling Global Font Awesome and Glyphicons in
Portal}\label{disabling-enabling-global-font-awesome-and-glyphicons-in-portal}

Since Liferay DXP Fix Pack 2 and Liferay Portal 7.2 CE GA2, Font Awesome
is available globally as a system setting, which is enabled by default.
You can disable this setting to improve performance. To update the
setting, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Menu and navigate to \emph{Control Panel} →
  \emph{Configuration} → \emph{System Settings} and select \emph{Third
  Party} under the \emph{PLATFORM} heading.
\item
  Select \emph{Font Awesome} under the \emph{System Scope} and
  check/uncheck the \emph{Enable Font Awesome} checkbox to
  enable/disable Font Awesome icons and Glyphicons across the site.
\item
  Click \emph{Save} to save the configuration.
\end{enumerate}

\section{Including Font Awesome and Glyphicons in Your
Theme}\label{including-font-awesome-and-glyphicons-in-your-theme}

As a safeguard, you should include Font Awesome and Glyphicons with your
theme if you want to use them. This ensures that your icons won't break
if the global system setting is disabled. If you created the theme with
the Liferay Theme Generator and answered yes (y) to the Font Awesome
prompt, the Font Awesome dependency is added which includes Font Awesome
and Glyphicons for you. If you didn't include Font Awesome and
Glyphicons when you initially created the theme, follow these steps to
include them in your theme now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the Font Awesome v3.2.1 or Bootstrap 3 Glyphicons in your theme's
  template. The example below uses Font Awesome icons:

\begin{verbatim}
<div id="social-media-links">
  <ul class="nav flex-row mx-auto">
      <li class="mx-2">
          <div id="facebook">
            <a class="icon-facebook icon-3x text-white"
            href="http://www.facebook.com/pages/Liferay/45119213107" 
            target="_blank"><span class="hide">Facebook</span>
            </a>
          </div>
      </li>
      <li class="mx-2">
          <div id="twitter">
            <a class="icon-twitter icon-3x text-white" 
            href="http://www.twitter.com/liferay" 
            target="_blank"><span class="hide">Twitter</span>
            </a>
          </div>
      </li>
      <li class="mx-2">
          <div id="linked-in">
            <a class="icon-linkedin icon-3x text-white"
            href="http://www.linkedin.com/company/83609" 
            target="_blank"><span class="hide">LinkedIn</span>
            </a>
          </div>
      </li>
      <li class="mx-2">
          <div id="youtube">
            <a class="icon-youtube icon-3x text-white" 
            href="http://www.youtube.com/user/liferayinc" 
            target="_blank"><span class="hide">YouTube</span>
            </a>
          </div>
      </li>
      <li class="mx-2">
          <div id="google-plus">
            <a class="icon-google-plus icon-3x text-white"
            href="https://plus.google.com/+liferay/posts" 
            target="_blank"><span class="hide">Google</span>
            </a>
          </div>
      </li>
  </ul>
</div>
\end{verbatim}
\item
  Open the theme's \texttt{package.json} and include the
  \texttt{liferay-font-awesome} dev dependency:

\begin{verbatim}
"liferay-font-awesome": "3.4.0"
\end{verbatim}
\item
  Run \texttt{gulp\ deploy} from the theme's root folder to build and
  deploy the theme's files. This adds a \texttt{/css/font/} folder to
  the theme's \texttt{build} folder that contains the Font Awesome and
  Glyphicon fonts.
\end{enumerate}

\section{Related Topics}\label{related-topics-57}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Installing
  the Theme Generator and Creating a Theme}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-a-theme-to-7-2}{Upgrading
  Themes}
\end{itemize}

\chapter{Extending Themes}\label{extending-themes}

Liferay DXP has additional features that you can use to extend your
theme and modify your site. This section covers these topics:

\begin{itemize}
\tightlist
\item
  Installing Themelets
\item
  Injecting additional context variables into your theme templates
\item
  Packaging independent UI resources for your site
\item
  Copying an existing theme's files
\item
  Listing your theme's extensions
\item
  Overwriting and extending liferay theme tasks
\end{itemize}

\chapter{Installing a Themelet in Your
Theme}\label{installing-a-themelet-in-your-theme}

After you've created your
\href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{themelet},
follow the steps below to install it into your theme.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ extend}.
\item
  Choose \emph{Themelet} as the theme asset to extend.
\item
  Select \emph{Search globally installed npm modules}, \emph{Search npm
  registry}, or \emph{Specify a package URL} to locate the themelet.

  \begin{figure}
  \centering
  \includegraphics{./images/install-themelet.png}
  \caption{You can extend your theme using globally installed npm
  modules or published npm modules.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can retrieve the URL for a package by running 
 `npm show package-name dist.tarball`. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Highlight your themelet, press spacebar to activate it, and press
  \emph{Enter} to install it.
\end{enumerate}

Great, now you know how to install a themelet in your theme! The next
time you
\href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{deploy}
your theme, the themelet will be bundled along with it.

\section{Related Topics}\label{related-topics-58}

-\href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
Themelets with the Theme Generator}
-\href{/docs/7-2/frameworks/-/knowledge_base/f/injecting-additional-context-variables-and-functionality-into-your-theme-templates}{Injecting
Additional Context Variables and Functionality into Your Theme
Templates}
-\href{/docs/7-2/frameworks/-/knowledge_base/f/packaging-independent-ui-resources-for-your-site}{Packaging
Independent UI Resources for Your Site}

\chapter{Injecting Additional Context Variables and Functionality into
Your Theme
Templates}\label{injecting-additional-context-variables-and-functionality-into-your-theme-templates}

JSPs are native to Java EE and therefore have access to all the
contextual objects inherit to the platform, like the request and
session. Through these objects, developers can obtain Liferay
DXP-specific context information by accessing container objects like
\texttt{themeDisplay} or \texttt{serviceContext}. This, however, is not
the case for FreeMarker templates. To access this information in
FreeMarker templates, you must inject it yourself into the template's
context. Liferay DXP gives you a head start by injecting several common
objects into the template's context and exposing them as
\href{/docs/7-2/reference/-/knowledge_base/r/product-freemarker-macros}{FreeMarker
macros}. To inject other objects into the FreeMarker template's context,
you must create a \emph{Context Contributor}.

You can create a Context Contributor to use non-JSP templating languages
for themes, widget templates, and any other templates used in Liferay
DXP. For example, suppose you want your theme to change color based on
the user's organization. You could create a Context Contributor to
inject the user's organization into your theme's context, and then
determine the theme's color based on that information.

Follow the steps below to create a context contributor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an OSGi module using your favorite third party tool, or use
  \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade CLI}.
\item
  Create a component class that implements the
  \texttt{TemplateContextContributor} service, and set the \texttt{type}
  property to the type of context you're injecting into. Set it to
  \texttt{TYPE\_THEME} to inject context-specific variables for your
  theme, or set it to \texttt{TYPE\_GLOBAL} to inject it into every
  context execution in Liferay DXP, like themes, widget templates, DDM
  templates, etc, as defined in
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}.
  To follow naming conventions, begin the class name with the entity you
  want to inject context-specific variables for, followed by
  \emph{TemplateContextContributor} (e.g.,
  \texttt{ProductMenuTemplateContextContributor}):

\begin{verbatim}
@Component(
    immediate = true,
    property = {"type=" + TemplateContextContributor.TYPE_THEME},
    service = TemplateContextContributor.class
)
\end{verbatim}
\item
  Implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/template/TemplateContextContributor.html}{TemplateContextContributor}
  interface in your \texttt{*TemplateContextContributor} class, and
  overwrite the
  \texttt{prepare(Map\textless{}String,Object\textgreater{},\ HttpServletRequest)}
  method to inject new or modified variables into the
  \texttt{contextObjects} map. This is your template's context that was
  described earlier.
\end{enumerate}

The \texttt{ProductMenuTemplateContextContributor}'s class is shown as
an example below. It overwrites the \texttt{prepare(...)} method to
inject a modified \texttt{bodyCssClass} variable and a new
\texttt{liferay\_product\_menu\_state} variable into the theme context
for the Product Menu. Specifically, the \texttt{cssClass} variable
provides styling for the Product Menu and the \texttt{productMenuState}
variable determines whether the visible Product Menu should be open or
closed:

\begin{verbatim}
@Override
public void prepare(
    Map<String, Object> contextObjects, HttpServletRequest request) {

    if (!isShowProductMenu(request)) {
        return;
    }

    String cssClass = GetterUtil.getString(
        contextObjects.get("bodyCssClass"));
    String productMenuState = SessionClicks.get(
        request,
        ProductNavigationProductMenuWebKeys.
            PRODUCT_NAVIGATION_PRODUCT_MENU_STATE,
        "closed");

    contextObjects.put(
        "bodyCssClass", cssClass + StringPool.SPACE + productMenuState);

    contextObjects.put("liferay_product_menu_state", productMenuState);
}
\end{verbatim}

The \texttt{ProductMenuTemplateContextContributor} provides an easy way
to inject variables into Liferay DXP's theme directly related to the
Product Menu. You can do the same with your custom context contributor.
With the power to inject additional variables into any context in
Liferay DXP, you're free to fully harness the power of your chosen
templating language.

\section{Related Topics}\label{related-topics-59}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-themes}{Developing
  Themes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/packaging-independent-ui-resources-for-your-site}{Theme
  Contributors}
\end{itemize}

\chapter{Packaging Independent UI Resources for Your
Site}\label{packaging-independent-ui-resources-for-your-site}

If you want to package UI resources independent of a specific theme and
include them on every page, a \emph{Theme Contributor} is your best
option. If, instead, you want to include separate UI resources on a page
that are attached to a theme, use
\href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{themelets}.

A Theme Contributor is a module that contains CSS and JS resources to
apply to the page. The Control Menu, Product Menu, and Simulation Panel
are packaged as Theme Contributors.

\begin{figure}
\centering
\includegraphics{./images/theme-contributor-menus-diagram.png}
\caption{The Control Menu, Product Menu, and Simulation Panel are
packaged as Theme Contributor modules.}
\end{figure}

If you want to edit or style these standard UI components, you must
create a Theme Contributor and add your modifications on top. You can
also add new UI components to Liferay DXP by creating a Theme
Contributor. This article shows how to create a Theme Contributor
module.

Follow these steps to create a Theme Contributor:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a generic OSGi module using your favorite third party tool, or
  use \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade
  CLI}. You can also use the
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-contributor-template}{Blade
  Template} to create your module, in which case you can skip step 2.
\item
  Add the \texttt{Liferay-Theme-Contributor-Type} header to your
  module's \texttt{bnd.bnd} file to identify your module as a Theme
  Contributor, and add the \texttt{Web-ContextPath} header to set the
  context from which the Theme Contributor's resources are hosted. See
  the
  \href{https://search.maven.org/search?q=a:com.liferay.product.navigation.control.menu.theme.contributor}{Control
  Menu module's} \texttt{bnd.bnd} below as an example:

\begin{verbatim}
Bundle-Name: Liferay Product Navigation Product Menu Theme Contributor
Bundle-SymbolicName: com.liferay.product.navigation.product.menu.theme.contributor
Bundle-Version: 3.0.4
Liferay-Theme-Contributor-Type: product-navigation-product-menu
Web-ContextPath: /product-navigation-product-menu-theme-contributor
\end{verbatim}

  The Theme Contributor type helps Liferay DXP better identify your
  module. If you're creating a Theme Contributor to override an existing
  Theme Contributor, you should try to use the same type to maximize
  compatibility with future developments.
\item
  Add the \texttt{Liferay-Theme-Contributor-Weight} to your
  \texttt{bnd.bnd} file to set a priority for your Theme Contributor. To
  override another Theme Contributor's styles, such as those for the
  Control Menu, set a higher weight. The higher the value, the higher
  the priority. If your Theme Contributor has a weight of 100, it will
  be loaded after one with a weight of 99, allowing your CSS to override
  theirs:

\begin{verbatim}
Liferay-Theme-Contributor-Weight: [value]
\end{verbatim}
\item
  Create a \texttt{src/main/resources/META-INF/resources} folder in your
  module and place your resources (CSS and JS) in that folder.
\item
  Build and deploy your module to see your modifications applied to
  Liferay DXP pages and themes.
\end{enumerate}

That's all you need to do to create a Theme Contributor for your site.
Remember, with great power comes great responsibility, so use Theme
Contributors wisely. The UI contributions affect every page and aren't
affected by theme deployments.

\section{Related Topics}\label{related-topics-60}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-themes}{Developing
  Themes}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
  Themelets}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/installing-a-themelet-in-your-theme}{Installing
  a Themelet}
\end{itemize}

\chapter{Changing Your Base Theme}\label{changing-your-base-theme}

Follow these steps to change your theme's base theme with the Extend
task. Note that this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ extend}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-ext-changing-base-themes-gulp-extend-base-theme.png}
  \caption{Run the \texttt{gulp\ extend} task to change your base
  theme.}
  \end{figure}
\item
  Enter 1 to select a new base theme to extend.
\item
  By default, themes created with the
  \href{https://github.com/liferay/generator-liferay-theme}{Liferay
  Theme Generator} are based off of the
  \href{https://www.npmjs.com/package/liferay-theme-styled}{styled
  theme}. You can extend the styled or unstyled base theme, a globally
  installed theme, a theme published on the npm registry, or you can
  specify a package URL. Enter the number for the option you wish to
  select.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can retrieve the URL for a package by running 
 `npm show package-name dist.tarball`. 
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ You can extend the styled or unstyled base theme, a globally installed theme, a theme published to the npm registry, or you can specify a package URL.](./images/theme-ext-changing-base-themes-gulp-extend-base-theme-choice.png)
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The Classic theme is an implementation of an existing base theme 
 and is therefore not meant to be extended. Extending Liferay's Classic 
 theme is strongly discouraged.
\end{verbatim}

\noindent\hrulefill

Your theme's \texttt{package.json} contains the updated base theme
configuration:

\begin{verbatim}
"liferayTheme": {
  "baseTheme": "styled",
  "screenshot": "",
  "templateLanguage": "ftl",
  "version": "7.2"
},
\end{verbatim}

Great! You've updated your base theme. When you
\href{/docs/7-2/frameworks/-/knowledge_base/f/building-your-themes-files}{build
your theme's files} or
\href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{deploy
it}, your theme will inherit the updated base theme's files.

\section{Related Topics}\label{related-topics-61}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/updating-your-themes-app-server}{Configuring
  Your Theme's App Server}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploying
  and Applying Themes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/listing-your-themes-extensions}{Listing
  Your Theme's Extensions}
\end{itemize}

\chapter{Copying an Existing Theme's
Files}\label{copying-an-existing-themes-files}

Follow these steps to copy an existing theme's files with the Kickstart
task. Unlike extending a base theme, which is a dynamic inheritance that
applies your \texttt{src} files on top of the base theme on every build,
the Kickstart task is a one time inheritance.

\noindent\hrulefill

\textbf{Warning:} The gulp kickstart task copies an existing theme's
files into your own, which can potentially overwrite files with the same
name. Proceed with caution.

\noindent\hrulefill

Note that this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder and run \texttt{gulp\ kickstart}.

  \begin{figure}
  \centering
  \includegraphics{./images/theme-ext-kickstarting-themes-gulp-kickstart.png}
  \caption{Run the \texttt{gulp\ kickstart} task to copy a theme's files
  into your own theme.}
  \end{figure}
\item
  Select where to search for the theme to copy. You can copy files from
  globally installed themes or themes published on the npm registry.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** **You can't kickstart the Classic Theme.**
\end{verbatim}

\noindent\hrulefill

\noindent\hrulefill

\begin{verbatim}
 **Note:** To globally install a theme, run the `npm link` command from the 
 theme's root folder.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
![ You can copy files from  globally installed themes.](./images/theme-ext-kickstarting-themes-global-theme.png)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  The theme's files are copied into your own theme, jump starting
  development. Add your changes on top of these files.
\end{enumerate}

Congrats! Now you have a head start to developing your theme.

\section{Related Topics}\label{related-topics-62}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/building-your-themes-files}{Building
  Your Theme's files}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
  Themelets with the Theme Generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/deploying-and-applying-themes}{Deploying
  and Applying Themes}
\end{itemize}

\chapter{Listing Your Theme's
Extensions}\label{listing-your-themes-extensions}

Do you need to know what base theme/themelet(s) your theme extends?
Follow these steps to list your theme's extensions with the Status task.
Note that this task only works for themes that use the
\href{https://github.com/liferay/liferay-themes-sdk/tree/master/packages}{liferay
JS Theme Toolkit}, such as those created with the
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Liferay
Theme Generator}.

\noindent\hrulefill

\textbf{Note:} Gulp is included as a local dependency in generated
themes, so you are not required to install it. It can be accessed by
running \texttt{node\_modules\textbackslash{}.bin\textbackslash{}gulp}
followed by the Gulp task from a generated theme's root folder.

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to your theme's root folder.
\item
  Run \texttt{gulp\ status} to print your theme's current extensions to
  the command line.
\end{enumerate}

Your theme's current extensions are also found under the
\texttt{baseTheme} and \texttt{themeletDependencies} headings in your
theme's \texttt{package.json}.

\begin{figure}
\centering
\includegraphics{./images/theme-ext-listing-theme-extensions.png}
\caption{Run the \texttt{gulp\ status} task to list your theme's current
extensions.}
\end{figure}

\section{Related Topics}\label{related-topics-63}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/changing-your-base-theme}{Changing
  Your Base Theme}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/updating-your-themes-app-server}{Configuring
  Your Theme's App Server}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
  Themelets with the Theme Generator}
\end{itemize}

\chapter{Overwriting and Extending Liferay Theme
Tasks}\label{overwriting-and-extending-liferay-theme-tasks}

Themes created with the Liferay Theme Generator have access to several
default gulp theme tasks that provide the standard features required to
develop and build your theme (build, deploy, watch, etc.). You may,
however, want to run additional processes on your theme's files prior to
deploying the theme to the server---such as minifying your JavaScript
files. The Liferay Theme Generator's APIs expose a \texttt{hookFn}
property that lets you hook into the default gulp theme tasks to inject
your own logic.

Follow these steps to hook into the default Liferay theme tasks:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Identify the gulp task or sub task that you want to hook into or
  overwrite. The tasks and their sub tasks are listed in their
  \texttt{{[}task-name{]}.js} file in the
  \href{https://github.com/liferay/liferay-js-themes-toolkit/tree/master/packages/liferay-theme-tasks/tasks}{\texttt{tasks}
  folder} of the
  \href{https://github.com/liferay/liferay-js-themes-toolkit/tree/master/packages/liferay-theme-tasks}{\texttt{liferay-theme-tasks}}
  package. For example, the gulp \texttt{build} task and sub tasks are
  defined in the
  \href{https://github.com/liferay/liferay-js-themes-toolkit/blob/master/packages/liferay-theme-tasks/tasks/build.js\#L73-L92}{\texttt{build.js}
  file}:

\begin{verbatim}
gulp.task('build', function(cb) {
    runSequence(
        'build:clean',
        'build:base',
        'build:src',
        'build:web-inf',
        'build:liferay-look-and-feel',
        'build:hook',
        'build:themelets',
        'build:rename-css-dir',
        'build:compile-css',
        'build:fix-url-functions',
        'build:move-compiled-css',
        'build:remove-old-css-dir',
        'build:fix-at-directives',
        'build:r2',
        'build:war',
        cb
    );
});
\end{verbatim}
\item
  Open your theme's \texttt{gulpfile.js} file and locate the
  \texttt{liferayThemeTasks.registerTasks()} method. This method
  registers the default gulp theme tasks. Add the \texttt{hookFn}
  property to the \texttt{registerTasks()} method's configuration
  object, making sure to pass in the \texttt{gulp} instance:

\begin{verbatim}
liferayThemeTasks.registerTasks({
  gulp: gulp,
  hookFn: function(gulp) {

  }
});
\end{verbatim}
\item
  Inside the \texttt{hookFn()} function, use the \texttt{gulp.hook()}
  method to specify the theme task or sub task that you want to hook
  into. You can inject your code before or after a task by prefixing it
  with the \texttt{before:} or \texttt{after:} keywords. Alternatively,
  you can use the \texttt{gulp.task()} method to overwrite a gulp task.
  Both methods have two parameters: the task or sub task you want to
  hook into and a callback function that invokes \texttt{done} or
  returns a stream with the logic that you want to inject. A few example
  configuration patterns are shown below:

\begin{verbatim}
liferayThemeTasks.registerTasks({
  gulp: gulp,
  hookFn: function(gulp) {
    gulp.hook('before:build:src', function(done) {
      // Fires before build:src task
    });

    gulp.hook('after:build', function(done) {
      // Fires after build task
    });

    gulp.task('build:base', function(done) {
      // Overwrites build:base task
    });
  }
});
\end{verbatim}
\end{enumerate}

The example below fires before the \texttt{build:war} sub-task and reads
the JavaScript files in the theme's \texttt{build} folder, minifies them
with the \texttt{gulp-uglify} module, places them back in the
\texttt{./build/js} folder, invokes \texttt{done}, and finally logs that
the JavaScript was minified. To follow along, replace your theme's
\texttt{gulpfile.js} with the contents shown below, install the
\href{https://www.npmjs.com/package/gulp-uglify}{gulp-uglify} module and
the \href{https://www.npmjs.com/package/fancy-log}{fancy-log} module,
and run \texttt{gulp\ deploy}:

\begin{verbatim}
'use strict';

var gulp = require('gulp');
var log = require('fancy-log');
var uglify = require('gulp-uglify');
var liferayThemeTasks = require('liferay-theme-tasks');

liferayThemeTasks.registerTasks({
   gulp: gulp,
   hookFn: function(gulp) {
     gulp.hook('before:build:war', function(done) {
      // Fires before build `war` task
      gulp.src('./build/js/*.js')
      .pipe(uglify())
      .pipe(gulp.dest('./build/js'))
      .on('end', done);
      log('Your JS is now minified...');
      });
   }
});
\end{verbatim}

You should see something similar to the output shown below:

\begin{verbatim}
[15:58:07] Finished 'build:r2' after 198 ms
[15:58:07] Starting 'build:war'...
[15:58:07] Your JS is now minified...
[15:58:07] Starting 'plugin:version'...
[15:58:07] Finished 'plugin:version' after 2.52 ms
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} The \texttt{hook} callback function must invoke the
\texttt{done} argument or return a stream.

\noindent\hrulefill

Now you know how to hook into and overwrite the default Liferay theme
tasks!

\section{Related Topics}\label{related-topics-64}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-the-theme-generator-and-creating-a-theme}{Installing
  the Theme Generator and Creating a Theme}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-themelets-with-the-themes-generator}{Generating
  Themelets}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Using
  Developer Mode with Themes}
\end{itemize}

\chapter{Clay CSS and Themes}\label{clay-css-and-themes}

\href{https://liferay.design/lexicon/}{Lexicon} is a design language
that provides a common framework for building consistent UIs.
\href{https://clayui.com/docs/css-framework/scss.html}{Clay}, the web
implementation of Lexicon, is an extension of Bootstrap's open source
CSS Framework. Bootstrap is by far the most popular CSS framework on the
web. Built with Sass, Clay CSS fills the front-end gaps between
Bootstrap and the specific needs of Liferay DXP.

Bootstrap features have been extended to cover more use cases. Here are
some of the new components added by Clay CSS:

\begin{itemize}
\tightlist
\item
  Aspect Ratio
\item
  Cards
\item
  Dropdown Wide and Dropdown Full
\item
  Figures
\item
  Nameplates
\item
  Sidebar / Sidenav
\item
  Stickers
\item
  SVG Icons
\item
  Timelines
\item
  Toggles
\end{itemize}

Several reusable CSS patterns have also been added to help accomplish
time consuming tasks such as these:

\begin{itemize}
\tightlist
\item
  truncating text
\item
  content filling the remaining container width
\item
  truncating text inside table cells
\item
  table cells filling remaining container width and table cells only
  being as wide as their content
\item
  open and close icons inside collapsible panels
\item
  nested vertical navigations
\item
  slide out panels
\item
  notification icons/messages
\item
  vertical alignment of content
\end{itemize}

\href{https://clayui.com/}{Clay CSS} is bundled with two sub-themes:
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay}{Clay
Base} and
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay/atlas}{Atlas}.
Clay Base is Liferay DXP's Bootstrap API extension. It adds all the
features and components you need and inherits Bootstrap's styles. As a
result, Clay Base is fully compatible with
\href{/docs/7-2/frameworks/-/knowledge_base/f/integrating-third-party-themes-with-clay}{third
party themes} that leverage Bootstrap's Sass variable API.

Atlas is Liferay DXP's custom Bootstrap theme that is used in the
Classic Theme. Its purpose is to overwrite and manipulate Bootstrap and
Clay Base to create its classic look and feel. Atlas is equivalent to
installing a Bootstrap third party theme.

\noindent\hrulefill

\textbf{Note:} It is not recommended to integrate third party themes
with Atlas, as it adds variables and styles that are outside the scope
of Bootstrap's API.

\noindent\hrulefill

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Customizing the Atlas and Clay base themes
\item
  Integrating third party themes with Clay
\end{itemize}

\chapter{Customizing Atlas and Clay Base Themes in Liferay
DXP}\label{customizing-atlas-and-clay-base-themes-in-liferay-dxp}

Whether you're customizing the Atlas or Clay base theme, the process is,
for the most part, the same. Follow these steps. If you're customizing
the Clay base theme, skip to step 3.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  By default, Clay base is imported into the theme. If you're
  overwriting Atlas, add a file named \texttt{clay.scss} to your theme's
  \texttt{/src/css/} folder and import \texttt{clay/atlas} instead:

\begin{verbatim}
@import "clay/atlas";
\end{verbatim}
\item
  By default, Clay base variables are imported into the theme. If you're
  overwriting Atlas, add an \texttt{\_imports.scss} file to your theme's
  \texttt{/src/css/} folder and import Atlas variables instead:

\begin{verbatim}
@import "bourbon";

@import "mixins";

@import "compat/mixins";

@import "clay/atlas-variables";
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Bourbon mixins are deprecated as of 7.0 and will be 
 removed in the next major release. We recommend you use Clay mixins 
 instead. To use Clay mixins, follow the instructions in 
 [Using Clay Mixins in Your Theme](/docs/7-2/frameworks/-/knowledge_base/f/using-clay-mixins-in-your-theme)
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Add a file named \texttt{\_clay\_variables.scss}. Place your Atlas,
  Bootstrap, and Clay Base variable modifications in this file.
\end{enumerate}

Great! Now you know how to customize the Atlas and Clay base themes.

\section{Related Topics}\label{related-topics-65}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/integrating-third-party-themes-with-clay}{Integrating
  Third Party Themes with Clay}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-clay-mixins-in-your-theme}{Using
  Clay Mixins in Your Theme}
\end{itemize}

\chapter{Integrating Third Party Themes with
Clay}\label{integrating-third-party-themes-with-clay}

\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled/src/main/resources/META-INF/resources/_styled/css/clay}{Clay
Base} provides all the features and components your theme needs and
inherits Bootstrap's styles. As a result, Clay Base is fully compatible
with third party themes that leverage Bootstrap's Sass variable API.

The
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/modules/apps/frontend-theme/frontend-theme-styled}{Styled
Theme} uses Clay Base to provide its styles and components. Therefore,
as a best practice, you should use the Styled base theme to integrate
third party themes.

\noindent\hrulefill

\textbf{Note:} You can purchase third party themes from the
\href{https://web.liferay.com/marketplace}{Liferay Marketplace}. Third
party themes must be built with Sass to be compatible. \textbf{Make
sure} Sass files are included before making any theme purchase.

\noindent\hrulefill

Follow these steps to integrate a third party theme with Clay Base:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new theme with the Styled Theme as its base. This is the
  default base theme for newly created themes, so no further action is
  required. This provides the Clay Base files you need.
\item
  In the theme's \texttt{/src/css/} folder, add a file named
  \texttt{\_clay\_variables.scss}. Place your Atlas, Bootstrap, and Clay
  Base variable modifications in this file.
\item
  Create a folder inside \texttt{/src/css/} to house your third party
  theme (e.g.~\texttt{/src/css/my-third-party-theme/})
\item
  Copy the CSS contents of the theme to the folder you just created.
\item
  In \texttt{\_clay\_variables.scss}, import the file containing the
  theme variables. For example,
  \texttt{@import\ "my-third-party-theme/variables.scss";}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You may omit the leading underscore when importing Sass files.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  In \texttt{\_custom.scss}, import the file containing the CSS. For
  example, \texttt{@import\ "my-third-party-theme/main.scss";}
\end{enumerate}

Now you know how to integrate third party themes with Clay Base!

\section{Related Topics}\label{related-topics-66}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-atlas-and-clay-base-themes}{Customizing
  Atlas and Clay Base Themes}
\end{itemize}

\chapter{Using Clay Icons in a Theme}\label{using-clay-icons-in-a-theme}

To use Clay icons in your themes, you must use the
\href{/docs/7-2/reference/-/knowledge_base/r/freemarker-taglib-macros}{clay
taglib macro}. If you want to use Clay icons in your portlets, follow
the steps in the
\href{/docs/7-2/reference/-/knowledge_base/r/clay-icons}{Clay taglib
icons} article. To use Clay icons in your theme, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the FreeMarker theme template you want to use the Clay icon in.
\item
  Use the \texttt{@clay{[}"icon"{]}} macro and specify the icon with the
  \texttt{symbol} attribute, as shown in the pattern below:

\begin{verbatim}
<@clay["icon"] symbol="icon-name" />
\end{verbatim}

  The full list of icons can be found on
  \href{https://clayui.com/docs/components/icon.html}{ClayUI's site}
  (CSS/Markup tab). Here is an example configuration for a Facebook
  social media icon:

\begin{verbatim}
    <a class="text-white"
    href="http://www.facebook.com/pages/Liferay/45119213107" 
    target="_blank">
      <span class="hide">Facebook</span>
      <@clay["icon"] symbol="social-facebook" />
    </a>
\end{verbatim}
\end{enumerate}

Great! Now you know how to use Clay icons in your theme.

\section{Related Topics}\label{related-topics-67}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/freemarker-taglib-macros}{FreeMarker
  Taglib Macros}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-icons}{Clay Icons}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-atlas-and-clay-base-themes}{Customizing
  Atlas and Clay Base Themes}
\end{itemize}

\chapter{Using Clay Mixins in Your
Theme}\label{using-clay-mixins-in-your-theme}

Bourbon mixins are deprecated as of 7.0 and will be removed in the next
major release. We recommend you use Clay mixins instead. Follow these
steps to use Clay mixins in your theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{clay-css} dependency to the theme's
  \texttt{package.json}:

\begin{verbatim}
"dependencies":{
  "clay-css": "^2.18.0",
}
\end{verbatim}
\item
  Delete \texttt{\_imports.scss} if you modified it.
\item
  Import the library into the theme's \texttt{main.scss} file:

\begin{verbatim}
@import 'node_modules/clay-css/src/scss/atlas-variables'
\end{verbatim}

  or import the base-variables if you want to use Clay Base instead:

\begin{verbatim}
@import 'node_modules/clay-css/src/scss/base-variables'
\end{verbatim}
\end{enumerate}

Great! Now you know how to use Clay mixins in your theme!

\section{Related Topics}\label{related-topics-68}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/customizing-atlas-and-clay-base-themes}{Customizing
  Atlas and Clay Base Theme}
\end{itemize}

\chapter{Theming Portlets}\label{theming-portlets}

Although you can individually style a portlet via the theme's CSS or the
portlet's
\href{/docs/7-2/user/-/knowledge_base/u/look-and-feel-configuration}{Look
and Feel Configuration} menu, you may want to modify the default look
and feel for all portlets in your site. A portlet's template--its
container, CSS classes, and overall HTML Markup--is defined via the
theme's \texttt{portlet.ftl} file. To provide a custom style for all
portlets, use the CSS classes in this file for the various container
elements along with the portlet decorators to achieve the desired look
and feel. Be cautious: changes to \texttt{portlet.ftl} affect all the
portlets in your site when the theme is applied.

To help you with your bearings as you modify your portlet's template,
below is a quick look at the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-theme/frontend-theme-classic/src/templates/portlet.ftl}{\texttt{portlet.ftl}}
file that's included in 7.0's Classic theme.

\begin{verbatim}
<#assign
    portlet_display = portletDisplay
    portlet_back_url = htmlUtil.escapeHREF(portlet_display.getURLBack())
    portlet_content_css_class = "portlet-content"
    portlet_display_name = htmlUtil.escape(portlet_display.getPortletDisplayName())
    portlet_display_root_portlet_id = htmlUtil.escapeAttribute(portlet_display.getRootPortletId())
    portlet_id = htmlUtil.escapeAttribute(portlet_display.getId())
    portlet_title = htmlUtil.escape(portlet_display.getTitle())
/>
\end{verbatim}

These variables are described in the table below:

\textbf{Portlet FTL Variables}

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Variable
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{portletDisplay} & Fetched from the \texttt{themeDisplay} object,
contains information about the portlet \\
\texttt{portlet\_back\_url} & URL to return to the previous page when
the portlet \texttt{WindowState} is maximized \\
\texttt{portlet\_display\_name} & The ``friendly'' name of the portlet
as displayed in the GUI \\
\texttt{portlet\_display\_root\_portlet\_id} & The root portlet ID of
the portlet \\
\texttt{portlet\_id} & The ID of the portlet (not the same as the
portlet namespace) \\
\texttt{portlet\_title} & The portlet name set in the portlet Java class
(usually from a \texttt{Keys.java} class) \\
\end{longtable}

\noindent\hrulefill

Next, a condition checks if the portlet header should be displayed. If
the portlet has a portlet toolbar (Configuration, Permissions, Look and
Feel), the condition is true and the header is displayed:

\begin{verbatim}
<#if portlet_display.isPortletDecorate() && !portlet_display.isStateMax() 
&& portlet_display.getPortletConfigurationIconMenu()?? 
&& portlet_display.getPortletToolbar()??>
\end{verbatim}

You can use a similar pattern if you want to dynamically show portions
of the portlet's UI.

Next, the portlet title menus are defined. These are used in portlets
that let you add resources (Web Content Display, Media Gallery,
Documents and Media):

\begin{verbatim}
portlet_title_menus = portlet_toolbar.getPortletTitleMenus(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The configuration below contains the information for the configuration
menu (Configuration, Permissions, Look and Feel):

\begin{verbatim}
portlet_configuration_icons = portlet_configuration_icon_menu.getPortletConfigurationIcons(portlet_display_root_portlet_id, renderRequest, renderResponse)
\end{verbatim}

The rest of the file contains the HTML markup for the portlet topper and
the portlet content. This section barely scratches the surface of the
\texttt{portlet.ftl} file. You must examine the \texttt{portlet.ftl}
file yourself and determine what elements and classes need updated for
your theme and site.

Now that you are more familiar with your theme's \texttt{portlet.ftl}
file, you can learn the role Portlet Decorators play in the overall look
and feel of your portlets.

\section{Portlet Decorators}\label{portlet-decorators}

Portlet Decorators modify the style of the application wrapper. Themes
come bundled with three default portlet decorators, defined in
\texttt{liferay-look-and-feel.xml}:

\begin{itemize}
\item
  Decorate: this is the default Application Decorator when using the
  Classic theme. It wraps the application in a white box with a border,
  and displays the title at the top.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-decorate.png}
  \caption{The Classic theme's Decorate Application Decorator wraps the
  portlet in a white box.}
  \end{figure}
\item
  Borderless: this decorator shows the title at the top, but does not
  display a wrapping box.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-borderless.png}
  \caption{The Classic theme's Borderless Application Decorator displays
  the application's custom title.}
  \end{figure}
\item
  Barebone: this decorator displays the bare application content,
  showing neither the wrapping box nor the custom application title.

  \begin{figure}
  \centering
  \includegraphics{./images/application-decorator-barebone.png}
  \caption{The Classic theme's Barebone Application Decorator displays
  only the application's content.}
  \end{figure}
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Upgrading to Liferay DXP assigns the \emph{borderless}
decorator automatically to those portlets that had the \emph{Show
Borders} option set to false in previous versions of Liferay.

\noindent\hrulefill

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Embedding Portlets in Themes
\end{itemize}

\chapter{Embedding Portlets in
Themes}\label{embedding-portlets-in-themes}

You may occasionally want to embed a portlet in a theme, making the
portlet visible on all pages where the theme is used. Since there are
numerous drawbacks to hard-coding a specific portlet into place, the
\emph{Portlet Providers} framework offers an alternative that displays
the appropriate portlet based on a given entity type and action.

The first thing you should do is open the template file for which you
want to declare an embedded portlet. For example, the
\texttt{portal\_normal.ftl} template file is a popular place to declare
embedded portlets. To avoid problems, it's usually best to embed
portlets with an entity type and action, but you may encounter
circumstances where you'll want to hard code it by portlet name. Both
methods are covered in this section. These topics are covered:

\begin{itemize}
\tightlist
\item
  Embedding a portlet by entity type and action
\item
  Embedding a portlet by instance name and ID
\end{itemize}

\chapter{Embedding Portlets in Themes by Entity Type and
Action}\label{embedding-portlets-in-themes-by-entity-type-and-action}

In this article, you'll learn how to declare an entity type and action
in a custom theme, and you'll create a module that finds the correct
portlet to use based on those given parameters. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Insert a declaration where you want the portlet embedded. This
  declaration expects two parameters: the type of action and the class
  name of the entity type the portlet should handle. An example
  configuration is shown below:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletProviderAction=portletProviderAction.VIEW
    portletProviderClassName="com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry"
/>
\end{verbatim}

  This example declares that the theme is requesting to view language
  entries. Liferay DXP determines which deployed portlet to use in this
  case by providing the portlet with the highest service ranking.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** In some cases, a default portlet is already provided to fulfill
 certain requests. You can override the default portlet with your custom
 portlet by specifying a higher service rank. To do this, set the following
 property in your class' `@Component` declaration:
 
     property= {"service.ranking:Integer=20"}
 
 Make sure you set the service ranking higher than the default portlet being
 used.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  The Portal is not yet configured to handle this request. You must
  create a module that can find the portlet that fits the theme's
  request.
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module}.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, name the class based on the entity type and action type,
  followed by \emph{PortletProvider} (e.g.,
  \texttt{SiteNavigationLanguageEntryViewPortletProvider}). The class
  should extend the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BasePortletProvider.html}{\texttt{BasePortletProvider}}
  class and implement the appropriate portlet provider interface based
  on the action you chose in your theme (e.g.,
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/ViewPortletProvider.html}{\texttt{ViewPortletProvider}},
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/BrowsePortletProvider.html}{\texttt{BrowsePortletProvider}},
  etc.).
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(
    immediate = true,
    property = {"model.class.name=CLASS_NAME"},
    service = INTERFACE.class
)
\end{verbatim}

  The \texttt{property} element must match the entity type you specified
  in your theme declaration (e.g.,
  \texttt{com.liferay.portal.kernel.servlet.taglib.ui.LanguageEntry}).
  Also, your \texttt{service} element should match the interface you're
  implementing (e.g., \texttt{ViewPortletProvider.class}).
\item
  Specify the methods you want to implement. Make sure to retrieve the
  portlet ID and page ID that should be provided when this service is
  called by your theme.

  A common use case is to implement the \texttt{getPortletId()} and
  \texttt{getPlid(ThemeDisplay)} methods. Below is an example
  configuration:

\begin{verbatim}
@Override
public String getPortletName() {
  return SiteNavigationLanguagePortletKeys.SITE_NAVIGATION_LANGUAGE;
}

@Override
public PortletURL getPortletURL(
    HttpServletRequest httpServletRequest, Group group)
  throws PortalException {

  return PortletURLFactoryUtil.create(
    httpServletRequest, getPortletName(), PortletRequest.RENDER_PHASE);
}

/**
 * @deprecated As of Judson (7.1.x)
 */
@Deprecated
@Override
protected long getPlid(ThemeDisplay themeDisplay) throws PortalException {
  return themeDisplay.getPlid();
}
\end{verbatim}

  This returns the portlet ID and the PLID, which is the ID that
  uniquely identifies a page used by your theme. By retrieving these,
  your theme will know which portlet to use, and which page to use it
  on.
\item
  Generate the module's JAR file and copy it to your app server's
  \texttt{osgi/modules/} folder. Once the module is installed and
  activated in your Portal's service registry, your embedded portlet is
  available for use wherever your theme is used.
\end{enumerate}

Awesome! You successfully requested a portlet based on the entity and
action types required, and created and deployed a module that retrieves
the portlet and embeds it in your theme.

\section{Related Topics}\label{related-topics-69}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes}{Embedding
  Portlets in Themes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder}
\end{itemize}

\chapter{Embedding a Portlet by Portlet
Name}\label{embedding-a-portlet-by-portlet-name}

If you'd like to embed a specific portlet in the theme, you can hard
code it by providing its instance ID and name. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the FreeMarker theme template that you want to embed the portlet
  in. (\texttt{portal\_normal.ftl} is a good choice.
\item
  Add the \texttt{liferay\_portlet{[}"runtime"{]}} macro to the
  template, as shown below. The portlet name \textbf{must} be the same
  as \texttt{javax.portlet.name}'s value.

\begin{verbatim}
<@liferay_portlet["runtime"]
    instanceId="INSTANCE_ID"
    portletName="PORTLET_NAME"
/>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} If your portlet is instanceable, an instance ID must be
provided; otherwise, you can remove this line. To set your portlet to
non-instanceable, set the property
\texttt{com.liferay.portlet.instanceable} in the component annotation of
your portlet to \texttt{false}.

\noindent\hrulefill

Here's an example of an embedded portlet declaration that uses the
portlet name to embed a web content portlet:

\begin{verbatim}
<@liferay_portlet["runtime"]
    portletName="com_liferay_journal_content_web_portlet_JournalContentPortlet"
/>
\end{verbatim}

Great! Now you know how to embed a portlet in your theme's by their name
and ID.

\section{Related Topics}\label{related-topics-70}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes-by-entity-type-and-action}{Embedding
  Portlets in Themes by Entity Type and Action}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder}
\end{itemize}

\chapter{Setting Default Preferences for an Embedded
Portlet}\label{setting-default-preferences-for-an-embedded-portlet}

Follow these steps to set default portlet preferences for an embedded
portlet:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve portlet preferences using the
  \texttt{freeMarkerPortletPreferences} object. The example below
  retrieves the \texttt{barebone}:

\begin{verbatim}
<#assign preferences = freeMarkerPortletPreferences.getPreferences(
  "portletSetupPortletDecoratorId", "barebone"
) />
\end{verbatim}
\item
  Set the \texttt{defaultPreferences} attribute of the embedded portlet
  to the \texttt{freeMarkerPortletPreferences} object you just
  configured:

\begin{verbatim}
<@liferay_portlet["runtime"]
    defaultPreferences="${preferences}"
    portletName="com_liferay_login_web_portlet_LoginPortlet"
/>
\end{verbatim}
\end{enumerate}

Below are some additional attributes you can define for embedded
portlets:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Preference
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{defaultPreferences} & A string of Portlet Preferences for the
application. This includes look and feel configurations. \\
\textbf{instanceId} & The instance ID for the app, if the application is
instanceable. \\
\textbf{persistSettings} & Whether to have an application use its
default settings, which will persist across layouts. The default value
is \emph{true}. \\
\textbf{settingsScope} & Specifies which settings to use for the
application. The default value is \texttt{portletInstance}, but it can
be set to \texttt{group} or \texttt{company}. \\
\end{longtable}

\noindent\hrulefill

Now you know how to set default preferences for embedded portlets!

\section{Related Topics}\label{related-topics-71}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-a-portlet-by-portlet-name}{Embedding
  Portlets by Name}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}
\item
  \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder}
\end{itemize}

\chapter{Importing Resources with a
Theme}\label{importing-resources-with-a-theme}

To truly appreciate a theme, you must view it with content. Showcasing a
theme in the proper context is key to communicating the true intentions
of its design. Who better to do this than the theme's designer?
Designers can provide a sample context that optimizes the design of
their themes. The Resources Importer does this for you.

\noindent\hrulefill

\textbf{Important:} The Resources Importer is deprecated as of 7.0 7.1.

\noindent\hrulefill

The Resources Importer module lets theme developers import files and web
content with a theme. Administrators can use the site or site template
created by the Resources Importer to showcase the theme. In fact, all
standalone themes that are uploaded to Liferay Marketplace \textbf{must
use} the Resources Importer. This ensures a uniform experience for
Marketplace users: a user can download a theme from Marketplace, install
it, go to Sites or Site Templates in the Control Panel and immediately
see their new theme in action.

\section{Organizing Your Resources}\label{organizing-your-resources}

Add your resources to the theme's
\texttt{/src/WEB-INF/src/resources-importer} folder as outlined below:

\begin{itemize}
\tightlist
\item
  \texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer/}

  \begin{itemize}
  \tightlist
  \item
    \texttt{sitemap.json} - defines the pages, layout templates, and
    portlets
  \item
    \texttt{assets.json} - (optional) specifies details on the assets
  \item
    \texttt{document\_library/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{documents/} - contains documents and media files (assets)
    \end{itemize}
  \item
    \texttt{journal/}

    \begin{itemize}
    \tightlist
    \item
      \texttt{articles/} - contains web content (HTML) and folders
      grouping web content articles (XML) by template. Each folder name
      must match the file name of the corresponding template. For
      example, create folder \texttt{Template\ 1/} to hold an article
      based on template file \texttt{Template\ 1.ftl}.
    \item
      \texttt{structures/} - contains structures (JSON) and folders of
      child structures. Each folder name must match the file name of the
      corresponding parent structure. For example, create folder
      \texttt{Structure\ 1/} to hold a child of structure file
      \texttt{Structure\ 1.json}.
    \item
      \texttt{templates/} - groups templates (VM or FTL) into folders by
      structure. Each folder name must match the file name of the
      corresponding structure. For example, create folder
      \texttt{Structure\ 1/} to hold a template for structure file
      \texttt{Structure\ 1.json}.
    \end{itemize}
  \end{itemize}
\end{itemize}

Using the Resources Importer involves the following steps:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Resources}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-assets-for-the-resources-importer}{Defining
  Assets for the Resources Importer} (optional)
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

This section explains how to use the Resources Importer to import
resources with your theme.

\chapter{Creating a Sitemap for the Resources
Importer}\label{creating-a-sitemap-for-the-resources-importer}

You have two options for specifying resources to be imported with your
theme: a sitemap or an
\href{/docs/7-2/frameworks/-/knowledge_base/f/archiving-your-sites-resources}{archive
LAR file}. Using a \texttt{sitemap.json} file is the most flexible
approach, so we recommend it; unlike LAR files, a \texttt{sitemap.json}
can be created in one version of Liferay DXP and used in another. LAR
files are version-specific, and can only be imported in the same version
in which they were created.

\noindent\hrulefill

\textbf{Important:} The Resources Importer is deprecated as of 7.0 7.1.

\noindent\hrulefill

The \texttt{sitemap.json} specifies the site pages, layout templates,
web content, assets, and portlet configurations provided with the theme.
This file describes the contents and hierarchy of the site to import as
a site or site template. If you're developing themes for Liferay
Marketplace, you must use the \texttt{sitemap.json} to specify resources
to be imported with your theme. Even if you're not familiar with JSON,
the \texttt{sitemap.json} file is easy to understand. An example
\texttt{sitemap.json} file is shown below:

\begin{verbatim}
{
    "layoutTemplateId": "2_columns_ii",
    "privatePages": [
        {
            "friendlyURL": "/private-page",
            "name": "Private Page",
            "title": "Private Page"
        }
    ],
    "publicPages": [
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Without Border.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "borderless"
                        }
                    },
                    {
                        "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                        "portletPreferences": {
                            "articleId": "Custom Title.html",
                            "groupId": "${groupId}",
                            "portletSetupPortletDecoratorId": "decorate",
                            "portletSetupTitle_en_US": "Web Content Display with Custom Title",
                            "portletSetupUseCustomTitle": "true"
                        }
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet_INSTANCE_${groupId}",
                        "portletPreferences": {
                            "displayStyle": "[custom]",
                            "headerType": "root-layout",
                            "includedLayouts": "all",
                            "nestedChildren": "1",
                            "rootLayoutLevel": "3",
                            "rootLayoutType": "relative"
                        }
                    },
                        "Web Content with Image.html",
                    {
                        "portletId": "com_liferay_nested_portlets_web_portlet_NestedPortletsPortlet",
                        "portletPreferences": {
                            "columns": [
                                [
                                    {
                                        "portletId": 
                                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                            "articleId": "Child Web Content 1.xml",
                                            "groupId": "${groupId}",
                                            "portletSetupPortletDecoratorId": "decorate",
                                            "portletSetupTitle_en_US": 
                                            "Web Content Display with Child Structure 1",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ],
                                [
                                    {
                                        "portletId": 
                                        "com_liferay_journal_content_web_portlet_JournalContentPortlet",
                                        "portletPreferences": {
                                            "articleId": "Child Web Content 2.xml",
                                            "groupId": "${groupId}",
                                            "portletSetupPortletDecoratorId": "decorate",
                                            "portletSetupTitle_en_US": 
                                            "Web Content Display with Child Structure 2",
                                            "portletSetupUseCustomTitle": "true"
                                        }
                                    }
                                ]
                            ],
                            "layoutTemplateId": "2_columns_i"
                        }
                    }
                ]
            ],
            "friendlyURL": "/home",
            "nameMap": {
                "en_US": "Welcome",
                "fr_FR": "Bienvenue"
            },
            "title": "Welcome"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/layout-prototypes-parent-page", 
            "layouts": [
                {
                    "friendlyURL": "/layout-prototypes-page-1",
                    "layoutPrototypeLinkEnabled": "true",
                    "layoutPrototypeUuid": "371647ba-3649-4039-bfe6-ae32cf404737",
                    "name": "Layout Prototypes Page 1",
                    "title": "Layout Prototypes Page 1"
                },
                {
                    "friendlyURL": "/layout-prototypes-page-2",
                    "layoutPrototypeUuid": "c98067d0-fc10-9556-7364-238d39693bc4",
                    "name": "Layout Prototypes Page 2",
                    "title": "Layout Prototypes Page 2"
                }
            ],
            "name": "Layout Prototypes",
            "title": "Layout Prototypes"
        },
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/parent-page",
            "layouts": [
                {
                    "friendlyURL": "/child-page-1",
                    "name": "Child Page 1",
                    "title": "Child Page 1"
                },
                {
                    "friendlyURL": "/child-page-2",
                    "name": "Child Page 2",
                    "title": "Child Page 2"
                }
            ],
            "name": "Parent Page",
            "title": "Parent Page"
        },
        {
            "friendlyURL": "/url-page",
            "name": "URL Page",
            "title": "URL Page",
            "type": "url"
        },
        {
            "friendlyURL": "/link-page",
            "name": "Link to another Page",
            "title": "Link to another Page",
            "type": "link_to_layout",
            "typeSettings": "linkToLayoutId=1"
        },
        {
            "friendlyURL": "/hidden-page",
            "name": "Hidden Page",
            "title": "Hidden Page",
            "hidden": "true"
        }
    ]
}
\end{verbatim}

If you don't understand the sitemap at this point, don't worry. This
section covers how to create a sitemap for your theme, from
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-layout-templates-and-pages-in-a-sitemap}{defining
pages} to
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-portlets-in-a-sitemap}{defining
portlets}.

\chapter{Defining Layout Templates and Pages in a
Sitemap}\label{defining-layout-templates-and-pages-in-a-sitemap}

A sitemap defines the layouts---pages---and layout templates that your
site or site template uses. Follow these steps to define pages and
layout templates in your theme's \texttt{sitemap.json}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define a default layout template ID so the target site or site
  template can reference the layout template to use for its pages. When
  defined outside the scope of a page, the \texttt{layoutTemplateId}
  sets the default layout template for the theme's pages:

\begin{verbatim}
{
  "layoutTemplateId": "2_columns_ii",
  "publicPages": [
    {
      "friendlyURL": "/my-page",
      "name": "My Page",
      "title": "My Page"
    }
  ]  
}
\end{verbatim}

  You can override this by defining a layout template inside a page
  configuration. In the example below, the Hidden Page and the Welcome
  page both use the default \texttt{2\_columns\_ii} layout template,
  while the Custom Layout Page overrides the default layout template and
  uses the \texttt{2\_columns\_i} layout template instead:

\begin{verbatim}
{
  "layoutTemplateId":"2_columns_ii",
  "publicPages": [
      {
        "friendlyURL": "/welcome-page",
        "name": "Welcome",
        "title": "Welcome"
      },
      {
        "friendlyURL": "/custom-layout-page",
        "name": "Custom Layout Page",
        "title": "Custom Layout Page",
        "layoutTemplateId": "2_columns_i"
      },
      {
        "friendlyURL": "/hidden-page",
        "name": "Hidden Page",
        "title": "Hidden Page",
        "hidden": "true"
      }
  ]
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Pages are imported into a site template by default. Site templates
 only support the importing of either public page sets or private page sets, not
 both.
 
 If you want to import both public and private page sets, as shown in the example
 `sitemap.json` below, you must
 [import your resources into a site](/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Follow the pattern below to specify the public and (optionally)
  private pages for your theme. You can specify a name for a page,
  title, friendly URL, whether it is hidden, and much more. The example
  below defines a default layout template and both public and private
  page sets to import into a site. See
  \href{/docs/7-2/reference/-/knowledge_base/r/sitemap-page-configuration-options}{Sitemap
  Page Configuration Options} for a full list of the available options.

\begin{verbatim}
        {
          "layoutTemplateId": "2_columns_ii",
          "privatePages": [
              {
                "friendlyURL": "/private-page",
                    "name": "Private Page",
                    "title": "Private Page"
              }
          ],
          "publicPages": [
              {
                "friendlyURL": "/welcome-page",
                "nameMap": {
                    "en_US": "Welcome",
                    "fr_FR": "Bienvenue"
                },
                "title": "Welcome"
              },
              {
                "friendlyURL": "/custom-layout-page",
                "name": "Custom Layout Page",
                "title": "Custom Layout Page",
                "layoutTemplateId": "2_columns_i"
              },
              {
                "friendlyURL": "/hidden-page",
                "name": "Hidden Page",
                "title": "Hidden Page",
                "hidden": "true"
              }
          ]
        }
\end{verbatim}

  You can create child pages by configuring the \texttt{layouts} element
  for a page configuration:

\begin{verbatim}
{      
"friendlyURL": "/parent-page",
"layouts": [
    {
        "friendlyURL": "/child-page-1",
        "name": "Child Page 1",
        "title": "Child Page 1"
    },
    {
        "friendlyURL": "/child-page-2",
        "name": "Child Page 2",
        "title": "Child Page 2"
    }
],
"name": "Parent Page",
"title": "Parent Page"
}
\end{verbatim}
\end{enumerate}

Great! Now you know how to configure pages for the Resources Importer.

\section{Related Topics}\label{related-topics-72}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-portlets-in-a-sitemap}{Defining
  Portlets in a Sitemap}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

\chapter{Defining Portlets in a
Sitemap}\label{defining-portlets-in-a-sitemap}

You can embed portlets in a sitemap for the pages you define. You can
embed them with the default settings or provide portlet preferences for
a more custom look and feel. This tutorial covers both these options.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Note the portlet's ID. This is the \texttt{javax.portlet.name}
  attribute of the portlet spec. For convenience, The IDs for portlets
  available out-of-the-box are listed in the
  \href{/docs/7-1/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Fully
  Qualified Portlet IDs} reference guide. For custom portlets, this
  property is listed in the portlet class as the
  \texttt{javax.portlet.name=} service property.
\item
  List the portlet ID in the column of the layout you want to display
  the portlet on. An example configuration is shown below:

\begin{verbatim}
{
    "layoutTemplateId": "2_columns_ii",
    "publicPages": [
        {
            "columns": [
                [
                    {
                        "portletId": "com_liferay_login_web_portlet_LoginPortlet"
                    },
                    {
                        "portletId": 
                        "com_liferay_site_navigation_menu_web_portlet_SiteNavigationMenuPortlet"
                    }
                ],
                [
                    {
                        "portletId": "com_liferay_hello_world_web_portlet_HelloWorldPortlet"
                    }
                ]
            ],
            "friendlyURL": "/home",
            "nameMap": {
                "en_US": "Welcome",
                "fr_FR": "Bienvenue"
            },
            "title": "Welcome"
        }
    ]
}
\end{verbatim}

  This approach embeds the portlet with its default settings. To
  customize the portlet, you must configure the portlet's preferences,
  as described in the next step.
\item
  Optionally specify portlet preferences for a portlet with the
  \texttt{portletPreferences} key. Below is an example for the Web
  Content Display portlet:

\begin{verbatim}
{
    "portletId": "com_liferay_journal_content_web_portlet_JournalContentPortlet",
    "portletPreferences": {
        "articleId": "Custom Title.xml",
        "groupId": "${groupId}",
        "portletSetupPortletDecoratorId": "decorate",
        "portletSetupTitle_en_US": "Web Content Display with Custom Title",
        "portletSetupUseCustomTitle": "true"
    }
}
\end{verbatim}

  \textbf{portletSetupPortletDecoratorId:} Specifies the \href{}{portlet
  decorator} to use for the portlet (\texttt{borderless}
  \textbar\textbar{} \texttt{barebone} \textbar\textbar{}
  \texttt{decorate}). See
  \href{/docs/7-2/frameworks/-/knowledge_base/f/setting-default-preferences-for-an-embedded-portlet}{Setting
  Default Preference for An Embedded Portlet} for more information.
\end{enumerate}

\noindent\hrulefill

\textbf{Tip:} You can specify an
\href{/docs/7-1/user/-/knowledge_base/u/styling-apps-and-assets}{application
display template} (ADT) for a portlet in the \texttt{sitemap.json} file
by setting the \texttt{displayStyle} and \texttt{displayStyleGroupId}
portlet preferences, as shown in the example below:

\begin{verbatim}
 "portletId": "com_liferay_asset_publisher_web_portlet_AssetPublisherPortlet",
     "portletPreferences": {
         "displayStyleGroupId": "10197",
         "displayStyle": "ddmTemplate_6fe4851b-53bc-4ca7-868a-c836982836f4"
 }
\end{verbatim}

\noindent\hrulefill

Portlet preferences are unique to each portlet, so first you must
determine which preferences you want to configure. There are two ways to
determine the proper key/value pair for a portlet preference. The first
is to set the portlet preference manually, and then check the values in
the \texttt{portletPreferences.preferences} column of the database as a
hint for what to configure in your \texttt{sitemap.json}. For example,
you can configure the Asset Publisher to display assets that match the
specified asset tags, using the following configuration:

\begin{verbatim}
"queryName0": "assetTags",
"queryValues0": "MyAssetTagName"
\end{verbatim}

Another approach is to search each app in your bundle for the keyword
\texttt{preferences-\/-}. This returns some of the app's JSPs that have
the portlet preferences defined for the portlet.

\noindent\hrulefill

\textbf{Note:} Portlet preferences that require an existing
configuration, such as a tag or category, may require you to create the
configuration on the Global site first, so that the Resources Importer
finds a match when deployed with the theme.

\noindent\hrulefill

\section{Related Topics}\label{related-topics-73}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-layout-templates-and-pages-in-a-sitemap}{Defining
  Layout Templates and Pages in a Sitemap}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

\chapter{Retrieving Portlet IDs with the Gogo
Shell}\label{retrieving-portlet-ids-with-the-gogo-shell}

To
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-portlets-in-a-sitemap}{include
a portlet in a sitemap}, you must have its ID. For convenience, IDs for
out-of-the-box portlets appear in the
\href{/docs/7-2/reference/-/knowledge_base/r/fully-qualified-portlet-ids}{Fully
Qualified Portlet IDs} reference guide. If you've installed purchased or
developed portlets, you can retrieve their IDs using the Gogo Shell, as
this tutorial instructs.

Follow these steps to use the Gogo Shell to retrieve a portlet ID:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the Control Panel and go to Configuration → Gogo Shell.
\item
  Run the command \texttt{lb\ {[}app\ prefix{]}}, and locate the app's
  web bundle. For example, run \texttt{lb\ blogs} to find the blogs web
  bundle.

\begin{verbatim}
100|Active     |   10|Liferay Blogs Web (3.0.7)
\end{verbatim}
\item
  Run the command \texttt{scr:list\ {[}bundle\ ID{]}}, and locate the
  app's component ID. The blogs portlet entry is shown below. The last
  number preceding the bundle's state is the component ID:

\begin{verbatim}
[ 100] com.liferay.blogs.web.internal.portlet.BlogsPortlet enabled 
[ 196] [active] 
\end{verbatim}
\item
  Run the command \texttt{scr:info\ {[}component\ ID{]}} to list the
  portlet's information. For example, to list the info for the blogs
  portlet component, run \texttt{scr:info\ 196}. Note that the bundle
  and/or component ID may be different for your instance.
\item
  Search for \texttt{javax.portlet.name} in the results.
  \texttt{javax.portlet.name}'s value is the portlet ID required for the
  sitemap. The blogs portlet's ID is shown below:

\begin{verbatim}
javax.portlet.name = com_liferay_blogs_web_portlet_BlogsPortlet
\end{verbatim}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/resources-importer-gogo-shell.png}
\caption{Portlet IDs can be found via the Gogo Shell.}
\end{figure}

\section{Related Topics}\label{related-topics-74}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-layout-templates-and-pages-in-a-sitemap}{Defining
  Layout Templates and Pages in a Sitemap}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-portlets-in-a-sitemap}{Defining
  Portlets in a Sitemap}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\end{itemize}

\chapter{Preparing and Organizing Web Content for the Resources
Importer}\label{preparing-and-organizing-web-content-for-the-resources-importer}

You must create the resources to import with your theme. You can create
resources from scratch and/or bring in resources that you've already
created. You can leverage your HTML (basic web content), JSON
(structures), or VM or FTL (templates) files with the Resource Importer.
All web content articles require a structure and optionally a template.
Note that some articles may share the same structure and perhaps even
the same template---this is the case for all basic web content articles.
Follow these steps to prepare your web content articles:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select \emph{Edit} from the article's options menu, click the
  \emph{Options} icon at the top right of the page and select \emph{View
  Source}. Copy the article's raw XML into an XML file locally. Create a
  folder for the article under
  \texttt{resources-importer/journal/articles/} and rename it as
  desired. The web content article's XML fills in the data required by
  the structure. An example web content article's XML is shown below:

\begin{verbatim}
<?xml version="1.0"?>

<root available-locales="en_US" default-locale="en_US">
  <dynamic-element name="content" type="text_area" index-type="keyword" index="0">
    <dynamic-content language-id="en_US">
        <![CDATA[
            <center>
            <p><img alt="" src="[$FILE=space-program-history.jpg$]" /></p>
            </center>

            <p>In the mid-20th century, after two of the 
            most violent wars in history, mankind turned 
            its gaze upwards to the stars. Instead of 
            continuing to strive against one another, 
            man choose instead to strive against the 
            limits that we had bound ourselves to. And 
            so the Great Space Race began.</p>

            <p>At first the race was to reach space--get 
            outside the earth's atmosphere, and when 
            that had been reached, we shot for the moon. 
            After sending men to the moon, robots to 
            Mars, and probes beyond the reaches of our 
            solar system, it seemed that there was 
            nowhere left to go.</p>

            <p>The Space Program aims to change that. 
            Beyond national boundaries, beyond what 
            anyone can imagine that we can do. The sky 
            is not the limit.</p>
        ]]>
    </dynamic-content>
  </dynamic-element>
</root>
\end{verbatim}
\item
  Download the web content article's structure. Open the structure and
  click the \emph{Source} tab to view the structure's file. Copy and
  paste its contents into a new JSON file in the
  \texttt{resources-importer/journal/structures/} folder. The structure
  JSON sets a wireframe, or blueprint, for an article's data. If you're
  saving a basic web content article, you can copy the structure below
  (replace \texttt{en\_US} with your language):

\begin{verbatim}
{
    "availableLanguageIds": [
        "en_US"
    ],
    "defaultLanguageId": "en_US",
    "fields": [
        {
            "label": {
                "en_US": "Content"
            },
            "predefinedValue": {
                "en_US": ""
            },
            "style": {
                "en_US": ""
            },
            "tip": {
                "en_US": ""
            },
            "dataType": "html",
            "fieldNamespace": "ddm",
            "indexType": "text",
            "localizable": true,
            "name": "content",
            "readOnly": false,
            "repeatable": false,
            "required": false,
            "showLabel": true,
            "type": "ddm-text-html"
        }
    ]
}
\end{verbatim}
\item
  Download the structure's matching template if it has one. Open the
  Actions menu for the structure and select \emph{Manage Templates} to
  view the templates that use it. Create a folder for the template under
  \texttt{resources-importer/journal/templates/} and copy and paste its
  contents into a new FTL file. The template defines how the data should
  be displayed. If you're saving a basic web content article, you can
  copy the FreeMarker template below:

\begin{verbatim}
${content.getData()}
\end{verbatim}
\end{enumerate}

Repeat the steps above for each web content article you have. Note that
some web content articles may share the same structure and template; In
these cases, only one copy of the structure and template is required for
all web content articles that use them. Once your web content articles
are saved, you can place them in their proper folder structure.

\section{Related Topics}\label{related-topics-75}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-assets-for-the-resources-importer}{Defining
  Assets for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

\chapter{Defining Assets for the Resources
Importer}\label{defining-assets-for-the-resources-importer}

The \texttt{sitemap.json} file defines the pages of the site or site
template to import---along with the layout templates, portlets, and
portlet preferences of these pages. You may also want to provide details
about the assets you include with the theme. An \texttt{assets.json}
file lets you provide this information.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the \texttt{assets.json} in your theme's
  \texttt{{[}theme-name{]}/src/WEB-INF/src/resources-importer} folder.
\item
  Follow the pattern below to configure your \texttt{assets.json} file.
  Tags can be applied to any asset. Abstract summaries and small images
  can be applied to web content articles. For example, the following
  \texttt{assets.json} file specifies two tags for the
  \texttt{company\_logo.png} image, one tag for the
  \texttt{Custom\ Title.xml} web content article, and an abstract
  summary and small image for the \texttt{Child\ Web\ Content\ 1.json}
  article structure:

\begin{verbatim}
{
    "assets": [
        {
            "name": "company_logo.png",
            "tags": [
                "logo",
                "company"
            ]
        },
        {
            "name": "Custom Title.xml",
            "tags": [
                "web content"
            ]
        },
        {
            "abstractSummary": "This is an abstract summary.",
            "name": "Child Web Content 1.json",
            "smallImage": "company_logo.png"
        }
    ]
}
\end{verbatim}
\end{enumerate}

Now you know how to configure assets for your web content!

\section{Related Topics}\label{related-topics-76}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-where-to-import-your-themes-resources}{Specifying
  Where to Import Your Theme's Resources}
\end{itemize}

\chapter{Specifying Where to Import Your Theme's
Resources}\label{specifying-where-to-import-your-themes-resources}

By default, resources are imported into a new site template named after
the theme, but you can also import resources into a new site or existing
sites or site templates. These options are covered below. Follow these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Before specifying where to import your resources, you must enable
  Developer Mode in your theme. To do this, add the following property
  to your theme's \texttt{liferay-plugin-package.properties} file. This
  is enabled by default for themes generated with the
  \href{/docs/7-2/reference/-/knowledge_base/r/theme-generator}{Liferay
  Theme Generator}. Without this property enabled, you must manually
  delete the sites or site templates built by the Resources Importer
  each time you want to apply changes from your theme's
  \texttt{src/WEB-INF/src/resources-importer} folder:

\begin{verbatim}
resources-importer-developer-mode-enabled=true
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Warning:** the `resources-importer-developer-mode-enabled=true` setting can be
 dangerous since it involves *deleting* (and re-creating) the affected site or
 site template. It's only intended to be used during development. **Never use it
 in production.**
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Specify where to import your resources. By default, resources are
  imported into a new site template named after the theme. If that's
  what you want, you can skip this step. If instead you want your
  resources to be imported into an existing site template, you must
  specify a value for the \texttt{resources-importer-target-value}
  property in your theme's \texttt{liferay-plugin-package.properties}
  file:

\begin{verbatim}
#resources-importer-target-class-name

resources-importer-target-value=[site-template-name]
\end{verbatim}

  Alternatively, you can import resources into an existing site.
  \textbf{You must} import your resources into a site if you define both
  public and private page sets in your \texttt{sitemap.json}. To import
  resources into an existing site, uncomment the
  \texttt{resources-importer-target-class-name} property and set it to
  \texttt{com.liferay.portal.kernel.model.Group}:

\begin{verbatim}
resources-importer-target-class-name=com.liferay.portal.kernel.model.Group

resources-importer-target-value=[site-name] 
\end{verbatim}

  Double check the name that you're specifying. If you specify the wrong
  value, you could end up deleting (and re-creating) the wrong site or
  site template!
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Warning:** It's safer to import theme resources into a site template than into
 an actual site. The
 `resources-importer-target-class-name=com.liferay.portal.kernel.model.Group`
 setting can be handy for development and testing but should be used cautiously.
 Don't use this setting in a theme deployed to a production Liferay instance or
 a theme submitted to Liferay Marketplace. To prepare a theme for deployment to
 a production Liferay instance, use the default setting so that the resources are
 imported into a site template. You can do this explicitly by setting
 `resources-importer-target-class-name=com.liferay.portal.kernel.model.LayoutSetPrototype`
 or implicitly by commenting out or removing the
 `resources-importer-target-class-name` property.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Deploy the theme. To view your theme and its resources, log in as an
  administrator, and check the Sites or Site Templates section of the
  Control Panel to make sure your resources were deployed correctly.
  From the Control Panel you can easily view your theme and its
  resources:

  \begin{itemize}
  \tightlist
  \item
    If you imported into a site template, open its actions menu and
    select \emph{View Pages} to see it.
  \item
    If you imported directly into a site, open its actions menu and
    select \emph{Go to Public Pages} to see it.
  \end{itemize}
\end{enumerate}

Great! Now you know how to specify where to import your theme's
resources.

\section{Related Topics}\label{related-topics-77}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-assets-for-the-resources-importer}{Defining
  Assets for the Resources Importer}
\end{itemize}

\chapter{Archiving Site Resources}\label{archiving-site-resources}

Although a \texttt{sitemap.json} is the recommended approach for
including resources with a theme, you can also export your site's data
in a LAR (Liferay Archive) file. A LAR file is version-specific; it
won't work on any version of Liferay DXP other than the one from which
it was exported. This approach does, however, require less
configuration, since it does not require a sitemap or other files. So,
if you're using the exported resources in the same version of Liferay
DXP and it's not for a theme on Liferay Marketplace, you may prefer a
LAR file.

Follow these steps to archive your site's resources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Export the contents of a site using the site scope.
\item
  Place the \texttt{archive.lar} file in your theme's
  \texttt{/src/WEB-INF/src/resources-importer} folder.
\end{enumerate}

Great! Now you know how to archive your site's resources.

\section{Related Topics}\label{related-topics-78}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/preparing-and-organizing-web-content-for-the-resources-importer}{Preparing
  and Organizing Web Content for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-sitemap-for-the-resources-importer}{Creating
  a Sitemap for the Resources Importer}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/defining-assets-for-the-resources-importer}{Defining
  Assets for the Resources Importer}
\end{itemize}

\chapter{Troubleshooting Themes}\label{troubleshooting-themes}

These frequently asked questions and answers help you troubleshoot and
correct problems in theme development.

Click a question to view the answer.

\begin{itemize}
\tightlist
\item
  \hyperref[osgi-headers-in-themes]{How can I include OSGi headers in my
  theme?}
\item
  \hyperref[developer-mode]{Why aren't my changes showing up after I
  redeploy my theme?}
\item
  \hyperref[default-theme-returned]{Why is my theme not loading? It
  returns the default theme instead.}
\item
  \hyperref[rtl-no-flip]{How can I prevent specific CSS rules from
  transforming for RTL Languages?}
\end{itemize}

\phantomsection\label{osgi-headers-in-themes}
{How can I include OSGi headers in my theme?~{}}

\begin{verbatim}
<p>Specify the headers you want to use in your theme's <code>liferay-plugin-package.properties</code> file. Any headers placed in this file are included automatically in your MANIFEST and the OSGi bundle.</p>
<p>For example, you can add OSGi dependencies in your theme by importing the exported package with the <code>Import-Package</code> header:</p>
<pre><code>Import-Package:com.liferay.docs.portlet</code></pre>
\end{verbatim}

\phantomsection\label{developer-mode}
{Why aren't my changes showing up after I redeploy my theme?~{}}

\begin{verbatim}
<p>By default CSS, JS, and theme template files are cached in the browser. During development, you can enable <a href="/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes">Devloper Mode</a> to prevent your theme's files from caching. </p>
\end{verbatim}

\phantomsection\label{default-theme-returned}
{Why is my theme not loading? It returns the default theme instead.~{}}

\begin{verbatim}
<p>If you receive the warning "No theme found for specified theme id...", you may be referencing an outdated theme ID in your Site. Verify that the theme ID in your theme's <code>liferay-look-and-feel.xml</code> matches the theme ID in the warning message: "mytheme_WAR_mytheme". If the theme IDs match, there may be pages using the outdated theme instead of the Site theme. You can verify this by checking the pages manually or searching the database for layouts with values for <code>themeId -</code>. </p>
\end{verbatim}

\phantomsection\label{rtl-no-flip}
{How can I prevent specific CSS rules from transforming for RTL
Languages?~{}}

\begin{verbatim}
<p>You can prevent specific CSS rules from transforming (flipping) with the <code>/* @noflip */</code> decoration. Place the decoration to the left of the CSS rule to apply it. For example, this rule gives a left margin of <code>20em</code> to the <code>body</code> no matter if the selected language is LTR or RTL:</p>
  <pre><code>
  /* @noflip */ body {
   margin-left: 20em;
  }
  </pre></code>
<p>You can also use the <code>.rtl</code> CSS selector for rules that exclusively apply to RTL languages.</p>
\end{verbatim}

\chapter{Layout Templates}\label{layout-templates}

Layout templates dictate where content and apps can be placed on a page.
There are several default layout templates for organizing content on
your pages:

\begin{figure}
\centering
\includegraphics{./images/page-select-layout.png}
\caption{There are many default layout templates to choose from.}
\end{figure}

If the default layouts don't work for your site, you can create your own
layout template by following the articles listed below:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Create
  the layout template}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-layout-template-thumbnail-previews}{Create
  the layout template thumbnail preview}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/including-layout-templates-with-a-theme}{Bundle
  the layout template with a theme}
\end{itemize}

Layout Templates specify a number of rows and columns for the page. The
rows and columns dictate where apps (and fragments) can be placed on the
page. Layout templates are written in
\href{https://freemarker.apache.org/}{FreeMarker}. An example row's HTML
markup is shown below:

\begin{verbatim}
<div class="portlet-layout row">
        <div class="col-md-4 col-sm-6 portlet-column portlet-column-first" 
        id="column-1">
                ${processor.processColumn("column-1", 
                "portlet-column-content portlet-column-content-first")}
        </div>
        <div class="col-md-8 col-sm-6 portlet-column portlet-column-last" 
        id="column-2">
                ${processor.processColumn("column-2", 
                "portlet-column-content portlet-column-content-last")}
        </div>
</div>
\end{verbatim}

Columns use the
\href{https://getbootstrap.com/docs/4.0/layout/grid/}{Bootstrap grid
system}. Every row consists of twelve sections, so columns can range in
size from \texttt{1} to \texttt{12}. Sizes are indicated with the number
that follows the \texttt{col-{[}breakpoint{]}} class prefix
(e.g.~\texttt{col-md-6}). These specify two things: the percentage-based
width of the element and the media query breakpoint (\texttt{xs},
\texttt{sm}, \texttt{md}, or \texttt{lg}), which specifies when the
element expands to 100\% width. For example, \texttt{col-md-6} indicates
\texttt{6/12} width, or \texttt{50\%}. These classes can also be mixed
to achieve more advanced layouts, as shown above. In the example, medium
sized viewports display \texttt{column-1} at 33.33\% width and
\texttt{column-2} at 66.66\% width, while both \texttt{column-1} and
\texttt{column-2} are 50\% width on small sized view ports.

The processor (\texttt{\$\{processor.processColumn()\}}) processes each
column's content, taking two arguments: the column's \texttt{id}, and
the classes \texttt{portlet-column-content} and
\texttt{portlet-column-content-{[}case{]}} (if applicable), where
\texttt{{[}case{]}} refers to the \texttt{first}, \texttt{last}, or
\texttt{only} column in the row.

\chapter{Creating Custom Layout Template Thumbnail
Previews}\label{creating-custom-layout-template-thumbnail-previews}

To showcase your layout template properly, you must provide a thumbnail
preview for it. Without this, no one will know the design of the layout.
Follow these steps to provide a thumbnail preview for your layout
template:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the layout template's \texttt{docroot/} folder. If you
  bundled the layout template with a theme created with the Liferay
  Theme Generator, the thumbnail is located in your theme's
  \texttt{src/layouttpl/custom/my-layoutttpl} folder.
\item
  Create a custom thumbnail PNG inside the folder specified in step 1
  with the same name as the layout template that is 120 px x 120 px .
  Delete the temporary thumbnail PNG file if it exist.

  \begin{figure}
  \centering
  \includegraphics{./images/porygon_50_50_width_limited.png}
  \caption{A thumbnail preview displays the layout's design to the
  user.}
  \end{figure}
\item
  Deploy your layout template to your app server to use it. If your
  layout template is
  \href{/docs/7-2/frameworks/-/knowledge_base/f/including-layout-templates-with-a-theme}{bundled
  with a theme}, it deploys when the theme is deployed. Now you know how
  to create a custom thumbnail preview for your Liferay DXP layout
  templates!
\end{enumerate}

\section{Related topics}\label{related-topics-79}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Layout
  Templates with the Liferay Theme Generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/including-layout-templates-with-a-theme}{Bundling
  Layout Templates with a Theme}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes}
\end{itemize}

\chapter{Including Layout Templates with a
Theme}\label{including-layout-templates-with-a-theme}

Although you can deploy a layout template by itself, you can also bundle
it with a theme. If you generated a layout template with the
\href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Layouts
sub-generator} from inside a generated theme project, the layout
template is bundled with the theme automatically. If, however, you
generated a layout template and want to bundle it with a theme
afterwards, follow these steps to include the layout template with a
theme:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Copy the layout template's \texttt{liferay-layout-templates.xml} file
  to the theme's \texttt{src/WEB-INF/} folder.
\item
  Create a \texttt{layouttpl/custom/my-layouttpl/} folder inside the
  theme's \texttt{src/} folder.
\item
  Copy the layout template's FreeMarker (.ftl) file, and
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-layout-template-thumbnail-previews}{thumbnail
  preview} (.png) if it exist, over to the
  \texttt{layouttpl/custom/my-layouttpl/} folder.
\item
  Copy the theme's \texttt{liferay-theme.json} file into the
  \texttt{src/layouttpl/custom/my-layouttpl/} folder and rename it
  \texttt{liferay-plugin.json}.
\item
  Open \texttt{liferay-plugin.json}, rename the \texttt{LiferayTheme}
  entry \texttt{LiferayPlugin}, and replace the \texttt{pluginName}
  entry's value with the name of the layout template. Below is an
  example configuration:
\end{enumerate}

\begin{verbatim}
{
  "LiferayPlugin": {
    "deploymentStrategy": "LocalAppServer",
    "appServerPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\tomcat-9.0.10",
    "deployPath": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\tomcat-9.0.10\\deploy",
    "url": "http://localhost:8080",
    "appServerPathPlugin": "C:\\Users\\liferay\\opt\\Liferay\\bundles\\liferay-ce-portal-tomcat-7.2.0\\tomcat-9.0.10\\webapps\\my-layouttpl",
    "deployed": false,
    "pluginName": "my-layouttpl"
  }
}
\end{verbatim}

Now you know how to include layout templates with your Liferay DXP
themes!

\section{Related topics}\label{related-topics-80}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-layout-templates-with-the-themes-generator}{Layout
  Templates with the Liferay Theme Generator}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-layout-template-thumbnail-previews}{Creating
  Custom Layout Template Thumbnail Previews}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/themes-introduction}{Themes}
\end{itemize}

\chapter{Creating and Bundling JavaScript Widgets with JavaScript
Tooling}\label{creating-and-bundling-javascript-widgets-with-javascript-tooling}

Portlets are a Java standard, so you must have a knowledge and
understanding of how Java works to write one. This can be quite the
hurdle for front-end developers who want to use JavaScript frameworks in
their widgets. Thanks to the Liferay JS Generator and
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler},
developers can easily create and develop JavaScript widgets in Liferay
DXP using pure JavaScript tooling. The Liferay JS Generator generates
JavaScript widgets for Liferay DXP. It is just one of Liferay JS
Toolkit's
\href{https://github.com/liferay/liferay-npm-build-tools/tree/master/packages}{tools}.

\noindent\hrulefill

\textbf{Note:} To use the Liferay JS Generator, you must have the
Liferay JS Portlet Extender activated in your Liferay DXP instance. It's
activated by default. You can confirm this by opening the Control Menu,
navigating to the \emph{App Manager}, and searching for
\texttt{com.liferay.frontend.js.portlet.extender}.

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/extender-lifecycle.png}
\caption{The JS Portlet Extender lets you use pure JavaScript tooling to
write widgets.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} JavaScript Server-Side-Rendering is not supported
out-of-the-box. To use JS frameworks for site rendering, you
\textbf{must} set up your server-side (or search-crawler) rendering
generation to support them.

\noindent\hrulefill

Once you've
\href{/docs/7-2/reference/-/knowledge_base/r/installing-the-js-generator-and-generating-a-bundle}{installed
the Liferay JS Generator and generated a widget}, you can configure
instance settings, system settings, and even provide localization for
your widget. This section explains how to configure these options for
your generated JS widget.

\chapter{Configuring System Settings and Instance Settings for Your
JavaScript
Widget}\label{configuring-system-settings-and-instance-settings-for-your-javascript-widget}

As of v1.1.0 of the JS Portlet Extender, you can define configuration
options for your widget. These options are passed to the widget's
JavaScript entry point as the \texttt{configuration} parameter. See the
\href{/docs/7-2/reference/-/knowledge_base/r/understanding-the-js-portlet-extender-configuration\#main-entry-point}{main
entry point's reference} for more information on the entry point. Follow
these steps to set system and/or portlet instance settings for your
widget:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{/features} folder in your project's root folder if it
  doesn't already exist.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This location can be overridden with the 
 `create-jar.features.configuration` option in your project's `.npmbundlerrc` 
 file. See [OSGi bundle configuration options](/docs/7-2/reference/-/knowledge_base/r/understanding-the-npmbundlerrcs-structure#osgi-bundle-creation-options) 
 for all the available options for the bundle.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Create a \texttt{configuration.json} file in the \texttt{/features}
  folder and follow the pattern below. See the
  \href{/docs/7-2/reference/-/knowledge_base/r/configuration-json-available-options}{Configuration
  JSON} reference for an explanation of each of the available options:

\begin{verbatim}
{
  "system": {
    "category": "{category identifier}",
    "name": "{name of configuration}",
    "fields": {
      "{field id 1}": {
        "type": "{field type}",
        "name": "{field name}",
        "description": "{field description}",
        "default": "{default value}",
        "options": {
          "{option id 1}": "{option name 1}",
          "{option id 2}": "{option name 2}",

          "{option id n}": "{option name n}"
        }
      },
      "{field id 2}": {},

      "{field id n}": {}
    }
  },
  "portletInstance": {
    "name": "{name of configuration}",
    "fields": {
      "{field id 1}": {
        "type": "{field type}",
        "name": "{field name}",
        "description": "{field description}",
        "default": "{default value}",
        "options": {
          "{option id 1}": "{option name 1}",
          "{option id 2}": "{option name 2}",

          "{option id n}": "{option name n}"
        }
      },
      "{field id 2}": {},

      "{field id n}": {}
    }
  }
}
\end{verbatim}
\item
  Access a system setting's value or a portlet instance setting's value
  with the syntax \texttt{configuration.system} or
  \texttt{configuration.portletInstance} respectively. For instance, to
  retrieve the \texttt{\{field\ id\ 1\}} system settings value, you
  would use \texttt{configuration.system.\{field\ id\ 1\}}. Note that
  all fields are passed as strings no matter what type they declare in
  their descriptor.
\end{enumerate}

Awesome! Now you know how to configure system settings and portlet
instance settings for your widget.

\section{Related Topics}\label{related-topics-81}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-widget}{Localizing
  Your Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-translation-features-in-your-widget}{Using
  Translation Features in Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-portlet-properties-for-your-widget}{Setting
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\chapter{Localizing Your Widget}\label{localizing-your-widget}

Follow the steps below to learn how to localize your widget:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you chose not to use localization when you generated the bundle,
  follow this step to enable it in your bundle. Create a
  \texttt{/features/localization} folder in your project and add a
  \texttt{Language.properties} file to it. Add a
  \texttt{create-jar.features.localization} key to your
  \texttt{.npmbuildrc} file that points to the
  \texttt{Language.properties} file. An example configuration is shown
  below:

\begin{verbatim}
{
    "create-jar": {
        "output-dir": "dist",
        "features": {
            "js-extender": true,
            "web-context": "/my-test-js-widget",
            "localization": "features/localization/Language",
            "settings": "features/settings.json"
        }
    },
    ...
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The default file path is shown above. You can update this value, 
 if you want to place your `Language.properties` file in a different 
 location.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Configure the \texttt{Language.properties} file and provide the
  localized property files
  (e.g.~\texttt{Language\_{[}locale{]}.properties}) with the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{language
  keys} for each
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{available
  translation}. The \emph{JavaScript based widget} configuration is
  shown below:

\begin{verbatim}
javax.portlet.title.my_js_portlet_project=My JS Widget Project
portlet-namespace=Portlet Namespace
context-path=Context Path
portlet-element-id=Portlet Element Id
configuration=Configuration
fruit=Favourite fruit
fruit-help=Choose the fruit you like the most
an-orange=An orange
a-pear=A pear
an-apple=An apple
\end{verbatim}
\item
  Retrieve a language key's localized value in JavaScript with the
  \texttt{Liferay.Language.get(\textquotesingle{}key\textquotesingle{})}
  method.
\end{enumerate}

Great! Now you know how to localize your widget!

\section{Related Topics}\label{related-topics-82}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-system-settings-and-instance-settings-for-your-js-widget}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-translation-features-in-your-widget}{Using
  Translation Features in Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-portlet-properties-for-your-widget}{Setting
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\chapter{Using Translation Features in Your
Widget}\label{using-translation-features-in-your-widget}

By default, the Liferay JS Generator creates an empty configuration for
translation. The translate script instructs the user how to add new
supported locales or configure the credentials when it's run. The
translate target reads the supported locales you have defined in the
\texttt{supportedLocales} key of your \texttt{.npmbuildrc} file and
checks your \texttt{*language.properties} files to make sure they match.

\noindent\hrulefill

\textbf{Note:} To use the translation features, you must have a
Microsoft Translator key. Provide your credentials through either the
\texttt{translatorTextKey} variable in your \texttt{.npmbuildrc} file,
or provide them in the \texttt{TRANSLATOR\_TEXT\_KEY} environment
variable.

\noindent\hrulefill

Follow these steps to add a new supported locale and automatically
create a language properties file for it with translations:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the locale to the \texttt{supportedLocales} array in your
  \texttt{.npmbuildrc} file.
\item
  Run the translate target with the command below:

\begin{verbatim}
npm run translate
\end{verbatim}
\item
  The translate target automatically creates a language properties file
  for each new \textbf{supported} locale with translations for your
  language keys. It also warns about locales that are not supported, but
  have a \texttt{*language.properties} file.
\end{enumerate}

Great! Now you know how to use the Liferay JS Generator's translation
features in your app.

\section{Related Topics}\label{related-topics-83}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-system-settings-and-instance-settings-for-your-js-widget}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-widget}{Localizing
  Your Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-portlet-properties-for-your-widget}{Setting
  Portlet Properties for Your JavaScript Widget}
\end{itemize}

\chapter{Configuring Portlet Properties for Your
Widget}\label{configuring-portlet-properties-for-your-widget}

Follow these steps to configure your widget's properties:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your generated JavaScript widget's \texttt{package.json} file.
\item
  Set the properties under the \texttt{portlet} entry. Note that these
  are the same properties you would define in the Java
  \texttt{@Component} annotation of a portlet, as defined in the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/definitions/liferay-portlet-app_7_2_0.dtd.html}{liferay-portlet-app\_7\_2\_0.dtd}.
  An example configuration is shown below:

\begin{verbatim}
"portlet": {
    "com.liferay.portlet.display-category": "category.sample",
    "com.liferay.portlet.header-portlet-css": "/css/styles.css",
    "com.liferay.portlet.instanceable": true,
    "javax.portlet.name": "my_js_portlet_project",
    "javax.portlet.security-role-ref": "power-user,user",
    "javax.portlet.resource-bundle": "content.Language"
},
\end{verbatim}
\item
  Deploy your bundle to apply the changes.
\end{enumerate}

Great! Now you know how to configure your JavaScript widget's
properties.

\section{Related Topics}\label{related-topics-84}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-system-settings-and-instance-settings-for-your-js-widget}{Configuring
  System Settings and Instance Settings for Your JavaScript Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-widget}{Localizing
  Your Widget}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-translation-features-in-your-widget}{Using
  Translation Features in Your JavaScript Widget}
\end{itemize}

\chapter{JavaScript Module Loaders}\label{javascript-module-loaders}

A JavaScript module encapsulates code into a useful unit that exports
its capability/value. This makes it easier to see the broader scope,
easier to find what you're looking for, and keeps related code close
together. A normal web page usually loads JavaScript files via HTML
\texttt{script} tags. That's fine for small websites, but when
developing large scale web applications, a more robust organization and
loader is needed. A module loader lets an application load dependencies
easily by specifying a string that identifies the JavaScript module's
name.

This section shows how to load JavaScript modules in Liferay DXP.

\chapter{Loading AMD Modules in
Liferay}\label{loading-amd-modules-in-liferay}

Modularized JavaScript code is a specification for the JavaScript
language called Asynchronous Module Definition, or AMD. The
\href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
AMD Module Loader} is the native loader that you can use to load your
AMD modules. The steps below cover how to use the Liferay AMD Module
Loader.

\noindent\hrulefill

\textbf{Note:} While you can manually configure the AMD Loader, we
recommend that you use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-npm-in-your-portlets}{liferay-npm-bundler}
instead.

\noindent\hrulefill

Follow these steps to prepare your module for the Liferay AMD Module
Loader:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wrap your AMD module code with the \texttt{Liferay.Loader.define()}
  method, such as the one shown below:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], 
function(myNode, myPluginBase) {
   return {
       log: function(text) {
           console.log('module my-dialog: ' + text);
       }
   };
});
\end{verbatim}
\item
  You can modify the configuration to load the module when another
  module is triggered or when a condition is met. The configuration
  below specifies that this module should be loaded if another module
  requests the \texttt{my-test} module:

\begin{verbatim}
Liferay.Loader.define('my-dialog', ['my-node', 'my-plugin-base'], 
function(myNode, myPluginBase) {
   return {
       log: function(text) {
           console.log('module my-dialog: ' + text);
       }
   };
}, {
   condition: {
       trigger: 'my-test',
       test: function() {
           var el = document.createElement('input');

           return ('placeholder' in el);
       }
   },
   path: 'my-dialog.js'
});
\end{verbatim}

  The Liferay AMD Loader uses the definition, along with the listed
  dependencies, as well as any other configurations specified, to create
  a \texttt{config.json} file. This configuration object tells the
  loader which modules are available, where they are located, and what
  dependencies they require. Below is an example of a generated
  \texttt{config.json} file:

\begin{verbatim}
{
    "frontend-js-web@1.0.0/html/js/parser": {
        "dependencies": []
    },
    "frontend-js-web@1.0.0/html/js/list-display": {
        "dependencies": ["exports"]
    },
    "frontend-js-web@1.0.0/html/js/autocomplete": {
        "dependencies": ["exports", "./parser", "./list-display"]
    }
}
\end{verbatim}
\item
  Load your module in your scripts. Pass the module name to the
  \texttt{Liferay.Loader.require} method. The example below loads a
  module called \texttt{my-dialog}:

\begin{verbatim}
Liferay.Loader.require('my-dialog', function(myDialog) {
    // your code here
}, function(error) {
    console.error(error);
});
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** By default, the AMD Loader times out in seven seconds. You can 
 configure this value through System Settings. Open the Control Panel and 
 navigate to *Configuration* &rarr; *System Settings* &rarr; *PLATFORM* &rarr; 
 *Infrastructure*, and select *JavaScript Loader*. Set the *Module Definition 
 Timeout* configuration to the time you want and click *Save*.
\end{verbatim}

\noindent\hrulefill

\section{Related Topics}\label{related-topics-85}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-modules-with-aui-script}{Loading
  Modules with AUI Script}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-npm-in-your-portlets}{Using
  npm in Your Portlets}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-modules-with-aui-script}{Loading
  Modules with AUI Script}
\end{itemize}

\chapter{Using External JavaScript
Libraries}\label{using-external-javascript-libraries}

You can use external JavaScript libraries in your portlets (i.e.,
anything but Metal.js or jQuery, which are included by default). If
you're the owner or hosting the external library, there are a few more
requirements to load them with the JavaScript Loaders.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're the owner of the library, you should make sure that it
  supports \href{https://github.com/umdjs/umd}{UMD} (Universal Module
  Definition). You can configure your code to support UMD with the
  template shown below:

\begin{verbatim}
// Assuming your "module" will be exported as "mylibrary"
(function (root, factory) {
    if (typeof Liferay.Loader.define === 'function' && Liferay.Loader.define.amd) {
        // AMD. Register as a "named" module.
        Liferay.Loader.define('mylibrary', [], factory);
    } else if (typeof module === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.mylibrary = factory();
  }
}(this, function () {

    // Your library code goes here
    return {};
}));
\end{verbatim}
\item
  If you're hosting the library (and not loading it from a CDN), you
  must hide the Liferay AMD Loader to use your Library. Open the Control
  Panel, navigate to \emph{Configuration} → \emph{System Settings}.
\item
  Click \emph{JavaScript Loader} under \emph{Platform} →
  \emph{Infrastructure}.
\item
  Uncheck the \texttt{expose\ global} option.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} Once this option is unchecked, you can no longer use the
\texttt{Liferay.Loader.define} or \texttt{Liferay.Loader.require}
functions in your app. Also, if you're using third party libraries that
are AMD compatible, they could stop working after unchecking this option
because they usually use global functions like \texttt{require()} or
\texttt{define()}.

\noindent\hrulefill

Great! Now you know how to adapt external libraries for Liferay's
JavaScript Loaders.

\section{Related Topics}\label{related-topics-86}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-amd-modules-in-liferay}{Liferay
  AMD Module Loader}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-esplus-modules-in-your-portlet}{Using
  ES2015+ Modules in Your Portlet}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-modules-with-aui-script}{Loading
  Modules with AUI Script}
\end{itemize}

\chapter{Loading Modules with AUI
Script}\label{loading-modules-with-aui-script}

The \texttt{aui:script} tag is a JSP tag that loads JavaScript on the
page, while ensuring that certain resources are loaded before executing.

\noindent\hrulefill

\textbf{Note:} AUI is deprecated and no longer in active development in
7.0, but all the tags will remain fully functional in Liferay DXP 7.2.
Eventually, these tags will be replaced with
\href{https://clayui.com/}{Clay} tag counterparts.

\noindent\hrulefill

The \texttt{aui:script} tag supports the following options:

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Option
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{require} & Requires an AMD module to load with the
\href{https://github.com/liferay/liferay-amd-loader\#amd-module-loader}{Liferay
AMD Module Loader}. \\
\texttt{use} & Uses an AlloyUI/YUI module that is loaded via the YUI
loader. \\
\texttt{position} & The position the script tag is put on the page.
Possible options are \texttt{inline} or \texttt{auto}. \\
\texttt{sandbox} & Whether to wrap the script tag in an anonymous
function. If set to \texttt{true}, in addition to the wrapping,
\texttt{\$} and \texttt{\_} are defined for jQuery and underscore. \\
\end{longtable}

\noindent\hrulefill

This section covers how to load ES2015, Metal.js, and AUI modules with
the AUI script tag.

\chapter{Loading AlloyUI Modules with AUI
Script}\label{loading-alloyui-modules-with-aui-script}

Follow these steps to load modules with
\texttt{\textless{}aui:script\textgreater{}}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following declaration to your portlet's JSP:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and use the
  \texttt{use} attribute to load AlloyUI/YUI modules:

\begin{verbatim}
<aui:script use="aui-base">
    A.one('#someNodeId').on(
        'click',
        function(event) {
            alert('Thank you for clicking.')
        }
    );
</aui:script>
\end{verbatim}
\end{enumerate}

This loads the \texttt{aui-base} AlloyUI component and makes it
available to the code inside the \texttt{aui:script}.

In the browser, the \texttt{aui:script} translates to the full
JavaScript shown below:

\begin{verbatim}
<script type="text/javascript">
    AUI().use("aui-base",
        function(A){
            A.one('#someNodeId').on(
                'click',
                function(event) {
                    alert('Thank you for clicking.')
                }
            );
        }
    );
</script>
\end{verbatim}

Wonderful! Now you know how to load AUI/YUI modules in AUI scripts.

\section{Related Topics}\label{related-topics-87}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-external-javascript-libraries}{Using
  External JavaScript Libraries}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-amd-modules-in-liferay}{Loading
  AMD Modules}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-es2015-and-metal-modules-with-aui-script}{Loading
  ES2015 and Metal.js Modules with AUI Script}
\end{itemize}

\chapter{Loading ES2015 and Metal.js Modules with AUI
Script}\label{loading-es2015-and-metal.js-modules-with-aui-script}

Follow these steps to load your ES2015 and Metal.js modules with
\texttt{\textless{}aui:script\textgreater{}}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following declaration to your portlet's JSP:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and use the
  \texttt{require} attribute to load ES2015 and Metal.js modules:

\begin{verbatim}
<aui:script require="metal-clipboard/src/Clipboard">
    new metalClipboardSrcClipboard.default();
</aui:script>
\end{verbatim}
\end{enumerate}

alternatively, you can specify a variable for your module by adding
\texttt{as\ variableName} after the module name, as shown in the example
below:

\begin{verbatim}
<aui:script require="metal-clipboard/src/Clipboard as myModule">
    new myModule.default();
</aui:script>
\end{verbatim}

This resolves the dependencies of the registered module and loads them
in order until all of them are satisfied and the requested module can be
safely executed.

In the browser, the \texttt{aui:script} translates to the full
JavaScript shown below:

\begin{verbatim}
<script type="text/javascript">
    Liferay.Loader.require("metal-clipboard/src/Clipboard", 
    function(metalClipboardSrcClipboard) {
        (function() {
            new metalClipboardSrcClipboard.default();
        })()
    }, function(error) {
        console.error(error)
    });
</script>
\end{verbatim}

Great! Now you know how to load ES2015 and Metal.js modules in AUI
scripts.

\section{Related Topics}\label{related-topics-88}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-external-javascript-libraries}{Using
  External JavaScript Libraries}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-amd-modules-in-liferay}{Loading
  AMD Modules}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-aui-es2015-and-metal-modules-with-aui-script}{Loading
  AUI, ES2015, and Metal.js Modules Together with AUI Script}
\end{itemize}

\chapter{Loading AUI, ES2015, and Metal.js Modules Together with AUI
Script}\label{loading-aui-es2015-and-metal.js-modules-together-with-aui-script}

You may want to load an AUI module along with an ES2015 module or
Metal.js module in an \texttt{aui:script}. The \texttt{aui:script} tag
doesn't support both the \texttt{require} and \texttt{use} attributes in
the same configuration. Not to worry though. You can use the
\texttt{aui:script}'s \texttt{require} attribute to load the ES2015 and
Metal.js modules, while loading the AUI module(s) with the
\texttt{AUI().use()} function within the script.

Follow these steps to load your ES2015, Metal.js, and AUI modules
together with \texttt{\textless{}aui:script\textgreater{}}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following declaration to your portlet's JSP:

\begin{verbatim}
<%@ taglib prefix="aui" uri="http://liferay.com/tld/aui" %>
\end{verbatim}
\item
  Add the \texttt{\textless{}aui:script\textgreater{}} tag and use the
  \texttt{require} attribute to load ES2015 and Metal.js modules, while
  using the \texttt{AUI().use()} function to load AUI modules, as shown
  in the example below:

\begin{verbatim}
<aui:script require="path-to/metal/module">
 AUI().use(
    'liferay-aui-module', 
    function(A) {
        let var = pathToMetalModule.default;
    }
);
</aui:script>
\end{verbatim}
\end{enumerate}

Great! Now you know how to load all your modules with
\texttt{aui:script}.

\section{Related Topics}\label{related-topics-89}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-external-javascript-libraries}{Using
  External JavaScript Libraries}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-amd-modules-in-liferay}{Loading
  AMD Modules}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/loading-es2015-and-metal-modules-with-aui-script}{Loading
  ES2015 and Metal.js Modules with AUI Script}
\end{itemize}

\chapter{Loading Bundled npm Modules in Your
Portlets}\label{loading-bundled-npm-modules-in-your-portlets}

Once you've
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-javascript-in-your-portlets}{exposed
your modules}, you can use them in your portlet via the
\texttt{aui:script} tag's \texttt{require} attribute. You can load the
npm module in your portlet using the \texttt{npmResolvedPackageName}
variable, which is available by default since 7.0. You can then create
an alias to reference it in your portlet.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Provide a \texttt{Web-ContextPath} in your bundle's \texttt{bnd.bnd}
  file:

\begin{verbatim}
Web-ContextPath: /my-module-web
\end{verbatim}
\item
  Make sure the
  \texttt{\textless{}liferay-frontend:defineObjects\ /\textgreater{}}
  tag is included in your portlet's \texttt{init.jsp}. This makes the
  \texttt{npmResolvedPackageName} variable available, setting it to your
  project module's resolved name. For instance, if your module is called
  \texttt{my-module} and is at version \texttt{2.3.0}, the implicit
  variable \texttt{npmResolvedPackageName} is set to
  \texttt{my-module@2.3.0}. This lets you prefix any JS module
  \texttt{require} or soy component rendering with this variable.
\item
  Use the \texttt{npmResolvedPackageName} variable along with the
  relative path to your JavaScript module file to create an alias in the
  \texttt{\textless{}aui:script\textgreater{}}'s \texttt{require}
  attribute. An example configuration is shown below:

\begin{verbatim}
<aui:script 
  require='<%= npmResolvedPackageName + 
  "/js/my-module.es as myModule" %>'>
</aui:script>
\end{verbatim}
\item
  Use the alias inside the \texttt{aui:script} to refer to your module:

\begin{verbatim}
<aui:script 
  require='<%= npmResolvedPackageName + 
  "/js/my-module.es as myModule" %>'>

    myModule.default();
</aui:script>
\end{verbatim}
\end{enumerate}

Now you know how to use an npm module's package!

\section{Related Topics}\label{related-topics-90}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/obtaining-dependency-npm-package-descriptors}{Obtaining
  an OSGi bundle's Dependency npm Package Descriptors}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/how-the-liferay-npm-bundler-publishes-npm-packages}{How
  liferay-npm-bundler Publishes npm Packages}
\end{itemize}

\chapter{The Info Framework}\label{the-info-framework}

7.0 introduces the Info Framework to provide a greater degree of
extensibility for the most common needs of retrieving, processing and
displaying any type of information. A key aspect of the Info Framework
is that it makes no assumptions about the source of the data or how it
is represented in memory (like which Java class the information is
from). It can work with information stored in the database, created
through some process in memory or retrieved from an external source.

In 7.0, the Info Framework still has limited functionality, but it sets
the foundation for obtaining and displaying information from external
systems or custom data models in Liferay. It also provides flexibility
in customizing how any piece of information is displayed.

The Info Framework is lightweight. By design, it does not require all
the information to implement any specific interface. This means that you
can use it with any existing Java class, even if you don't have access
to modify it. It comprises a collection of loosely coupled
micro-frameworks, so that developers can choose which features to use
and ignore the others. This lowers the learning curve and minimizes work
for developers.

\noindent\hrulefill

\textbf{Note:} Liferay veterans may notice similarities between the
\href{/docs/7-2/frameworks/-/knowledge_base/f/asset-framework}{Asset
Framework} and Info Frameworks. The Info Framework can be considered a
generalization of the Asset Framework and its design has considered lots
of lessons learned from the Asset Framework. In particular, the Info
Framework provides many similar characteristics (such as rendering of
information) but with fewer requirements (such as having an
\texttt{AssetEntry} in the database). We have also made sure the two
frameworks play well together so that when the Asset Framework is used,
for rendering an asset, the renderer is also available through the Info
framework. The Info framework is not meant to be a full replacement for
the Asset Framework, but if the Asset Framework seems too complex for
your needs, the Info Framework might be a better fit for you.

\noindent\hrulefill

\section{Using the Info Framework}\label{using-the-info-framework}

The Info Framework helps generalize information handling. Custom
applications can use it to make them more generic and extensible.

Some of the out-of-the-box Liferay features use it to achieve that same
goal. In particular, Liferay DXP 7.2 uses it in two ways:

\begin{itemize}
\item
  The Asset Publisher can display Assets from Information Lists defined
  by the Info Framework.
\item
  Display Pages, which previously only worked for an
  \texttt{AssetEntry}, can now leverage the \texttt{InfoFramework} to
  create display pages for any type of information that can be
  represented by a Java class. Developers can add support for display
  pages for various entities like Orders, Categories, and Events that
  are not Assets.
\end{itemize}

There are currently two tools provided by the Info Framework:
Information Item Renderers and Information List Providers. You can
create an Information List Provider to obtain a list of information
items from a source, or create an Information Item Renderer to provide a
custom renderer for any type of information. These two features can be
used together or separately.

\section{List Providers}\label{list-providers}

Information List Providers obtain a list of information items from a
source. To do this, a developer must implement the
\texttt{InfoListProvider} interface and provide the necessary logic for
retrieving the information from its source. By providing an
implementation of the \texttt{InfoListProvider} interface, developers
can provide programmatic retrieval of information of any type, as long
as it can be represented through a Java class.

\texttt{InfoListProvider} has four methods to implement:

\texttt{getLabel()} provides the label that is displayed for this
provider in the UI of applications like the Asset Publisher.

\texttt{getInfoList()} provides the information list. This method has
two variants: a plain list or a list with pagination and sorting.

\texttt{getInfoListCount()} provides total number of items. This is
needed for the paginated variant of \texttt{getInfoList}.

For an example of how to create Information List providers, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-information-list-provider}{Creating
Information List Providers}.

\section{Item Renderers}\label{item-renderers}

Developers can create custom renderers for any type of information. To
do this, a developer must provide an implementation of the
\texttt{InfoItemRenderer} interface to provide programmatic rendering of
information. It can be any kind of information as long as it can be
represented through a Java class. You can create multiple renderers for
a single type of information.

Internally, Liferay's Display Pages use this from the Content component.
When it is added to a display page template, this component renders
whatever piece of information is shown through that template (whether it
is Content in the strict sense or some other entity type). It is
rendered by the first \texttt{InfoItemRenderer} class registered that
entity. Information Item Renderers will be leveraged further in future
Liferay versions.

To create an Information Item Renderer you must create a class that
implements \texttt{InfoItemRenderer} and registers it as a component.
Inside that class, you need a \texttt{render()} method that contains
your logic. To learn about Information Item Renderers, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/custom-rendering-of-information-with-infoitemrenderer}{Creating
Information Item Renderers}.

\chapter{Creating an Information List
Provider}\label{creating-an-information-list-provider}

To demonstrate Information List Providers, follow the instructions below
to implement an \texttt{InfoListProvider} for the most viewed asset
entries. In this case the list shows a list of \texttt{AssetEntry}
instances. Since they already have their own renderer, they can appear
in the Asset Publisher with no additional changes. If you create a
provider for a custom class, you must also render it.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{module}
  named asset-entry-info-list-provider.
\item
  Create a package inside the module named
  \texttt{com.liferay.docs.info.provider}.
\item
  Inside the package, create a class named
  \texttt{AssetEntryInfoListProvider} that implements
  \texttt{InfoListProvider} and registers it as a component:

\begin{verbatim}
@Component(service = InfoListProvider.class)
  public class AssetEntryInfoListProvider implements InfoListProvider<AssetEntry> {

}
\end{verbatim}
\item
  Next, add the necessary \texttt{@Reference} that you need for the
  logic of retrieving assets to the bottom of the class.

\begin{verbatim}
@Reference
AssetEntryLocalService _assetEntryLocalService;
\end{verbatim}
\item
  Then implement \texttt{getInfoList} which returns just the list.

\begin{verbatim}
@Override
public List<AssetEntry> getInfoList(
 InfoListProviderContext infoListProviderContext) {

 return _assetEntryLocalService.getTopViewedEntries(
    new String[0], false, 0, 20);
}
\end{verbatim}

  Descending order and a maximum of 20 items to return is hardcoded.
\item
  Now implement the second method, which provides greater control over
  how items are returned to the provider.

\begin{verbatim}
@Override
public List<AssetEntry> getInfoList(
  InfoListProviderContext infoListProviderContext, Pagination pagination,
  Sort sort) {

  return _assetEntryLocalService.getTopViewedEntries(
     new String[0], !sort.isReverse(), pagination.getStart(),
     pagination.getEnd());
}
\end{verbatim}
\item
  Provide a method to get a full count of info list items.

\begin{verbatim}
@Override
public int getInfoListCount(
InfoListProviderContext infoListProviderContext) {

    Company company = infoListProviderContext.getCompany();

    return _assetEntryLocalService.getCompanyEntriesCount(
    company.getCompanyId());
}
\end{verbatim}
\item
  Finally, add a method that provides a display label for the list.

\begin{verbatim}
@Override
public String getLabel(Locale locale) {
 return "Most Viewed Content";
 }
\end{verbatim}
\end{enumerate}

The completed class should look like this:

\begin{verbatim}
@Component(service = InfoListProvider.class)
  public class AssetEntryInfoListProvider implements InfoListProvider<AssetEntry> {

           @Override
           public List<AssetEntry> getInfoList(
             InfoListProviderContext infoListProviderContext) {

             return _assetEntryLocalService.getTopViewedEntries(
                new String[0], false, 0, 20);
           }

         @Override
         public List<AssetEntry> getInfoList(
           InfoListProviderContext infoListProviderContext, Pagination pagination,
           Sort sort) {

           return _assetEntryLocalService.getTopViewedEntries(
              new String[0], !sort.isReverse(), pagination.getStart(),
              pagination.getEnd());
         }

         @Override
         public int getInfoListCount(
         InfoListProviderContext infoListProviderContext) {

             Company company = infoListProviderContext.getCompany();

             return _assetEntryLocalService.getCompanyEntriesCount(
             company.getCompanyId());
         }

           @Override
           public String getLabel(Locale locale) {
             return "Most Viewed Content";
             }

@Reference
AssetEntryLocalService _assetEntryLocalService;
}
\end{verbatim}

This class is now ready to go! If you deploy it, it shows the ``Most
Viewed Content'' in any Asset Publisher.

\section{Next steps}\label{next-steps}

This example is pretty simplistic and probably not useful in real world
cases. To begin with, you may want to scope the search to the current
site. You can also add more advanced filter criteria or provide a
configuration for the provider using Liferay's configuration framework.

As mentioned, it is also possible to implement providers for custom
types. The following code shows a partial example of a provider for a
custom \texttt{MyOrder} class:

\begin{verbatim}
@Component(service = InfoListProvider.class)
public class MyOrderProvider implements InfoListProvider<MyOrder> {

    @Override
    public List<MyOrder> getInfoList(
        InfoListProviderContext infoListProviderContext, Pagination pagination,
        Sort sort) {

        return _myOrderLocalService.getOrders(
            [...], !sort.isReverse(), pagination.getStart(),
            pagination.getEnd());
        }

    [..]

    @Reference
    MyOrderLocalService _myOrderLocalService;
\end{verbatim}

\chapter{\texorpdfstring{Custom rendering of information with
\texttt{InfoItemRenderer}}{Custom rendering of information with InfoItemRenderer}}\label{custom-rendering-of-information-with-infoitemrenderer}

To demonstrate the \texttt{InfoItemRenderer}, implement a class that can
render information provided through a custom class called
\texttt{MyOrder}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{module}
  named \texttt{my-order}.
\item
  In \texttt{my-order}, create a package named
  \texttt{com.liferay.docs.info.myorder}
\item
  In the package, create a class that implements
  \texttt{InfoItemRenderer} and register it as a component.

\begin{verbatim}
@Component(service = InfoItemRenderer.class)
public class MyOrderRenderer implements InfoItemRenderer<MyOrder> {
    @Override
    public void render(
       MyOrder myOrder, HttpServletRequest httpServletRequest,
       HttpServletResponse httpServletResponse) {

    }
}
\end{verbatim}
\item
  Next you must add the logic for the \texttt{render()} method.

\begin{verbatim}
@Override
public void render(
   MyOrder myOrder, HttpServletRequest httpServletRequest,
   HttpServletResponse httpServletResponse) {

   StringBundler sb = new StringBundler(3);

   sb.append("<ul>");
   sb.append("<li>By: " + myOrder.getBy());
   sb.append("<li>When: " + myOrder.getWhen());
   sb.append("<li>Items: " + myOrder.getItems());
   sb.append("</ul>");

   try {
      PrintWriter printWriter = httpServletResponse.getWriter();

      printWriter.write(sb.toString());
   }
   catch (IOException ioe) {
      throw new RuntimeException(ioe);
   }
}
\end{verbatim}
\end{enumerate}

For this example you rendered everything through a
\texttt{StringBundler}. In more complex cases, you would use JSPs or
another templating technology.

The renderer is ready for use! In 7.0, Info Item Renderers are not
widely used, but the usages and application will grow in future
releases.

\chapter{Using Providers with Custom
Applications}\label{using-providers-with-custom-applications}

Imagine a widget that can display lists of orders. You can use the Info
Framework so that it shows any list of orders provided through
\texttt{InfoListProvider}.

First you must obtain a list of all available providers for the desired
type, and then you would obtain a specific provider through that list.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The list of all available providers for \texttt{MyOrder}, can be
  obtained done by using the \texttt{InfoListProviderTracker}:

\begin{verbatim}
@Reference
InfoListProviderTracker _infoListProviderTracker;
\end{verbatim}

  Once a tracker is available, obtaining the list is as simple as
  invoking \texttt{getInfoListProviders()}:

\begin{verbatim}
_infoListProviderTracker.getInfoListProviders(MyOrder.class);
\end{verbatim}

  When the user selects an item from this list, you can store the
  class's name.
\item
  When a specific provider is desired it can be obtained through its
  class name as follows:

\begin{verbatim}
_infoListProviderTracker.getInfoListProvider(infoListProviderClassName);
\end{verbatim}
\end{enumerate}

\section{Leveraging renderers from a custom
application}\label{leveraging-renderers-from-a-custom-application}

Using renderers from a custom application is almost identical to using
providers. Here is the equivalent code to what you've seen previously:

\begin{verbatim}
_infoItemRendererTracker.getInfoItemRenderers(MyOrder.class.getName());

String infoItemRendererClassName = MyOrderRenderer.class.getName();
_infoItemRendererTracker.getInfoItemRenderer(infoItemRendererClassName);
\end{verbatim}

\chapter{Liferay Forms}\label{liferay-forms}

The Liferay Forms application is a full-featured form building tool for
collecting data. There's lots of built-in functionality, and for the
pieces you're missing, there's lots of extensibility.

\chapter{Form Serialization with the DDM IO
API}\label{form-serialization-with-the-ddm-io-api}

When a form creator saves a form in the Liferay Forms application, the
Form object is \emph{serialized} (converted) into JSON for storage in
the Liferay DXP database. That's the default behavior; if you need the
form in a different format, you must write your own serialization and
deserialization code. Why would you want to do that? Maybe you think
JSON storage is not secure, or you have another tool that can consume
the form if it's in YAML. Whatever your reasons, the form can be stored
in any format as long as you write a \texttt{DDMFormSerializer} and its
corresponding \texttt{DDMFormDeserializer} with the proper logic.

First consider what form data looks like by default, in JSON. A simple
form, \emph{My Form}, with one text field, \emph{Full Name}, is first
created as a \texttt{DDMForm} Java object, then \emph{serialized} into
JSON for storage in the Liferay DXP database when saved.

\begin{verbatim}
{
    "availableLanguageIds":["en_US"],
    "successPage":{"body":{},
    "title":{},
    "enabled":false},
    "defaultLanguageId":"en_US",
    "fields":[{
        "autocomplete":false,
        "ddmDataProviderInstanceId":"[]",
        "dataType":"string",
        "predefinedValue":{"en_US":""},
        "tooltip":{"en_US":""},
        "readOnly":false,
        "label":{"en_US":"Full Name"},
        "type":"text",
        "required":false,
        "showLabel":true,
        "displayStyle":"singleline",
        "fieldNamespace":"",
        "indexType":"keyword",
        "visibilityExpression":"",
        "ddmDataProviderInstanceOutput":"[]",
        "repeatable":false,
        "name":"FullName",
        "options":[{"label":{"en_US":"Option"},"value":"Option"}],
        "localizable":true,
        "tip":{"en_US":""},
        "placeholder":{"en_US":""},
        "dataSourceType":"",
        "validation":{"expression":"","errorMessage":""}
    }]
}
\end{verbatim}

From its initial state as a \texttt{DDMForm} Java object, the form is
\emph{serialized} into JSON format, and upon retrieval from the
database, it's \emph{deserialized}: the JSON object representing the
form is translated back into a \texttt{DDMForm} Java object, with all
its requisite fields. For example, the JSON for the above example holds
each form field in the \texttt{fields} attribute. To translate this back
into the necessary \texttt{DDMForm} object, first parse the data
contained in the JSON object into an actual form field using your
deserialization logic. Here's the logic from
\texttt{DDMFormJsonDeserializer} that parses the JSON \texttt{"fields"}
element into a list of \texttt{DDMFormFields}:

\begin{verbatim}
protected List<DDMFormField> getDDMFormFields(JSONArray jsonArray)
    throws PortalException {

    List<DDMFormField> ddmFormFields = new ArrayList<>();

    for (int i = 0; i < jsonArray.length(); i++) {
        DDMFormField ddmFormField = getDDMFormField(
            jsonArray.getJSONObject(i));

        ddmFormFields.add(ddmFormField);
    }

    return ddmFormFields;
}
\end{verbatim}

Now calling \texttt{DDMForm.setDDMFormFields(ddmFormFields)} in the
deserializer completes the translation process from the JSON array back
to a \texttt{DDMFormField} object that the \texttt{DDMForm} needs.

If you'd like to store forms in a different format, provide custom
\emph{serialization} and \emph{deserialization} functionality.

\chapter{Serializing Forms}\label{serializing-forms}

The DDM IO API serializes and deserializes forms using a
request/response structure. The example here creates a serializer for
saving form data in \href{https://yaml.org}{YAML} format. The same
principles shown here apply to writing a deserializer.

To serialize form data into YAML:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that implements \texttt{DDMFormSerializer}:

\begin{verbatim}
@Component(immediate = true, property = "ddm.form.serializer.type=yaml") public
class DDMFormYamlSerializer implements DDMFormSerializer { .....  }
\end{verbatim}

  The property \texttt{ddm.form.serializer.type=yaml} marks the
  Component so that \texttt{DDMFormSerializerTracker} can find the YAML
  serializer.
\item
  Add the serializing logic to the overridden \texttt{serialize} method.
  It takes a \texttt{DDMFormSerializerSerializeRequest} and returns a
  \texttt{DDMFormSerializerSerializeResponse} with the serialized string
  in it.

\begin{verbatim}
@Override public DDMFormSerializerSerializeResponse serialize(
DDMFormSerializerSerializeRequest ddmFormSerializerSerializeRequest) {

        DDMForm ddmForm = ddmFormSerializerSerializeRequest.getDDMForm(); 

        ...YOUR CODE FOR BUILDING A YAML OBJECT GOES HERE ...  

        DDMFormSerializerSerializeResponse.Builder builder = 
            DDMFormSerializerSerializeResponse.Builder.newBuilder(yamlObject.toString());

        return builder.build(); }
\end{verbatim}
\end{enumerate}

This is what you need to create your serializer. Of course,
\texttt{YOUR\ CODE\ FOR\ BUILDING\ A\ YAML\ OBJECT\ GOES\ HERE} requires
some explanation. While you can do whatever you want here, there are
several things you really ought to do:

\textbf{Add the available Language IDs:} Since you have the
\texttt{DDMForm} object from the request, call
\texttt{ddmForm.getAvailableLocales()}.

\textbf{Add the default Language ID:} Get this from the \texttt{DDMForm}
object by calling \texttt{ddmForm.getDefaultLocale()}.

\textbf{Add the Form Fields:} Get these from the \texttt{DDMForm} object
by calling \texttt{ddmForm.getDDMFormFields()}.

\textbf{Add any Form Rules:} Get them form the \texttt{DDMForm} object
with \texttt{ddmForm.getDDMFormRules()}.

\textbf{Add Success Page Settings:} Get these from the \texttt{DDMForm}
with \texttt{ddmForm.getDDMFormSuccessPageSettings()}.

All these are done in the default form serializer,
\texttt{DDMFormJSONSerializer}.

If you have the Liferay DXP source code, you can find the default
serializer in

\begin{verbatim}
modules/apps/dynamic-data-mapping/dynamic-data-mapping-io/src/main/java/com/liferay/dynamic/data/mapping/io/internal/DDMFormJSONSerializer.java
\end{verbatim}

You didn't create serialization code for no reason. You'll want to call
it from somewhere.

\section{Calling the Serializer}\label{calling-the-serializer}

To get properly serialized form content, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get the serializer from the \texttt{DDMFormSerializerTracker}, passing
  in the value of the \texttt{ddm.form.serializer.type} property.
\item
  Construct a \texttt{DDMFormSerializerSerializeRequest} object using
  its nested static \texttt{Builder} class.
\item
  Call the \texttt{serialize} method you wrote in the last section to
  create the \texttt{DDMFormSerializerSerializeResponse}, passing the
  \texttt{DDMFormSerializerSerializeRequest} object, via a call to the
  \texttt{Builder}'s \texttt{build} method.
\item
  Get the serialized form content from the
  \texttt{DDMFormSerializerSerializeResponse} by calling its
  \texttt{getContent} method.
\end{enumerate}

Here's a code example:

\begin{verbatim}
DDMFormSerializer ddmFormSerializer =
ddmFormSerializerTracker.getDDMFormSerializer("yaml");

DDMFormSerializerSerializeRequest.Builder builder =
DDMFormSerializerSerializeRequest.Builder.newBuilder(ddmForm);

DDMFormSerializerSerializeResponse ddmFormSerializerSerializeResponse =
ddmFormSerializer.serialize(builder.build());

ddmFormSerializerSerializeResponse.getContent();
\end{verbatim}

You can create a serializer for any format that can be saved in the
database as a String. Once you create the serializer, make it the
default by changing the storage format in the Form's Settings menu.

\chapter{Localization}\label{localization}

If you're writing a Liferay application, you're probably a genius who is
also really cool, which means your application will be used throughout
the entire world. At least, if its messages can be translated into their
language, it will. Thankfully, Liferay facilitates creating and using
message translations and adapting to cultural conventions for user names
and initials.

You can leverage Liferay's localization framework or use standard
resource bundles to localize your app. The localization framework uses
properties files (the same as any resource bundle) but leverages a
default properties file called \texttt{Language.properties} to propagate
messages (language keys) to properties files for all your locales. For
example, when you add a new message to the \texttt{Language.properties}
file and run Language Builder, it propagates the message to your locale
files. All you must do is translate the message in each locale file,
manually or automatically using Language Builder.

Language Builder integrates the Microsoft Text Translator API to
translate each locale file's messages from your default locale to the
respective locale. A machine's translation is no substitute for a
human's, of course, but the automatic translation gives you a base to
work from.

It's common to use the same messages in multiple apps. Liferay DXP
provides these message sharing features:

\begin{itemize}
\item
  Liferay DXP's messages (and their translations) are available for all
  your apps to use. JSP tags such as
  \texttt{\textless{}liferay-ui:message\ ...\ /\textgreater{}} let you
  use all Liferay DXP messages.
\item
  Language modules are easy to use in all your apps. They're great for
  centralizing messages in all your locales.
\end{itemize}

Lastly, Liferay DXP provides settings for adapting your app to cultures:

\begin{itemize}
\item
  Naming conventions for users
\item
  Initial conventions for user avatars
\item
  Text direction settings (left-to-right or right-to-left)
\end{itemize}

Localization is important to all site users. Liferay helps you get it
right! Start with localizing your application using Liferay's
localization framework.

\chapter{Localizing Your Application}\label{localizing-your-application}

Liferay's localization framework helps you create and use localized
messages in minutes. You create your messages in a default properties
file called \texttt{Language.properties} and localize them in properties
files that use the convention \texttt{Language\_xx.properties}, where
\texttt{xx} is the locale code. After deploying your app, the messages
are available to your templates. Liferay's JSP tags, such as
\texttt{\textless{}liferay-ui:message\ .../\textgreater{}} display them
in the user's current locale automatically, without requiring you to
access \texttt{ResourceBundle} or \texttt{Locale} objects explicitly.
Here are the steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a default language properties file called
  \texttt{Language.properties} in your project's resource bundle folder.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Project Type              | Resource Bundle Folder |
 ------------------------- | ---------------------- |
 Bean Portlet              | `src/main/resources/content/` |
 JSF Portlet               | `src/main/resources/` |
 Liferay MVC Portlet       | `src/main/resources/content/` |
 PortletMVC4Spring Portlet | `src/main/java/resources/content/` |
 Angular Widget            | `features/localization/` |
 React Widget              | `features/localization/` |
 Vue.js Widget             | `features/localization/` |
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Specify your language properties (language keys) using key/value
  pairs. For example, create a friendly greeting.

\begin{verbatim}
howdy-partner=Howdy, Partner!
\end{verbatim}
\item
  Configure your app's resource bundle and the locales you're
  supporting. The locales your Liferay DXP instance supports are
  specified in its
  \href{/docs/7-2/deploy/-/knowledge_base/d/portal-properties}{portal
  properties} file (here are Liferay DXP's
  \href{(https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones)}{default
  locales}. For example, these configurations support translations for
  English and Spanish locales:

  \textbf{\texttt{@PortletConfiguration} class annotation:} Can be used
  in Portlet 3.0 portlets such as Bean Portlets.

\begin{verbatim}
@PortletConfiguration (
    ...
    resourceBundle="content.Language",
    supportedLocales = {"en", "es"}
)
\end{verbatim}

  \textbf{Portlet descriptor \texttt{portlet.xml}:} Can be used in any
  portlet WAR.

\begin{verbatim}
<portlet>
...
<supported-locale>en</supported-locale>
<supported-locale>es</supported-locale>
<resource-bundle>content.Language</resource-bundle>
...
</portlet>
\end{verbatim}

  \textbf{\texttt{@Component} class annotation:} Can be used in a
  portlet module such as a Liferay MVC Portlet.

\begin{verbatim}
@Component (
    ...
    property = {
        ...
        "javax.portlet.supported-locale=en",
        "javax.portlet.supported-locale=es",
        "javax.portlet.resource-bundle=content.Language"
    }
)
\end{verbatim}
\item
  Create language properties for a locale. For demonstration purposes,
  create one manually.
  \href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-generating-translations}{Automatically
  generating translations} is discussed later.

  For example, create a Spanish translation by copying
  \texttt{Language.properties} to \texttt{Language\_es.properties} and
  translating the property values to Spanish.

\begin{verbatim}
howdy-partner=Hola, Compañero!
\end{verbatim}
\item
  In your front-end template code, use the language property. For
  example, a JSP could use the \texttt{howdy-partner} property via the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/liferay-ui/message.html}{\texttt{\textless{}liferay-ui:message\ /\textgreater{}}}
  tag.

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/ui" prefix="liferay-ui" %> 
...
<liferay-ui:message key="howdy-partner" />
...
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Tip:** The
 [`liferay-ui`](https://docs.liferay.com/dxp/portal/7.2-latest/taglibs/util-taglib/liferay-ui/tld-summary.html)
 tag library has several tags (e.g., `alert`, `error`, and `message`) that
 accept language keys. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Deploy your application and view it in different locales. For example,
  you could view the app locally in Spanish by specifying the
  \texttt{es} locale code in the URL (e.g.,
  \texttt{http://localhost:8080/es/...}).
\end{enumerate}

Congratulations on a great start to localizing your application!

Next, you can explore
\href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-generating-translations}{generating
translations automatically} or
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-language-module}{create
a language module} for using language keys across applications.

\section{Related Topics}\label{related-topics-91}

\href{/docs/7-2/frameworks/-/knowledge_base/f/automatically-generating-translations}{Automatically
Generating Translations}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{Using
Language Modules}

\href{/docs/7-2/frameworks/-/knowledge_base/f//docs/7-1/tutorials/-/knowledge_base/t/using-liferays-language-settings}{Using
Liferay DXP's Language Settings}

\chapter{Using Liferay's Localization
Settings}\label{using-liferays-localization-settings}

You can customize a given locale's default language settings by
overriding the properties that control those settings. For instructions
on this, see
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
Language Keys}. Here, you'll learn which properties correspond to common
language settings.

So what all can be customized? This is an excellent question! Consider
these examples:

\begin{itemize}
\item
  In the add and edit user forms, you can configure the name fields that
  are displayed and the field values available in select fields. For
  example, you can leave out the middle name field or alter the prefix
  selections.
\item
  You can also control the directionality of content and messages (left
  to right or right to left).
\end{itemize}

Language properties exist in \texttt{Language\_xx.properties} files,
where \texttt{xx} represents the locale. For example,
\texttt{Language\_es.properties} contains the properties for Spanish,
\texttt{Language\_en.properties} contains the properties for English,
and so on.

The default (core) language properties are in
\texttt{Language.properties}. \textbf{Do not edit this file.} You can,
however, open it to view the default language settings. There are two
ways to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From Liferay Portal's source code. Navigate to

\begin{verbatim}
liferay-portal/portal-impl/src/content/Language.properties
\end{verbatim}
\item
  From a bundle's \texttt{portal-impl.jar}.

\begin{verbatim}
[Liferay Home]/tomcat-[version]/webapps/ROOT/WEB-INF/lib/portal-impl.jar
\end{verbatim}

  Open the \texttt{content} folder in the JAR to find the language
  files.
\end{enumerate}

The first section in the core \texttt{Language.properties} file is
labeled \emph{Language Settings} and contains language properties that
begin with \texttt{lang}:

\begin{verbatim}
##
## Language Settings
##

lang.dir=ltr
lang.line.begin=left
lang.line.end=right
lang.user.default.portrait=initials
lang.user.initials.field.names=first-name,last-name
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

To use the language settings mentioned here, you must have a module. See
the articles on
\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{overriding
language keys} to set up a module with the following characteristics:

\begin{itemize}
\item
  Contains an implementation of \texttt{ResourceBundle} that is
  registered in the OSGi runtime.
\item
  Contains a \texttt{Language\_xx.properties} file for the locale whose
  properties you want to override.
\end{itemize}

\section{Localizing User Names}\label{localizing-user-names}

Naming conventions can differ between locales. For example, users in
some locales have more than one last name. You can therefore change the
user name properties to fit the given locale. The properties for
changing user name settings begin with \texttt{lang.user.name}.

User name fields are configurable in the following ways:

\begin{itemize}
\item
  Remove certain name fields and make others appear more than once. Some
  locales need more than one last name, for example.

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Change the prefix and suffix values for a locale.

\begin{verbatim}
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}
\item
  Specify which fields are required.

\begin{verbatim}
lang.user.name.required.field.names=last-name
\end{verbatim}
\end{itemize}

A user's first name is mandatory. Because of this, take these two points
into consideration when configuring a locale's user name settings:

\begin{itemize}
\item
  The \texttt{first-name} field can't be removed from the field names
  list.

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
\end{verbatim}
\item
  Because a first name is required, it's always implicitly included in
  the \texttt{required\ field\ names} property:

\begin{verbatim}
lang.user.name.required.field.names=last-name
\end{verbatim}

  Therefore, any fields you enter here are \emph{in addition to} the
  first name field. Last name is required by default, but you can
  disable it by deleting its value from the property:

\begin{verbatim}
lang.user.name.required.field.names=
\end{verbatim}

  In that case, only a first name would be required.
\end{itemize}

For most of the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/propertiesdoc/portal.properties.html\#Languages\%20and\%20Time\%20Zones}{locales
enabled by default}, the user name properties are tailored to each
locale. The default locales are specified by the
\texttt{locales.enabled} property:

\begin{verbatim}
locales.enabled=ar_SA,ca_ES,zh_CN,nl_NL,en_US,fi_FI,fr_FR,de_DE,hu_HU,ja_JP,pt_BR,es_ES,sv_SE
\end{verbatim}

For example, here are the English (\texttt{Language\_en.properties})
properties for setting user name fields:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,middle-name,last-name,suffix
lang.user.name.prefix.values=Dr,Mr,Ms,Mrs
lang.user.name.required.field.names=last-name
lang.user.name.suffix.values=II,III,IV,Jr,Phd,Sr
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/english-user-name-fields.png}
\caption{The user name settings impact the appearance of user
information and forms.}
\end{figure}

Compare those to the Spanish (\texttt{Language\_es.properties})
settings:

\begin{verbatim}
lang.user.name.field.names=prefix,first-name,last-name
lang.user.name.prefix.values=Sr,Sra,Sta,Dr,Dra
lang.user.name.required.field.names=last-name
\end{verbatim}

\begin{figure}
\centering
\includegraphics{./images/spanish-user-name-fields.png}
\caption{The Spanish user name settings omit the suffix and middle name
fields.}
\end{figure}

The biggest difference between the English and Spanish form fields is
that the middle name and suffix fields are omitted in the Spanish
configuration. Other differences include the specific prefix values.
¡Muy excelente!

\section{Identifying User Initials}\label{identifying-user-initials}

The default avatar displays a user's initials. Some cultures use
initials differently, so there's a way to configure them in the
appropriate \texttt{Language\_xx.properties} file.

\begin{verbatim}
lang.user.default.portrait=initials
lang.user.initials.field.names=first-name,last-name
\end{verbatim}

The \texttt{lang.user.default.portrait} property sets the type of
portrait to use for users. This can be set to \texttt{initials} or
\texttt{image}. If set to \texttt{image}, the default images defined by
the \texttt{image.default.user.female.portrait} or
\texttt{image.default.user.male.portrait} properties residing in the
\texttt{portal.properties} file are used. Therefore, the
\texttt{lang.user.initials.field.names} property is ignored.

\begin{figure}
\centering
\includegraphics{./images/initials-avatar.png}
\caption{The user's initials are displayed for their avatar by default.}
\end{figure}

If you're leveraging the user's initials for the default avatar, you can
use the \texttt{lang.user.initials.field.names} property to organize how
the initials are displayed. Valid values for this property include
\texttt{first-name}, \texttt{middle-name}, and \texttt{last-name}, in
any order.

\section{Right to Left or Left to
Right?}\label{right-to-left-or-left-to-right}

The first three properties in the core \texttt{Language.properties}
file's Language Settings section change the display direction of a
language's characters. Most languages read from left to right, but some
languages read from right to left (e.g., Arabic, Hebrew, and Persian).

Here are the relevant language properties for a right-to-left language:

\begin{verbatim}
lang.dir=rtl
lang.line.begin=right
lang.line.end=left
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} You can prevent specific CSS rules from transforming
(flipping) with the \texttt{/*\ @noflip\ */} decoration. Place the
decoration to the left of the CSS rule to apply it. For example, this
rule gives a left margin of \texttt{20em} to the \texttt{body} no matter
if the selected language is LTR or RTL:

\begin{verbatim}
/* @noflip */ body {
 margin-left: 20em;
}
\end{verbatim}

You can also use the \texttt{.rtl} CSS selector for rules that
exclusively apply to RTL languages.

\noindent\hrulefill

\section{Related Topics}\label{related-topics-92}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
Language Keys}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{Localizing
Your Application}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-language-module}{Creating
a Language Module}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{Using
a Language Module}

\chapter{Creating a Language Module}\label{creating-a-language-module}

You might have an application with multiple modules that provide the
view layer. These modules are often called web modules. For example,
this application contains three such modules:

\begin{verbatim}
my-application/
my-application-web/
my-admin-application-web/
my-application-content-web/
my-application-api/
my-application-service/
\end{verbatim}

Each of these modules can have language keys and translations to
maintain, likely resulting in duplicate keys. You don't want to end up
with different values for the same key, and you don't want to maintain
language keys in multiple places. In this case, you should create a
single module---a language module---for housing all your app's language
keys.

Follow these steps to create a language module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the root project folder (the one that holds your service, API, and
  web modules),
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{create
  a new module} to hold your app's language keys.
\item
  In the language module, create a \texttt{src/main/resources/content}
  folder. In this folder, create a \texttt{Language.properties} file for
  your app's default language keys. For example, such a file might look
  like this:

\begin{verbatim}
my-app-title=My Application
add-entity=Add Entity
\end{verbatim}
\item
  Create any translations you want in additional language properties
  files, appending the locale's ID to the file name. For example, a file
  \texttt{Language\_es.properties} holds Spanish (\texttt{es})
  translations and could contain something like this:

\begin{verbatim}
my-app-title=Mi Aplicación
add-entity=Añadir Entity
\end{verbatim}

  Here's the folder structure of an example language module called
  \texttt{my-application-lang}. This module contains the app's default
  language keys (\texttt{Language.properties}) and a Spanish translation
  (\texttt{Language\_es.properties}):

\begin{verbatim}
my-application-lang/
    bnd.bnd
    src/
        main/
            resources/
                content/
                    Language.properties
                    Language_es.properties
                    ...
\end{verbatim}
\end{enumerate}

On building the language module, Liferay DXP's
\texttt{ResourceBundleLoaderAnalyzerPlugin} detects the module's
\texttt{Language.properties} file and adds a resource bundle
\href{http://blog.osgi.org/2015/12/using-requirements-and-capabilities.html}{capability}
to the module. A capability is a contract a module declares to the OSGi
framework. Capabilities let you associate services with modules that
provide them. In this case, Liferay DXP registers a
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/util/ResourceBundleLoader.html}{ResourceBundleLoader}
service for the resource bundle capability.

\section{Related Topics}\label{related-topics-93}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
Language Keys}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{Localizing
Your Application}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-liferays-localization-settings}{Using
Liferay's Localization Settings}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{Using
a Language Module}

\chapter{Using a Language Module}\label{using-a-language-module}

A module or traditional Liferay plugin can use a resource bundle from
another module and optionally include its own resource bundle. OSGi
manifest headers \texttt{Require-Capability} and
\texttt{Provide-Capability} make this possible, and it's especially easy
in modules generated from Liferay project templates. Instructions for
using a language module are divided into these environments:

\begin{itemize}
\tightlist
\item
  \hyperref[using-a-language-module-from-a-module]{Using a Language
  Module from a Module}
\item
  \hyperref[using-a-language-module-from-a-traditional-plugin]{Using a
  Language Module from a Traditional Plugin}
\end{itemize}

If you're using bnd with Maven or Gradle, you need only specify
Liferay's \texttt{-liferay-aggregate-resource-bundle:} bnd
instruction---at build time, Liferay's bnd plugin converts the
instruction to \texttt{Require-Capability} and
\texttt{Provide-Capability} parameters automatically. Both approaches
are demonstrated here.

\section{Using a Language Module from a
Module}\label{using-a-language-module-from-a-module}

Modules generated from Liferay project templates have a Liferay bnd
build time instruction called
\texttt{-liferay-aggregate-resource-bundles}. It lets you use other
resource bundles (including their language keys) along with your own.

Here's how to use this bnd instruction:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's \texttt{bnd.bnd} file.
\item
  Add the \texttt{-liferay-aggregate-resource-bundles:} bnd instruction
  and assign it the bundle symbolic names of modules whose resource
  bundles you wish to aggregate with the current module's resource
  bundle:

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    [bundle.symbolic.name1],\
    [bundle.symbolic.name2]
\end{verbatim}
\end{enumerate}

For example, a module that uses resource bundles from modules
\texttt{com.liferay.docs.l10n.myapp1.lang} and
\texttt{com.liferay.docs.l10n.myapp2.lang} would set this in its
\texttt{bnd.bnd} file:

\begin{verbatim}
-liferay-aggregate-resource-bundles: \
    com.liferay.docs.l10n.myapp1.lang,\
    com.liferay.docs.l10n.myapp2.lang
\end{verbatim}

The current module's resource bundle is prioritized over those of the
listed modules.

\noindent\hrulefill

\textbf{Note:} The Shared Language Key
\href{/docs/7-2/reference/-/knowledge_base/r/shared-language-keys}{sample
project} is a working example that demonstrates aggregating resource
bundles. You can deploy it in Gradle, Maven, and Liferay Workspace build
environments.

\noindent\hrulefill

At build time, Liferay's bnd plugin converts the bnd instruction to
\texttt{Require-Capability} and \texttt{Provide-Capability} parameters
automatically. In traditional Liferay plugins, you must specify the
parameters manually.

\noindent\hrulefill

\textbf{Note:} You can always specify the \texttt{Require-Capability}
and \texttt{Provide-\ \ Capability} OSGi manifest headers manually, as
the next section demonstrates.

\noindent\hrulefill

\section{Using a Language Module from a Traditional
Plugin}\label{using-a-language-module-from-a-traditional-plugin}

To use a language module from a traditional Liferay plugin you must
specify the language module via the \texttt{Require-Capability} and
\texttt{Provide-Capability} OSGi manifest headers in the plugin's
\texttt{liferay-plugin-package.properties} file.

Follow these steps to configure your traditional plugin to use a
language module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the plugin's \texttt{liferay-plugin-package.properties} file and
  add a \texttt{Require-Capability} header that filters on the language
  module's resource bundle capability. For example, if the language
  module's symbolic name is \texttt{myapp.lang}, specify the requirement
  like this:

\begin{verbatim}
Require-Capability: liferay.resource.bundle;filter:="(bundle.symbolic.name=myapp.lang)"
\end{verbatim}
\item
  In the same \texttt{liferay-plugin-package.properties} file, add a
  \texttt{Provide-Capability} header that adds the language module's
  resource bundle as this plugin's (the \texttt{myapp.web} plugin) own
  resource bundle:

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}
\end{enumerate}

In this case, the \texttt{myapp.web} plugin solely uses the language
module's resource bundle---the resource bundle aggregate only includes
language module \texttt{myapp.lang}.

Aggregating resource bundles comes into play when you want to use a
language module's resource bundle in addition to your plugin's resource
bundle. These instructions show you how to do this, while prioritizing
your current plugin's resource bundle over the language module resource
bundle. In this way, the language module's language keys compliment your
plugin's language keys.

For example, a portlet whose bundle symbolic name is \texttt{myapp.web}
uses keys from the language module \texttt{myapp.lang} in addition to
its own. The portlet's \texttt{Provide-Capability} and
\texttt{Web-ContextPath} OSGi headers accomplish this.

\begin{verbatim}
Provide-Capability:\
liferay.resource.bundle;resource.bundle.base.name="content.Language",\
liferay.resource.bundle;resource.bundle.aggregate:String="(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)";bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language";service.ranking:Long="4";\
servlet.context.name=myapp-web
\end{verbatim}

The example \texttt{Provide-Capability} header has two parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{liferay.resource.bundle;resource.bundle.base.name="content.Language"}
  declares that the module provides a resource bundle whose base name is
  \texttt{content.language}.
\item
  The
  \texttt{liferay.resource.bundle;resource.bundle.aggregate:String=...}
  directive specifies the list of bundles whose resource bundles are
  aggregated, the target bundle, the target bundle's resource bundle
  name, and this service's ranking:

  \begin{itemize}
  \tightlist
  \item
    \texttt{"(bundle.symbolic.name=myapp.web),(bundle.symbolic.name=myapp.lang)"}:
    The service aggregates resource bundles from bundles
    \texttt{bundle.symbolic.name=myapp.web} (the current module) and
    \texttt{bundle.symbolic.name=myapp.lang}. Aggregate as many bundles
    as desired. Listed bundles are prioritized in descending order.
  \item
    \texttt{bundle.symbolic.name=myapp.web;resource.bundle.base.name="content.Language"}:
    Override the \texttt{myapp.web} bundle's resource bundle named
    \texttt{content.Language}.
  \item
    \texttt{service.ranking:Long="4"}: The resource bundle's service
    ranking is \texttt{4}. The OSGi framework applies this service if it
    outranks all other resource bundle services that target
    \texttt{myapp.web}'s \texttt{content.Language} resource bundle.
  \item
    \texttt{servlet.context.name=myapp-web}: The target resource bundle
    is in servlet context \texttt{myapp-web}.
  \end{itemize}
\end{enumerate}

Now the language keys from the aggregated resource bundles compliment
your plugin's language keys.

\section{Related Topics}\label{related-topics-94}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{Localizing
Your Application}

\href{/docs/7-2/customization/-/knowledge_base/c/overriding-language-keys}{Overriding
Language Keys}

\chapter{Automatically Generating
Translations}\label{automatically-generating-translations}

If your app uses a
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{language
module} or
\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{\texttt{Language.properties}
file} for its user interface messages, you're in the right place.
Language Builder provides these localization capabilities:

\begin{itemize}
\item
  Generating language files for each supported locale with a single
  command. It also propagates new default language file keys to all
  language files, while keeping their translated values intact.
\item
  Generating translations automatically using Microsoft's Translator
  Text API. This gives you a jump start on creating translations.
\end{itemize}

\noindent\hrulefill

\textbf{Note:} Language Builder is available as a plugin for projects
that use Gradle or Maven.

\noindent\hrulefill

Start with Configuring the Language Builder plugin.

\section{Configuring the Language Builder
Plugin}\label{configuring-the-language-builder-plugin}

Configure the Language Builder plugin for
\href{/docs/7-2/reference/-/knowledge_base/r/lang-builder-gradle-plugin}{Gradle}
or
\href{/docs/7-2/reference/-/knowledge_base/r/lang-builder-plugin}{Maven}.

\textbf{Gradle:}

\begin{verbatim}
buildscript {
    dependencies {
        classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
    }

    repositories {
        maven {
            url "https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/"
        }
    }
}

apply plugin: "com.liferay.lang.builder"

repositories {
    maven {
        url "https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/"
    }
}
\end{verbatim}

\textbf{Maven:}

\begin{verbatim}
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>com.liferay</groupId>
                <artifactId>com.liferay.lang.builder</artifactId>
                <version>1.0.30</version>
                <configuration>
                    <langDirName>.</langDirName>
                    <translateClientId>${microsoft.translator.client.id}</translateClientId>
                    <translateClientSecret>${microsoft.translator.client.secret}</translateClientSecret>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ...
</project>
\end{verbatim}

Now you can invoke Language Builder in your project.

\section{Running Language Builder}\label{running-language-builder}

When you run Language Builder, it generates properties files for all
your locales and propagates all new language properties from
\texttt{Language.properties} to your locale language files (newly
generated and existing). Additionally if you configured the Microsoft
Translator Text API (discussed next), Language Builder translates your
locale language properties.

Here's the command:

\textbf{Gradle:}

\begin{verbatim}
gradlew buildLang
\end{verbatim}

\textbf{Maven:}

\begin{verbatim}
mvn lang-builder:build
\end{verbatim}

\noindent\hrulefill

\textbf{Tip:} Run Language Builder to update your locale files each time
you change your \texttt{Language.properties} file.

\noindent\hrulefill

Note, until you configure translation credentials (discussed next),
Language Builder prints this message:

\begin{verbatim}
Translation is disabled because credentials are not specified
\end{verbatim}

If you want to configure your app to generate automatic translations
using the Microsoft Translator Text API, keep reading.

\section{Translating Language Keys
Automatically}\label{translating-language-keys-automatically}

If you've configured the Language Builder plugin (above) in your
project, you're well on your way to translating language keys
automatically. Now you have to configure
\href{https://azure.microsoft.com/en-us/services/cognitive-services/translator-text-api/}{Microsoft's
Translator Text API} so you can translate language keys automatically.

\noindent\hrulefill

\textbf{Important:} Lang Builder does not translate language keys
containing HTML (e.g., \texttt{\textless{}em\textgreater{}},
\texttt{\textless{}b\textgreater{}},
\texttt{\textless{}code\textgreater{}}, etc.). Default language keys
that contain HTML are only \emph{copied} to your locale language files.

\noindent\hrulefill

\noindent\hrulefill

\textbf{Note:} These translations are best used as a starting point. A
machine translation can't match the accuracy of a real person who is
fluent in the language. Then again, if you only speak English and you
need a Hungarian translation, this is better and faster than your
attempts at a manual translation.

\noindent\hrulefill

Here's how to set up the translator and generate translations.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Generate a translation subscription key for the Microsoft Translator
  Text API. Follow the instructions
  \href{https://www.microsoft.com/en-us/translator/business/}{here}.
\item
  Add your client credentials to the Language Builder plugin
  configuration. For security reasons, pass the credentials to a
  property that's stored in your local build environment (e.g., see the
  \href{https://docs.gradle.org/current/userguide/build_environment.html}{Gradle
  environment guide}).

  \textbf{Gradle:}

  Make sure the \texttt{buildLang} task knows to use your subscription
  key for translation by setting the \texttt{translateSubscriptionKey}
  property:

\begin{verbatim}
buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}
\end{verbatim}

  Here's the entire \texttt{build.gradle} example code,

\begin{verbatim}
buildscript {
    dependencies {
        classpath 'com.liferay:com.liferay.gradle.plugins.lang.builder:latest.release'
    }

    repositories {
        maven {
            url "https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/"
        }
    }
}

apply plugin: "com.liferay.lang.builder"

buildLang {
   translateSubscriptionKey = langTranslateSubscriptionKey
}

repositories {
    maven {
        url "https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/"
    }
}
\end{verbatim}

  \textbf{Maven:}

  Set the following Language Builder plugin
  \texttt{\textless{}translateClientId\ /\textgreater{}} and
  \texttt{\textless{}translateClientSecret\ /\textgreater{}}
  configuration elements using Maven build environment properties:

\begin{verbatim}
<configuration>
    <langDirName>.</langDirName>
    <translateClientId>${microsoft.translator.client.id}</translateClientId>
    <translateClientSecret>${microsoft.translator.client.secret}</translateClientSecret>
</configuration>
...
\end{verbatim}

  Here's the entire \texttt{pom.xml} example code,

\begin{verbatim}
<project>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>com.liferay</groupId>
                <artifactId>com.liferay.lang.builder</artifactId>
                <version>1.0.30</version>
                <configuration>
                    <langDirName>.</langDirName>
                    <translateClientId>${microsoft.translator.client.id}</translateClientId>
                    <translateClientSecret>${microsoft.translator.client.secret}</translateClientSecret>
                </configuration>
            </plugin>
        </plugins>
    </build>
    ...
</project>
\end{verbatim}
\item
  Run Language Builder.

  \textbf{Gradle:}

\begin{verbatim}
gradlew buildLang
\end{verbatim}

  \textbf{Maven:}

\begin{verbatim}
mvn lang-builder:build
\end{verbatim}
\end{enumerate}

Great! You can now generate language files and provide automatic
translations of your language keys.

\section{Related Topics}\label{related-topics-95}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{Localizing
Your Application}

\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-language-module}{Using
Language Modules}

\href{/docs/7-2/reference/-/knowledge_base/r/lang-builder-gradle-plugin}{Gradle
Language Builder Plugin}

\href{/docs/7-2/reference/-/knowledge_base/r/lang-builder-plugin}{Maven
Language Builder Plugin}

\href{/docs/7-2/reference/-/knowledge_base/r/liferay-workspace}{Liferay
Workspace}

\href{/docs/7-2/reference/-/knowledge_base/r/tooling}{Tooling}

\chapter{Portlets}\label{portlets}

{ This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

Liferay DXP started off as a portal server, designed to serve Java-based
web applications called \emph{portlets} (see
\href{https://jcp.org/en/jsr/detail?id=168}{JSR 168},
\href{https://jcp.org/en/jsr/detail?id=286}{JSR-286}, and
\href{https://jcp.org/en/jsr/detail?id=362}{JSR-362}). Portlets process
requests and generate responses like any other web application. One key
difference, however, between portlets and other web apps is that
portlets run in a portion of the web page. When you're writing a portlet
application, you need only worry about that application: the rest of the
page---the navigation, the top banner, and any other global components
of the interface---is handled by other components. Portlets run only in
a portal server. They use the portal's existing support for user
management, authentication, permissions, page management, and more. This
frees you to focus on developing the portlet's core functionality. In
many ways, writing your application as a portlet is easier than writing
a standalone application.

Many portlets can be placed on a single page by users (if they have
permission) or portal administrators. For example, a page in a community
site could have a calendar portlet for community events, an
announcements portlet for important announcements, and a bookmarks
portlet for links of interest to the community. You can drag and drop to
reposition and resize portlets on a page without altering any portlet
code. Alternatively, a single portlet can take up an entire page if it's
the only app you need on that page. For example, message boards or Wikis
with complex user interfaces are best suited on their own pages. In
short, portlets alleviate many of the traditional pain points associated
with developing Java-based web apps.

\begin{figure}
\centering
\includegraphics{./images/portlet-applications.png}
\caption{You can place multiple portlets on a single page.}
\end{figure}

Portlets handle requests in multiple phases. This makes portlets much
more flexible than servlets. Each portlet phase executes different
operations:

\begin{itemize}
\tightlist
\item
  \textbf{Render:} Generates the portlet's content based on its current
  state. When this phase runs on one portlet, it also runs on all other
  portlets on the page. The Render phase runs when any portlets on the
  page complete the Action or Event phases.
\item
  \textbf{Action:} In response to a user action, the Action phase
  performs operations that change the portlet's state. The Action phase
  can also trigger events that are processed by the Event phase.
  Following the Action phase and optional Event phase, the Render phase
  then regenerates the portlet's contents.
\item
  \textbf{Event:} Processes events triggered in the Action phase. Events
  are used for inter-portlet communication (IPC). Once the portlet
  processes all events, the portal calls the Render phase on all
  portlets on the page.
\item
  \textbf{Resource-serving:} Serves a resource independently from the
  rest of the lifecycle. This lets a portlet serve dynamic content
  without running the Render phase on all portlets on a page. The
  Resource-serving phase handles AJAX requests.
\item
  \textbf{Header:} Lets you specify resource dependencies, such as CSS,
  prior to the Render phase.
\end{itemize}

Compared to servlets, portlets also have some other key differences.
Since portlets only render a portion of a page, tags like
\texttt{\textless{}html\textgreater{}},
\texttt{\textless{}head\textgreater{}}, and
\texttt{\textless{}body\textgreater{}} aren't allowed. And because you
don't know the portlet's page ahead of time, you can't create portlet
URLs directly. Instead, the portlet API gives you methods to create
portlet URLs programmatically. Also, because portlets don't have direct
access to the \texttt{javax.servlet.ServletRequest}, they can't read
query parameters directly from a URL. Portlets instead access a
\texttt{javax.portlet.PortletRequest} object. The portlet specification
provides a mechanism for a portlet to read only its own URL parameters
or those declared as public render parameters. Liferay DXP does,
however, provide utility methods that can access the
\texttt{ServletRequest} and query parameters. Portlets also have a
\emph{portlet filter} available for each phase in the portlet lifecycle.
Portlet filters are similar to servlet filters in that they allow
request and response modification on the fly.

Portlets also differ from servlets by having distinct modes and window
states. Modes distinguish the portlet's current function:

\begin{itemize}
\tightlist
\item
  \textbf{View mode:} The portlet's standard mode. Use this mode to
  access the portlet's main functionality.
\item
  \textbf{Edit mode:} The portlet's configuration mode. Use this mode to
  configure a custom view or behavior. For example, the Edit mode of a
  weather portlet might let you choose a location to retrieve weather
  data from.
\item
  \textbf{Help mode:} A mode that displays the portlet's help
  information.
\end{itemize}

Most modern applications use View Mode only.

Portlet window states control the amount of space a portlet takes on a
page. Window states mimic window behavior in a traditional desktop
environment:

\begin{itemize}
\tightlist
\item
  \textbf{Normal:} The portlet can be on a page that contains other
  portlets. This is the default window state.
\item
  \textbf{Maximized:} The portlet takes up an entire page.
\item
  \textbf{Minimized:} Only the portlet's title bar shows.
\end{itemize}

All of the
\href{/docs/7-2/appdev/-/knowledge_base/a/web-front-ends}{ways to
develop web front-ends} on Liferay DXP involve portlets. The
JavaScript-based widgets use Liferay's JS Portlet Extender behind the
scenes and the Java-based web front-ends are explicitly portlets. All of
the web front-end types vary in their support of Portlet 3.0,
\href{/docs/7-2/frameworks/-/knowledge_base/f/dependency-injection}{dependency
injection (DI)}, Model View Controller (MVC), and modularity, giving you
plenty of good options for developing portlets.

\section{Related Topics}\label{related-topics-96}

\href{/docs/7-2/appdev/-/knowledge_base/a/portletmvc4spring}{Spring
Portlet MVC: PortletMVC4Spring}

\href{/docs/7-2/appdev/-/knowledge_base/a/liferay-mvc-portlet}{Liferay
MVC Portlet}

\href{/docs/7-2/appdev/-/knowledge_base/a/jsf-portlet}{JSF Portlet}

\href{/docs/7-2/reference/-/knowledge_base/r/portlet-3-0-api-opt-in}{Portlet
3.0 API Opt In}

\chapter{Using JavaScript in Your
Portlets}\label{using-javascript-in-your-portlets}

Would you like to use the latest ECMAScript features in your JavaScript
files and portlets? Do you wish you could use npm and npm packages in
your portlets?

To use the ES2015+ syntax in a JavaScript file, add the extension
\texttt{.es} to its name. For example, you rename file
\texttt{filename.js} to \texttt{filename.es.js}. The extension indicates
it uses ES2015+ syntax and must therefore be transpiled by
\href{https://babeljs.io/}{Babel} before deployment.

ES2015+ advanced features, such as
\href{https://babeljs.io/docs/learn-es2015/\#generators}{generators},
are available to you if you import the \texttt{polyfillBabel} class from
the \texttt{polyfill-babel} module:

\begin{verbatim}
import polyfillBabel from 'polyfill-babel'
\end{verbatim}

The \href{http://babeljs.io/docs/usage/polyfill/}{Babel Polyfill}
emulates a complete ES6 environment. Use it at your own discretion, as
it loads a large amount of code. You can inspect
\url{https://github.com/zloirock/core-js\#core-js} to see what's
polyfilled.

Once you've completed writing your module, you can expose it by creating
a \texttt{package.json} file that specifies your bundle's name and
version. Make sure to create this in your module's root folder. Below is
an example \texttt{package.json} file for a \texttt{js-logger} module:

\begin{verbatim}
{
    "name": "js-logger",
    "version": "1.0.0"
}
\end{verbatim}

The Module Config Generator creates the module based on this
information. In this section, you'll learn how to prepare your
JavaScript files to leverage ECMAScript and npm features in your
portlets.

\chapter{Using ES2015 Modules in your
Portlet}\label{using-es2015-modules-in-your-portlet}

Once you've
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-javascript-in-your-portlets}{exposed
your modules} via your \texttt{package.json} file, you can use them in
your portlets. The \texttt{aui:script} tag's \texttt{require} attribute
makes it easy.

Follow the steps below to use your exposed modules in your portlets:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Declare the \texttt{aui} taglib in your view JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/aui" prefix="aui" %>
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** if you created the portlet using Blade, the `aui` taglib is 
 already provided for you in the `init.jsp`. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Add an \texttt{aui:script} tag to the JSP and set the \texttt{require}
  attribute to the relative path for your module.

  The \texttt{require} attribute lets you include your exposed modules
  in your JSP. The AMD Loader fetches the specified module and its
  dependencies. An example faux Console Logger Portlet's
  \texttt{view.jsp} shown below includes the module \texttt{logger.es}:

\begin{verbatim}
<aui:script require="js-logger/logger.es">
    var Logger = jsLoggerLoggerEs.default;

    var loggerOne = new Logger('*** -> ');
    loggerOne.log('Hello');

    var loggerDefault = new Logger();
    loggerDefault.log('World');
</aui:script>
\end{verbatim}

  References to the module within the script tag are named after the
  \texttt{require} value, in camel-case and with all invalid characters
  removed. The \texttt{logger.es} module's reference
  \texttt{jsLoggerLoggerEs} is derived from the module's relative path
  value \texttt{js-logger/logger.es}. The value is stripped of its dash
  and slash characters and converted to camel case.
\end{enumerate}

Thanks to the \texttt{aui:script} tag and its \texttt{require}
attribute, using your modules in your portlet is a piece of cake!

\section{Related Topics}\label{related-topics-97}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/customizing-jsps}{Customizing
  JSPs}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{Web
  Services}
\end{itemize}

\chapter{Using npm in Your Portlets}\label{using-npm-in-your-portlets}

npm is a powerful tool, and almost a necessity for Front-End
development. You can use npm as your JavaScript package manager
tool---including npm and npm packages---while developing portlets in
your normal, everyday workflow.

Deployed portlets leverage
\href{/docs/7-2/frameworks/-/knowledge_base/f/loading-amd-modules-in-liferay}{Liferay
AMD Loader} to share JavaScript modules and take advantage of semantic
versioning when resolving modules among portlets on the same page. The
liferay-npm-bundler helps prepare your npm modules for the Liferay AMD
Loader.

The bundler copies the project and \texttt{node\_modules}' JS files to
the output and wraps them inside a \texttt{Liferay.Loader.define()} call
so that the Liferay AMD Loader knows how to handle them. It also
namespaces the module names in \texttt{require()} calls and inside the
\texttt{Liferay.Loader.define()} call with the project's name prefix to
achieve
\href{/docs/7-2/reference/-/knowledge_base/r/how-the-liferay-npm-bundler-publishes-npm-packages\#isolated-package-dependencies}{dependency
isolation}. The bundler injects the dependencies in the
\texttt{package.json} pertaining to the module to make them available at
runtime.

This section covers how to set up npm-based portlet projects.

\chapter{Formatting Your npm Modules for
AMD}\label{formatting-your-npm-modules-for-amd}

For Liferay DXP to recognize your npm modules, they must be formatted
for the Liferay AMD Loader. Luckily, the liferay-npm-bundler handles
this for you, you just have to provide the proper configuration and add
it to your build script. This article shows how to use the
liferay-npm-bundler to set up npm-based portlet projects.

Follow these steps to configure your project to use the
liferay-npm-bundler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install NodeJS \textgreater=
  \href{http://nodejs.org/dist/v6.11.0/}{v6.11.0} if you don't have it
  installed.
\item
  Navigate to your portlet's project folder and initialize a
  \texttt{package.json} file if it's not present yet.

  If you don't have a portlet already, create an empty MVC portlet
  project. For convenience, you can use
  \href{/docs/7-2/reference/-/knowledge_base/r/installing-blade-cli}{Blade
  CLI} to create an empty portlet with the
  \href{/docs/7-2/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{mvc
  portlet blade template}.

  If you don't have a \texttt{package.json} file, you can run
  \texttt{npm\ init\ -y} to create an empty one based on the project
  directory's name.
\item
  Run this command to install the liferay-npm-bundler:

\begin{verbatim}
npm install --save-dev liferay-npm-bundler
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** Use npm from within your portlet project's root folder (where the
 `package.json` file lives), as you normally do on a typical web project.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Add the \texttt{liferay-npm-bundler} to your \texttt{package.json}'s
  build script to pack the needed npm packages and transform them to
  AMD:

\begin{verbatim}
"scripts": {
      "build": "liferay-npm-bundler"
}
\end{verbatim}
\item
  Configure your project for the bundler, using the
  \texttt{.npmbundlerrc} file (create this file in your project's root
  folder if it doesn't exist). See the
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-the-npmbundlerrcs-structure}{liferay-npm-bundler's
  \texttt{.npmbundlerrc} structure reference} for more information on
  the available options. Specify the
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{loaders
  and rules} to use for your project's source files. The example below
  processes the JavaScript files in the project's \texttt{/src/} and
  \texttt{/assets/} folders with Babel via the
  \href{https://github.com/liferay/liferay-js-toolkit/tree/master/packages/liferay-npm-bundler-loader-babel-loader}{\texttt{babel-loader}}:

\begin{verbatim}
{
  "sources": ["src", "assets"],
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env"]
          }
        }
      ]
    }
  ]
}
\end{verbatim}
\item
  Run \texttt{npm\ install} to install the required dependencies.
\item
  Run the build script to bundle your dependencies with the
  liferay-npm-bundler:

\begin{verbatim}
npm run-script build
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} By default, the AMD Loader times out in seven seconds.
You can configure this value through System Settings. Open the Control
Panel and navigate to \emph{Configuration} → \emph{System Settings} →
\emph{PLATFORM} → \emph{Infrastructure}, and select \emph{JavaScript
Loader}. Set the \emph{Module Definition Timeout} configuration to the
time you want and click \emph{Save}.

\noindent\hrulefill

Great! Now you know how to use the liferay-npm-bundler to bundle your
npm-based portlets for the Liferay AMD Loader.

\section{Related Topics}\label{related-topics-98}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-javascript-in-your-portlets}{Preparing
  Your JavaScript Files for ES2015+}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's Loaders and Rules}
\end{itemize}

\chapter{Migrating a liferay-npm-bundler Project from 1.x to
2.x}\label{migrating-a-liferay-npm-bundler-project-from-1.x-to-2.x}

You should use the latest 2.x version of the liferay-npm-bundler. It
\href{/docs/7-2/reference/-/knowledge_base/r/what-changed-between-liferay-npm-bundler-1-x-and-2-x}{offers
more stability and includes more features out-of-the-box}. If you
already created a project using the 1.x version, don't worry. Follow
these steps to migrate your project to 2.x:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Update the \texttt{liferay-npm-bundler} dependency in your
  \texttt{package.json} to version 2.x:

\begin{verbatim}
{
  "devDependencies": {
    ...
    "liferay-npm-bundler": "^2.0.0",
    ...
  },
  ...
}
\end{verbatim}
\item
  Remove all \texttt{liferay-npm-bundler-preset-*} dependencies from
  your \texttt{package.json} because liferay-npm-bundler 2.x includes
  these by default.
\item
  Remove any bundler presets you configured in your
  \texttt{.npmbundlerrc} file. liferay-npm-bundler 2.x includes one
  smart preset that handles all frameworks automatically.
\end{enumerate}

These are the standard requirements that all projects have in common.
The remaining steps depend on your project's framework. Follow the
instructions in the corresponding section to finish migrating your
project.

\chapter{Migrating a Plain JavaScript, Billboard JS, JQuery, Metal JS,
React, or Vue JS Project to Use Bundler
2.x}\label{migrating-a-plain-javascript-billboard-js-jquery-metal-js-react-or-vue-js-project-to-use-bundler-2.x}

After following the steps covered in the intro to this section, follow
these remaining steps to migrate the framework projects shown below to
2.x:

\begin{itemize}
\tightlist
\item
  plain JS project
\item
  Billboard.js project
\item
  JQuery project
\item
  Metal.js project
\item
  React project
\item
  Vue.js project
\end{itemize}

While Babel is required to transpile your source files, you must remove
any Babel preset used for transformations from your project that bundler
1.x imposed. liferay-npm-bundler 2.x handles these transformations by
default:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Remove the \emph{liferay-project} preset from your project's
  \texttt{.babelrc} file. All that should remain is the \texttt{es2015}
  preset shown below:

\begin{verbatim}
{
  "presets": ["es2015"]
}
\end{verbatim}

  If your project uses React, make sure the \texttt{react} preset
  remains as well:

\begin{verbatim}
{
  "presets": ["es2015", "react"]
}
\end{verbatim}
\item
  Remove the \texttt{babel-preset-liferay-project} dependency from your
  \texttt{package.json}.
\end{enumerate}

Awesome! Your project is migrated to use the new version of the
liferay-npm-bundler.

\section{Related Topics}\label{related-topics-99}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/formatting-your-npm-modules-for-amd}{Formatting
  Your npm Modules for AMD}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-npmresolver-api-in-your-portlets}{Using
  the NPMResolver API in Your Portlets}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/what-changed-between-liferay-npm-bundler-1-x-and-2-x}{What
  Changed between liferay-npm-bundler 1.x and 2.x}
\end{itemize}

\chapter{Migrating an Angular Project to Use Bundler
2.x}\label{migrating-an-angular-project-to-use-bundler-2.x}

After following the steps covered in the intro to this section, follow
these remaining steps to migrate your Angular project to 2.x. While
liferay-npm-bundler 1.x relied on Babel to perform some transformation
steps, these transformations are now automatically applied in version
2.x. Therefore, you should remove Babel from your project:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your \texttt{tsconfig.json} file and replace the
  \texttt{"module":\ "amd"} compiler option with the configuration shown
  below to produce CommonJS modules:

\begin{verbatim}
{
  "compilerOptions": {
    ...
    "module": "commonjs",
    ...
  }
}
\end{verbatim}
\item
  Delete the \texttt{.babelrc} file to remove the Babel configuration.
\item
  Remove Babel from your \texttt{package.json} build process so it
  matches the configuration below:

\begin{verbatim}
{
  "scripts": {
    "build": "tsc && liferay-npm-bundler"
  },
  ...
}
\end{verbatim}
\item
  Remove the following Babel dependencies from your
  \texttt{package.json} \emph{devDependencies}:

\begin{verbatim}
"babel-cli": "6.26.0",
"babel-preset-liferay-amd": "1.2.2"
\end{verbatim}
\end{enumerate}

Great! Your project is migrated to use the new version of the
liferay-npm-bundler.

\section{Related Topics}\label{related-topics-100}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/formatting-your-npm-modules-for-amd}{Formatting
  Your npm Modules for AMD}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-the-npmresolver-api-in-your-portlets}{Using
  the NPMResolver API in Your Portlets}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/what-changed-between-liferay-npm-bundler-1-x-and-2-x}{What
  Changed between liferay-npm-bundler 1.x and 2.x}
\end{itemize}

\chapter{Migrating Your Project to Use liferay-npm-bundler's New
Mode}\label{migrating-your-project-to-use-liferay-npm-bundlers-new-mode}

In the previous version of the liferay-npm-bundler, before the bundler
ran, the build did some preprocessing, then the bundler modified the
output from the preprocessed files, as shown in the example build script
below:

\begin{verbatim}
{
  "scripts":{
    "build": "babel --source-maps -d build src && liferay-npm-bundler"
  }
}
\end{verbatim}

In the new mode, the liferay-npm-bundler runs the whole process, like
webpack, and is configured via a set of rules. The build script is
condensed, as shown below:

\begin{verbatim}
{
  "scripts":{
    "build": "liferay-npm-bundler"
  }
}
\end{verbatim}

Follow these steps to migrate your project to use the new configuration
mode:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the project's \texttt{package.json} file and update the
  \texttt{build} script to use only the liferay-npm-bundler:

\begin{verbatim}
{
  "scripts":{
    "build": "liferay-npm-bundler"
  }
}
\end{verbatim}
\item
  Define the rules for the bundler to use (e.g.~running babel to
  transpile files) in the project's \texttt{.npmbundlerrc} file. The
  example configuration below defines rules for using the
  \texttt{babel-loader} to transpile JavaScript files. See the
  \href{/docs/7-2/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  Loaders reference} for the full list of default loaders. Follow the
  steps in
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-custom-loaders-for-the-liferay-npm-bundler}{Creating
  Custom Loaders for the Bundler} to create a custom loader. The
  liferay-npm-bundler processes the \texttt{*.js} files in
  \texttt{/src/} with babel and writes the results in the default
  \texttt{/build/} folder:

\begin{verbatim}
{
  "sources": ["src"],
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env"]
          }
        }
      ]
    }
  ]
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
**Note:** The new mode of the liferay-npm-bundler acts very much 
 like webpack, but because webpack creates a single JS bundle file and 
 liferay-npm-bundler targets AMD loader, they are not compatible.
\end{verbatim}

\noindent\hrulefill

\section{Related Topics}\label{related-topics-101}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  liferay-npm-bundler Loaders}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's Loaders}
\end{itemize}

\chapter{Creating Custom Loaders for the
liferay-npm-bundler}\label{creating-custom-loaders-for-the-liferay-npm-bundler}

Since webpack creates JavaScript bundles and the liferay-npm-bundler
targets AMD loader, webpack's loaders aren't compatible with the
liferay-npm-bundler. So, if you want to use a loader that isn't
\href{/docs/7-2/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{available
by default}, you must create a custom loader.

A loader, in terms of the liferay-npm-bundler, is defined as an npm
package that has a main module which exports a default function with
this signature:

\begin{verbatim}
function(context, options){
}
\end{verbatim}

The arguments are defined as follows:

\texttt{context}: an object containing these fields:

\begin{quote}
\texttt{content}: a string with the contents of the processed file (the
main input of the loader)
\end{quote}

\begin{quote}
\texttt{filepath}: the project-relative path to the file to process with
the loader
\end{quote}

\begin{quote}
\texttt{extraArtifacts}: an object with project-relative paths as keys
and strings as values of properties that may be used to output extra
files along with the one being processed (for example, you can use it to
generate source maps).
\end{quote}

\begin{quote}
\texttt{log}: a logger that writes execution information to the
bundler's report file (see the
\href{https://github.com/liferay/liferay-js-toolkit/blob/master/packages/liferay-npm-build-tools-common/src/plugin-logger.js}{\texttt{PluginLogger}
class} for information on its structure and API).
\end{quote}

\texttt{options}: an object taken from the \texttt{options} field of the
loader's configuration (See
\href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
liferay-npm-bundler's loaders and rules} for more information).

\noindent\hrulefill

\textbf{Note:} the function may return nothing or modified content. If
something is returned, it is copied on top of the
\texttt{context.content} field and used to feed the next loader or write
the output file. This is the equivalent to
\texttt{context.content\ =\ \textquotesingle{}something\textquotesingle{}}.
If your loader does not return a file, but instead it only filters files
to prevent them from being generated, you must explicitly set
\texttt{context.content\ =\ \textquotesingle{}undefined\textquotesingle{}}.

\noindent\hrulefill

Follow these steps to write a new loader. These steps use the Babel
loader as an example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If your loader requires configuration, like Babel, you may define a
  rule configuration like the one shown below so you can specify options
  for the loader:

\begin{verbatim}
{
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env", "react"]
          }
        }
      ]
    }
  ]
}
\end{verbatim}
\item
  Create an \texttt{index.js} file and write a function that takes the
  input content, passes it through the loader, and writes the result and
  the source map file to the output folder. The loader function below
  takes the passed content (JS files), run it through babel, and writes
  the result and source map to the default \texttt{/build/} output
  folder:

\begin{verbatim}
export default function(context, options) {
  // Get input parameters
  const { content, filePath, log, sourceMap } = context;

  // Run babel on content
  const result = babel.transform(content, options);

  // Create an extra .map file with source map next to source .js file
  context.extraArtifacts[`${filePath}.map`] = JSON.stringify(result.map);

  // Tell the user what we have done
  log.info("babel-loader", "Transpiled file");

  // Return the modified content
  return result.code;
}
\end{verbatim}
\item
  Place the \texttt{index.js} file in an npm package and publish it.
\item
  Include the npm package you just created as a \texttt{devDependency}
  in the project's \texttt{package.json}:

\begin{verbatim}
"devDependencies": {
  "liferay-npm-bundler": "2.12.0",
  "liferay-npm-build-support": "2.12.0",
  "liferay-npm-bundler-loader-babel-loader": "2.12.0",
  ...
}
\end{verbatim}
\item
  Configure the loader's name in the \texttt{rules} section of the
  project's \texttt{.npmbundlerrc} file:

\begin{verbatim}
{
  "sources": ["src"],
  ...
  "rules": [
    {
      "test": "\\.js$",
      "exclude": "node_modules",
      "use": [
        {
          "loader": "babel-loader",
          "options": {
            "presets": ["env", "react"]
          }
        }
      ]
    }
  ],
  ...
}
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-102}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/default-liferay-npm-bundler-loaders}{Default
  liferay-npm-bundler Loaders}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/understanding-liferay-npm-bundlers-loaders}{Understanding
  liferay-npm-bundler's Loaders}
\end{itemize}

\chapter{Using the NPMResolver API in Your
Portlets}\label{using-the-npmresolver-api-in-your-portlets}

If you're developing an npm-based portlet, your OSGi bundle's
\texttt{package.json} is a treasure-trove of information. It contains
everything that's stored in the npm registry about your bundle: default
entry point, dependencies, modules, package names, versions, and more.
The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
APIs} expose this information so you can access it in your portlet. If
it's defined in the OSGi bundle's \texttt{package.json}, you can
retrieve the information in your portlet with the \texttt{NPMResolver}
API. For instance, you can use this API to
\href{/docs/7-2/frameworks/-/knowledge_base/f/obtaining-dependency-npm-package-descriptors}{reference
an npm package's static resources} (such as CSS files) and even to
\href{/docs/7-2/frameworks/-/knowledge_base/f/referencing-an-npm-modules-package}{make
your code more maintainable}.

To enable the \texttt{NPMResolver} in your portlet, use the
\texttt{@Reference} annotation to inject the \texttt{NPMResolver} OSGi
component into your portlet's Component class, as shown below:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;

public class MyPortlet extends MVCPortlet {
  
  @Reference
  private NPMResolver `_npmResolver`;
  
}
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} Because the \texttt{NPMResolver} reference is tied
directly to the OSGi bundle's \texttt{package.json} file, it can only be
used to retrieve npm module and package information from that file. You
can't use the \texttt{NPMResolver} to retrieve npm package information
for other OSGi bundles.

\noindent\hrulefill

Now that the \texttt{NPMResolver} is added to your portlet, read the
topics in this section to learn how to retrieve your OSGi bundle's npm
package and module information.

\chapter{Referencing an npm Module's Package to Improve Code
Maintenance}\label{referencing-an-npm-modules-package-to-improve-code-maintenance}

Once you've
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-javascript-in-your-portlets}{exposed
your modules}, you can use them in your portlet via the
\texttt{aui:script} tag's \texttt{require} attribute. By default,
Liferay DXP automatically composes an npm module's JavaScript variable
based on its name. For example, the module \texttt{my-package@1.0.0}
translates to the variable \texttt{myPackage100} for the
\texttt{\textless{}aui:script\textgreater{}} tag's \texttt{require}
attribute. This means that each time a new version of the OSGi bundle's
npm package is released, you must update your code's variable to reflect
the new version. You can use the
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html}{\texttt{JSPackage}
interface} to obtain the module's package name and create an alias to
reference it, so the variable name always reflects the latest version
number!

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Retrieve a reference to the OSGi bundle's npm package using the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getJSPackage}{\texttt{getJSPackage()}
  method}:

\begin{verbatim}
JSPackage jsPackage = _npmResolver.getJSPackage();
\end{verbatim}
\item
  Grab the npm package's resolved ID (the current package version, in
  the format
  \texttt{\textless{}package\ name\textgreater{}@\textless{}version\textgreater{}},
  defined in the OSGi module's \texttt{package.json}) using the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/JSPackage.html\#getResolvedId}{\texttt{getResolvedId()}
  method} and alias it with the \texttt{as\ myVariableName} pattern. The
  example below retrieves the npm module's resolved ID, sets it to the
  \texttt{bootstrapRequire} variable, and assigns the entire value to
  the attribute \texttt{bootstrapRequire}. This ensures that the package
  version is always up to date:

\begin{verbatim}
renderRequest.setAttribute(
  "bootstrapRequire",
  jsPackage.getResolvedId() + " as bootstrapRequire");
\end{verbatim}
\item
  Include the reference to the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}}:

\begin{verbatim}
@Reference
private NPMResolver _npmResolver;
\end{verbatim}
\item
  Resolve the \texttt{JSPackage} and \texttt{NPMResolver} imports:

\begin{verbatim}
import com.liferay.frontend.js.loader.modules.extender.npm.JSPackage;
import com.liferay.frontend.js.loader.modules.extender.npm.NPMResolver;
\end{verbatim}
\item
  In the portlet's JSP, retrieve the aliased attribute
  (\texttt{bootstrapRequire} in the example):

\begin{verbatim}
<%
String bootstrapRequire =
    (String)renderRequest.getAttribute("bootstrapRequire");
%>
\end{verbatim}
\item
  Finally, use the attribute as the
  \texttt{\textless{}aui:script\textgreater{}} require attribute's
  value:

\begin{verbatim}
<aui:script require="<%= bootstrapRequire %>">
    bootstrapRequire.default();
</aui:script>
\end{verbatim}

  Below is the full example \texttt{*Portlet} class:

\begin{verbatim}
public class MyPortlet extends MVCPortlet {

    @Override
    public void doView(
            RenderRequest renderRequest, RenderResponse renderResponse)
        throws IOException, PortletException {

        JSPackage jsPackage = _npmResolver.getJSPackage();

        renderRequest.setAttribute(
            "bootstrapRequire",
            jsPackage.getResolvedId() + " as bootstrapRequire");

        super.doView(renderRequest, renderResponse);
    }

    @Reference
    private NPMResolver _npmResolver;

}
\end{verbatim}

  And here is the corresponding example \texttt{view.jsp}:

\begin{verbatim}
<%
String bootstrapRequire =
  (String)renderRequest.getAttribute("bootstrapRequire");
%>

<aui:script require="<%= bootstrapRequire %>">
  bootstrapRequire.default();
</aui:script>
\end{verbatim}
\end{enumerate}

Now you know how to reference an npm module's package!

\section{Related Topics}\label{related-topics-103}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/obtaining-dependency-npm-package-descriptors}{Obtaining
  an OSGi bundle's Dependency npm Package Descriptors}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/liferay-npm-bundler}{liferay-npm-bundler}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/how-the-liferay-npm-bundler-publishes-npm-packages}{How
  Liferay DXP Publishes npm Packages}
\end{itemize}

\chapter{Obtaining an OSGi bundle's Dependency npm Package
Descriptors}\label{obtaining-an-osgi-bundles-dependency-npm-package-descriptors}

While writing your npm portlet, you may need to reference a dependency
package or its modules. For instance, you can retrieve an npm dependency
package module's CSS file and use it in your portlet. The
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html}{\texttt{NPMResolver}
OSGi component} provides two methods for retrieving an OSGi bundle's
dependency npm package descriptors:
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#getDependencyJSPackage}{\texttt{getDependencyJSPackage()}}
to retrieve dependency npm packages and
\href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/frontend/js/loader/modules/extender/npm/NPMResolver.html\#resolveModuleName}{\texttt{resolveModuleName()}}
to retrieve dependency npm modules. This article references the
\texttt{package.json} below to help demonstrate these methods:

\begin{verbatim}
{
    "dependencies": {
        "react": "15.6.2",
        "react-dom": "15.6.2"
    },
    .
    .
    .
}
\end{verbatim}

To obtain an OSGi bundle's npm dependency package, pass the package's
name in as the \texttt{getDependencyJSPackage()} method's argument. The
example below resolves the \texttt{react} dependency package:

\begin{verbatim}
String reactResolvedId = npmResolver.getDependencyJSPackage("react");
\end{verbatim}

\texttt{reactResolvedId}'s resulting value is \texttt{react@15.6.2}.

You can use the \texttt{resolveModuleName()} method To obtain a module
in an npm dependency package. To do this, pass the module's relative
path in as the \texttt{resolveModuleName()} method's argument. The
example below resolves a module named \texttt{react-with-addons} for the
\texttt{react} dependency package:

\begin{verbatim}
String resolvedModule = 
npmResolver.resolveModuleName("react/dist/react-with-addons");
\end{verbatim}

The \texttt{resolvedModule} variable evaluates to
\texttt{react@15.6.2/dist/react-with-addons}. You can also use this to
reference static resources inside npm packages (like CSS or image
files), as shown in the example below:

\begin{verbatim}
String cssPath = npmResolver.resolveModuleName(
      "react/lib/css/main.css"); 
\end{verbatim}

Now you know how to obtain an OSGi bundle's dependency npm packages
descriptors!

\section{Related Topics}\label{related-topics-104}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/referencing-an-npm-modules-package}{Referencing
  an npm Module's Package}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/the-structure-of-osgi-bundles-containing-npm-packages}{The
  Structure of OSGi Bundles Containing npm Packages}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/how-the-liferay-npm-bundler-publishes-npm-packages}{How
  Liferay DXP Publishes npm Packages}
\end{itemize}

\chapter{Automatic Single Page
Applications}\label{automatic-single-page-applications}

A good user experience is the measure of a well-designed site. A user's
time is highly valuable. The last thing you want is for someone to grow
frustrated with your site because of constant page reloads. A Single
Page Application (SPA) avoids this issue. Single Page Applications
drastically cut down on load times by loading only a single HTML page
that's dynamically updated as the user interacts and navigates through
the site. This provides a more seamless app experience by eliminating
page reloads. \textbf{SPA is enabled by default in your apps and sites
and requires no changes to your workflow or code!} If Spa is disabled,
ensure that the \texttt{com.liferay.frontend.js.spa.web-{[}version{]}}
module is deployed and active.

\section{The Benefits of SPAs}\label{the-benefits-of-spas}

Let's say you're surfing the web and you find a really rad site that
happens to be SPA enabled. All right! Page load times are blazin' fast.
You're deep into the site, scrolling along, when you find this great
post that just speaks to you. You copy the URL from the address bar and
email it to all of your friends with the subject: `Your Life Will Change
Forever.' They must experience this awe-inspiring work!

You get a response back almost immediately. ``This is a rad site, but
what post are you talking about?'' it reads.

``What!? Do my eyes deceive me?'' you exclaim. You were in so much of a
hurry to share this life-changing content that you neglected to notice
that the URL never updated when you clicked the post. You click the back
button, hoping to get back to the post, but it takes you to the site you
were on before you ever visited this one. The page history didn't update
as you navigated through the app; Only the main app URL was saved.

What a bummer! ``Why? Why have you failed me, site?'' you cry.

If only there was a way to have a Single Page Application, but also be
able to link to the content you want. Well, don't despair my friend. You
can have your cake and eat it too, thanks to SennaJS.

\section{What is SennaJS?}\label{what-is-sennajs}

SennaJS is Liferay DXP's SPA engine. SennaJS handles the client-side
data, and AJAX loads the page's content dynamically. While there are
other JavaScript frameworks out there that may provide some of the same
features, Senna's only focus is SPA, ensuring that your site provides
the best user experience possible.

SennaJS provides the following key enhancements to SPA:

\textbf{SEO \& Bookmarkability}: Sharing or bookmarking a link displays
the same content you are viewing. Search engines are able to index this
content.

\textbf{Hybrid rendering}: Ajax + server-side rendering lets you disable
\texttt{pushState} at any time, allowing progressive enhancement. You
can use your preferred method to render the server side (e.g.~HTML
fragments or template views).

\textbf{State retention}: Scrolling, reloading, or navigating through
the history of the page takes you back to where you were. SennaJS
exposes lifecycle events that represent state changes in the
application. See \href{available-spa-lifecycle-events}{Available SPA
Lifecycle Events} for more information.

\textbf{UI feedback}: The UI indicates to the user when some content is
requested.

\textbf{Pending navigations}: UI rendering is blocked until data is
loaded, and the content is displayed all at once.

\textbf{Timeout detection}: If the request takes too long to load or the
user tries to navigate to a different link while another request is
pending, the request times out.

\textbf{History navigation}: The browser history is manipulated via the
\href{https://developer.mozilla.org/en-US/docs/Web/API/History}{History
API}, so you can use the back and forward history buttons to navigate
through the history of the page.

\textbf{Cacheable screens}: Once a surface is loaded, the content is
cached in memory and is retrieved later without any additional request,
speeding up your application.

\textbf{Page resources management}: Scripts and stylesheets are
evaluated from dynamically loaded resources. Additional content can be
appended to the DOM using \texttt{XMLHttpRequest}. For security reasons,
some browsers won't evaluate \texttt{\textless{}script\textgreater{}}
tags from content fragments. Therefore, SennaJS extracts scripts from
the content and parses them to ensure that they meet the browser loading
requirements.

You can see examples and read more about SennaJS at its
\href{http://sennajs.com/}{website}.

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Configuring SPA System Settings
\item
  Disabling SPA
\item
  Specifying how resources are loaded during SPA navigation
\item
  Detaching Global Listeners
\end{itemize}

\chapter{Configuring SPA System
Settings}\label{configuring-spa-system-settings}

Depending on what behaviors you need to customize, you can configure SPA
options in one of two places. SPA caching and SPA timeout settings are
configured in System Settings. If you wish to disable SPA for a certain
link, page, or portlet in your site, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/disabling-spa}{Disabling
SPA}.

Follow these steps to configure system settings for SPA:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the Control Panel, navigate to \emph{Configuration} → \emph{System
  Settings}.
\item
  Select \emph{Infrastructure} under the \emph{PLATFORM} heading.
\item
  Click \emph{Frontend SPA Infrastructure}.
\end{enumerate}

The following configuration options are available:

\textbf{Cache Expiration Time}: The time, in minutes, in which the SPA
cache is cleared. A negative value means the cache should be disabled.

\textbf{Navigation Exception Selectors}: Defines a CSS selector that SPA
should ignore.

\textbf{Request Timeout Time}: The time, in milliseconds, in which a SPA
request times out. A zero value means the request should never timeout.

\textbf{User Notification Timeout}: The time, in milliseconds, in which
a notification is shown to the user stating that the request is taking
longer than expected. A zero value means no notification should be
shown.

Great! Now you know how to configure system settings for SPA.

\section{Related Topics}\label{related-topics-105}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/disabling-spa}{Disabling
  SPA}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-how-resources-are-loaded-during-navigation}{Specifying
  How Resources Are Loaded During SPA Navigation}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/detaching-global-listeners}{Detaching
  Global Listeners}
\end{itemize}

\chapter{Disabling SPA}\label{disabling-spa}

Certain elements of your page may require a regular navigation to work
properly. For example, you may have downloadable content that you want
to share with the user. In these cases, SPA must be disabled for those
specific elements. You can disable SPA at these scopes:

\begin{itemize}
\tightlist
\item
  disable SPA across an entire Liferay DXP instance
\item
  disable SPA in a portlet
\item
  Disable SPA in individual elements
\end{itemize}

Follow the steps in the corresponding section to disable SPA for that
scope.

\section{Disabling SPA across an
Instance}\label{disabling-spa-across-an-instance}

To disable SPA across an entire Liferay DXP instance, add the following
line to your \texttt{portal-ext.properties}:

\begin{verbatim}
javascript.single.page.application.enabled = false
\end{verbatim}

\section{Disabling SPA for a Portlet}\label{disabling-spa-for-a-portlet}

To disable SPA for a portlet, you must blacklist it. To blacklist a
portlet from SPA, follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your portlet class.
\item
  Set the \texttt{com.liferay.portlet.single-page-application} property
  to false:

\begin{verbatim}
com.liferay.portlet.single-page-application=false
\end{verbatim}

  If you prefer, you can set this property to false in your
  \texttt{liferay-portlet.xml} instead by adding the following property
  to the \texttt{\textless{}portlet\textgreater{}} section:

\begin{verbatim}
<single-page-application>false</single-page-application>
\end{verbatim}
\item
  Alternatively, you can override the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-impl/com/liferay/portal/model/impl/PortletImpl.html\#isSinglePageApplication--}{\texttt{isSinglePageApplication}
  method} of the portlet to return \texttt{false}.
\end{enumerate}

\section{Disabling SPA for an Individual
Element}\label{disabling-spa-for-an-individual-element}

To disable SPA for a form or link follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{data-senna-off} attribute to the element.
\item
  Set the value to \texttt{true}. See the example below:

\begin{verbatim}
<a data-senna-off="true" href="/pages/page2.html">Page 2</a>
\end{verbatim}
\end{enumerate}

Nice! Now you know how to disable SPA in your app.

\section{Related Topics}\label{related-topics-106}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-spa-system-settings}{Configuring
  SPA System Settings}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-how-resources-are-loaded-during-navigation}{Specifying
  How Resources Are Loaded During SPA Navigation}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/detaching-global-listeners}{Detaching
  Global Listeners}
\end{itemize}

\chapter{Specifying How Resources Are Loaded During
Navigation}\label{specifying-how-resources-are-loaded-during-navigation}

By default, Liferay DXP unloads CSS resources from the
\texttt{\textless{}head\textgreater{}} element on navigation. JavaScript
resources in the \texttt{\textless{}head\textgreater{}}, however, are
not removed on navigation. This functionality can be customized by
setting the resource's \texttt{data-senna-track} attribute. Follow these
steps to customize your resources:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the resource you want to modify the default behavior for.
\item
  Add the \texttt{data-senna-track} attribute to the resource.
\item
  Set the \texttt{data-senna-track} attribute to \texttt{permanent} to
  prevent a resource from unloading on navigation.

  Alternatively, set the \texttt{data-senna-track} attribute to
  \texttt{temporary} to unload the resource on navigation.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** the `data-senna-track` attribute can be added to resources loaded
 outside of the `<head>` element as well to specify navigation behavior.
\end{verbatim}

\noindent\hrulefill

The example below ensures that the JS resource isn't unloaded during
navigation:

\begin{verbatim}
<script src="myscript.js" data-senna-track="permanent" />
\end{verbatim}

Great! Now you know how to specify how resources are loaded during SPA
navigation.

\section{Related Topics}\label{related-topics-107}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-spa-system-settings}{Configuring
  SPA System Settings}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/disabling-spa}{Disabling
  SPA}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/detaching-global-listeners}{Detaching
  Global Listeners}
\end{itemize}

\chapter{Detaching Global Listeners}\label{detaching-global-listeners}

SPA provides several improvements that highly benefit your site and
users, but with great power comes great re-SPA-nsibility. I apologize
for that last sentence, but the fact remains that there is potentially
some additional maintenance as a consequence of SPA. In a traditional
navigation scenario, every page refresh resets everything, so you don't
have to worry about what's left behind. In a SPA scenario, however,
global listeners such as \texttt{Liferay.on}, \texttt{Liferay.after}, or
body delegates can become problematic. Every time you execute these
global listeners, you add yet another listener to the globally persisted
\texttt{Liferay} object. The result is multiple invocations of those
listeners. This can obviously cause problems if not handled.

Follow these steps to prevent potential problems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Listen to the navigation event in order to detach your listeners. For
  example, you would use the following code to listen to a global
  \texttt{category} event and \texttt{destroyPortlet} event:

\begin{verbatim}
Liferay.on('category', function(event){...});
Liferay.on('destroyPortlet', function(event){...});
\end{verbatim}
\item
  Detach the event listeners when the portlet is destroyed, as shown in
  the example below:

\begin{verbatim}
var onCategory = function(event) {...};

var clearPortletHandlers = function(event) {
    if (event.portletId === '<%= portletDisplay.getRootPortletId() %>') {
        Liferay.detach('onCategoryHandler', onCategory);
        Liferay.detach('destroyPortlet', clearPortletHandlers);
    }
};


Liferay.on('category', onCategory);
Liferay.on('destroyPortlet', clearPortletHandlers);
\end{verbatim}
\end{enumerate}

Great! Now you know how to properly maintain your global listeners for
SPA.

\section{Related Topics}\label{related-topics-108}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/available-spa-lifecycle-events}{Available
  SPA Lifecycle Events}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/disabling-spa}{Disabling
  SPA}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-spa-system-settings}{Configuring
  SPA System Settings}
\end{itemize}

\chapter{Applying Clay Styles to your
App}\label{applying-clay-styles-to-your-app}

It's important to have a consistent user experience across your apps.
Portal's built-in apps achieve this through Liferay's
\href{https://liferay.design/lexicon/}{Lexicon Experience Language} and
its web implementation,
\href{https://clayui.com/docs/getting-started/clay.html}{Clay}.

Clay provides a consistent, user-friendly UI and is included in all
themes that are based on the \texttt{\_styled} base theme, making all
the components documented on the
\href{https://clayui.com/docs/components/alerts.html}{Clay site}
accessible.

This means you can use Clay markup and components in your apps. This
section explains how to apply Clay's design patterns to achieve the same
look and feel as Portal's built-in apps.

This section covers these topics:

\begin{itemize}
\tightlist
\item
  Applying Clay to navigation
\item
  Implementing the Management Toolbar
\end{itemize}

\chapter{Applying Clay Patterns to
Navigation}\label{applying-clay-patterns-to-navigation}

This article covers how to leverage Clay patterns in your app's
navigation to make it more user-friendly. Updating your app's navigation
bar to use Clay is easy, thanks to the
\texttt{\textless{}clay:navigation-bar\ /\textgreater{}} tag. Follow
these steps to update your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the required imports to your app's \texttt{init.jsp}:

\begin{verbatim}
// Import the clay tld file to be able to use the new tag
<%@ taglib uri="http://liferay.com/tld/clay" prefix="clay" %>

// Import the NavigationItem utility class to create the items model
<%@ page import="com.liferay.frontend.taglib.clay.servlet.taglib.util.JSPNavigationItemList" %>
\end{verbatim}
\item
  Add the \texttt{frontend-taglib-clay} and \texttt{frontend.taglib.soy}
  module dependencies to your app's \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.soy", 
version: "1.0.10"

compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.clay", 
version: "1.0.0"
\end{verbatim}
\item
  Inside your JSP view, add a java scriplet to retrieve the navigation
  variable and portlet URL. An example configuration is shown below:

\begin{verbatim}
<%
final String navigation = ParamUtil.getString(request, "navigation", 
"entries");

PortletURL portletURL = renderResponse.createRenderURL();

portletURL.setParameter("mvcRenderCommandName", "/blogs/view");
portletURL.setParameter("navigation", navigation);
%>
\end{verbatim}
\item
  Add the \texttt{\textless{}clay:navigation-bar\ /\textgreater{}} tag
  to your app, and use the \texttt{items} attribute to specify the
  navigation items. The navigation bar should be dark if your app is
  intended for Admin use. To do this, set the \texttt{inverted}
  attribute to \texttt{true}. If your app is intended for an instance on
  a live site, keep the navigation bar light by setting the
  \texttt{inverted} attribute to \texttt{false}. An example
  configuration for an admin app is shown below:

\begin{verbatim}
<clay:navigation-bar
    inverted="<%= true %>"
    navigationItems="<%=
        new JSPNavigationItemList(pageContext) {
            {
                add(
                navigationItem -> {
                    navigationItem.setActive(navigation.equals("entries"));
                    navigationItem.setHref(renderResponse.createRenderURL());
                    navigationItem.setLabel(LanguageUtil.get(request, "entries"));
                });

                add(
                navigationItem -> {
                    navigationItem.setActive(navigation.equals("images"));
                    navigationItem.setHref(renderResponse.createRenderURL(), 
          "navigation", "images");
                    navigationItem.setLabel(LanguageUtil.get(request, "images"));
                });
            }
        }
    %>"
/>
\end{verbatim}
\item
  Add a conditional block to display the proper JSP for the selected
  navigation item. An example configuration for the Blogs Admin portlet
  is shown below:

\begin{verbatim}
<c:choose>
    <c:when test='<%= navigation.equals("entries") %>'>
        <liferay-util:include page="/blogs_admin/view_entries.jsp" 
    servletContext="<%= application %>" />
    </c:when>
    <c:otherwise>
        <liferay-util:include page="/blogs_admin/view_images.jsp" 
    servletContext="<%= application %>" />
    </c:otherwise>
</c:choose>
\end{verbatim}
\end{enumerate}

Live site navigation bar:

\begin{figure}
\centering
\includegraphics{./images/clay-patterns-navbar.png}
\caption{The navigation bar should be light for apps on the live site.}
\end{figure}

Admin app navigation bar:

\begin{figure}
\centering
\includegraphics{./images/clay-patterns-navbar-inverted.png}
\caption{The navigation bar should be dark (inverted) in admin apps.}
\end{figure}

Sweet! Now you know how to style a navigation bar with Clay.

\section{Related topics}\label{related-topics-109}

\href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-the-management-toolbar}{Implementing
the Management Toolbar}

\chapter{Implementing the Management
Toolbar}\label{implementing-the-management-toolbar}

The Management Toolbar is a combination of search, filters, sorting
options, and display options that let you manage data. For admin apps,
we recommend that you add a management toolbar to manage your search
container results. The
\href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar}{Clay
Management Toolbar} taglib reference covers how to use the Clay taglibs
to create the Management Toolbar. This section covers how to create the
features below for the Management Toolbar:

\begin{itemize}
\tightlist
\item
  Implementing View Types
\item
  Sorting and Filtering Items
\end{itemize}

\chapter{Implementing the View Types}\label{implementing-the-view-types}

The Management Toolbar has three predefined view types for your app's
search container results. Each style offers a slightly different look
and feel. To provide these view types in your app, you must make some
updates to your search result columns. Start by defining the view types
you want to provide.

\begin{itemize}
\item
  \textbf{Cards:} displays search result columns on a horizontal or
  vertical card
\item
  \textbf{List:} displays a detailed description along with summarized
  details for the search result columns
\item
  \textbf{Table:} the default view, which list the search result columns
  from left to right
\end{itemize}

Follow these steps to define the view types for your management toolbar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Import the \texttt{ViewTypeItemList} utility class to create the
  action items model:

\begin{verbatim}
<%@ page import="com.liferay.frontend.taglib.clay.servlet.taglib.util.JSPViewTypeItemList" %>
\end{verbatim}
\item
  Add the \texttt{frontend.taglib.clay} and \texttt{frontend.taglib.soy}
  module dependencies to your app's \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.soy", 
version: "1.0.10"

compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib.clay", 
version: "1.0.0"
\end{verbatim}
\item
  In your app's main view, retrieve the \texttt{displayStyle} for
  reference. Each view type corresponds to a display style. this is used
  to determine the proper content configuration to display for the
  selected view type:

\begin{verbatim}
<%
String displayStyle = ParamUtil.getString(request, "displayStyle");
%>
\end{verbatim}
\item
  Add the management toolbar to your app's main view and configure the
  display buttons as shown below. Note that while this example
  implements all three view types, only one view type is required. The
  default or active view type is set by adding
  \texttt{viewTypeItem.setActive(true)} to the view type:

\begin{verbatim}
<clay:management-toolbar
    disabled=<%= assetTagsDisplayContext.isDisabledTagsManagementBar() %>
    namespace="<%= renderResponse.getNamespace() %>"
    searchContainerId="assetTags"
    selectable="<%= true %>"
    viewTypeItems="<%=
        new JSPViewTypeItemList(pageContext, baseURL, selectedType) {
            {
                addCardViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setActive(true);
                        viewTypeItem.setLabel("Card");
                    });

                addListViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setLabel("List");
                    });

                addTableViewTypeItem(
                    viewTypeItem -> {
                        viewTypeItem.setLabel("Table");
                    });
            }
        }
    %>"
/>
\end{verbatim}

  \texttt{viewTypeItems}: The available view types
\item
  Create a conditional block to check for the view types. If you only
  have one view type, you can skip this step.

\begin{verbatim}
<c:choose>
    <%-- view type configuration goes here --%>
</c:choose>
\end{verbatim}
\end{enumerate}

Now that the view types are defined, you can follow the instructions in
the rest of this section to configure them.

\chapter{Implementing the Card View}\label{implementing-the-card-view}

The card view displays the entry's information in a vertical or
horizontal card with an image, user profile, or an icon representing the
content's type, along with details about the content, such as its name,
workflow status, and a condensed description.

See the
\href{/docs/7-2/reference/-/knowledge_base/r/liferay-front-end-cards}{Liferay
Frontend Cards} reference for examples and use cases of each card.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-card.png}
\caption{The Management Toolbar's card view gives a quick summary of the
content's description and status.}
\end{figure}

Follow the steps below to create your card view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{\textless{}c:choose\textgreater{}} conditional
  block, add a condition for the icon display style (Card view type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "icon") %>'>
    <%-- card view type configuration goes here --%>
</c:when>
\end{verbatim}
\item
  Add the proper java scriplet to make the card view responsive to
  different devices:

  Use the pattern below for vertical cards:

\begin{verbatim}
<%
row.setCssClass("col-md-2 col-sm-4 col-xs-6");
%>
\end{verbatim}

  For horizontal cards use the following pattern:

\begin{verbatim}
<%
row.setCssClass("col-md-3 col-sm-4 col-xs-12");
%>
\end{verbatim}
\item
  Add the search container column text containing your card. The card
  should include the actions for the entry(if applicable), as well as an
  image, icon or user profile, and the entry's title. An example
  configuration is shown below:

\begin{verbatim}
<liferay-frontend:icon-vertical-card
  actionJsp='<%= dlPortletInstanceSettingsHelper.isShowActions() ? 
  "/image_gallery_display/image_action.jsp" : StringPool.BLANK %>'
  actionJspServletContext="<%= application %>"
  cssClass="entry-display-style"
  icon="documents-and-media"
  resultRow="<%= row %>"
  title="<%= dlPortletInstanceSettingsHelper.isShowActions() ? 
  fileEntry.getTitle() : StringPool.BLANK %>"
/>
\end{verbatim}
\end{enumerate}

Great! Now you know how to implement the Card view!

\section{Related Topics}\label{related-topics-110}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar}{Configuring
  the Clay Management Toolbar Taglib}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
  and Sorting Items with the Management Toolbar}
\end{itemize}

\chapter{Implementing the List View}\label{implementing-the-list-view}

The list view displays the entry's complete description, along with a
small icon for the content type, and its name.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-list.png}
\caption{The Management Toolbar's list view gives the content's full
description.}
\end{figure}

Follow these steps to configure the List view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{\textless{}c:choose\textgreater{}} conditional
  block, add a condition for the descriptive display style (list view
  type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "descriptive") %>'>
    <%-- list view type configuration goes here --%>
</c:when>
\end{verbatim}
\item
  Follow the example below to add the three columns to the conditional
  block:
\end{enumerate}

Column \textbar{} Content Options \textbar{} Example 1 \textbar{} icon
\textbar{}
\textless liferay-ui:search-container-column-icon/\textgreater{} ~
\textbar{} image \textbar{}
\textless liferay-ui:search-container-column-image/\textgreater{} ~
\textbar{} user portrait \textbar{}
\textless liferay-ui:search-container-column-text\textgreater{}~~\textless liferay-ui:user-portrait/\textgreater{}\textless/liferay-ui:search-container-column-text\textgreater{}
2 \textbar{} description \textbar{}
\textless liferay-ui:search-container-column-text
~~colspan=``\textless\%=2\%\textgreater{}''
\textgreater{}~~\textless h5\textgreater\textless\%= userGroup.getName()
\%\textgreater\textless/h5\textgreater{} ~~\textless h6
class=``text-default''\textgreater{}
~~~~\textless span\textgreater\textless\%= userGroup.getDescription()
\%\textgreater\textless/span\textgreater{} ~~\textless/h6\textgreater{}
~~\textless h6 class=``text-default''\textgreater{}
~~~~\textless span\textgreater{} ~~~~~~~~''
key=``x-users''/\textgreater{} ~~~~\textless/span\textgreater{}
~~\textless/h6\textgreater{} 3 \textbar{} actions \textbar{}
\textless liferay-ui:search-container-column-jsp
~~path=``/edit\_team\_assignments\_user\_groups\_action.jsp''/\textgreater{}

Great! Now you know how to implement the List view!

\section{Related Topics}\label{related-topics-111}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar}{Configuring
  the Clay Management Toolbar Taglib}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
  and Sorting Items with the Management Toolbar}
\end{itemize}

\chapter{Implementing the Table View}\label{implementing-the-table-view}

The table view list the search container columns from left to right.

\begin{figure}
\centering
\includegraphics{./images/clay-taglib-management-toolbar-view-type-table.png}
\caption{The Management Toolbar's table view list the content's
information in individual columns.}
\end{figure}

Follow these steps to configure the Table view:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{\textless{}c:choose\textgreater{}} conditional
  block, add a condition for the list display style (table view type):

\begin{verbatim}
<c:when test='<%= Objects.equals(displayStyle, "list") %>'>
  <%-- table view type configuration goes here --%>
</c:when>
\end{verbatim}
\item
  Follow the example below to add the required columns to the
  conditional block:
\end{enumerate}

Column \textbar{} Content Options \textbar{} Example 1 \textbar{} name
\textbar{} \textless liferay-ui:search-container-column-text
~~cssClass=``content-column name-column title-column'' ~~name=``name''
~~truncate=``\textless\%= true \%\textgreater{}'' ~~value=``\textless\%=
rule.getName(locale) \%\textgreater{}'' /\textgreater{} 2 \textbar{}
description \textbar{} \textless liferay-ui:search-container-column-text
~~cssClass=``content-column description-column'' ~~name=``description''
~~truncate=``\textless\%= true \%\textgreater{}'' ~~value=``\textless\%=
rule.getDescription(locale) \%\textgreater{}'' /\textgreater{} 3
\textbar{} create date \textbar{}
\textless liferay-ui:search-container-column-date
~~cssClass=``create-date-column text-column'' ~~name=``create-date''
~~property=``createDate'' /\textgreater{} 4 \textbar{} actions
\textbar{} \textless liferay-ui:search-container-column-jsp ~~
cssClass=``entry-action-column'' ~~path=``/rule\_actions.jsp''
/\textgreater{}

Great! Now you know how to implement the Table view!

\section{Related Topics}\label{related-topics-112}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar}{Configuring
  the Clay Management Toolbar Taglib}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
  and Sorting Items with the Management Toolbar}
\end{itemize}

\chapter{Updating the Search
Iterator}\label{updating-the-search-iterator}

Once the view type's display styles are defined, you must update the
search iterator to show the selected view type. Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If your management toolbar only has one view type, you can set the
  \texttt{displayStyle} attribute to the style you defined, otherwise
  follow the pattern below:

\begin{verbatim}
<liferay-ui:search-iterator
    displayStyle="<%= displayStyle %>"
    markupView="lexicon"
    searchContainer="<%= searchContainer %>"
/>
\end{verbatim}

  The \texttt{displayStyle}'s value is set to the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-the-view-types}{current
  view type}.
\item
  Save the changes.
\end{enumerate}

Great! You've updated your search iterator to use your display styles.

\section{Related Topics}\label{related-topics-113}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar}{Configuring
  the Clay Management Toolbar Taglib}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/filtering-and-sorting-items-with-the-management-toolbar}{Filtering
  and Sorting Items with the Management Toolbar}
\end{itemize}

\chapter{Filtering and Sorting Items with the Management
Toolbar}\label{filtering-and-sorting-items-with-the-management-toolbar}

The Management Toolbar lets you filter and sort your search container
results. While you can configure the toolbar's filters in the JSP, this
can quickly crowd the JSP. We recommend instead that you move this
functionality to a separate java class, which we refer to as a Display
Context throughout this tutorial.

There are two main types of filters: navigation and order. Both of these
are contained within the same dropdown menu. Follow the steps below to
create your filters.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Depending on your needs, there are two classes that you can extend for
  your management toolbar Display Context. These base classes provide
  the required methods to create your navigation and order filters:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-taglib/frontend-taglib-clay/src/main/java/com/liferay/frontend/taglib/clay/servlet/taglib/display/context/BaseManagementToolbarDisplayContext.java}{\texttt{BaseManagementToolbarDisplayContext}}:
    for apps without a search container
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-taglib/frontend-taglib-clay/src/main/java/com/liferay/frontend/taglib/clay/servlet/taglib/display/context/SearchContainerManagementToolbarDisplayContext.java}{\texttt{SearchContainerManagementToolbarDisplayContext}}:
    for apps with a search container (extends
    \texttt{BaseManagementToolbarDisplayContext} and provides additional
    logic for search containers)
  \end{itemize}

  An example configuration for each is shown below:

  \texttt{BaseManagementToolbarDisplayContext} example:

\begin{verbatim}
public class MyManagementToolbarDisplayContext
  extends BaseManagementToolbarDisplayContext {

  public MyManagementToolbarDisplayContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    HttpServletRequest request) {

    super(liferayPortletRequest, liferayPortletResponse, request);
  }
  ...
}
\end{verbatim}

  \texttt{SearchContainerManagementToolbarDisplayContext} example:

\begin{verbatim}
public class MyManagementToolbarDisplayContext
  extends SearchContainerManagementToolbarDisplayContext {

  public MyManagementToolbarDisplayContext(
    LiferayPortletRequest liferayPortletRequest,
    LiferayPortletResponse liferayPortletResponse,
    HttpServletRequest request, SearchContainer searchContainer) {

    super(
      liferayPortletRequest, liferayPortletResponse, request,
      searchContainer);
  }
}
\end{verbatim}
\item
  Override the \texttt{getNavigationKeys()} method to return the
  navigation filter dropdown item(s). If your app doesn't require any
  navigation filters, you can just provide the \emph{all} filter to
  display everything. An example configuration is shown below:

\begin{verbatim}
@Override
protected String[] getNavigationKeys() {
  return new String[] {"all", "pending", "done"};
}
\end{verbatim}
\item
  override the \texttt{getOrderByKeys()} method to return the columns to
  order. An example configuration is shown below:

\begin{verbatim}
@Override
protected String[] getOrderByKeys() {
  return new String[] {"name", "items", "status"};
}
\end{verbatim}
\item
  Open the JSP view that contains the Clay Management Toolbar and set
  its \texttt{displayContext} attribute to the Display Context you
  created. An example configuration is shown below:

\begin{verbatim}
<clay:management-toolbar
    displayContext="<%= myManagementToolbarDisplayContext %>"
/>
\end{verbatim}
\end{enumerate}

Now you know how to configure the Management Toolbar's filters via a
Display Context.

\section{Related Topics}\label{related-topics-114}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/clay-management-toolbar\#filtering-and-sorting-search-results}{Configuring
  Filtering and Sorting Management Toolbar Attributes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-the-view-types}{Implementing
  the View Types}
\end{itemize}

\chapter{Configuring Your Application's Title and Back
Link}\label{configuring-your-applications-title-and-back-link}

For administration applications, the title should be moved to the inner
views of the app and the associated back link should be moved to the
portlet titles. If you open the Blogs Admin application in the Control
Panel and add a new blog entry, you'll see this behavior in action:

\begin{figure}
\centering
\includegraphics{./images/new-blog-entry-title.png}
\caption{Adding a new blog entry displays the portlet title at the top,
along with a back link.}
\end{figure}

The Blogs Admin application is used as an example throughout this
article. Follow these steps to configure your app's title and back URL:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use \texttt{ParamUtil} to retrieve the redirect for the URL:

\begin{verbatim}
String redirect = ParamUtil.getString(request, "redirect");
\end{verbatim}
\item
  Display the back icon and set the back URL to the \texttt{redirect}:

\begin{verbatim}
portletDisplay.setShowBackIcon(true);
portletDisplay.setURLBack(redirect);
\end{verbatim}
\item
  Finally, set the title using the \texttt{renderResponse.setTitle()}
  method. The example below provides a title for two scenarios:

  \begin{itemize}
  \tightlist
  \item
    If an existing blog entry is being updated, the blog's title is
    displayed.
  \item
    Otherwise it defaults to \emph{New Blog Entry} since a new blog
    entry is being created.
  \end{itemize}

\begin{verbatim}
renderResponse.setTitle((entry != null) ? entry.getTitle() : 
LanguageUtil.get(request, "new-blog-entry"));
%>
\end{verbatim}
\item
  Update any back links in the view to use the \texttt{redirect}. The
  Blog Admin app's \texttt{edit\_entry.jsp} form's cancel button is
  shown below as an example:

\begin{verbatim}
<aui:button cssClass="btn-lg" href="<%= redirect %>" name="cancelButton" 
type="cancel" />
\end{verbatim}
\end{enumerate}

Great! Now you know how to configure your app's title and back URL.

\section{Related Topics}\label{related-topics-115}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/applying-clay-patterns-to-navigation}{Applying
  Clay Patterns to Your Navigation Bar}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/setting-empty-results-messages}{Setting
  Empty Results Messages}
\end{itemize}

\chapter{Applying the Add Button
Pattern}\label{applying-the-add-button-pattern}

Clay's add button pattern is for actions that add entities (for example
a new blog entry button). It gives you a clean, minimal UI. You can use
it in any of your app's screens. Follow these steps to add a plus button
to your app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-frontend} taglib declaration to your portlet's
  \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
\end{verbatim}
\item
  Add an
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/add-menu.html}{\texttt{add-menu}
  tag} to your portlet's view:

\begin{verbatim}
<liferay-frontend:add-menu>
</liferay-frontend:add-menu>
\end{verbatim}
\item
  Nest a
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/add-menu-item.html}{\texttt{\textless{}liferay-frontend:add-menu-item\textgreater{}}}
  tag for every menu item you have. Here's an example of the add button
  pattern with a single item:

\begin{verbatim}
<liferay-frontend:add-menu>
    <liferay-frontend:add-menu-item 
      title='<%= LanguageUtil.get(request,"titleName") %>' 
      url="<%= nameURL.toString() %>" 
    />
</liferay-frontend:add-menu>
\end{verbatim}

  If there's only one item, the plus icon acts as a button that triggers
  the item. If there's multiple items, clicking the plus icon displays a
  menu containing them.

  \begin{figure}
  \centering
  \includegraphics{./images/add-button-diagram.png}
  \caption{The add button pattern consists of an \texttt{add-menu} tag
  and at least one \texttt{add-menu-item} tag.}
  \end{figure}
\end{enumerate}

The \texttt{com.liferay.mobile.device.rules.web} module's add menu is
shown below:

\begin{verbatim}
<liferay-frontend:add-menu
  inline="<%= true %>"
>
  <liferay-frontend:add-menu-item
    title='<%= LanguageUtil.get(resourceBundle, "add-device-family") %>'
    url="<%= addRuleGroupURL %>"
  />
</liferay-frontend:add-menu>
\end{verbatim}

There you have it! Now you know how to use the add button pattern.

\section{Related Topics}\label{related-topics-116}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/setting-empty-results-messages}{Setting
  Empty Results Messages}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/implementing-the-management-toolbar}{Implementing
  the Management Toolbar}
\end{itemize}

\chapter{Configuring Your Admin App's Actions
Menu}\label{configuring-your-admin-apps-actions-menu}

Rather then have a series of buttons or menus with actions in the
different views of the app, you can move all of these actions to the
upper right menu of the administrative portlet, leaving the primary
action (often an
\href{/docs/7-2/frameworks/-/knowledge_base/f/applying-the-add-button-pattern}{``Add''
operation}) visible in the add menu. For example, the web content
application has the actions menu shown below:

\begin{figure}
\centering
\includegraphics{./images/actions-menu.png}
\caption{The upper right ellipsis menu contains most of the actions for
the app.}
\end{figure}

Follow these steps to configure the actions menu in your admin app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{*ConfigurationIcon} Component class for the action
  that extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/BasePortletConfigurationIcon.html}{\texttt{BasePortletConfigurationIcon}
  class} and implements the \texttt{PortletConfigurationIcon} service:

\begin{verbatim}
@Component(
    immediate = true,
    service = PortletConfigurationIcon.class
)
public class MyConfigurationIcon extends BasePortletConfigurationIcon {
  ...
}
\end{verbatim}
\item
  Override the \texttt{getMessage()} method to specify the action's
  label:

\begin{verbatim}
@Override
public String getMessage(PortletRequest portletRequest) {
  ThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(
    WebKeys.THEME_DISPLAY);

  ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
    themeDisplay.getLocale(), ExportAllConfigurationIcon.class);

  return LanguageUtil.get(resourceBundle, "export-all-settings");
}
\end{verbatim}
\item
  Override the \texttt{get()} method to specify whether the action is
  invoked with the \texttt{GET} or \texttt{POST} method:

\begin{verbatim}
@Override
public String getMethod() {
    return "GET";
}
\end{verbatim}
\item
  Override the \texttt{getURL()} method to specify the URL (or
  \texttt{onClick} JavaScript method) to invoke when the action is
  clicked:

\begin{verbatim}
@Override
public String getURL(
  PortletRequest portletRequest, PortletResponse portletResponse) {

  LiferayPortletURL liferayPortletURL =
    (LiferayPortletURL)_portal.getControlPanelPortletURL(
      portletRequest, ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
      PortletRequest.RESOURCE_PHASE);

  liferayPortletURL.setResourceID("export");

  return liferayPortletURL.toString();
}
\end{verbatim}
\item
  Override the \texttt{getWeight()} method to specify the order that the
  action should appear in the list:

\begin{verbatim}
@Override
public double getWeight() {
  return 1;
}
\end{verbatim}
\item
  Override the \texttt{isShow()} method to specify the context in which
  the action should be displayed:

\begin{verbatim}
@Override
public boolean isShow(PortletRequest portletRequest) {
    return true;
}
\end{verbatim}
\item
  Define the view where you want to display the configuration options.
  By default, if the portlet uses \texttt{mvcPath}, the global actions
  (such as configuration, export/import, maximized, etc.) are displayed
  for the JSP indicated in the initialization parameter of the portlet
  \texttt{javax.portlet.init-param.view-template=/view.jsp}. The value
  indicates the JSP where the global actions should be displayed.
  However, if the portlet uses MVC Command, the views for the global
  actions must be indicated with the initialization parameter
  \texttt{javax.portlet.init-param.mvc-command-names-default-views=/wiki\_admin/view}
  and the value must contain the \texttt{mvcRenderCommandName} where the
  global actions should be displayed.
\item
  If the portlet can be added to a page and you want to always include
  the configuration options, add this initialization parameter to the
  portlet's properties:

\begin{verbatim}
javax.portlet.init-param.always-display-default-configuration-icons=true
\end{verbatim}

  In this example, the action appears in the System Settings portlet. To
  make it appear in a secondary screen, you can use the \texttt{path}
  property as shown below. The value of the \texttt{path} property
  depends on the MVC framework used to develop the app. For the
  MVCPortlet framework, provide the path (often a JSP) from the
  \texttt{mvcPath} parameter. For MVCPortlet with MVC Commands, the path
  should contain the \texttt{mvcRenderCommandName} where the actions
  should be displayed (such as \texttt{/document\_library/edit\_folder}
  for example):

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "javax.portlet.name=" + ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
        "path=/view_factory_instances"
    },
    service = PortletConfigurationIcon.class
)
public class ExportFactoryInstancesIcon extends BasePortletConfigurationIcon {

    @Override
    public String getMessage(PortletRequest portletRequest) {
        ThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(
            WebKeys.THEME_DISPLAY);

        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
            themeDisplay.getLocale(), ExportFactoryInstancesIcon.class);

        return LanguageUtil.get(resourceBundle, "export-entries");
    }

    @Override
    public String getMethod() {
        return "GET";
    }

    @Override
    public String getURL(
        PortletRequest portletRequest, PortletResponse portletResponse) {

        LiferayPortletURL liferayPortletURL =
            (LiferayPortletURL)_portal.getControlPanelPortletURL(
                portletRequest, ConfigurationAdminPortletKeys.SYSTEM_SETTINGS,
                PortletRequest.RESOURCE_PHASE);

        ConfigurationModel factoryConfigurationModel =
            (ConfigurationModel)portletRequest.getAttribute(
                ConfigurationAdminWebKeys.FACTORY_CONFIGURATION_MODEL);

        liferayPortletURL.setParameter(
            "factoryPid", factoryConfigurationModel.getFactoryPid());

        liferayPortletURL.setResourceID("export");

        return liferayPortletURL.toString();
    }

    @Override
    public double getWeight() {
        return 1;
    }

    @Override
    public boolean isShow(PortletRequest portletRequest) {
        ConfigurationModelIterator configurationModelIterator =
            (ConfigurationModelIterator)portletRequest.getAttribute(
                ConfigurationAdminWebKeys.CONFIGURATION_MODEL_ITERATOR);

        if (configurationModelIterator.getTotal() > 0) {
            return true;
        }

        return false;
    }

    @Reference
    private Portal _portal;

}
\end{verbatim}
\end{enumerate}

This covers some of the available methods. See the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/configuration/icon/BasePortletConfigurationIcon.html}{Javadoc}
for a complete list of the available methods.

Great! Now you know how to configure your admin app's actions.

\section{Related Topics}\label{related-topics-117}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/applying-clay-patterns-to-navigation}{Applying
  Clay Patterns to Your Navigation Bar}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configuring-your-applications-title-and-back-link}{Configuring
  Your Application's Title and Back Link}
\end{itemize}

\chapter{Setting Empty Results
Messages}\label{setting-empty-results-messages}

If you've toured the UI, you've probably noticed messages or possibly
even animations in the search containers when no results are found.

\begin{figure}
\centering
\includegraphics{./images/no-web-content-found.png}
\caption{This is a still frame from the Web Content portlet's empty
results animation.}
\end{figure}

You can configure your apps to use empty results messages and animations
too, thanks to the \texttt{liferay-frontend:empty-results-message} tag.

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the \texttt{liferay-frontend} taglib declaration into your
  portlet's \texttt{init.jsp}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/frontend" prefix="liferay-frontend" %>
\end{verbatim}
\item
  Add an
  \href{https://docs.liferay.com/dxp/apps/frontend-taglib/latest/taglibdocs/liferay-frontend/empty-result-message.html}{\texttt{empty-result-message}
  tag} to your portlet's view:

\begin{verbatim}
<liferay-frontend:empty-result-message />
\end{verbatim}
\item
  Configure the tag's attributes to define your search container's empty
  results message, with or without an animation or image. The attributes
  are described in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Attribute | Description |
 --- | --- |
 `actionDropdownItems` | Specifies the action or actions to display for the empty results in either a dropdown menu, a link, or a button, depending on the number of available actions. |
 `animationType` | The CSS class for the animation. Four values are available by default with these CSS classes: `EmptyResultMessageKeys.AnimationType.EMPTY` (`taglib-empty-state`), `EmptyResultMessageKeys.AnimationType.SEARCH` (`taglib-search-state`), `EmptyResultMessageKeys.AnimationType.SUCCESS` (`taglib-success-state`), and `EmptyResultMessageKeys.AnimationType.NONE`. You can also specify a custom CSS class if you prefer. |
 `componentId` | Specifies the ID for the `actionDropdownItems` component (dropdown menu, link, or button)|
 `description` | The descriptive text to display beneath the main message. |
 `elementType` | The type of element to replace the `x` parameter in the main message's language key `no-x-yet`. |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
An example configuration is shown below:

```markup
<liferay-frontend:empty-result-message
    actionDropdownItems="<%= (availableSegmentsEntries.size() > 0) ? 
    editAssetListDisplayContext.getAssetListEntryVariationActionDropdownItems() : null %>"
    animationType="<%= EmptyResultMessageKeys.AnimationType.NONE %>"
    componentId='<%= renderResponse.getNamespace() + "emptyResultMessageComponent" %>'
    description='<%= LanguageUtil.get(request, "no-personalized-variations-were-found") %>'
    elementType='<%= LanguageUtil.get(request, "personalized-variations") %>'
/>
```
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can replace the available default animations with your own 
 by overriding the `taglib-empty-state`, `taglib-search-state`, and 
 `taglib-success-state` CSS classes provided by 
 [_empty_result_message.scss](https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-css/frontend-css-web/src/main/resources/META-INF/resources/taglib/_empty_result_message.scss), 
 or by replacing the existing animations in the `@theme_image_path@/states/` 
 folder. Alternatively, you can also provide a new CSS class that defines 
 the animation and use it for the `animationType` attribute's value. 
\end{verbatim}

\noindent\hrulefill

empty\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/empty_state.gif}
\caption{If you can use the add button to add entities to the app, use
the empty state animation.}
\end{figure}

search\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/search_state.gif}
\caption{If you can use the add button to add entities to the app, use
the search state animation.}
\end{figure}

success\_state.gif:

\begin{figure}
\centering
\includegraphics{./images/success_state.gif}
\caption{If you can use the add button to add entities to the app, use
the success state animation.}
\end{figure}

\noindent\hrulefill

\textbf{Note:} Empty results messages can also contain static images if
you prefer. Just use a valid image type instead. All animations must be
of type \texttt{GIF} though.

\noindent\hrulefill

Great! Now you know how to configure your app to display an empty
results message.

\section{Related Topics}\label{related-topics-118}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/using-liferay-front-end-taglibs-in-your-portlet}{Using
  the Liferay Front-End Taglib}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/applying-the-add-button-pattern}{Applying
  the Add Button Pattern}
\end{itemize}

\chapter{Search}\label{search}

Liferay DXP contains a search engine based on
\href{https://www.elastic.co/products/elasticsearch}{Elasticsearch}. You
can extend it, implement search for your own applications, and it's
highly configurable.

\section{Basic Search Concepts}\label{basic-search-concepts}

\textbf{Indexing}: During indexing, a document is sent to the search
engine. This document contains fields of various types (string, etc.).
The search engine processes each field and determines whether to store
the field or analyze it. Index time analysis can be configured for each
field (see Mapping Definitions).

For fields requiring analysis, the search engine first tokenizes the
value to obtain individual words or tokens. Then it passes each token
through a series of analyzers, which perform different functions. Some
remove common words or stop words (e.g., ``the'', ``and'', ``or'') while
others perform operations like lowercasing all characters.

\textbf{Searching}: Searching involves sending a search query and
obtaining results (a.k.a. hits) from the search engine. The search query
might contain both queries and filters (more on this later). Queries and
filters specify a field to search within and the value to match against.
The search engine iterates through each field within the nested queries
and filters and may perform special analysis prior to executing the
query (search time analysis). Search time analysis can be configured for
each field (see Mapping Definitions).

\section{Mapping Definitions}\label{mapping-definitions}

\emph{Mappings} control how a search engine processes a given field. For
instance, if a field name ends in ``es\_ES'', it should be processed as
Spanish, removing any common Spanish words like ``si''.

In Elasticsearch and Solr, the two supported search engines for Liferay
DXP, mappings are defined in \texttt{liferay-type-mappings.json} and
\texttt{schema.xml}, respectively.

The Elasticsearch mapping JSON file is in the Liferay DXP
\href{https://github.com/liferay/liferay-portal}{source code}, in the
\texttt{portal-search-elasticsearch6} module:

\begin{verbatim}
portal-search-elasticsearch6-impl/src/main/resources/META-INF/mappings/liferay-type-mappings.json
\end{verbatim}

The Solr \texttt{schema.xml} is in the \texttt{portal-search-solr7}
module's source code:

\begin{verbatim}
portal-search-solr7-impl/src/main/resources/META-INF/resources/schema.xml
\end{verbatim}

Access the Solr 7 module's source code from the \texttt{liferay-portal}
repository
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-search-solr7/portal-search-solr7-impl/src/main/resources/META-INF/resources/schema.xml}{here}.

You can customize these mappings to fit your needs. For example, you
might want to use a special analyzer for a custom inventory number
field.

\section{Liferay Search
Infrastructure}\label{liferay-search-infrastructure}

Search engines already provide native APIs, but Liferay wraps the engine
with a search infrastructure that does several things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Index documents with the fields Liferay needs
  (\texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status, etc.).
\item
  Apply the right filters to search queries (e.g., for scoping results).
\item
  Apply permission checking on the results.
\item
  Summarize returned results.
\end{enumerate}

That's just a taste of Liferay's Search Infrastructure. Continue reading
to learn more.

\chapter{Aggregations}\label{aggregations}

Aggregations take the results of a query and group the data into logical
sets. Aggregations can be composed to provide complex data summaries.

7.0 has a new API that exposes
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations.html}{Elasticsearch's
native Aggregation functionality}.

Currently, these aggregation types are supported:

\begin{itemize}
\tightlist
\item
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-bucket.html}{Bucketing
  aggregations} create buckets of documents based on some criterion.
  They support sub-aggregations.

  \begin{itemize}
  \tightlist
  \item
    Supported bucket aggregations include children aggregations, date
    histogram aggregations, date range aggregations, diversified sampler
    aggregations, filter aggregations, filters aggregations, geo
    distance aggregations, geo hash grid aggregations, global
    aggregations, histogram aggregations, missing aggregations, nested
    aggregations, range aggregations, reverse nested aggregations,
    sample aggregations, significant terms aggregations, significant
    text aggregations, and terms aggregations.
  \end{itemize}
\item
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics.html}{Metrics
  aggregations} compute metrics over a set of documents.

  \begin{itemize}
  \tightlist
  \item
    Supported metrics aggregations include average aggregations,
    cardinality aggregations, extended stats aggregations, geo bounds
    aggregations, geo centroid aggregations, max aggregations, min
    aggregations, percentile ranks aggregations, percentiles
    aggregations, scripted metric aggregations, stats aggregations, sum
    aggregations, top hits aggregations, value count aggregations, and
    weighted average aggregations.
  \end{itemize}
\item
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-pipeline.html}{Pipeline
  aggregations} aggregate the output of other aggregations and their
  associated metrics.

  \begin{itemize}
  \tightlist
  \item
    Supported pipeline aggregations include average bucket pipeline
    aggregations, bucket metrics pipeline aggregations, bucket script
    pipeline aggregations, bucket selector pipeline aggregations, bucket
    sort pipeline aggregations, cumulative sum pipeline aggregations,
    derivative pipeline aggregations, extended stats bucket pipeline
    aggregations, max bucket pipeline aggregations, min bucket pipeline
    aggregations, moving function pipeline aggregations, percentiles
    bucket pipeline aggregations, pipeline aggregations, serial diff
    pipeline aggregations, stats bucket pipeline aggregations, and sum
    bucket pipeline aggregations.
  \end{itemize}
\end{itemize}

All the supported aggregations are found in the
\texttt{portal-search-api} module's
\texttt{com.liferay.portal.search.aggregation} package.

In addition to these aggregations, other aggregation-like features are
present in the Liferay DXP search API:

\textbf{Group By} collects search results (documents) based on a
particular field. For example, if you want to group the search results
based on the asset type (e.g., web content article, document, blog post,
etc.), you can create a search query that contains a
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-kernel/src/com/liferay/portal/kernel/search/GroupBy.java}{com.liferay.portal.kernel.search.GroupBy}
aggregation with the field \texttt{entryClassName}.

You can specify these attributes for returned groups:

\begin{itemize}
\tightlist
\item
  The maximum number of results in each group
\item
  Special sorting for the grouped results
\end{itemize}

\textbf{Facets} act like bucket aggregations, holding results that share
a certain characteristic.

\section{Using Aggregations}\label{using-aggregations}

The generalized approach for using aggregations in your own search code
is like this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Instantiate and construct the aggregation object
\item
  Add the aggregation information to the search request
\item
  Process the search response
\end{enumerate}

These steps are covered in more detail (with examples)
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-aggregations-in-low-level-search-calls}{here}.

\section{External References}\label{external-references}

\begin{itemize}
\tightlist
\item
  \url{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations.html}
\item
  \url{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations.html\#_structuring_aggregations}
\end{itemize}

\section{Search Engine Connector
Support}\label{search-engine-connector-support}

\begin{itemize}
\tightlist
\item
  Elasticsearch 6: Yes
\item
  Solr 7: No
\end{itemize}

\section{New/Related APIs}\label{newrelated-apis}

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2558}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.5116}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2326}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
API (FQCN)
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Provided by Artifact
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{com.liferay.portal.search.aggregation.*} &
com.liferay.portal.search.api & The whole
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/aggregation}{``aggregation''
package} is new as of 7.0 \\
\end{longtable}

\chapter{Creating Aggregations}\label{creating-aggregations}

Each aggregation has a different purpose and should be processed
differently once returned from the search engine, but you add the
aggregation information to the search request in a similar way between
all aggregations.

\section{Instantiate and Construct the
Aggregation}\label{instantiate-and-construct-the-aggregation}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the \texttt{com.liferay.portal.search.aggregation.Aggregations} to
  instantiate the aggregation you'll construct. For example,

\begin{verbatim}
PercentilesAggregation percentilesAggregation =
    aggregations.percentiles("percentiles", Field.PRIORITY);
\end{verbatim}

  To discover what fields each aggregation must have (e.g.,
  \texttt{Sting\ name,\ String\ field} in the case of the above
  \texttt{PercentilesAggregation}), see the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/aggregation/Aggregations.java}{\texttt{Aggregations}
  interface}.
\item
  Build out the aggregation to get the desired response. This looks
  different for each aggregation type, but Elasticsearch's documentation
  on the aggregation type explains it well (such as
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics-percentile-aggregation.html}{Percentiles
  Aggregations}) combined with the setters in Liferay's corresponding
  interface.

  For example, use the
  \texttt{setPercentilesMethod(PercentilesMethod.HDR)} method to use the
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics-percentile-aggregation.html\#_hdr_histogram}{High
  Dynamic Range Histogram} for calculating the percentiles.

\begin{verbatim}
percentilesAggregation.setPercentilesMethod(PercentilesMethod.HDR);
\end{verbatim}
\end{enumerate}

Once the aggregation itself is in good shape, feed it to the search
query.

\section{Build the Search Query}\label{build-the-search-query}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get an instance of
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilder} from
  the \texttt{SearchRequestBuilderFactory} service:

\begin{verbatim}
SearchRequestBuilder searchRequestBuilder = 
    searchRequestBuilderFactory.builder();
\end{verbatim}
\item
  Get a \texttt{com.liferay.portal.search.searcher.SearchRequest}
  instance from the builder, then add the aggregation to it and run its
  \texttt{build} method:

\begin{verbatim}
SearchRequest searchRequest =
    searchRequestBuilder.addAggregation(percentilesAggregation).build();
\end{verbatim}
\end{enumerate}

\section{Execute the Search Query}\label{execute-the-search-query}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Perform a search using the \texttt{Searcher} service and the
  \texttt{SearchRequest} to get a
  \texttt{com.liferay.portal.search.searcher.SearchResponse}:

\begin{verbatim}
SearchResponse searcher.search(searchRequest);
\end{verbatim}
\item
  To satisfy the dependencies of the example code here, get a reference
  to
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilderFactory}
  and \texttt{com.liferay.portal.search.searcher.Searcher}:

\begin{verbatim}
@Reference
protected Searcher searcher;

@Reference
SearchRequestBuilderFactory searchRequestBuilderFactory;
\end{verbatim}
\end{enumerate}

\section{Process the response}\label{process-the-response}

What you'll do with the \texttt{SearchResponse} returned by the
\texttt{searcher.search} call depends on the type of aggregation and
your specific use case. A separate article will be written to
demonstrate how to process the response.

\chapter{Statistical Aggregations}\label{statistical-aggregations}

Support for
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/portal-kernel/src/com/liferay/portal/kernel/search/GroupBy.java}{GroupBy}
and
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/portal-kernel/src/com/liferay/portal/kernel/search/Stats.java}{Stats}
aggregations were introduced in 7.0.

Cardinality Aggregations extend Liferay DXP's metrics aggregation
capabilities, providing an approximate (i.e., statistical) count of
distinct values returned by a search query. For example, you could
compute a count of distinct values of the \emph{tag} field. Refer to the
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics-cardinality-aggregation.html}{Elasticsearch
documentation} for more details.

While this functionality was available in the past directly in the
portal kernel code, it's been extracted and re-implemented in
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/stats/StatsRequest.java}{\texttt{StatsRequest}}
and
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/stats/StatsResponse.java}{\texttt{StatsResponse}},
both introduced in the \texttt{com.liferay.portal.search.api} module to
avoid modifying \texttt{portal-kernel}. \texttt{StatsRequest} provides
the same statistical features that the legacy
\texttt{com.liferay.portal.kernel.search.Stats} does, and adds the new
cardinality option.

\section{\texorpdfstring{\texttt{StatsRequest}}{StatsRequest}}\label{statsrequest}

The \texttt{StatsRequest} Provides a map of field names and the metric
aggregations that are to be computed for each field.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a reference to
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilderFactory}:

\begin{verbatim}
@Reference
SearchRequestBuilderFactory searchRequestBuilderFactory;
\end{verbatim}
\item
  Get an instance of
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilder}:

\begin{verbatim}
SearchRequestBuilder searchRequestBuilder = searchRequestBuilderFactory.builder();
\end{verbatim}
\item
  Get a \texttt{com.liferay.portal.search.searcher.SearchRequest}
  instance from the builder:

\begin{verbatim}
SearchRequest searchRequest = searchRequestBuilder.build();
\end{verbatim}
\item
  Get a reference to
  \texttt{com.liferay.portal.search.stats.StatsRequestBuilderFactory}:

\begin{verbatim}
@Reference
StatsRequestBuilderFactory statsRequestBuilderFactory;
\end{verbatim}
\item
  Get a \texttt{com.liferay.portal.search.stats.StatsRequestBuilder}
  instance and build
  \texttt{com.liferay.portal.search.stats.StatsRequest} with the desired
  metrics:

\begin{verbatim}
StatsRequestBuilder statsRequestBuilder = 
    statsRequestBuilderFactory.getStatsRequestBuilder();
StatsRequest statsRequest = statsRequestBuilder
    .cardinality(true)
    .count(true)
    .field(field)
    .max(true)
    .mean(true)
    .min(true)
    .missing(true)
    .sum(true)
    .sumOfSquares(true)
    .build();
\end{verbatim}
\item
  Set \texttt{StatsRequest} on the \texttt{SearchRequest}:

\begin{verbatim}
searchRequest.statsRequests(statsRequest);
\end{verbatim}
\item
  Get a reference to
  \texttt{com.liferay.portal.search.searcher.Searcher}:

\begin{verbatim}
@Reference
protected Searcher searcher;
\end{verbatim}
\item
  Perform a search using \texttt{Searcher} and \texttt{SearchRequest} to
  get \texttt{com.liferay.portal.search.searcher.SearchResponse}:

\begin{verbatim}
SearchResponse searcher.search(searchRequest);
\end{verbatim}
\end{enumerate}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-test-util/src/main/java/com/liferay/portal/search/test/util/stats/BaseStatisticsTestCase.java\#L128}{\textbf{Click
here to see an example from Liferay's codebase}}

\section{\texorpdfstring{\texttt{StatsResponse}}{StatsResponse}}\label{statsresponse}

The stats response contains the metrics aggregations computed by the
search engine for a given field.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get the map containing the metrics aggregations computed by the search
  engine:

\begin{verbatim}
Map<String, StatsResponse> map = searchResponse.getStatsResponseMap();
\end{verbatim}
\item
  Get the \texttt{StatsResponse} for a given field:

\begin{verbatim}
StatsResponse statsResponse = map.get(field);
\end{verbatim}
\item
  Get the desired metric, for example \emph{cardinality}:

\begin{verbatim}
statsResponse.getCardinality();
\end{verbatim}
\end{enumerate}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-test-util/src/main/java/com/liferay/portal/search/test/util/stats/BaseStatisticsTestCase.java\#L128}{\textbf{Click
here to see an example from Liferay's codebase}}

\section{\texorpdfstring{Using the Legacy \texttt{Stats}
Object}{Using the Legacy Stats Object}}\label{using-the-legacy-stats-object}

The legacy \texttt{com.liferay.portal.kernel.search.Stats} object
continues to be fully supported:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{Stats} instance with the desired metrics:

\begin{verbatim}
Stats stats = new Stats() {
    {
        setCount(true);
        setField(field);
        setMax(true);
        setMean(true);
        setMin(true);
        setSum(true);
        setSumOfSquares(true);
    }
};
\end{verbatim}
\item
  Set \texttt{Stats} on the \texttt{SearchContext}:

\begin{verbatim}
searchRequestBuilder.withSearchContext(searchContext -> searchContext.addStats(stats));
\end{verbatim}
\end{enumerate}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-test-util/src/main/java/com/liferay/portal/search/test/util/stats/BaseStatisticsTestCase.java\#L42}{\textbf{Click
here to see an example from Liferay's codebase}}

\section{External References}\label{external-references-1}

\begin{itemize}
\tightlist
\item
  https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics.html
\item
  https://www.elastic.co/guide/en/elasticsearch/reference/7.x/search-aggregations-metrics-cardinality-aggregation.html
\item
  https://lucene.apache.org/solr/guide/7\_5/the-stats-component.html
\end{itemize}

\section{Search Engine Connector
Support}\label{search-engine-connector-support-1}

\begin{itemize}
\tightlist
\item
  Elasticsearch 6: Yes
\item
  Solr 7: Yes
\end{itemize}

\section{New/Related APIs}\label{newrelated-apis-1}

These are the relevant APIs for building Statistics Aggregations:

API (FQCN) \textbar{} Provided by Artifact \textbar{}
\texttt{com.liferay.portal.search.searcher.SearchRequestBuilder\#statsRequests(StatsRequest...\ statsRequests)}
\textbar{} \texttt{com.liferay.portal.search.api}
\texttt{com.liferay.portal.search.searcher.SearchResponse\#getStatsResponseMap()}
\textbar{} \texttt{com.liferay.portal.search.api}
\textbf{\texttt{com.liferay.portal.search.stats.StatsRequest}}
\textbar{} \texttt{com.liferay.portal.search.api}
\texttt{com.liferay.portal.search.stats.StatsRequestBuilder} \textbar{}
\texttt{com.liferay.portal.search.api}
\texttt{com.liferay.portal.search.stats.StatsRequestBuilderFactory}
\textbar{} \texttt{com.liferay.portal.search.api}
\textbf{\texttt{com.liferay.portal.search.stats.StatsResponse}}
\textbar{} \texttt{com.liferay.portal.search.api}
\texttt{com.liferay.portal.kernel.search.Stats} \textbar{}
\texttt{portal-kernel}

\section{Deprecated APIs}\label{deprecated-apis}

\begin{itemize}
\tightlist
\item
  SearchSearchRequest\#getStats()
\item
  SearchSearchRequest\#setStats(Map\textless String, Stats\textgreater{}
  stats)
\end{itemize}

\chapter{Model Entity Indexing
Framework}\label{model-entity-indexing-framework}

Unless you're searching for model entities using database queries (not
recommended in most cases), each asset in Liferay DXP must be indexed in
the search engine. The indexing code is specific to each asset, as the
asset's developers know what fields to index and what filters to apply
to the search query. This paradigm applies to Liferay's own developers
and anyone developing model entities for use with Liferay DXP.

In past versions of Liferay DXP, when your asset required indexing, you
would implement a new Indexer by extending
\texttt{com.liferay.portal.kernel.search.BaseIndexer\textless{}T\textgreater{}}.
Liferay DXP version 7.1 introduced a new pattern that relies on
\href{https://stackoverflow.com/questions/2399544/difference-between-inheritance-and-composition}{composition
instead of inheritance}. That said, if you want to use the old approach,
feel free to extend \texttt{BaseIndexer}. It's still supported.

\section{Search and Indexing
Overview}\label{search-and-indexing-overview}

Starting with the 7.0 version of Liferay DXP, the Search API has become
less tied to Lucene. Elasticsearch support was added (in addition to
Solr), and most of the newer searching and indexing APIs aim to
leverage/map Elasticsearch APIs. This means that in many cases (for
example the \texttt{Query} types) there is a one-to-one mapping between
the Liferay and Elasticsearch APIs.

In addition to the Elasticsearch-centered APIs, Liferay's Search
Infrastructure includes additional APIs serving these purposes:

\begin{itemize}
\tightlist
\item
  Ensure all indexed documents include some required fields (e.g.,
  \texttt{entryClassName}, \texttt{entryClassPK},
  \texttt{assetTagNames}, \texttt{assetCategories}, \texttt{companyId},
  \texttt{groupId}, staging status).
\item
  Ensure the scope of returned search results is appropriate by applying
  the right filters to search requests.
\item
  Provide permission checking and hit summaries for display in the
  built-in \href{/docs/7-2/user/-/knowledge_base/u/search}{search
  application}.
\end{itemize}

\section{\texorpdfstring{Mapping the Composite Search and Indexing
Framework to \texttt{Indexer}/\texttt{BaseIndexer}
Code}{Mapping the Composite Search and Indexing Framework to Indexer/BaseIndexer Code}}\label{mapping-the-composite-search-and-indexing-framework-to-indexerbaseindexer-code}

If you're used to the old way of indexing custom entities (extending
\texttt{BaseIndexer}, the abstract implementation of \texttt{Indexer}),
the table below provides a quick overview about how the methods of the
\texttt{Indexer} interface were decomposed into several new classes and
methods.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.3857}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Indexer/BaseIndexer method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Composite Indexer Equivalent
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Class Constructor & \texttt{SearchRegistrar} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/BlogsEntrySearchRegistrar.java}{\texttt{BlogsEntrySearchRegistrar}} \\
\texttt{setDefaultSelectedFieldNames} &
\texttt{SearchRegistrar.activate} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/BlogsEntrySearchRegistrar.java}{\texttt{BlogsEntrySearchRegistrar}} \\
\texttt{setDefaultSelectedLocalizedFieldNames} &
\texttt{SearchRegistrar.activate} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/BlogsEntrySearchRegistrar.java}{\texttt{BlogsEntrySearchRegistrar}} \\
\texttt{setPermissionAware} & \texttt{ModelResourcePermissionRegistrar}
&
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/security/permission/resource/DLFileEntryModelResourcePermissionRegistrar.java}{\texttt{DLFileEntryModelResourcePermissionRegistrar}} \\
\texttt{setFilterSearch} & \texttt{ModelResourcePermissionRegistrar} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/security/permission/resource/DLFileEntryModelResourcePermissionRegistrar.java}{\texttt{DLFileEntryModelResourcePermissionRegistrar}} \\
\texttt{getDocument}/\texttt{doGetDocument} &
\texttt{ModelDocumentContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/index/contributor/BlogsEntryModelDocumentContributor.java}{\texttt{BlogsEntryModelDocumentContributor}} \\
\texttt{reindex}/\texttt{doReindex} &
\texttt{ModelIndexerWriterContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/index/contributor/BlogsEntryModelIndexerWriterContributor.java}{\texttt{BlogsEntryModelIndexerWriterContributor}} \\
\texttt{addRelatedEntryFields} & \texttt{RelatedEntryIndexer} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryRelatedEntryIndexer.java}{\texttt{DLFileEntryRelatedEntryIndexer}} \\
\texttt{postProcessContextBooleanFilter}/\texttt{PostProcessContextQuery}
& \texttt{ModelPreFilterContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/query/contributor/BlogsEntryModelPreFilterContributor.java}{\texttt{BlogsEntryModelPreFilterContributor}} \\
\texttt{postProcessSearchQuery} & \texttt{KeywordQueryContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/query/contributor/BlogsEntryKeywordQueryContributor.java}{\texttt{BlogsEntryKeywordQueryContributor}} \\
\texttt{getFullQuery} & \texttt{SearchContextContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryModelSearchContextContributor.java}{\texttt{DLFileEntryModelSearchContextContributor}} \\
\texttt{isVisible}/\texttt{isVisibleRelatedEntry} &
\texttt{ModelVisibilityContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/result/contributor/BlogsEntryModelVisibilityContributor.java}{\texttt{BlogsEntryModelVisibilityContributor}} \\
\texttt{getSummary}/\texttt{createSummary}/\texttt{doGetSummary} &
\texttt{ModelSummaryContributor} &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-service/src/main/java/com/liferay/blogs/internal/search/spi/model/result/contributor/BlogsEntryModelSummaryContributor.java}{\texttt{BlogsEntryModelSummaryContributor}} \\
\texttt{Indexer.search}/\texttt{searchCount} & No change &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/blogs/blogs-web/src/main/java/com/liferay/blogs/web/internal/display/context/BlogEntriesDisplayContext.java}{\texttt{BlogEntriesDisplayContext}} \\
\texttt{Indexer.delete}/\texttt{doDelete} & No change &
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/message-boards/message-boards-service/src/main/java/com/liferay/message/boards/service/impl/MBMessageLocalServiceImpl.java\#L703}{\texttt{MBMessageLocalServiceImpl.deleteMessage}} \\
\end{longtable}

\noindent\hrulefill

In addition, you can index \texttt{ExpandoBridge} attributes. This was
previously accomplished in \texttt{BaseIndexer}'s
\texttt{getBaseModelDocument}. Now you implement an
\texttt{ExpandoBridgeRetriever}. See
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/document-library/document-library-service/src/main/java/com/liferay/document/library/internal/search/DLFileEntryExpandoBridgeRetriever.java}{\texttt{DLFileEntryExpandoBridgeRetriever}}
for an example implementation.

\section{Permissions-Aware Searching and
Indexing}\label{permissions-aware-searching-and-indexing}

In previous versions of Liferay DXP, search was only \emph{permissions
aware} (indexed with the entity's permissions and searched with those
permissions intact) if the application developer specified this line in
the \texttt{Indexer} class's constructor:

\begin{verbatim}
setPermissionAware(true);
\end{verbatim}

Now, search is permissions aware by default \emph{if the new permissions
approach}, as described in
\href{/docs/7-2/frameworks/-/knowledge_base/f/defining-application-permissions}{these
tutorials}, is implemented for an application.

\section{Annotating Service Methods to Trigger
Indexing}\label{annotating-service-methods-to-trigger-indexing}

Having objects translated into database entities \emph{and} search
engine documents means that there's a possibility for a state mismatch
between the database and search engine. For example, when a Blogs Entry
is added, updated, or removed from the database, corresponding changes
must be made in the search engine. To do this, intervention must be made
in the service layer. For Service Builder entities, this occurs in the
\texttt{LocalServiceImpl} classes. An annotation simplifies this:
\texttt{@Indexable}. It takes a \texttt{type} property that can have two
values: \texttt{REINDEX} or \texttt{DELETE}. Commonly, a
\texttt{deleteEntity} method in the service layer is annotated like
this:

\begin{verbatim}
@Indexable(type = IndexableType.DELETE)
@Override
@SystemEvent(type = SystemEventConstants.TYPE_DELETE)
public BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {
    ...
}
\end{verbatim}

The \texttt{@Indexable} annotation is executed by Liferay's AOP
infrastructure, so if you have a method with that annotation, you must
call it using a service instance variable injected by your dependency
injector, and not using the \texttt{this} keyword. Whether using OSGi's
Declarative Services (DS) or Spring for dependency injection, there's a
protected variable declared in the superclass
(\texttt{*LocalServiceBaseImpl}) that can be used in the
\texttt{*LocalServiceImpl}, like this.

\begin{verbatim}
blogsEntryLocalService.deleteEntry(entry);
\end{verbatim}

Since you're using the injected service variable, that means you must
not call

\begin{verbatim}
this.deleteEntry(...) 
\end{verbatim}

in your \texttt{*LocalServiceImpl} methods. The annotation won't be
executed and you'll be left with a state mismatch between the search
engine document and the database column.

\section{Search and Localization: a Cheat
Sheet}\label{search-and-localization-a-cheat-sheet}

\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}
is important. Search and localization can play nicely together, if you
take some precautions:

\begin{itemize}
\tightlist
\item
  For each field that should be localized (e.g., \texttt{content}),
  index a separate field for each of the site's languages (e.g.,
  \texttt{content\_en\_US}, \texttt{content\_ja\_JP},
  \texttt{content\_es\_ES}, \ldots).
\item
  Search the localized fields. Whatever you index, that's what you
  should be querying for.
\item
  Don't index content in plain (unlocalized) fields if you expect the
  content to be present in multiple locales.
\item
  Don't index both the plain and the localized field.
\end{itemize}

The indexing and searching articles included in this section demonstrate
how to handle localized fields in the search code properly.

\chapter{Indexing Model Entities}\label{indexing-model-entities}

Model entities are searchable when their data fields are indexed by the
search engine. Search and indexing code relies on Search APIs and SPIs.

The extension points (i.e., the interfaces to implement) in this section
are provided by the \texttt{com.liferay.portal.search.spi} bundle. Calls
are also made to the \texttt{com.liferay.portal.search.api} bundle's
methods.

Here are the Gradle dependencies for Liferay DXP 7.2.0 GA1:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.portal.search.spi", version: "3.2.1"
    compileOnly group: "com.liferay", name: "com.liferay.portal.search.api", version: "3.7.0"
}
\end{verbatim}

\noindent\hrulefill

\textbf{APIs and SPIs:} SPIs are a special type of API. Generally, code
inside a SPI module (e.g., \texttt{portal-search-spi}) is used to
customize existing behavior, while API modules contain behavior you want
to use. Put simply, implement interfaces from an SPI, and consume the
code from the API.

SPI example: \texttt{ModelDocumentContributor} lives in an SPI module
because you're supposed to implement it directly, defining your own
indexing behavior.

API example: \texttt{SearchRequest} lives in an API module because its
behavior is leveraged inside your code to build a search request.

\noindent\hrulefill

\section{Contributing Model Entity Fields to the
Index}\label{contributing-model-entity-fields-to-the-index}

Write a \texttt{ModelDocumentContributor} class to control how model
entity fields are indexed in search engine documents.

\textbf{Extension Point (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/index/contributor/ModelDocumentContributor.java}{\texttt{com.liferay.portal.search.spi.model.index.contributor.ModelDocumentContributor\textless{}T\textgreater{}}}

Declare the Component's \texttt{indexer.class.name} and its service type
as a \texttt{ModelDocumentContributor} class:

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = ModelDocumentContributor.class
)
public class FooEntryModelDocumentContributor
    implements ModelDocumentContributor<FooEntry> {
\end{verbatim}

Implement the \texttt{contribute} method, calling the
\texttt{com.liferay.portal.kernel.Document.add()} method appropriate for
the data type the index should use (e.g., \texttt{addText} for fields
that should be searched using a
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/text.html}{full
text search strategy}).

\begin{verbatim}
@Override
public void contribute(Document document, FooEntry fooEntry) {

    document.addDate(Field.DISPLAY_DATE, fooEntry.getDisplayDate());
    document.addDate(Field.MODIFIED_DATE, fooEntry.getModifiedDate());
    document.addText(Field.SUBTITLE, fooEntry.getSubtitle());
\end{verbatim}

For fields that should be
\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{localized},
index a field for each locale in the Site. Many times you'll want to
localize the title and content fields, for example:

\begin{verbatim}
for (Locale locale :
        LanguageUtil.getAvailableLocales(fooEntry.getGroupId())) {

    String languageId = LocaleUtil.toLanguageId(locale);

    document.addText(
        LocalizationUtil.getLocalizedName(Field.CONTENT, languageId),
        content);
    document.addText(
        LocalizationUtil.getLocalizedName(Field.TITLE, languageId),
        fooEntry.getTitle());
}
\end{verbatim}

The above strategy is a good one: loop through the available locales in
the site, then use
\texttt{com.liferay.portal.kernel.util.LocalizationUtil} to add the
localized field name to the document.

The \texttt{contribute} method is called each time the \texttt{add} and
\texttt{update} methods in the entity's service layer are called.

\section{Configure Re-Indexing and Batch Indexing
Behavior}\label{configure-re-indexing-and-batch-indexing-behavior}

\texttt{ModelIndexerWriterContributor} classes configure the re-indexing
and batch re-indexing behavior for the model entity. This class's
\texttt{customize} method is called when a re-index is triggered from
the Search administrative application found in Control Panel →
Configuration → Search, or when a CRUD operation is made on the entity,
\emph{if} the \texttt{modelIndexed} method is implemented in the
contributor.

\textbf{Extension Point (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/index/contributor/ModelIndexerWriterContributor.java}{\texttt{com.liferay.portal.search.spi.model.index.contributor.ModelIndexerWriterContributor}}

The bulk of the work is in the \texttt{customize} method. This code uses
the actionable dynamic query helper method to retrieve all existing Foo
entities in the virtual instance (identified by the Company ID). If
you're using Service Builder, this query method was generated for you
when you built the services. Each Foo Entry document is then retrieved
and added to a collection.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First set up the component and class declarations:

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = ModelIndexerWriterContributor.class
)
public class FooEntryModelIndexerWriterContributor
    implements ModelIndexerWriterContributor<FooEntry> {
\end{verbatim}
\item
  Write the \texttt{customize} method:

\begin{verbatim}
@Override
public void customize(
    BatchIndexingActionable batchIndexingActionable,
    ModelIndexerWriterDocumentHelper modelIndexerWriterDocumentHelper) {

    batchIndexingActionable.setAddCriteriaMethod(
        dynamicQuery -> {
            Property displayDateProperty = PropertyFactoryUtil.forName(
                "displayDate");

            dynamicQuery.add(displayDateProperty.lt(new Date()));

            Property statusProperty = PropertyFactoryUtil.forName("status");

            Integer[] statuses = {
                WorkflowConstants.STATUS_APPROVED,
                WorkflowConstants.STATUS_IN_TRASH
            };

            dynamicQuery.add(statusProperty.in(statuses));
        });
    batchIndexingActionable.setPerformActionMethod(
        (FooEntry fooEntry) -> {
            Document document =
                modelIndexerWriterDocumentHelper.getDocument(fooEntry);

            batchIndexingActionable.addDocuments(document);
        });
}
\end{verbatim}
\item
  Override \texttt{getBatchIndexingActionable}:

\begin{verbatim}
@Override
public BatchIndexingActionable getBatchIndexingActionable() {
    return _dynamicQueryBatchIndexingActionableFactory.
        getBatchIndexingActionable(
            _fooEntryLocalService.getIndexableActionableDynamicQuery());
}
\end{verbatim}
\item
  Override \texttt{getcompanyId}, getting the ID from your entity:

\begin{verbatim}
@Override
public long getCompanyId(FooEntry fooEntry) {
    return fooEntry.getCompanyId();
}
\end{verbatim}
\item
  Override \texttt{getIndexerWriterMode}:

\begin{verbatim}
@Override
public IndexerWriterMode getIndexerWriterMode(FooEntry fooEntry) {
    int status = fooEntry.getStatus();

    if ((status == WorkflowConstants.STATUS_APPROVED) ||
        (status == WorkflowConstants.STATUS_IN_TRASH) ||
        (status == WorkflowConstants.STATUS_DRAFT)) {

        return IndexerWriterMode.UPDATE;
    }

    return IndexerWriterMode.DELETE;
}
\end{verbatim}

  \texttt{com.liferay.portal.search.spi.model.index.contributor.helper.IndexerWriterMode}
  defines the following index-writing options:

  \begin{itemize}
  \tightlist
  \item
    \texttt{IndexerWriterMode.DELETE}: instructs the search framework to
    delete the given document in the search index without re-creating it
  \item
    \texttt{IndexerWriterMode.PARTIAL\_UPDATE},
    \texttt{IndexerWriterMode.UPDATE}: instructs the search framework to
    update the given document in the search index.
  \item
    \texttt{IndexerWriterMode.SKIP}: instructs the search framework to
    not write anything to the search index.
  \end{itemize}

  The default is \texttt{IndexerWriterMode.UPDATE}.
\item
  Add the services referenced:

\begin{verbatim}
@Reference
private FooEntryLocalService _fooEntryLocalService;

@Reference
private DynamicQueryBatchIndexingActionableFactory
    _dynamicQueryBatchIndexingActionableFactory;
\end{verbatim}
\end{enumerate}

\section{Contribute Fields to Every
Document}\label{contribute-fields-to-every-document}

\texttt{DocumentContributor} classes (without any
\texttt{indexer.class.name} component property or type parameter)
contribute certain fields to every index document, regardless of what
base entity is being indexed. For example, the
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/document/GroupedModelDocumentContributor.java}{\texttt{GroupedModelDocumentContributor}}
contains logic to contribute \texttt{GROUP\_ID} and
\texttt{SCOPE\_GROUP\_ID} fields for all documents with a backing entity
that's also a \texttt{GroupedModel}.

\chapter{Searching the Index for Model
Entities}\label{searching-the-index-for-model-entities}

The heart of searching for your model entity documents is querying for
what you indexed. To do this, contribute search terms to the Liferay DXP
search query.

The extension points (i.e., the interfaces to implement) on this page
are provided by the \texttt{com.liferay.portal.search.spi} bundle.

Here's the Gradle dependency for Liferay DXP 7.2.0 GA1:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay", name: "com.liferay.portal.search.spi", version: "3.2.1"
}
\end{verbatim}

\section{Adding your Model Entity's Terms to the
Query}\label{adding-your-model-entitys-terms-to-the-query}

\texttt{KeywordQueryContributor} classes contribute clauses to the
ongoing search query, to control the way model entities are searched. If
you're storing localized fields in the index (a good idea, as covered in
the example code for your \texttt{ModelDocumentContributor}), query the
localized fields at search time.

\textbf{Extension Point (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/query/contributor/KeywordQueryContributor.java}{com.liferay.portal.search.spi.model.query.contributor.KeywordQueryContributor}

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = KeywordQueryContributor.class
)
public class FooEntryKeywordQueryContributor
    implements KeywordQueryContributor {

    @Override
    public void contribute(
        String keywords, BooleanQuery booleanQuery,
        KeywordQueryContributorHelper keywordQueryContributorHelper) {

        SearchContext searchContext =
            keywordQueryContributorHelper.getSearchContext();

        queryHelper.addSearchLocalizedTerm(
            booleanQuery, searchContext, Field.CONTENT, false);
        queryHelper.addSearchTerm(
            booleanQuery, searchContext, Field.SUBTITLE, false);
        queryHelper.addSearchLocalizedTerm(
            booleanQuery, searchContext, Field.TITLE, false);
    }

    @Reference
    protected QueryHelper queryHelper;

}
\end{verbatim}

The entity in this example has a title, subtitle, and content field. The
subtitle field wasn't stored as a localized field, so it's not searched
that way, either.

\section{Contributing Query Clauses to Every
Search}\label{contributing-query-clauses-to-every-search}

It's a less common need, but to contribute query clauses to every
search, regardless of what base entity is being searched, implement a
\texttt{KeywordQueryContributor} class registered without an
\texttt{indexer.class.name} component property. For example, see
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/query/AlwaysPresentFieldsKeywordQueryContributor.java}{\texttt{AlwaysPresentFieldsKeywordQueryContributor}}.

It includes a String array that includes the fields that are always
searched:

\begin{verbatim}
private static final String[] _ALWAYS_PRESENT_FIELDS = {
    Field.COMMENTS, Field.CONTENT, Field.DESCRIPTION, Field.PROPERTIES,
    Field.TITLE, Field.URL, Field.USER_NAME
};
\end{verbatim}

\section{Pre-Filtering}\label{pre-filtering}

\texttt{*PreFilterContributor} classes control how search results are
filtered before they're returned from the search engine. For example,
adding the workflow status to the query ensures that an entity in the
trash isn't returned in the search results. They're constructed each
time a query for the model entity is made.

\textbf{Extension Pointi (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/query/contributor/ModelPreFilterContributor.java}{\texttt{ModelPreFilterContributor}s}

To contribute filter clauses specific to a model entity, use a
\texttt{ModelPreFilterContributor}. This one adds a filter for workflow
status:

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = ModelPreFilterContributor.class
)
public class FooEntryModelPreFilterContributor
    implements ModelPreFilterContributor {

    @Override
    public void contribute(
        BooleanFilter booleanFilter, ModelSearchSettings modelSearchSettings,
        SearchContext searchContext) {

        addWorkflowStatusFilter(
            booleanFilter, modelSearchSettings, searchContext);
    }

    protected void addWorkflowStatusFilter(
        BooleanFilter booleanFilter, ModelSearchSettings modelSearchSettings,
        SearchContext searchContext) {

        workflowStatusModelPreFilterContributor.contribute(
            booleanFilter, modelSearchSettings, searchContext);
    }

    @Reference(target = "(model.pre.filter.contributor.id=WorkflowStatus)")
    protected ModelPreFilterContributor workflowStatusModelPreFilterContributor;

}
\end{verbatim}

\textbf{Extension Point (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/query/contributor/QueryPreFilterContributor.java}{\texttt{com.liferay.portal.search.spi.model.query.contributor.QueryPreFilterContributor}}

To contribute Filter clauses to every search, regardless of what base
entity is being searched, implement a
\texttt{QueryPreFilterContributor}. \texttt{QueryPreFilterContributor}
is constructed only once under the root filter during a search. For
example, see
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/contributor/query/AssetCategoryTitlesKeywordQueryContributor.java}{\texttt{AssetCategoryTitlesKeywordQueryContributor}}.

What's the difference between \texttt{QueryPreFilterContributor} and
\texttt{ModelPreFilterContributor}? \texttt{QueryPreFilterContributor}
is constructed only once under the root filter during a search, while
\texttt{ModelPreFilterContributor} is constructed once per model entity
and added under each specific entity's sub-filter.

\chapter{Returning Results}\label{returning-results}

When a model entity's indexed search document is obtained during a
search request, it's converted into a summary of the model entity. You
can exert control over your model entity's summary.

\section{Creating a Results Summary}\label{creating-a-results-summary}

\texttt{ModelSummaryContributor} classes get the \texttt{Summary} object
created for each search document, so you can manipulate it by adding
specific fields or setting the length of the displayed content.

\textbf{Extension Pointi (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/result/contributor/ModelSummaryContributor.java}{\texttt{com.liferay.portal.search.spi.model.result.contributor.ModelSummaryContributor}}

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = ModelSummaryContributor.class
)
public class FooEntryModelSummaryContributor
    implements ModelSummaryContributor {

    @Override
    public Summary getSummary(
        Document document, Locale locale, String snippet) {

        String languageId = LocaleUtil.toLanguageId(locale);

        return _createSummary(
            document,
            LocalizationUtil.getLocalizedName(Field.CONTENT, languageId),
            LocalizationUtil.getLocalizedName(Field.TITLE, languageId));
    }

    private Summary _createSummary(
        Document document, String contentField, String titleField) {

        String prefix = Field.SNIPPET + StringPool.UNDERLINE;

        Summary summary = new Summary(
            document.get(prefix + titleField, titleField),
            document.get(prefix + contentField, contentField));

        summary.setMaxContentLength(200);

        return summary;
    }

}
\end{verbatim}

\section{Controlling the Visibility of Model
Entities}\label{controlling-the-visibility-of-model-entities}

\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/result/contributor/ModelVisibilityContributor.java}{\texttt{ModelVisibilityContributor}}
classes control the visibility of model entities that can be attached to
other asset types (for example, File Entries can be attached to Wiki
Pages), in the search context.

\textbf{Extension Point (SPI):}
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/result/contributor/ModelVisibilityContributor.java}{\texttt{com.liferay.portal.search.spi.model.result.contributor.ModelVisibilityContributor}}

\begin{verbatim}
@Component(
    immediate = true,
    property = "indexer.class.name=com.liferay.foo.model.FooEntry",
    service = ModelVisibilityContributor.class
)
public class FooEntryModelVisibilityContributor
    implements ModelVisibilityContributor {

    @Override
    public boolean isVisible(long classPK, int status) {
        try {
            FooEntry entry = fooEntryLocalService.getEntry(classPK);

            return isVisible(entry.getStatus(), status);
        }
        catch (PortalException pe) {
            if (_log.isWarnEnabled()) {
                _log.warn("Unable to check visibility for foo entry ", pe);
            }
        }

        return false;
    }

    protected boolean isVisible(int entryStatus, int queryStatus) {
        if (((queryStatus != WorkflowConstants.STATUS_ANY) &&
             (entryStatus == queryStatus)) ||
            (entryStatus != WorkflowConstants.STATUS_IN_TRASH)) {

            return true;
        }

        return false;
    }

    @Reference
    protected FooEntryLocalService fooEntryLocalService;

    private static final Log _log = LogFactoryUtil.getLog(
        FooEntryModelVisibilityContributor.class);

}
\end{verbatim}

Once you index model entities, add their terms to the Liferay DXP search
query, and get the summary just right, your model entity is ready to be
searched.

\chapter{Search Service Registration}\label{search-service-registration}

The search framework must know about your entity and how to handle it
during a search request. To register model entities with Liferay's
search framework, \texttt{SearchRegistrar}s use the
\href{https://github.com/liferay/liferay-portal/tree/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/registrar}{search
framework's registry} to define certain things about your model entity's
\href{https://github.com/liferay/liferay-portal/blob/7.2.0-ga1/modules/apps/portal-search/portal-search-spi/src/main/java/com/liferay/portal/search/spi/model/registrar/ModelSearchDefinition.java}{\texttt{ModelSearchDefinition}}:
the default fields used to retrieve documents from the search engine,
and the optional search services registered for your entity (for
example, the \texttt{ModelIndexWriterContributor} for you entity).
Registration occurs as soon as the Component is activated (during portal
startup or deployment of the bundle).

A Registrar is required so the container knows about your
implementation.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  First, declare the class a component and create the class declaration:

\begin{verbatim}
@Component(immediate = true, service = {})
public class FooEntrySearchRegistrar {
\end{verbatim}
\item
  Next write the \texttt{activate} method, annotated with the OSGi
  annotation \texttt{@Activate}. On activation of this component, call
  the \texttt{ModelSearchRegistrarHelper.register} method and use the
  call to build out a \texttt{ModelSearchDefinition}:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _serviceRegistration = modelSearchRegistrarHelper.register(
        FooEntry.class, bundleContext,
        modelSearchDefinition -> {
            modelSearchDefinition.setDefaultSelectedFieldNames(
                Field.ASSET_TAG_NAMES, Field.COMPANY_ID, 
                Field.ENTRY_CLASS_NAME, Field.ENTRY_CLASS_PK,
                Field.GROUP_ID, Field.MODIFIED_DATE, Field.SCOPE_GROUP_ID,
                Field.UID);
            modelSearchDefinition.setDefaultSelectedLocalizedFieldNames(
                Field.CONTENT, Field.TITLE);
            modelSearchDefinition.setModelIndexWriteContributor(
                modelIndexWriterContributor);
            modelSearchDefinition.setModelSummaryContributor(
                modelSummaryContributor);
            modelSearchDefinition.setModelVisibilityContributor(
                modelVisibilityContributor);
        });
}
\end{verbatim}

  On activation of the Component, a chain of search and indexing classes
  is registered for the Foo entity. In addition, set the default
  selected field names used to retrieve results documents from the
  search engine. Then set the contributors used to build a model search
  definition.

  In addition to the \texttt{ModelSearchDefinition} setter methods used
  in the above code, there's another to be aware of:

  To select all locales all the time when searching for your model
  entity, pass \texttt{true} to \texttt{setSelectAllLocales}:

\begin{verbatim}
modelSearchDefinition.setSelectAllLocales(true);
\end{verbatim}

  Technically, there's another setter in \texttt{ModelSearchDefinition}
  that takes a boolean,
  \texttt{setSearchResultPermissionFilterSuppressed}. However, this is
  intended for internal consumption.
\item
  Write a corresponding \texttt{deactivate} method:

\begin{verbatim}
@Deactivate
protected void deactivate() {
    _serviceRegistration.unregister();
}
\end{verbatim}
\item
  Get references to the services needed in the class. For the search
  services you're providing, specify them by entering the FQCN of your
  model entity in the reference target's \texttt{indexer.class.name}
  property:

\begin{verbatim}
@Reference(
    target = "(indexer.class.name=com.liferay.foo.model.FooEntry)"
)
protected ModelIndexerWriterContributor<FooEntry>
    modelIndexWriterContributor;

@Reference
protected ModelSearchRegistrarHelper modelSearchRegistrarHelper;

@Reference(
    target = "(indexer.class.name=com.liferay.foo.model.FooEntry)"
)
protected ModelSummaryContributor modelSummaryContributor;

@Reference(
    target = "(indexer.class.name=com.liferay.foo.model.FooEntry)"
)
protected ModelVisibilityContributor modelVisibilityContributor;

private ServiceRegistration<?> _serviceRegistration;
\end{verbatim}
\end{enumerate}

It's quite possible you'll want to write this class after first getting
all the search and indexing logic into place. How can you register a
\texttt{ModelIndexerWriterContributor} if you haven't written one yet?

\chapter{Search Queries and Filters}\label{search-queries-and-filters}

To get sensible results from the search engine, you must provide a
sensible query.

\section{Queries and Filters in Liferay's Search
API}\label{queries-and-filters-in-liferays-search-api}

Elasticsearch and Solr do not make API level distinctions between
queries and filters. In the past, Liferay's API explicitly provided two
sets of APIs, one for queries and one for filters. Both APIs lived in
\texttt{portal-kernel} (the 7.1 source code for filters is
\href{https://github.com/liferay/liferay-portal/tree/7.1.x/portal-kernel/src/com/liferay/portal/kernel/search/filter}{here}).

In 7.0, there's a new way of querying and filtering via Liferay's Search
API, and the APIs for it live in the \texttt{portal-search-api} module.
Instead of calling specific filter APIs, you'll now construct a query
and add it to the search request, specifying it as a filter using the
\texttt{SearchRequestBuilder.postFilterQuery(Query)} method. See the
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/query}{7.2
Query APIs}.

\noindent\hrulefill

\textbf{Note}: Support for the legacy
\texttt{com.liferay.portal.kernel.search.Query.getPreBooleanFilter()} is
only present in the new search request builder and assembler
implementation to allow for backwards compatibility with the
\texttt{Indexer} framework's handling of queries. The older approach
encourages some practices that are not ideal:

\begin{itemize}
\item
  Wrapping a \texttt{BooleanQuery} with another \texttt{BooleanQuery}.
\item
  Some queries shouldn't have filters according to Elasticsearch's API.
\end{itemize}

\noindent\hrulefill

Despite the more unified filtering and querying code, you should
understand the functional difference between filtering and querying:

\emph{Filters} ask a yes or no question for every document. A filter
might ask \emph{is the status field equal to staging or live?}

\emph{Queries} ask the same yes or no question AND how well a document
matches the specified criteria. This is the concept of
\href{https://www.elastic.co/guide/en/elasticsearch/guide/current/scoring-theory.html}{relevance
scoring}. A query might ask \emph{Does the document's content field
field contain the words ``Liferay'', ``Content'', or ``Management'', and
how relevant is the content of the document to the searched keywords?}

\noindent\hrulefill

\textbf{Hint:} Filtering is faster than querying, since the documents
matching a filter can be cached. Queries not only match documents but
also calculate scores. We recommend using filtering and querying
together: filters to reduce the number of matched documents, queries for
the final examination.

\noindent\hrulefill

\section{Supported Query Types}\label{supported-query-types}

Liferay's Search API supports the following types of queries:

\section{Full Text Queries}\label{full-text-queries}

\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/full-text-queries.html}{Full
text queries} are high-level queries usually used for querying full text
fields like the \texttt{content} field of a Blogs Entry. How terms are
matched depends on the query type.

\emph{Supported Full Text Queries}

\begin{verbatim}
CommonTermsQuery
MatchPhraseQuery
MatchPhrasePrefixQuery
MatchQuery
MultiMatchQuery
SimpleStringQuery
StringQuery
\end{verbatim}

Here are some common full text queries:

\begin{itemize}
\tightlist
\item
  Match Query: A full text query, scored by relevance.
\item
  Multi Match Query: Execute a \texttt{MatchQuery} over several fields.
\item
  String Query: Use Lucene query syntax.
\end{itemize}

\section{Term Queries}\label{term-queries}

\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/term-level-queries.html}{Term
queries} look for exact matching on keyword fields and indexed terms.

\begin{verbatim}
ExistsQuery
FuzzyQuery
IdsQuery
PrefixQuery
RangeQuery    
RegexpQuery
TermQuery
TermsQuery
TermRangeQuery
TermsSetQuery
WildcardQuery
\end{verbatim}

Here are some common term queries:

\begin{itemize}
\tightlist
\item
  Wildcard Query: Wildcard (\texttt{*} and \texttt{?}) matching on
  keyword fields and indexed terms
\item
  Fuzzy Query: Scrambles characters in input before matching
\end{itemize}

\section{Compound Queries}\label{compound-queries}

\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/compound-queries.html}{Compound
queries} are often used to wrap other queries. They're commonly used to
switch from query to filter context.

\begin{verbatim}
BooleanQuery
BoostingQuery
ConstantScoreQuery
DisMaxQuery
FunctionScoreQuery
\end{verbatim}

Here are some common compound queries:

\begin{itemize}
\tightlist
\item
  Boolean Query: Allows a combo of several query types. Individual
  queries are as clauses with \texttt{SHOULD} \textbar{} \texttt{MUST}
  \textbar{} \texttt{MUST\_NOT} \textbar{} \texttt{FILTER}
\item
  Constant Score Query: Wraps another query, switches it to filter mode,
  and gives all returned documents a constant relevance score.
\end{itemize}

\section{Joining Queries}\label{joining-queries}

The concept of a join doesn't work well in a distributed index.
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/joining-queries.html}{Joining
queries} allow similar behavior in the search index, such as using the
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/nested.html}{\texttt{nested}
datatype} to index an array of objects that can be queried
independently, using the \texttt{NestedQuery}.

\begin{verbatim}
NestedQuery
\end{verbatim}

Nested Query: Query nested objects as if they each had a separate
document in the index.

\section{Geo Queries}\label{geo-queries}

In Elasticsearch, you can index latitude/longitude pairs and geographic
shapes.
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/geo-queries.html}{Geo
queries} let you query for these points and shapes.

\begin{verbatim}
GeoBoundingBoxQuery
GeoDistanceQuery
GeoDistanceRangeQuery
GeoPolygonQuery
GeoShapeQuery
\end{verbatim}

A common Geo Query is the \texttt{GeoDistanceQuery}, used to find
documents within a certain distance of a geographic point
(latitude/longitude).

\section{Specialized Queries}\label{specialized-queries}

These
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/specialized-queries.html}{queries}
don't fit into another group:

\begin{verbatim}
MoreLikeThisQuery
PercolateQuery
ScriptQuery
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{More Like This:} Use a document to query for similar
  documents.
\item
  \textbf{Percolate:} Match individual documents against indexed queries
  (for alerting to new documents of interest, or automatically
  categorizing documents).
\item
  \textbf{Script:} Filter based on a script.
\end{itemize}

\section{Other Queries}\label{other-queries}

\texttt{MatchAllQuery} Matches all documents in the index.

The proper search query is entirely context- and search engine-specific,
so you should read the Query documentation straight from
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl.html}{Elasticsearch}
or
\href{https://lucene.apache.org/solr/guide/7_1/query-syntax-and-parsing.html}{Solr}
to determine which queries are available and what they do.

All the recommended and supported queries and filters are found in the
\texttt{portal-search-api} module's
\texttt{com.liferay.portal.search.query} and
\texttt{com.liferay.portal.search.filter} packages.

Legacy queries and filters, which are still supported but moving towards
deprecation, are found in the
\texttt{com.liferay.portal.kernel.search.*} packages provided by
\texttt{portal-kernel}.

\section{Using Queries}\label{using-queries}

Here's the generalized approach for querying and filtering search
documents in your own search code:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Instantiate and construct the query object.
\item
  Add the query to the search request---the method you use determines
  whether the context is filtering or querying (or both in the same
  request).
\item
  Execute the search request.
\item
  Process the search response.
\end{enumerate}

These steps are covered in more detail (with examples)
\href{/docs/7-2/frameworks/-/knowledge_base/f/building-search-queries-and-filters}{in
the next article}.

\section{Search Queries in Liferay's
Code}\label{search-queries-in-liferays-code}

The APIs for creating queries are best exemplified in Liferay's own test
cases. For example,
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-search/portal-search-test-util/src/main/java/com/liferay/portal/search/test/util/query/BaseTermsQueryTestCase.java}{BaseTermsQueryTestCase}
constructs a search request containing a \texttt{TermsQuery} using the
\texttt{Queries} API:

\begin{verbatim}
TermsQuery termsQuery = queries.terms(Field.USER_NAME);
\end{verbatim}

This code executes the search request with the terms query constructed
above in a query context.

Other query test cases are also available to reference in the
\texttt{portal-search} module's
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/portal-search/portal-search-test-util/src/main/java/com/liferay/portal/search/test/util/query}{source
code}.

\section{External References}\label{external-references-2}

\begin{itemize}
\tightlist
\item
  \url{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl.html}
\item
  \url{https://lucene.apache.org/solr/guide/7_1/query-syntax-and-parsing.html}
\end{itemize}

\section{Search Engine Connector
Support}\label{search-engine-connector-support-2}

\begin{itemize}
\tightlist
\item
  Elasticsearch 6: Yes
\item
  Solr 7: No* (Only the ``legacy'' query types from
  \texttt{com.liferay.portal.kernel.search.*} are supported as of
  Liferay DXP Beta 2.)
\end{itemize}

\section{New/Related APIs}\label{newrelated-apis-2}

Package \textbar{} Provided by Artifact \textbar{} Notes \textbar{}
\texttt{com.liferay.portal.search.query.*} \textbar{}
com.liferay.portal.search.api \textbar{} Most of the provided
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/query}{query
types} are new as of 7.2 \texttt{com.liferay.portal.search.filter.*}
\textbar{} com.liferay.portal.search.api \textbar{} Some of the provided
\href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/filter}{filter
types} are new as of 7.2

\chapter{Building Search Queries and
Filters}\label{building-search-queries-and-filters}

Each filter and query has a
\href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl.html}{different
purpose}, but the way you'll add the information to the search request
is similar between all queries and filters.

\section{Queries}\label{queries}

A mostly-complete code snippet for building Queries is provided for your
copying and pasting convenience \hyperref[example]{below}.

\section{Declare Gradle Dependencies}\label{declare-gradle-dependencies}

Add the following to your \texttt{build.gradle} file:

\begin{verbatim}
dependencies {
    compileOnly group: "biz.aQute.bnd", name: "biz.aQute.bndlib", version: "3.5.0"
    compileOnly group: "com.liferay.portal", name: "release.portal.api", version: "7.2.0"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

With this you can import all the Search APIs.

\section{Reference the Search
Services}\label{reference-the-search-services}

To satisfy the dependencies of the example code presented here, get
references to

\begin{itemize}
\tightlist
\item
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilderFactory}
\item
  \texttt{com.liferay.portal.search.searcher.Searcher}
\item
  \texttt{com.liferay.portal.search.query.Queries}
\end{itemize}

\begin{verbatim}
@Reference
protected Queries queries;

@Reference
protected Searcher searcher;

@Reference
protected SearchRequestBuilderFactory searchRequestBuilderFactory;
\end{verbatim}

\section{Build the Search Query}\label{build-the-search-query-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use the \texttt{com.liferay.portal.search.query.Queries} interface to
  instantiate the queries you'll construct. For example,

\begin{verbatim}
TermsQuery termsQuery = queries.terms("fieldName");
MatchQuery matchQuery = queries.match("fieldName", "value");
BooleanQuery booleanQuery = queries.booleanQuery();
\end{verbatim}

  To discover what parameters each query must have (e.g.,
  \texttt{String\ field} in the case of the above
  \texttt{com.liferay.portal.search.query.TermsQuery}), see the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-search/portal-search-api/src/main/java/com/liferay/portal/search/query/Queries.java}{\texttt{Queries}}
  interface.
\item
  Build out the queries to get the desired response. This looks
  different for each query type, as explained in
  \href{https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl.html}{Elasticsearch's
  Query documentation}.

\begin{verbatim}
termsQuery.addValues("value1", "value2");
\end{verbatim}
\item
  You might want to wrap queries. For example, use the queries
  constructed above as MUST clauses in a \texttt{BooleanQuery} wrapper:

\begin{verbatim}
booleanQuery.addMustQueryClauses(termsQuery, matchQuery);
\end{verbatim}
\end{enumerate}

Once the query itself is in good shape, feed it to the search request.

\section{Build the Search Request}\label{build-the-search-request}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilderFactory}
  to get an instance of
  \texttt{com.liferay.portal.search.searcher.SearchRequestBuilder}:

\begin{verbatim}
SearchRequestBuilder searchRequestBuilder =
    searchRequestBuilderFactory.builder();
\end{verbatim}

  If not setting search keywords into the \texttt{SearchContext}
  (covered below), make sure the request builder enables empty search.

\begin{verbatim}
searchRequestBuilder.emptySearchEnabled(true);
\end{verbatim}

  Set the \texttt{long\ companyId} and, optionally,
  \texttt{String\ keywords} into the
  \texttt{com.liferay.portal.kernel.search.SearchContext}:

\begin{verbatim}
searchRequestBuilder.withSearchContext(
    searchContext -> {
        searchContext.setCompanyId(companyId);
        searchContext.setKeywords(keywords);
    });
\end{verbatim}

  Setting the Company ID into the \texttt{SearchContext} is required to
  ensure the correct index is searched.

  Setting ``keywords'' on the \texttt{SearchContext} is necessary if you
  want to search via user input. For example, if providing a Search bar
  in an application's view layer, pass its input into the search
  context. Liferay's search framework adds the user input keywords and
  any other data in the \texttt{SearchContext} object to its own
  queries, searching the appropriate fields of each indexed entity, as
  defined by its
  \href{/docs/7-2/frameworks/-/knowledge_base/f/searching-the-index-for-model-entities\#adding-your-model-entitys-terms-to-the-query}{\texttt{KeywordQueryContributor}}
  or by the \texttt{postProcessSearchQuery} method of its
  \texttt{Indexer}.
\item
  To execute the query, get a
  \texttt{com.liferay.portal.search.searcher.SearchRequest} instance
  from the builder by adding the query to it and running its
  \texttt{build} method:

\begin{verbatim}
SearchRequest searchRequest = 
    searchRequestBuilder.query(booleanQuery).build();
\end{verbatim}
\item
  To use a constructed query in a filter context, call the
  \texttt{postFilterQuery} method while building the request:

\begin{verbatim}
SearchRequest searchRequest = 
    searchRequestBuilder.postFilterQuery(termsQuery).build();
\end{verbatim}
\item
  When constructing a search request, you'll often find it necessary to
  chain the builder methods together:

\begin{verbatim}
SearchRequest searchRequest = 
    searchRequestBuilder.postFilterQuery(myQuery1).query(myQuery2).build();
\end{verbatim}

  Chaining allows you to add filters and queries (and anything else from
  the builder API) to the same request in one fell swoop.
\end{enumerate}

\section{Execute the Search Request}\label{execute-the-search-request}

Perform a search using the
\texttt{com.liferay.portal.search.searcher.Searcher} service and the
\texttt{SearchRequest} to get a
\texttt{com.liferay.portal.search.searcher.SearchResponse}:

\begin{verbatim}
SearchResponse searchResponse = searcher.search(searchRequest);
\end{verbatim}

\section{Process the Search Response}\label{process-the-search-response}

What you'll do with the \texttt{SearchResponse} returned by the
\texttt{searcher.search} call is dependent on the type of query and your
specific use case. Much of the time you'll want to loop through the
\texttt{com.liferay.portal.search.hits.SearchHit} and
\texttt{com.liferay.portal.search.document.Document} objects, so that's
what's shown here, with a simple message printed in the log for each
one.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get the \texttt{SearchHits} from the response:

\begin{verbatim}
SearchHits searchHits = searchResponse.getSearchHits();
\end{verbatim}
\item
  Get a List of the \texttt{SearchHit} objects:

\begin{verbatim}
List<SearchHit> searchHitsList = searchHits.getSearchHits();
\end{verbatim}
\item
  Loop through the \texttt{SearchHit} objects in the List, get the
  \texttt{Document} associated with each one, printing its score and UID
  to the console:

\begin{verbatim}
searchHitsList.forEach(
    searchHit -> {
        float hitScore = searchHit.getScore();

        Document doc = searchHit.getDocument();

        String uid = doc.getString(Field.UID);

        System.out.println(
            StringBundler.concat(
                "Document ", uid, " had a score of ", hitScore));
    });
\end{verbatim}
\end{enumerate}

\section{Search Insights: Request and Response
Strings}\label{search-insights-request-and-response-strings}

When building a search application, it can be useful to inspect the
request string (translated into the search engine's dialect), and
subsequently see the response string returned by the search server.

Retrieve these from the \texttt{SearchResponse} as

\begin{verbatim}
searchResponse.getRequestString();
searchResponse.getResponseString();
\end{verbatim}

The format depends on your search engine: with Elasticsearch, both are
JSON.

\noindent\hrulefill

\textbf{Note:} The JSON returned as a request string is pruned from
several Elasticsearch query defaults for clarity. To see the full
request JSON that Elasticsearch processed, adjust the
\href{https://www.elastic.co/guide/en/elasticsearch/reference/6.x/logging.html}{Elasticsearch
server's logging}.

\noindent\hrulefill

Inspecting the request string produced by the code example included
\hyperref[example]{here} reveals two main \texttt{"bool":"must"} query
clauses in the JSON being sent to the search engine:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{BooleanQuery} explicitly declared in the code example.
\item
  A (very long) query determined by the logic embedded in the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/portal-search/portal-search/src/main/java/com/liferay/portal/search/internal/searcher/SearcherImpl.java\#L137}{\texttt{SearcherImpl\#doSearch}}
  method.
\end{enumerate}

How you construct the \texttt{SearchRequest} determines how the
\texttt{Searcher} API processes it, which in turn influences the request
String sent to Elasticsearch. For example, sending \texttt{keywords}
into the \texttt{SearchContext} object passed to the
\texttt{SearchRequest} ensures that queries for certain fields are
executed on all searchable documents.

\section{Queries Example}\label{queries-example}

The code below performs a \texttt{MatchQuery} on the
\texttt{title\_en\_US} field for the value provided via the
\texttt{keywords} String. In addition, a \texttt{TermsQuery} on the
\texttt{folderId} field is executed to match a value of \texttt{0} (root
\texttt{JournalFolder}s are identified by
\texttt{JournalFolderConstants.DEFAULT\_PARENT\_FOLDER\_ID}, which
evaluates to \texttt{0}). Both queries are wrapped in a
\texttt{BooleanQuery} must clause.

Because this example passes \texttt{keywords} to the
\texttt{SearchContext}, \texttt{emptySearchEnabled(true)} is not called
on the \texttt{SearchRequestBuilder}. The \texttt{keywords} variable is
not explicitly declared because this should come from user input.
Therefore the example \texttt{search} method receives \texttt{keywords}
as a parameter, along with the \texttt{companyId}:

\begin{verbatim}
package com.liferay.docs.search;

import com.liferay.petra.string.StringBundler;
import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.search.Field;
import com.liferay.portal.kernel.util.LocaleUtil;
import com.liferay.portal.search.document.Document;
import com.liferay.portal.search.hits.SearchHit;
import com.liferay.portal.search.hits.SearchHits;
import com.liferay.portal.search.query.BooleanQuery;
import com.liferay.portal.search.query.MatchQuery;
import com.liferay.portal.search.query.Queries;
import com.liferay.portal.search.query.TermsQuery;
import com.liferay.portal.search.searcher.SearchRequest;
import com.liferay.portal.search.searcher.SearchRequestBuilder;
import com.liferay.portal.search.searcher.SearchRequestBuilderFactory;
import com.liferay.portal.search.searcher.SearchResponse;
import com.liferay.portal.search.searcher.Searcher;

import java.util.ArrayList;
import java.util.List;

import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

@Component(
    service = MySearchComponent.class
)
public class MySearchComponent {

    public List<String> search(long companyId, String keywords)
        throws PortalException {

        MatchQuery titleQuery = queries.match(
            Field.getLocalizedName(LocaleUtil.US, Field.TITLE), keywords);

        TermsQuery rootFolderQuery = queries.terms(Field.FOLDER_ID);

        rootFolderQuery.addValues(String.valueOf(
                JournalFolderConstants.DEFAULT_PARENT_FOLDER_ID));

        BooleanQuery booleanQuery = queries.booleanQuery();

        booleanQuery.addMustQueryClauses(rootFolderQuery, titleQuery);

        SearchRequestBuilder searchRequestBuilder =
            searchRequestBuilderFactory.builder();

        // Uncomment this line below if you aren't setting "keywords"
        // on the SearchContext
        //      searchRequestBuilder.emptySearchEnabled(true);

        searchRequestBuilder.withSearchContext(
            searchContext -> {
                searchContext.setCompanyId(companyId);
                searchContext.setKeywords(keywords);
            });

        SearchRequest searchRequest = searchRequestBuilder.query(
            booleanQuery
        ).build();

        SearchResponse searchResponse = searcher.search(searchRequest);

        SearchHits searchHits = searchResponse.getSearchHits();

        List<SearchHit> searchHitsList = searchHits.getSearchHits();

        List<String> resultsList = new ArrayList<>(searchHitsList.size());

        searchHitsList.forEach(
            searchHit -> {
                float hitScore = searchHit.getScore();

                Document doc = searchHit.getDocument();

                String uid = doc.getString(Field.UID);

                System.out.println(
                    StringBundler.concat(
                        "Document ", uid, " had a score of ", hitScore));

                resultsList.add(uid);
            });

        System.out.println(StringPool.EIGHT_STARS);

        /*
         *  // Uncomment to inspect the Request and Response Strings
         * System.out.println( "Request String:\n" + searchResponse.getRequestString() +
         * "\n" + StringPool.EIGHT_STARS);
         * System.out.println( "Response String:\n" +
         * searchResponse.getResponseString() + "\n" + StringPool.EIGHT_STARS);
         */

        return resultsList;
    }

    @Reference
    protected Queries queries;

    @Reference
    protected Searcher searcher;

    @Reference
    protected SearchRequestBuilderFactory searchRequestBuilderFactory;

}
\end{verbatim}

\section{Filters}\label{filters}

Filters as a distinct API-level object in Liferay DXP are going away.
It's best to mirror the APIs of the search engine, and neither supported
search engine makes an API level distinction between queries and
filters. In recognition of this, there's a new way to perform
post-filtering, which is filtering the returned search documents at the
end of the search request (after calculating any aggregations). Add the
filter to the query using the \texttt{postFilterQuery} method in the
request builder:

\begin{verbatim}
SearchRequestBuilder.postFilterQuery(Query);
\end{verbatim}

As you can see, this takes a \texttt{Query} object, not a
\texttt{Filter}. Therefore, construct the \texttt{Query} as in the
previous section, and specify it as a post-filter while building the
request. All of the legacy \texttt{Filter} objects from
\texttt{portal-kernel} can now be constructed as queries, per the above
query-building documentation.

\section{Legacy Filters in Legacy Search
Calls}\label{legacy-filters-in-legacy-search-calls}

Constructing the filters found in \texttt{portal-kernel}'s
\texttt{com.liferay.portal.kernel.search.filter} package is demonstrated
by this \texttt{new} term filter:

\begin{verbatim}
TermFilter termFilter = new TermFilter("fieldName", "filterValue");
\end{verbatim}

Filters are added in legacy search calls by going through the
\texttt{Indexer} framework's \texttt{postProcessContextBooleanFilter}
method, which is invoked while the search framework is constructing the
main search query. See the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/users-admin/users-admin-impl/src/main/java/com/liferay/users/admin/internal/search/UserIndexer.java}{\texttt{UserIndexer}'s
\texttt{addContextQueryParams} method}, which is called in the
overridden \texttt{postProcessContextBooleanFilter} to add the filter
logic.

\section{Discovering Indexed Fields}\label{discovering-indexed-fields}

To find the fields to use in your Queries, navigate to \emph{Control
Panel} → \emph{Configuration} → \emph{Search} in a running portal. From
there, open the Field Mappings tab and browse the mappings for the
\texttt{liferay-{[}companyId{]}} index. Scroll to the
\href{https://www.elastic.co/guide/en/elasticsearch/reference/current/properties.html}{\texttt{properties}}
section of the mapping.

A summary of the text fields that are localized can be found
\href{/docs/7-2/user/-/knowledge_base/u/searching-for-localized-content}{here}.

\chapter{Segmentation and
Personalization}\label{segmentation-and-personalization}

Segments are groups of users that are defined by a specific criteria.
You can use the metadata from the user or organization profile, context
information derived from the user's behavior, or some combination of the
two to define that criteria. Alternatively, segments can be a static set
of manually selected members.

In 7.0, the creation of user segments and experience personalization are
now part of the product's core functionality. Up to Liferay DXP 7.1,
this functionality was provided through the Audience Targeting
application. In addition to the administration features of Segmentation
and Personalization, developers can integrate and extend it.

\section{Managing segments}\label{managing-segments}

The API to manage segments is provided by the
\texttt{com.liferay.segments.api\ module}. The
\texttt{SegmentsEntryService} provides the methods to perform permission
aware operations on segments. You can use the provided tools to assign
members to segments and to extend segment criteria.

The \texttt{segmentsEntry} criteria field determines the conditions that
a user must meet to be assigned to the segment. A condition represents a
combination of properties, operations, target values, and conjunctions.
For example, a condition identifying Liferay Engineers for a Segment
might look like this:

\begin{verbatim}
organization name EQUALS Liferay AND Job Title EQUALS Engineer
\end{verbatim}

In the Segments UI, the segments criteria is built using the
\href{/docs/7-2/user/-/knowledge_base/u/the-segment-editor}{Segments
Editor}. The available properties are grouped by topic (e.g.~User,
Organization, Session). Technically, they are called a
\texttt{SegmentsCriteriaContributor}, because they \emph{contribute}
conditions to the segments criteria.

You can see a number of common Segment management operations with
example code in
\href{/docs/7-2/frameworks/-/knowledge_base/f/segment-management}{Segment
Management}.

\section{Extending Segment Criteria}\label{extending-segment-criteria}

The default segment capabilities are robust enough to cover most use
cases, and many types of third party integration can be performed
without developing a code extension. Some cases, like retrieving an
external segment or list can be be handled by using the REST API.

On the other hand, if you want to segment users based on a field
provided from an external source (for example, the number of followers a
user has on Instagram), you can contribute an indexable
\href{/docs/7-2/user/-/knowledge_base/u/custom-fields}{custom field} to
the User entity and query the value using the Expando API. Your new
field is automatically available for its use as a profile-based
criteria.

You must only develop a code extension if you must:

\begin{itemize}
\item
  Add a custom session property. This is done through the
  \texttt{RequestContextContributor}.
\item
  Extend the criteria query with new queries, based either on existing
  model entities or in custom model entities. This is done through the
  \texttt{SegmentsCriteriaContributor}.
\end{itemize}

\section{\texorpdfstring{\texttt{RequestContextContributor}}{RequestContextContributor}}\label{requestcontextcontributor}

User and Organization properties are model-based properties. That means
that the available criteria for users and organizations are based on the
attributes for users and organizations defined by the entities
\texttt{model}. Criteria for model-based entities can be extended by
creating a Custom Field for the corresponding model. Session properties
are context-based properties and can't be extended through custom
fields. To allow for user segmentation based on new context-based
properties, like custom HTTP headers or attributes, you must develop an
extension and deploy it in your Liferay DXP instance.

The default fields available for context-based segmentation can be found
in the Context interface. Liferay generates a context instance with
real-time information for every request. These are mostly obtained from
the \texttt{HttpServletRequest}. The \texttt{RequestContextContributor}
interface provides an extension point for adding a new context-based
property to the Session panel in the Segments criteria editor and
populating the segmentation context with the right value for that field.

The following service properties define a
\texttt{RequestContextContributor}:

\texttt{request.context.contributor.key}: the unique key of the
contributed field.

\texttt{request.context.contributor.type}: the contributor field type
(boolean, date, double, integer, or string{[}default{]}).

The \texttt{contribute} method of the \texttt{RequestContextContributor}
adds the custom field key-value pair to the context.

\begin{figure}
\centering
\includegraphics{./images/request-context-contributor.png}
\caption{Learn more about a \texttt{RequestContextContributor} by
viewing how it's used.}
\end{figure}

To create a \texttt{RequestContextContributor} through the step by step
process, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-request-context-contributor}{Creating
a Request Context Contributor}.

\section{\texorpdfstring{\texttt{SegmentsCriteriaContributor}}{SegmentsCriteriaContributor}}\label{segmentscriteriacontributor}

The \texttt{SegmentsCriteriaContributor} interface provides a mechanism
to extend the segment criteria query. Each
\texttt{SegmentsCriteriaContributor} contributes a sub-query (or
criterion) and the conjunction (AND, OR) to build the complete criteria
query that defines the segment. They also provide a list of Field
elements to be shown in the Segment Editor UI, as depicted in the
figure:

\begin{figure}
\centering
\includegraphics{./images/segment-field-contributor.png}
\caption{Learn more about a \texttt{SegmentsCriteriaContributor} by
viewing how it's used.}
\end{figure}

The following service properties describe a
\texttt{SegmentsCriteriaContributor}:

\texttt{segments.criteria.contributor.key}: the unique key that
identifies the contributor.

\texttt{segments.criteria.contributor.model.class.name}: the entity type
the contributor targets.

\texttt{segments.criteria.contributor.priority}: the order in which the
fields and queries are contributed.

The \texttt{UserOrganizationSegmentsCriteriaContributor} is a good
example of how a \texttt{SegmentsCriteriaContributor} works. It
contributes new organization-related fields (\emph{Organization
Properties}) to the segments criteria editor, executes a query on the
Organization based model, and finally contributes a subquery to the
global user query (AND/OR the user belongs to the organizations found in
the Organization model query). In summary, you can filter users based on
aspects of a different but related entity, such as the organization.

To create a \texttt{SegmentsCriteriaContributor} through the step by
step process, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-a-segment-criteria-contributor}{Creating
Segment Criteria Contributors}.

\chapter{Segment Management}\label{segment-management}

There are a broad array of uses for Segments and ways that you can
integrate them with your application. You'll learn more about how to
manage segments next.

\section{Defining a Segment}\label{defining-a-segment}

This snippet defines a segment by retrieving \texttt{@Reference} objects
from \texttt{SegmentsCriteriaContributor} and instantiating a new
\texttt{Criteria} object. It then adds user criteria using the
\texttt{segmentsEntryService}:

\begin{itemize}
\tightlist
\item
  the user's \texttt{jobTitle} is \texttt{Developer} \textbf{AND}
\item
  the user belongs to an Organization with a name that contains
  \texttt{America}
\end{itemize}

\begin{verbatim}
private void addSegmentWithCriteria() {
    Criteria criteria = new Criteria();

    _userSegmentsCriteriaContributor.contribute(
        criteria, "(jobTitle eq 'Developer')", Criteria.Conjunction.AND);
    _organizationCriteriaContributor.contribute(
        criteria, "contains(name,'America')", Criteria.Conjunction.OR);

    segmentsEntryService.addSegmentsEntry(
        "segment-key", nameMap, descriptionMap, true, CriteriaSerializer.serialize(criteria),
                    User.class.getName(), serviceContext);
}

@Reference(target = "(segments.criteria.contributor.key=organization)")
private SegmentsCriteriaContributor _organizationSegmentsCriteriaContributor;

@Reference(target = "(segments.criteria.contributor.key=user)")
private SegmentsCriteriaContributor _userSegmentsCriteriaContributor;
\end{verbatim}

\section{Manual Segment Member
Assignments}\label{manual-segment-member-assignments}

To define manual user-segment member assignments with the
\texttt{SegmentsEntryRelService}, use a snippet like this:

\begin{verbatim}
segmentsEntryRelService.addSegmentsEntryRel(
    segmentsEntryId, _portal.getClassNameId(User.class), userId, serviceContext)
\end{verbatim}

This assigns a user identified by a \texttt{userId} to a segment
identified by a \texttt{segmentsEntryId}:

\section{Retrieving Segments}\label{retrieving-segments}

Segments and Segment Members can be retrieved programmatically. The code
snippet below retrieves an ordered range of active segments for the
\texttt{User}, within a site identified by a \texttt{groupId}.

\begin{verbatim}
List<SegmentsEntry> segmentsEntries = segmentsEntryService.getSegmentsEntries(groupId, true, User.class.getName(), 0, 10, orderByComparator);
\end{verbatim}

\section{Retrieving segment members}\label{retrieving-segment-members}

The local API to query computed segment-member associations is available
in the \texttt{com.liferay.segments.api\ module}. The
\texttt{SegmentsEntryProvider} service provides methods to obtain the
entities associated to a segment, and the segments associated to an
entity.

This snippet retrieves a range of primary keys of the entities
associated to a segment identified by a \texttt{segmentsEntryId}:

\begin{verbatim}
long[] segmentsEntryClassPKs = segmentsEntryProvider.getSegmentsEntryClassPKs(segmentsEntryId, 0, 10);
\end{verbatim}

To obtain the total count of entities associated to a segment, use the
\texttt{getSegmentsEntryClassPKsCount} method, as shown in the following
snippet:

\begin{verbatim}
int segmentsEntryClassPksCount =
    segmentsEntryProvider.getSegmentsEntryClassPKsCount(segmentsEntryId);
\end{verbatim}

The method \texttt{getSegmentsEntryIds} obtains the reverse association
--- the segments associated to a specific entity. For example, this
snippet returns the segments associated to a user identified by a
\texttt{userId}:

\begin{verbatim}
int segmentsEntryClassPksCount =
    segmentsEntryProvider.getSegmentsEntryIds(User.class.getName(), userId);
\end{verbatim}

Great! You now know how to manage segments!

\chapter{Creating a Request Context
Contributor}\label{creating-a-request-context-contributor}

To better understand the Request Context Contributor, you'll explore how
to create one. First, you'll create the
\texttt{SampleRequestContentContributor} class file, which contains the
\texttt{contribute} method that contributes a new field to the context
with a custom attribute. You can view the
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/segments/segments-context-extension-sample}{full
project on Github}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a new module}.
\item
  Inside the module, create a package named
  \texttt{com.liferay.segments.context.extension.sample.internal.context.contributor}
\item
  Create a Java class named \texttt{SampleRequestContentContributor}.
\item
  Inside the file, insert the \texttt{@Component} declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "request.context.contributor.key=" + SampleRequestContextContributor.KEY,
        "request.context.contributor.type=boolean"
    },
    service = RequestContextContributor.class
)
\end{verbatim}
\item
  Add the class declaration:

\begin{verbatim}
public class SampleRequestContextContributor
    implements RequestContextContributor {

}
\end{verbatim}
\item
  Create the attribute that you're adding. In this case, it's just a
  static string.

\begin{verbatim}
public static final String KEY = "sample";
\end{verbatim}
\item
  Create the \texttt{contribute} method:

\begin{verbatim}
@Override
public void contribute(
    Context context, HttpServletRequest httpServletRequest) {

        context.put(KEY,
        GetterUtil.getBoolean(httpServletRequest.getAttribute("sample.attribute")));
    }
\end{verbatim}
\end{enumerate}

To customize your field label or add a set of selectable options, you
can add an optional \texttt{SegmentsFieldCustomizer} service associated
to your contributed field by its key. Create one now.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the module, create a package named
  \texttt{com.liferay.context.extension.sample.internal.field.customizer}
\item
  Create a Java class named \texttt{SampleSegmentsFieldCustomizer}.
\item
  Inside the file, insert the \texttt{@Component} declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "segments.field.customizer.entity.name=Context",
        "segments.field.customizer.key=" + SampleSegmentsFieldCustomizer.KEY,
        "segments.field.customizer.priority:Integer=50"
    },
    service = SegmentsFieldCustomizer.class
)
\end{verbatim}
\item
  Create the class declaration:

\begin{verbatim}
public class SampleSegmentsFieldCustomizer implements SegmentsFieldCustomizer {

}
\end{verbatim}
\item
  Create the \texttt{KEY} value:

\begin{verbatim}
public static final String KEY = "sample";
\end{verbatim}
\item
  Create the methods to provide a list of fields to be displayed when
  configuring the criteria.

\begin{verbatim}
@Override
public List<String> getFieldNames() {
    return _fieldNames;
}

@Override
public String getKey() {
    return KEY;
}

@Override
public String getLabel(String fieldName, Locale locale) {
        ResourceBundle resourceBundle = ResourceBundleUtil.getBundle(
        "content.Language", locale, getClass());

        return LanguageUtil.get(resourceBundle, "sample-field-label");
}

private static final List<String> _fieldNames = ListUtil.fromArray(
        new String[] {"sample"});
\end{verbatim}
\end{enumerate}

Once you deploy your extensions, the session section of the segment
criteria editor includes your new context-based field.

\begin{figure}
\centering
\includegraphics{./images/context-based-field.png}
\caption{The sample field appears.}
\end{figure}

Great! You've created a Request Context Contributor!

\chapter{Creating a Segment Criteria
Contributor}\label{creating-a-segment-criteria-contributor}

To demonstrate the Segment Criteria Contributor, you'll create a
contributor that segments users based on the title of Knowledge Base
articles they have authored.

The first step is to make your related entity searchable through OData
queries. For this purpose, you must have classes:

\begin{itemize}
\item
  \texttt{EntityModel}: represents your associated entity (in this case,
  the \texttt{KBArticle}) with its fields of interest.
\item
  \texttt{ODataRetriever}: obtains the \texttt{KBArticles} that match a
  given OData query.
\end{itemize}

You can view the
\href{https://github.com/epgarcia/liferay-portal/tree/LPS-86249.criteria.extension.sample.2/modules/apps/segments/segments-criteria-extension-sample}{full
project on Github}.

Follow the instructions below to get started.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module}.
\item
  Create the following packages within the module:

  \begin{itemize}
  \tightlist
  \item
    \texttt{com.liferay.segments.criteria.extension.sample.internal.odata.retreiver}
  \item
    \texttt{com.liferay.segments.criteria.extension.sample.internal.odata.entity}
  \item
    \texttt{com.liferay.segments.criteria.extension.sample.internal.criteria.contributor}
  \end{itemize}
\end{enumerate}

Excellent! You have your module ready. Next, you'll create the entity
model.

\section{Creating the Entity Model}\label{creating-the-entity-model}

First, create the Entity Model for \texttt{KBArticle}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{...internal.odata.entity} package, create the
  \texttt{KBArticleEntityModel} class which implements
  \texttt{EntityModel}:

\begin{verbatim}
public class KBArticleEntityModel implements EntityModel {

}
\end{verbatim}
\item
  Create the key for the entity name:

\begin{verbatim}
public static final String NAME = "KBArticle";
\end{verbatim}
\item
  Create the variable for the entity field map:

\begin{verbatim}
private final Map<String, EntityField> _entityFieldsMap;
\end{verbatim}
\item
  Create the methods to retrieve the \texttt{KBArticleEntity}, entity
  map, and entity name key:

\begin{verbatim}
public KBArticleEntityModel() {
    _entityFieldsMap = Stream.of(
        new StringEntityField("title", locale -> "titleKeyword")
        ).collect(
            Collectors.toMap(EntityField::getName, Function.identity())
        );
}

@Override
public Map<String, EntityField> getEntityFieldsMap() {
    return _entityFieldsMap;
}

@Override
public String getName() {
    return NAME;
}
\end{verbatim}
\end{enumerate}

Next, you'll create the OData Retriever.

\section{\texorpdfstring{Creating the
\texttt{ODataRetriever}}{Creating the ODataRetriever}}\label{creating-the-odataretriever}

Next, create the \texttt{ODataRetriever} which gets the data using the
relevant filter.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{...internal.odata.retreiver} package, create
  \texttt{KBArticleODataRetriever.java} which implements
  \texttt{ODataRetriever}:

\begin{verbatim}
public class KBArticleODataRetriever implements ODataRetriever<KBArticle> {

}
\end{verbatim}
\item
  Add the \texttt{@Component} declaration above the class declaration:

\begin{verbatim}
@Component(
    immediate = true,
    property = "model.class.name=com.liferay.knowledge.base.model.KBArticle",
    service = ODataRetriever.class
)
\end{verbatim}
\item
  Create the \texttt{@Reference} objects that you need for the Filter
  Parser, Knowledge Base Article Service, and OData Search Adapter:

\begin{verbatim}
@Reference
private FilterParserProvider _filterParserProvider;

 @Reference
private KBArticleLocalService _kbArticleLocalService;

@Reference
private ODataSearchAdapter _oDataSearchAdapter;
\end{verbatim}
\item
  Create and instantiate the \texttt{\_entityModel} object for the
  \texttt{KBArticle} model:

\begin{verbatim}
private static final EntityModel _entityModel = new KBArticleEntityModel();
\end{verbatim}
\item
  Create the public methods to retrieve the results and the results
  count from the OData filter:

\begin{verbatim}
@Override
public List<KBArticle> getResults(
        long companyId, String filterString, Locale locale, int start,  int end)
    throws PortalException {

    Hits hits = _oDataSearchAdapter.search(
        companyId, filterString, KBArticle.class.getName(), _entityModel,
            _getFilterParser(), locale, start, end);

    return _getKBArticles(hits);
}

@Override
public int getResultsCount(
        long companyId, String filterString, Locale locale)
    throws PortalException {

    return _oDataSearchAdapter.searchCount(
        companyId, filterString, KBArticle.class.getName(), _entityModel,
            _getFilterParser(), locale);
}
\end{verbatim}
\item
  Create the private methods for instantiating the \texttt{FilterParser}
  and retrieving the Knowledge Base article(s) that meet the criteria:

\begin{verbatim}
private FilterParser _getFilterParser() {
    return _filterParserProvider.provide(_entityModel);
}

private KBArticle _getKBArticle(Document document) throws PortalException {
    long resourcePrimKey = GetterUtil.getLong(
        document.get(Field.ENTRY_CLASS_PK));

    return _kbArticleLocalService.getLatestKBArticle(resourcePrimKey, 0);
}

private List<KBArticle> _getKBArticles(Hits hits) throws PortalException {
    Document[] documents = hits.getDocs();

    List<KBArticle> kbArticles = new ArrayList<>(documents.length);

    for (Document document : documents) {
        kbArticles.add(_getKBArticle(document));
    }

    return kbArticles;
}
\end{verbatim}
\end{enumerate}

You're all set to create the Segments Criteria Contributor!

\section{\texorpdfstring{Creating the
\texttt{SegmentsCriteriaContributor}}{Creating the SegmentsCriteriaContributor}}\label{creating-the-segmentscriteriacontributor}

Now create the \texttt{SegmentsCriteriaContributor} class that consumes
the previous classes to retrieve the articles that match the query
generated by the criteria editor, and contributes a query to filter
users based on the articles they authored.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the \texttt{...internal.criteria.contributor} package, create a
  \texttt{UserKBArticleSegmentCritieriaContributor} class that
  implements \texttt{SegmentsCriteriaContributor}.

\begin{verbatim}
public class UserKBArticleSegmentsCriteriaContributor
    implements SegmentsCriteriaContributor {

}
\end{verbatim}
\item
  Create the \texttt{@Component} declaration to set properties and
  declare the service class.

\begin{verbatim}
@Component(
    immediate = true,
    property = {
        "segments.criteria.contributor.key=" + UserKBArticleSegmentsCriteriaContributor.KEY,
        "segments.criteria.contributor.model.class.name=com.liferay.portal.kernel.model.User",
        "segments.criteria.contributor.priority:Integer=70"
    },
    service = SegmentsCriteriaContributor.class
)
\end{verbatim}
\item
  Create the variables to enable logging, retrieve the entity model, and
  entity key.

\begin{verbatim}
private static final Log _log = LogFactoryUtil.getLog(
    UserKBArticleSegmentsCriteriaContributor.class);

    private static final EntityModel _entityModel = new KBArticleEntityModel();

    public static final String KEY = "user-kb-article";
\end{verbatim}
\item
  Create the reference variables for the OData retriever and Portal
  instance.

\begin{verbatim}
@Reference(
    target = "(model.class.name=com.liferay.knowledge.base.model.KBArticle)"
)

private ODataRetriever<KBArticle> _oDataRetriever;

@Reference
private Portal _portal;
\end{verbatim}
\item
  Create the methods to define the implementation of
  \texttt{SegmentsCriteriaContributor}.

\begin{verbatim}
@Override
public void contribute(
    Criteria criteria, String filterString,
        Criteria.Conjunction conjunction) {

    criteria.addCriterion(getKey(), getType(), filterString, conjunction);

    long companyId = CompanyThreadLocal.getCompanyId();
    String newFilterString = null;

    try {
        StringBundler sb = new StringBundler();

        List<KBArticle> kbArticles = _oDataRetriever.getResults(
            companyId, filterString, LocaleUtil.getDefault(),
            QueryUtil.ALL_POS, QueryUtil.ALL_POS);

        for (int i = 0; i < kbArticles.size(); i++) {
            KBArticle kbArticle = kbArticles.get(i);

            sb.append("(userId eq '");
            sb.append(kbArticle.getUserId());
            sb.append("')");

            if (i < (kbArticles.size() - 1)) {
                sb.append(" or ");
            }
        }

        newFilterString = sb.toString();
    }
    catch (PortalException pe) {
        _log.error(
            com.liferay.petra.string.StringBundler.concat(
                "Unable to evaluate criteria ", criteria, " with filter ",
                filterString, " and conjunction ", conjunction.getValue()),
            pe);
    }

    if (Validator.isNull(newFilterString)) {
        newFilterString = "(userId eq '0')";
    }

    criteria.addFilter(getType(), newFilterString, conjunction);
}

@Override
public EntityModel getEntityModel() {
    return _entityModel;
}

@Override
public String getEntityName() {
    return KBArticleEntityModel.NAME;
}

@Override
public List<Field> getFields(PortletRequest portletRequest) {
    return Collections.singletonList(
        new Field(
            "title",
            LanguageUtil.get(_portal.getLocale(portletRequest), "title"),
            "string"));
}

@Override
public String getKey() {
    return KEY;
}

@Override
public Criteria.Type getType() {
    return Criteria.Type.MODEL;
}
\end{verbatim}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module}.
\end{enumerate}

After deploying your extension, the segment criteria editor includes a
new section containing Knowledge Base properties. Notice that the
section's UI, the properties, and their associated input fields and
operations have been automatically generated based on the information
provided by the extension services. For instance, the Knowledge Base
article title supports \emph{equals}, \emph{not equals},
\emph{contains}, and \emph{not contains} operations because it was
defined as a \texttt{StringEntityField}.

\begin{figure}
\centering
\includegraphics{./images/segment-new-category.png}
\caption{The sample field appears.}
\end{figure}

Awesome! You've created a Segment Criteria Contributor!

\chapter{ServiceContext}\label{servicecontext}

The \texttt{ServiceContext} class holds contextual information for a
service. It aggregates information necessary for features used
throughout Liferay's portlets, such as permissions, tagging,
categorization, and more. This article covers the following
\texttt{ServiceContext} class topics:

\begin{itemize}
\tightlist
\item
  \hyperref[service-context-fields]{Service Context Fields}
\item
  \hyperref[creating-and-populating-a-service-context]{Creating and
  Populating a Service Context in Java}
\item
  \hyperref[creating-and-populating-a-service-context-in-javascript]{Creating
  and Populating a Service Context in JavaScript}
\item
  \hyperref[accessing-service-context-data]{Accessing Service Context
  Data}
\end{itemize}

The \texttt{ServiceContext} fields are first.

\section{Service Context Fields}\label{service-context-fields}

The \texttt{ServiceContext} class has many fields. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/service/ServiceContext.html}{\texttt{ServiceContext}
class Javadoc} describes them.

Here's a categorical listing of some commonly used Service Context
fields:

\begin{itemize}
\tightlist
\item
  Actions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_command}
  \item
    \texttt{\_workflowAction}
  \end{itemize}
\item
  Attributes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_attributes}
  \item
    \texttt{\_expandoBridgeAttributes}
  \end{itemize}
\item
  Classification:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetCategoryIds}
  \item
    \texttt{\_assetTagNames}
  \end{itemize}
\item
  Exception

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_failOnPortalException}
  \end{itemize}
\item
  IDs and Scope:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_companyId}
  \item
    \texttt{\_portletPreferencesIds}
  \item
    \texttt{\_plid}
  \item
    \texttt{\_scopeGroupId}
  \item
    \texttt{\_userId}
  \item
    \texttt{\_uuid}
  \end{itemize}
\item
  Language:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_languageId}
  \end{itemize}
\item
  Miscellaneous:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_headers}
  \item
    \texttt{\_signedIn}
  \end{itemize}
\item
  Permissions:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_addGroupPermissions}
  \item
    \texttt{\_addGuestPermissions}
  \item
    \texttt{\_deriveDefaultPermissions}
  \item
    \texttt{\_modelPermissions}
  \end{itemize}
\item
  Request

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_request}
  \end{itemize}
\item
  Resources:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_assetEntryVisible}
  \item
    \texttt{\_assetLinkEntryIds}
  \item
    \texttt{\_assetPriority}
  \item
    \texttt{\_createDate}
  \item
    \texttt{\_formDate}
  \item
    \texttt{\_indexingEnabled}
  \item
    \texttt{\_modifiedDate}
  \item
    \texttt{\_timeZone}
  \end{itemize}
\item
  URLs, paths and addresses:

  \begin{itemize}
  \tightlist
  \item
    \texttt{\_currentURL}
  \item
    \texttt{\_layoutFullURL}
  \item
    \texttt{\_layoutURL}
  \item
    \texttt{\_pathMain}
  \item
    \texttt{\_pathFriendlyURLPrivateGroup}
  \item
    \texttt{\_pathFriendlyURLPrivateUser}
  \item
    \texttt{\_pathFriendlyURLPublic}
  \item
    \texttt{\_portalURL}
  \item
    \texttt{\_remoteAddr}
  \item
    \texttt{\_remoteHost}
  \item
    \texttt{\_userDisplayURL}
  \end{itemize}
\end{itemize}

Are you wondering how the \texttt{ServiceContext} fields get populated?
Good! You'll learn about that next.

\section{Creating and Populating a Service
Context}\label{creating-and-populating-a-service-context}

Although all the \texttt{ServiceContext} class fields are optional,
services that store data with scope must at least specify the scope
group ID. Here's an example of creating a \texttt{ServiceContext}
instance and passing it as a parameter to a Liferay service API:

\begin{verbatim}
ServiceContext serviceContext = new ServiceContext();
serviceContext.setScopeGroupId(myGroupId);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

If you invoke the service from a servlet, a Struts action, or any other
front-end class with access to the \texttt{PortletRequest}, use one of
the \texttt{ServiceContextFactory.getInstance(...)} methods. These
methods create a \texttt{ServiceContext} object from the request and
automatically populate its fields with all the values specified in the
request. The above example looks different if you invoke the service
from a servlet:

\begin{verbatim}
ServiceContext serviceContext =
    ServiceContextFactory.getInstance(BlogsEntry.class.getName(), portletRequest);

...

_blogsEntryService.addEntry(..., serviceContext);
\end{verbatim}

You can see an example of populating a \texttt{ServiceContext} with
information from a request object in the code of the
\texttt{ServiceContextFactory.getInstance(...)} methods. The methods
demonstrate how to set parameters like \emph{scope group ID},
\emph{company ID}, \emph{language ID}, and more. They also demonstrate
how to access and populate more complex context parameters like
\emph{tags}, \emph{categories}, \emph{asset links}, \emph{headers}, and
the \emph{attributes} parameter. By calling
\texttt{ServiceContextFactory.getInstance(String\ className,\ PortletRequest\ portletRequest)},
you can assure that your Expando bridge attributes are set on the
\texttt{ServiceContext}. Expandos are the back-end implementation of
custom fields for entities in Liferay.

\section{Creating and Populating a Service Context in
JavaScript}\label{creating-and-populating-a-service-context-in-javascript}

Liferay's API can be invoked in languages other than Java. Some methods
require or allow a \texttt{ServiceContext} parameter. If you're invoking
such a method via Liferay's JSON web services, you might want to create
and populate a \texttt{ServiceContext} object in JavaScript. Creating a
\texttt{ServiceContext} object in JavaScript is no different from
creating any other object in JavaScript.

Before examining a JSON web service invocation that uses a
\texttt{ServiceContext} object, it helps to see a simple JSON web
service example in JavaScript:

\begin{verbatim}
Liferay.Service(
    '/user/get-user-by-email-address`,
    {
        companyId: 20101,
        emailAddress: 'test@example.com`
    },
    function(obj) {
        console.log(obj);
    }
);
\end{verbatim}

If you run this code, the \emph{test@example.com} user (JSON object) is
logged to the JavaScript console.

The \texttt{Liferay.Service(...)} function takes three arguments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  A string representing the service being invoked
\item
  A parameters object
\item
  A callback function
\end{enumerate}

The callback function takes the result of the service invocation as an
argument.

The Liferay JSON web services page (its URL is
\url{localhost:8080/api/jsonws} if you're running Liferay locally on
port 8080) generates example code for invoking web services. To see the
generated code for a particular service, click on the name of the
service, enter the required parameters, and click \emph{Invoke}. The
JSON result of your service invocation appears. There are multiple ways
to invoke Liferay's JSON web services: click on \emph{JavaScript
Example} to see how to invoke the web service via JavaScript, click on
\emph{curl Example} to see how to invoke the web service via curl, or
click on \emph{URL example} to see how to invoke the web service via a
URL.

\begin{figure}
\centering
\includegraphics{./images/jsonws-simple-example.png}
\caption{When you invoke a service from Liferay's JSON web services
page, you can view the result of your service invocation as well as
example code for invoking the service via JavaScript, curl, or URL.}
\end{figure}

Next, you'll learn how to access information from a
\texttt{ServiceContext} object.

\section{Accessing Service Context
Data}\label{accessing-service-context-data}

In this section, you'll find code snippets from
\texttt{BlogsEntryLocalServiceImpl.addEntry(...,\ ServiceContext)}. This
code demonstrates how to access information from a
\texttt{ServiceContext} and provides an example of how the context
information can be used.

As mentioned above, services for entities with scope must get a scope
group ID from the \texttt{ServiceContext} object. This is true for the
Blogs entry service because the scope group ID provides the scope of the
Blogs entry (the entity being persisted). For the Blogs entry, the scope
group ID is used in the following way:

\begin{itemize}
\tightlist
\item
  It's used as the \texttt{groupId} for the \texttt{BlogsEntry} entity.
\item
  It's used to generate a unique URL for the blog entry.
\item
  It's used to set the scope for comments on the blog entry.
\end{itemize}

Here are the corresponding code snippets:

\begin{verbatim}
long groupId = serviceContext.getScopeGroupId();

...

entry.setGroupId(groupId);

...

entry.setUrlTitle(getUniqueUrlTitle(entryId, groupId, title));

...

// Message boards

if (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {
    mbMessageLocalService.addDiscussionMessage(
        userId, entry.getUserName(), groupId,
        BlogsEntry.class.getName(), entryId,
        WorkflowConstants.ACTION_PUBLISH);
}
\end{verbatim}

Can \texttt{ServiceContext} be used to access the UUID of the blog
entry? Absolutely! Can you use \texttt{ServiceContext} to set the time
the blog entry was added? You sure can. See here:

\begin{verbatim}
entry.setUuid(serviceContext.getUuid());
...
entry.setCreateDate(serviceContext.getCreateDate(now));
\end{verbatim}

Can \texttt{ServiceContext} be used in setting permissions on resources?
You bet! When adding a blog entry, you can add new permissions or apply
existing permissions for the entry, like this:

\begin{verbatim}
// Resources

if (serviceContext.isAddGroupPermissions() ||
    serviceContext.isAddGuestPermissions()) {

    addEntryResources(
        entry, serviceContext.isAddGroupPermissions(),
        serviceContext.isAddGuestPermissions());
}
else {
    addEntryResources(
        entry, serviceContext.getGroupPermissions(),
        serviceContext.getGuestPermissions());
}
\end{verbatim}

\texttt{ServiceContext} helps apply categories, tag names, and the link
entry IDs to asset entries too. Asset links are the back-end term for
related assets in Liferay.

\begin{verbatim}
// Asset

updateAsset(
    userId, entry, serviceContext.getAssetCategoryIds(),
    serviceContext.getAssetTagNames(),
    serviceContext.getAssetLinkEntryIds());
\end{verbatim}

Does \texttt{ServiceContext} also play a role in starting a workflow
instance for the blogs entry? Must you ask?

\begin{verbatim}
// Workflow

if ((trackbacks != null) && (trackbacks.length > 0)) {
    serviceContext.setAttribute("trackbacks", trackbacks);
}
else {
    serviceContext.setAttribute("trackbacks", null);
}

_workflowHandlerRegistry.startWorkflowInstance(
    user.getCompanyId(), groupId, userId, BlogsEntry.class.getName(),
    entry.getEntryId(), entry, serviceContext);
\end{verbatim}

The snippet above also demonstrates the \texttt{trackbacks} attribute, a
standard attribute for the blogs entry service. There may be cases where
you need to pass in custom attributes to your blogs entry service. Use
Expando attributes to carry custom attributes along in your
\texttt{ServiceContext}. Expando attributes are set on the added blogs
entry like this:

\begin{verbatim}
entry.setExpandoBridgeAttributes(serviceContext);
\end{verbatim}

You can see that the \texttt{ServiceContext} can be used to transfer
lots of useful information for your services. Understanding how
\texttt{ServiceContext} is used in Liferay helps you determine when and
how to use \texttt{ServiceContext} in your own Liferay application
development.

\section{Related Topics}\label{related-topics-119}

\href{/docs/7-2/appdev/-/knowledge_base/a/business-logic-with-service-builder}{Business
Logic with Service Builder}

\href{/docs/7-2/appdev/-/knowledge_base/a/invoking-local-services}{Invoking
Local Services}

\href{/docs/7-2/frameworks/-/knowledge_base/f/web-services}{Web
Services}

\chapter{Injecting Service Components into Integration
Tests}\label{injecting-service-components-into-integration-tests}

Test driven development plays a key role in quality assurance. Liferay's
tooling and integration with standard test frameworks support test
driven development and help you reach quality milestones. You can use
Liferay DXP's \texttt{@Inject} annotation to inject service components
into an integration test, like you use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/declarative-services}{\texttt{@Reference}
annotation to inject service components} into an OSGi component.

\noindent\hrulefill

\textbf{Note:} \href{http://arquillian.org/}{Arquillian} plus
\href{https://junit.org}{JUnit} annotations is one way to develop
integration tests. Liferay lets you use whatever testing framework you
want.

\noindent\hrulefill

Follow these steps to inject a service component into a test class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your test class, add a rule field of
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{type
  \texttt{com.liferay.portal.test.rule.LiferayIntegrationTestRule}}. For
  example,

\begin{verbatim}
@ClassRule
@Rule
public static final AggregateTestRule aggregateTestRule = 
    new LiferayIntegrationTestRule();
\end{verbatim}
\item
  Add a field to hold a service component. Making the field static
  improves efficiency because the container injects static fields once
  before test runs and nulls them after all tests run. Non-static fields
  are injected before each test run but stay in memory till all tests
  finish.
\item
  Annotate the field with an \texttt{@Inject} annotation. By default,
  the container injects the field with a service component object
  matching the field's type.

  \texttt{@Inject} uses reflection to inject a field with a service
  component object matching the field's interface.
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-test-integration/com/liferay/portal/test/rule/LiferayIntegrationTestRule.html}{Test
  rule \texttt{LiferayIntegrationTestRule}} provides the annotation.
\item
  Optionally add a \texttt{filter} string or \texttt{type} parameter to
  further specify the service component object to inject. They can be
  used separately or together.

  To fill a field with a particular implementation or sub-class object,
  set the \texttt{type} with it.

\begin{verbatim}
@Inject(type = SubClass.class)
\end{verbatim}

  Replace \texttt{SubClass} with the name of the service interface to
  inject.
\end{enumerate}

At runtime, the \texttt{@Inject} annotation blocks the test until a
matching service component is available. The block has a timeout and
messages are logged regarding the test's unavailable dependencies.

\noindent\hrulefill

\textbf{Important}: If you're publishing the service component you are
injecting, the test might never run. If you must publish the service
component from the test class, use
\href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{Service
Trackers} to access service components.

\noindent\hrulefill

Here's an example test class that injects a \texttt{DDLServiceUpgrade}
object into an \texttt{UpgradeStepRegistrator} interface field:

\begin{verbatim}
public class Test {

    @ClassRule
    @Rule
    public static final AggregateTestRule aggregateTestRule = 
        new LiferayIntegrationTestRule();

    @Test
    public void testSomething() {
        // your test code here
    }

    @Inject(
        filter = "(&(objectClass=com.liferay.dynamic.data.lists.internal.upgrade.DDLServiceUpgrade))"
    )
    private static UpgradeStepRegistrator _upgradeStepRegistrator;

}
\end{verbatim}

Great! Now you can inject service components into your tests.

\section{Related Topics}\label{related-topics-120}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-a-service-tracker}{Service
  Trackers}
\end{itemize}

\chapter{Upgrade Processes}\label{upgrade-processes}

The development process doesn't end when you first release your
application. Through your own planning, feature requests, and bug
reports, developers improve their applications on a regular basis.
Sometimes, those changes result in changes to the data structure and
underlying database. When users upgrade, they need a process that
transitions them to improved versions of your application. For this, you
must create an upgrade process.

Here's what's involved in creating an upgrade process for your app:

\begin{itemize}
\tightlist
\item
  Specifying the schema version
\item
  Declaring dependencies
\item
  Writing upgrade steps
\item
  Writing the registrator
\item
  Waiting for upgrade completion
\end{itemize}

Liferay has an Upgrade framework you can use to make this easier to do.
It's a feature-rich framework that makes upgrades safe: the system
records the current state of the schema so that if the upgrade fails,
the process can revert the module back to its previous version.
\href{/docs/7-2/reference/-/knowledge_base/r/meaningful-schema-versioning}{Meaningful
schema versioning} is important to clearly communicate the updates to
your users.

Liferay DXP's Upgrade framework executes your module's upgrades
automatically when the new version starts for the first time. You
implement concrete data schema changes in upgrade step classes and then
register them with the upgrade framework using an \emph{upgrade step}
registrator. An upgrade step is a class that adapts module data to the
module's target database schema. It can execute SQL commands and DDL
files to upgrade the data. The Upgrade framework lets you encapsulate
upgrade logic in multiple upgrade step classes per schema version.

The Upgrade framework executes the upgrade steps to update the current
module data to the latest schema. The registrator's \texttt{register}
method informs the Upgrade framework about each new schema and
associated upgrade steps to adapt data to it. Each schema upgrade is
represented by a \emph{registration}. A registration is an abstraction
for all the changes you need to apply to the database from one schema
version to the next one.

Upgrade registrations are defined by the following values:

\begin{itemize}
\tightlist
\item
  \textbf{Module's bundle symbolic name}
\item
  \textbf{Schema version to upgrade from} (as a \texttt{String})
\item
  \textbf{Schema version to upgrade to} (as a \texttt{String})
\item
  \textbf{List of upgrade steps}
\end{itemize}

A registration's upgrade step list can consist of as many upgrade steps
as needed. How you name and organize upgrade steps is up to you.
Liferay's upgrade classes are organized using a package structure
similar to this one:

\begin{itemize}
\tightlist
\item
  \emph{some.package.structure}

  \begin{itemize}
  \tightlist
  \item
    \texttt{upgrade}

    \begin{itemize}
    \tightlist
    \item
      \texttt{v1\_1\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{v2\_0\_0}

      \begin{itemize}
      \tightlist
      \item
        \texttt{UpgradeFoo.java} ← Upgrade Step
      \item
        \texttt{UpgradeBar.java} ← Upgrade Step
      \end{itemize}
    \item
      \texttt{MyCustomModuleUpgrade.java} ← Registrator
    \end{itemize}
  \end{itemize}
\end{itemize}

The example upgrade structure shown above is for a module that has two
database schema versions: \texttt{1.1.0} and \texttt{2.0.0}. They're
represented by packages \texttt{v1\_1\_0} and \texttt{v2\_0\_0}. Each
version package contains upgrade step classes that update the database.
The example upgrade steps focus on fictitious data elements \texttt{Foo}
and \texttt{Bar}. The registrator class (\texttt{MyCustomModuleUpgrade},
in this example) is responsible for registering the applicable upgrade
steps for each schema version.

Here are some organizational tips:

\begin{itemize}
\item
  Put all upgrade classes in a sub-package called \texttt{upgrade}.
\item
  Group together similar database updates (ones that operate on a data
  element or related data elements) in the same upgrade step class.
\item
  Create upgrade steps in sub-packages named after each data schema
  version.
\end{itemize}

The diagram below illustrates the relationship between the registrator
and the upgrade steps.

\begin{figure}
\centering
\includegraphics{./images/data-upgrade-module-upgrade-architecture.png}
\caption{In a registrator class, the developer specifies a registration
for each schema version upgrade. The upgrade steps handle the database
updates.}
\end{figure}

This section covers these topics:

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-upgrade-process-for-your-app}{Creating
  an upgrade process for your app}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes-for-former-service-builder-plugins}{Creating
  upgrade processes for former service builder plugins}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrading-data-schemas-in-development}{Upgrading
  data schemas in development}
\end{itemize}

\chapter{Creating Upgrade Processes for
Modules}\label{creating-upgrade-processes-for-modules}

Follow these steps to create an upgrade process for your module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your module's \texttt{bnd.bnd} file, and specify a
  \texttt{Liferay-Require-SchemaVersion} header with the new schema
  version value. Here's an example schema version header for a module
  whose new schema is version \texttt{1.1}:

\begin{verbatim}
Liferay-Require-SchemaVersion: 1.1
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Important**: If no `Liferay-Require-SchemaVersion` header is specified, 
 Liferay DXP considers the `Bundle-Version` header value to be the database 
 schema version. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  \href{/docs/7-2/customization/-/knowledge_base/c/configuring-dependencies}{Add
  a dependency} on the
  \href{https://repository.liferay.com/nexus/content/repositories/liferay-public-releases/com/liferay/com.liferay.portal.upgrade/}{\texttt{com.liferay.portal.upgrade}
  module}, along with any other modules your upgrade process requires,
  in your your module's dependency management file (e.g., Maven POM,
  Gradle build file, or Ivy \texttt{ivy.xml} file). An example
  configuration for a \texttt{build.gradle} file is shown below:

\begin{verbatim}
compile group: "com.liferay", name: "com.liferay.portal.upgrade.api", version: "2.0.3"
\end{verbatim}
\item
  Create an \texttt{UpgradeProcess} class that extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
  base class} ( which implements the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeStep.html}{\texttt{UpgradeStep}
  interface}):

\begin{verbatim}
public class MyUpgradeSchemaClass extends UpgradeProcess {
  ...
}
\end{verbatim}
\item
  Override the \texttt{UpgradeProcess} class's \texttt{doUpgrade()}
  method with instructions for modifying the database. Use the
  \texttt{runSQL} and \texttt{runSQLTemplate*} methods (inherited from
  the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/dao/db/BaseDBProcess.html}{\texttt{BaseDBProcess}
  class}) to execute your SQL commands and SQL DDL, respectively. If you
  want to create, modify, or drop tables or indexes by executing DDL
  sentences from an SQL file, make sure to use ANSI SQL only. Doing this
  assures the commands work on different databases. If you need to use
  non-ANSI SQL, it's best to write it in the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}
  class's} \texttt{runSQL} or \texttt{alter} methods, along with tokens
  that allow porting the sentences to different databases, as shown in
  journal-service module's
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/journal/journal-service/src/main/java/com/liferay/journal/internal/upgrade/v0_0_4/UpgradeSchema.java}{\texttt{UpgradeSchema}
  upgrade step class} below which uses the \texttt{runSQLTemplateString}
  method to execute ANSI SQL DDL from an SQL file and the \texttt{alter}
  method and
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/upgrade/UpgradeProcess.html}{\texttt{UpgradeProcess}'s}
  \texttt{UpgradeProcess.AlterColumnName} and
  \texttt{UpgradeProcess.AlterColumnType} inner classes as token classes
  to modify column names and column types:

\begin{verbatim}
public class UpgradeSchema extends UpgradeProcess {

  @Override
  protected void doUpgrade() throws Exception {
      String template = StringUtil.read(
          UpgradeSchema.class.getResourceAsStream("dependencies/update.sql"));

      runSQLTemplateString(template, false, false);

      upgrade(UpgradeMVCCVersion.class);

      alter(
          JournalArticleTable.class,
          new AlterColumnName(
              "structureId", "DDMStructureKey VARCHAR(75) null"),
          new AlterColumnName(
              "templateId", "DDMTemplateKey VARCHAR(75) null"),
          new AlterColumnType("description", "TEXT null"));

      alter(
          JournalFeedTable.class,
          new AlterColumnName("structureId", "DDMStructureKey TEXT null"),
          new AlterColumnName("templateId", "DDMTemplateKey TEXT null"),
          new AlterColumnName(
              "rendererTemplateId", "DDMRendererTemplateKey TEXT null"),
          new AlterColumnType("targetPortletId", "VARCHAR(200) null"));
  }
}
\end{verbatim}

  Here's a simpler example upgrade step from the
  \texttt{com.liferay.calendar.service} module. It uses the
  \texttt{alter} method to modify a column type in the calendar booking
  table:

\begin{verbatim}
public class UpgradeCalendarBooking extends UpgradeProcess {

        @Override
        protected void doUpgrade() throws Exception {
                alter(
                        CalendarBookingTable.class,
                        new AlterColumnType("description", "TEXT null"));
        }

}
\end{verbatim}
\item
  If your application was modularized from a former traditional Liferay
  plugin application (application WAR) and it uses Service Builder,
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes-for-former-service-builder-plugins}{create
  and register a Bundle Activator} to register it in Liferay DXP's
  \texttt{Release\_} table.
\item
  Create an \texttt{UpgradeStepRegistrator} OSGi Component class of
  service type \texttt{UpgradeStepRegistrator.class} that implements the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html}{\texttt{UpgradeStepRegistrator}
  interface}:

\begin{verbatim}
package com.liferay.mycustommodule.upgrade;

import com.liferay.portal.upgrade.registry.UpgradeStepRegistrator;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class MyCustomModuleUpgrade implements UpgradeStepRegistrator {


}
\end{verbatim}
\item
  Override the
  \href{https://docs.liferay.com/dxp/apps/foundation/latest/javadocs/com/liferay/portal/upgrade/registry/UpgradeStepRegistrator.html\#register-com.liferay.portal.upgrade.registry.UpgradeStepRegistrator.Registry-}{\texttt{register}
  method} to implement the module's upgrade registrations---abstractions
  for the upgrade steps required to update the database from one schema
  version to the next. For example, the upgrade step registrator class
  \texttt{MyCustomModuleUpgrade} (below) registers three upgrade steps
  incrementally for each schema version (past and present,
  \texttt{0.0.0} to \texttt{2.0.0}, \texttt{1.0.0} to \texttt{1.1.0},
  and \texttt{1.1.0} to \texttt{2.0.0}).

  The first registration is applied if the module hasn't been installed
  previously. It contains only one empty upgrade step:
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-kernel/src/com/liferay/portal/kernel/upgrade/DummyUpgradeStep.java}{new
  \texttt{DummyUpgradeStep}}(). This registration records the module's
  latest schema version (i.e., \texttt{2.0.0}) in Liferay DXP's
  \texttt{Release\_} table. Note that if the same class name is used in
  multiple packages, you must provide the fully qualified class name for
  the class, as shown in the second registration (\texttt{1.0.0} to
  \texttt{1.1.0}) below for the \texttt{UpgradeFoo} class:

\begin{verbatim}
package com.liferay.mycustommodule.upgrade;

import com.liferay.portal.upgrade.registry.UpgradeStepRegistrator;

import org.osgi.service.component.annotations.Component;

@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class MyCustomModuleUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register(
            "com.liferay.mycustommodule", "0.0.0", "2.0.0",
            new DummyUpgradeStep());

        registry.register(
            "com.liferay.mycustommodule", "1.0.0", "1.1.0",
            new com.liferay.mycustommodule.upgrade.v1_1_0.UpgradeFoo());

        registry.register(
            "com.liferay.mycustommodule", "1.1.0", "2.0.0",
            new com.liferay.mycustommodule.upgrade.v2_0_0.UpgradeFoo(),
            new UpgradeBar());
    }

}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Important**: Modules that use Service Builder *should not* define a
 registration for their initial database schema version, as Service Builder
 already records their schema versions to Liferay DXP's `Release_` table. Modules
 that don't use Service Builder, however, *should* define a registration for
 their initial schema. 
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\item
  If your upgrade step uses an OSGi service, \textbf{your upgrade must
  wait for that service's availability}. Use the \texttt{@Reference}
  annotation to declare any classes that the registrator class depends
  on. For example, the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/internal/upgrade/WikiServiceUpgrade.java}{\texttt{WikiServiceUpgrade}
  registrator class} below references the \texttt{SettingsFactory} class
  for the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/wiki/wiki-service/src/main/java/com/liferay/wiki/internal/upgrade/v1_0_0/UpgradePortletSettings.java}{\texttt{UpgradePortletSettings}
  upgrade step}. The \texttt{setSettingsFactory} method's
  \texttt{@Reference} annotation declares that the registrator class
  depends on and must wait for the \texttt{SettingsFactory} service to
  be available in the run time environment:

\begin{verbatim}
@Component(immediate = true, service = UpgradeStepRegistrator.class)
public class WikiServiceUpgrade implements UpgradeStepRegistrator {

    @Override
    public void register(Registry registry) {
        registry.register("0.0.1", "0.0.2", new UpgradeSchema());

        registry.register("0.0.2", "0.0.3", new UpgradeKernelPackage());

        registry.register(
            "0.0.3", "1.0.0", new UpgradeCompanyId(),
            new UpgradeLastPublishDate(), new UpgradePortletPreferences(),
            new UpgradePortletSettings(_settingsFactory), new UpgradeWikiPage(),
            new UpgradeWikiPageResource());

        registry.register("1.0.0", "1.1.0", new UpgradeWikiNode());

        registry.register(
            "1.1.0", "1.1.1",
            new UpgradeDiscussionSubscriptionClassName(
                _subscriptionLocalService, WikiPage.class.getName(),
                UpgradeDiscussionSubscriptionClassName.DeletionMode.ADD_NEW));

        registry.register(
            "1.1.1", "2.0.0",
            new BaseUpgradeSQLServerDatetime(
                new Class<?>[] {WikiNodeTable.class, WikiPageTable.class}));
    }

    @Reference
    private SettingsFactory _settingsFactory;

    @Reference
    private SubscriptionLocalService _subscriptionLocalService;

}
\end{verbatim}
\item
  Upgrade the database to the latest database schema version before
  making its services available. To do this, configure the Bnd header
  \texttt{Liferay-Require-SchemaVersion} to the latest schema version
  for \href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
  Builder} services. For all other services, specify an
  \texttt{@Reference} annotation that targets the containing module and
  its latest schema version.

  Here are the target's required attributes:

  \begin{itemize}
  \tightlist
  \item
    \texttt{release.bundle.symbolic.name}: module's bundle symbolic name
  \item
    \texttt{release.schema.version}: module's current schema version
  \end{itemize}

  For example, the \texttt{com.liferay.comment.page.comments.web}
  module's
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/comment/comment-page-comments-web/src/main/java/com/liferay/comment/page/comments/web/internal/portlet/PageCommentsPortlet.java}{\texttt{PageCommentsPortlet}
  class} upgrades to schema version \texttt{2.0.0} by defining the
  reference below:

\begin{verbatim}
@Reference(
    target = "(&(release.bundle.symbolic.name=com.liferay.comment.page.comments.web)(release.schema.version=2.0.0))"
)
private Release _release;
\end{verbatim}

  Dependencies between OSGi services can reduce the number of service
  classes in which upgrade reference annotations are needed. For
  example, there's no need to add an upgrade reference in a dependent
  service, if the dependency already refers to the upgrade.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note**: Data verifications using the class `VerifyProcess` are deprecated.
 Verifications should be tied to schema versions. Upgrade processes are associated
 with schema versions but `VerifyProcess` instances are not.
\end{verbatim}

\noindent\hrulefill

Great! Now you know how to create data upgrades for all your modules.

\section{Related Topics}\label{related-topics-121}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/upgrade-processes-for-former-service-builder-plugins}{Upgrade
  Processes for Former Service Builder Plugins}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-code-to-product-ver}{Upgrading
  Code to 7.0}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/configurable-applications}{Configurable
  Applications}
\end{itemize}

\chapter{Upgrade Processes for Former Service Builder
Plugins}\label{upgrade-processes-for-former-service-builder-plugins}

If you modularized a traditional Liferay plugin application that
implements Service Builder services, your new modular application must
register itself in the Liferay DXP's \texttt{Release\_} table. This is
required regardless of whether release records already exist for
previous versions of the app. A Bundle Activator is the recommended way
to add a release record for the first modular version of your converted
application.

\textbf{Important}: The steps covered in this article only apply to
modular applications that use Service Builder and were modularized from
traditional Liferay plugin applications. They do not apply to you if
your application doesn't use Service Builder or has never been a
traditional Liferay plugin application (a WAR application).

Bundle Activator class code is dense but straightforward. Referring to
an example Bundle Activator can be helpful. Here's the Liferay Knowledge
Base application's Bundle Activator:

\begin{verbatim}
public class KnowledgeBaseServiceBundleActivator implements BundleActivator {

    @Override
    public void start(BundleContext bundleContext) throws Exception {
        Filter filter = bundleContext.createFilter(
            StringBundler.concat(
                "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
                ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

        _serviceTracker = new ServiceTracker<Object, Object>(
            bundleContext, filter, null) {

            @Override
            public Object addingService(
                ServiceReference<Object> serviceReference) {

                try {
                    BaseUpgradeServiceModuleRelease
                        upgradeServiceModuleRelease =
                            new BaseUpgradeServiceModuleRelease() {

                                @Override
                                protected String getNamespace() {
                                    return "KB";
                                }

                                @Override
                                protected String getNewBundleSymbolicName() {
                                    return "com.liferay.knowledge.base.service";
                                }

                                @Override
                                protected String getOldBundleSymbolicName() {
                                    return "knowledge-base-portlet";
                                }

                            };

                    upgradeServiceModuleRelease.upgrade();

                    return null;
                }
                catch (UpgradeException ue) {
                    throw new RuntimeException(ue);
                }
            }

        };

        _serviceTracker.open();
    }

    @Override
    public void stop(BundleContext bundleContext) {
        _serviceTracker.close();
    }

    private ServiceTracker<Object, Object> _serviceTracker;

}
\end{verbatim}

Follow these steps to create a Bundle Activator:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a class that implements the
  \texttt{org.osgi.framework.BundleActivator} interface:

\begin{verbatim}
public class KnowledgeBaseServiceBundleActivator implements BundleActivator {

}
\end{verbatim}
\item
  Add a service tracker field:

\begin{verbatim}
`private ServiceTracker<Object, Object> _serviceTracker;`
\end{verbatim}
\item
  Override BundleActivator's \texttt{stop} method to close the service
  tracker:

\begin{verbatim}
@Override
public void stop(BundleContext bundleContext) throws Exception {
    _serviceTracker.close();
}
\end{verbatim}
\item
  Override BundleActivator's \texttt{start} method to instantiate a
  service tracker that creates a filter to listen for the app's database
  initialization event and initializes the service tracker to use that
  filter. You'll add the service tracker initialization code in the next
  steps. At the end of the \texttt{start} method, open the service
  tracker.

\begin{verbatim}
@Override
public void start(BundleContext bundleContext) throws Exception {
    Filter filter = bundleContext.createFilter(
        StringBundler.concat(
            "(&(objectClass=", ModuleServiceLifecycle.class.getName(), ")",
            ModuleServiceLifecycle.DATABASE_INITIALIZED, ")"));

    _serviceTracker = new ServiceTracker<Object, Object>(
        bundleContext, filter, null) {
        // See the next step for this code ...
    };

    _serviceTracker.open();
}
\end{verbatim}
\item
  In the service tracker initialization block
  \texttt{\{\ //\ See\ the\ next\ step\ for\ this\ \ \ \ \ \ code\ ...\ \}}
  from the previous step, add an \texttt{addingService} method that
  instantiates a \texttt{BaseUpgradeServiceModuleRelease} for describing
  your app. The example \texttt{BaseUpgradeServiceModuleRelease}
  instance below describes Liferay's Knowledge Base app:

\begin{verbatim}
@Override
public Object addingService(
    ServiceReference<Object> serviceReference) {

    try {
        BaseUpgradeServiceModuleRelease
                upgradeServiceModuleRelease =
            new BaseUpgradeServiceModuleRelease() {

                @Override
                protected String getNamespace() {
                    return "KB";
                }

                @Override
                protected String getNewBundleSymbolicName() {
                    return "com.liferay.knowledge.base.service";
                }

                @Override
                protected String getOldBundleSymbolicName() {
                    return "knowledge-base-portlet";
                }

            };

        upgradeServiceModuleRelease.upgrade();

        return null;
    }
    catch (UpgradeException ue) {
        throw new RuntimeException(ue);
    }
}
\end{verbatim}

  The \texttt{BaseUpgradeServiceModuleRelease} implements the following
  methods:

  \begin{itemize}
  \tightlist
  \item
    \texttt{getNamespace}: Returns the namespace value as specified in
    the former plugin's \texttt{service.xml} file. This value is also in
    the \texttt{buildNamespace} field in the plugin's
    \texttt{ServiceComponent} table record.
  \item
    \texttt{getOldBundleSymbolicName}: Returns the former plugin's name.
  \item
    \texttt{getNewBundleSymbolicName}: Returns the module's symbolic
    name. In the module's \texttt{bnd.bnd} file, it's the
    \texttt{Bundle-SymbolicName} value.
  \item
    \texttt{upgrade}: Invokes the app's upgrade processes.
  \end{itemize}
\item
  In the module's \texttt{bnd.bnd} file, reference the Bundle Activator
  class you created. Here's the example's Bundle Activator reference:

\begin{verbatim}
Bundle-Activator: com.liferay.knowledge.base.internal.activator.KnowledgeBaseServiceBundleActivator
\end{verbatim}
\end{enumerate}

The Bundle Activator uses one of the following values to initialize the
\texttt{schemaVersion} field in the application's \texttt{Release\_}
table record:

\begin{itemize}
\tightlist
\item
  Current \texttt{buildNumber}: if there is an existing
  \texttt{Release\_} table record for the previous plugin.
\item
  \texttt{0.0.1}: if there is no existing \texttt{Release\_} table
  record.
\end{itemize}

Wonderful! You've set your service module's data upgrade process.

\section{Related Topics}\label{related-topics-122}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-upgrade-process-for-your-app}{Creating
  Upgrade Processes for Modules}
\item
  \href{/docs/7-2/tutorials/-/knowledge_base/t/upgrading-code-to-product-ver}{Upgrading
  Code to 7.0}
\end{itemize}

\chapter{Upgrading Data Schemas in
Development}\label{upgrading-data-schemas-in-development}

As you develop modules, you might need to iterate through several
database schema changes. Before you release new module versions with
your finalized schema changes, you must create a formal
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-upgrade-process-for-your-app}{data
upgrade process}. Until then, you can use the Build Auto Upgrade feature
to test schema changes on the fly.

Follow these steps to use the Build Auto Upgrade feature to test schema
changes in development:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a \texttt{portal-ext.properties} file in your app server's
  \texttt{{[}Liferay\_Home{]}/} folder if it doesn't already exist.
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/using-developer-mode-with-themes}{Enable
  Developer Mode in your app server} by adding the following line to the
  properties file:

\begin{verbatim}
include-and-override=portal-developer.properties;
\end{verbatim}

  The Build Auto Upgrade feature is a global property
  \texttt{schema.module.build.auto.upgrade} in the file
  \texttt{{[}Liferay\_Home{]}/portal-developer.properties}, so enabling
  Developer Mode automatically enables this property as well.

  Alternatively, if you prefer not to enable all the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-impl/src/portal-developer.properties}{other
  properties included in Developer Mode}, you can just add the
  \texttt{schema.module.build.auto.upgrade} property to your
  \texttt{portal-ext.properties} file and set it to \texttt{true}:

\begin{verbatim}
schema.module.build.auto.upgrade = true;
\end{verbatim}
\end{enumerate}

Setting the global property \texttt{schema.module.build.auto.upgrade} to
\texttt{true} applies module schema changes for redeployed modules whose
service build numbers have incremented. The \texttt{build.number}
property in the module's \texttt{service.properties} file indicates the
service build number. Build Auto Upgrade executes schema changes without
massaging existing data. It leaves data empty for created columns, drops
data from deleted and renamed columns, and orphans data from deleted and
renamed tables.

Although Build Auto Upgrade updates databases quickly and automatically,
it doesn't guarantee a proper data upgrade--you implement that via
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-upgrade-process-for-your-app}{data
upgrade processes}. Build Auto Upgrade is for development purposes only.

\noindent\hrulefill

\textbf{WARNING}: DO NOT USE the Build Auto Upgrade feature in
production. Liferay DXP DOES NOT support Build Auto Upgrade in
production. Build Auto Upgrade is for development purposes only.
Enabling it in production can result in data loss and improper data
upgrade. In production environments, leave the property
\texttt{schema.module.build.auto.upgrade} in
\texttt{portal-developer.properties} set to \texttt{false}.

\noindent\hrulefill

By default, \texttt{schema.module.build.auto.upgrade} is set to
\texttt{false}. On any module's first deployment, the module's tables
are generated regardless of the
\texttt{schema.module.build.auto.upgrade} value.

The table below summarizes Build Auto Upgrade's handling of schema
changes:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5200}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.4800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Schema Change
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Result
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Add column & Create a new empty column. \\
Rename column & Drop the existing column and delete all its data. Create
a new empty column. \\
Delete column & Drop the existing column and delete all its data. \\
Create or rename a table in Liferay DXP's built-in data source. & Orphan
the existing table and all its data. Create the new table. \\
\end{longtable}

Great! Now you know how to use the Build Auto Upgrade developer feature.

\section{Related Topics}\label{related-topics-123}

\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-an-upgrade-process-for-your-app}{Creating
Data Upgrade Process for Modules}

\chapter{Managing User-Associated Data Stored by Custom
Applications}\label{managing-user-associated-data-stored-by-custom-applications}

Administrators can
\href{/docs/7-2/user/-/knowledge_base/u/managing-user-data}{delete or
anonymize} User Associated Data (UAD) using management tools that aid
compliance efforts with the EU's General Data Protection Regulation
(GDPR). Out of the box, the UAD management tool supports Liferay DXP
applications (Blogs, Documents and Media, etc.), and you can also
anonymize data stored by your custom applications.

This task is made easier for
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder applications}. At the core of the anonymization effort, you must
identify the model entity's fields to anonymize. With Service Builder,
attach anonymization attributes to elements in the \texttt{-service}
module's \texttt{service.xml} file. For the entire DTD for Service
Builder, see
\href{https://docs.liferay.com/portal/7.2-ga1/definitions/}{here}. These
two are the most important attributes for the UAD framework:

\begin{itemize}
\item
  The \texttt{uad-anonymize-field-name=fieldName} attribute indicates a
  field whose value is replaced by that of the anonymous user in the UAD
  deletion process.
\item
  The \texttt{uad-nonanonymizable=true} attribute indicates data that
  cannot be anonymized automatically and must be reviewed by an
  administrator.
\end{itemize}

Once your application uses the UAD framework to manage User data, there
are more features in 7.0 that make searching and deleting User
Associated Data even easier.

\chapter{Adding the UAD Framework to a Service Builder
Application}\label{adding-the-uad-framework-to-a-service-builder-application}

You'll touch two modules of a Service Builder application to implement
the UAD features: the \texttt{-service} module and a brand new module
that Service Builder generates for you, the \texttt{-uad} module.

\section{Update the Service Module}\label{update-the-service-module}

Before you specify your model entity's fields to manage with the UAD
framework, make sure you have the right dependencies.

\section{Include Dependencies}\label{include-dependencies}

To compile the code that Service Builder generates, you need
dependencies on \texttt{com.liferay.petra.String} and
\texttt{com.liferay.portal\ kernel}. Make sure your service module's
\texttt{build.gradle} includes both:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "4.4.0"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "3.0.0"
    ...
}
\end{verbatim}

\section{Choose the Fields to
Anonymize}\label{choose-the-fields-to-anonymize}

In the \texttt{service.xml} file, choose the fields to be handled by the
framework by adding a
\texttt{uad-anonymize-field-name="{[}fieldName{]}"} or
\texttt{uad-nonanonymizable=true}.

For example, to replace the \texttt{userName} field of your custom
entity with the \texttt{fullName} of the anonymous user,

\begin{verbatim}
<column name="userName" type="String" uad-anonymize-field-name="fullName" />
\end{verbatim}

This declaration specifies that the \texttt{content} field cannot be
auto-anonymized by the framework but should be reviewed manually.

\begin{verbatim}
<column name="content" type="String" uad-nonanonymizable="true" />
\end{verbatim}

Run Service Builder. A new module is generated alongside your other
modules, called \texttt{my-app-uad}. It requires a little massaging.

\section{Update the UAD Module}\label{update-the-uad-module}

First, include your dependencies, and then provide your application's
name to the user interface.

\section{Include Dependencies}\label{include-dependencies-1}

The new module is generated without a build script, so you must provide
one. It should include dependencies on
\texttt{osgi.service.component.annotations},
\texttt{com.liferay.portal.kernel}, \texttt{com.liferay.petra.string},
the \texttt{com.liferay.user.associated.data.api}, and your own
application's \texttt{-api} module:

\begin{verbatim}
dependencies {
  compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "4.4.0"
  compileOnly group: "com.liferay", name: "com.liferay.user.associated.data.api", version: "4.1.1"
  compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "3.0.0"
  compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
  compileOnly project(":modules:custom:custom-api")
  }
\end{verbatim}

\section{Provide Your App's Name to the
UI}\label{provide-your-apps-name-to-the-ui}

The simplest way to provide your app's name to the anonymization UI is
to include a language key in your \texttt{Language.properties} file:

\begin{verbatim}
application.name.[Bundle-SymbolicName]=Custom App
\end{verbatim}

The bracketed text is the \texttt{Bundle-SymbolicName} from your
\texttt{-uad} module's \texttt{bnd.bnd} file.

While this approach is recommended, it has one downside: multiple
language keys are used to label a single application. Liferay DXP
applications use the \texttt{com.liferay.lang.merger} plugin to avoid
this. Here's the relevant part of the Blogs application's
\texttt{blogs-uad/build.gradle}:

\begin{verbatim}
apply plugin: "com.liferay.lang.merger"

dependencies {

...

}

mergeLang {
    setting("../blogs-web/src/main/resources/content") {
        transformKey "javax.portlet.title.com_liferay_blogs_web_portlet_BlogsPortlet", "application.name.com.liferay.blogs.uad"
    }

    sourceDirs = ["../blogs-web/src/main/resources/content"]
}
\end{verbatim}

\chapter{Enhancing the Data Erasure
UI}\label{enhancing-the-data-erasure-ui}

As of 7.0, there are new features that enhance an administrator's
experience finding data in the Personal Data Erasure UI:

\begin{description}
\tightlist
\item[\textbf{Filtering}]
User content can now be viewed and acted upon based on whether it is
part of the User's personal Site, some other Site, or the overall
company.
\item[\textbf{Search}]
A search bar now allows for filtering content based on a search term.
\item[\textbf{Hierarchy Display}]
If there are multiple types of content that are related in a hierarchy,
you can define that relationship using a
\texttt{UADHierarchyDeclaration}, and the user interface shows that
hierarchy (e.g.~files and folders).
\end{description}

\section{Filtering and Searching in the Data Erasure
UI}\label{filtering-and-searching-in-the-data-erasure-ui}

To support filtering and searching in your custom entities, implement
three methods in the \texttt{UADDisplay} class (found in your
\texttt{-uad} module):

\begin{itemize}
\tightlist
\item
  \texttt{isSiteScoped}
\item
  \texttt{search}
\item
  \texttt{searchCount}
\end{itemize}

The \texttt{isSiteScoped} method returns a boolean, determining if the
entity can be associated with a particular Site. This is used to
determine which filter they are associated with (``instance'',
``personal-site'', or ``regular-sites'').

\begin{figure}
\centering
\includegraphics{./images/uad-scope-filter.png}
\caption{Items in the Personal Data Erasure screen can be filtered by
scope.}
\end{figure}

The \texttt{search} method takes the following parameters:

\texttt{userId}: The \texttt{userId} of the selected User.

\texttt{groupIds}: An array of \texttt{groupId}s used to filter which
data is shown by which groups it is associated with. In the case that no
\texttt{groupId}s are given (it can be null), the search method should
return data that is not scoped to any given group.

\texttt{keywords}: The contents of the search bar. The search method
should filter by whatever fields are relevant for the given entity.

\texttt{orderByField}: The name of the field used to sort the results.
This is one of the names returned by \texttt{getSortingFieldNames}.

\texttt{orderByType}: Sort the results in ascending order or descending
order (\texttt{asc} or \texttt{desc}), for pagination.

\texttt{start}: The starting index of the result set. For pagination.

\texttt{end}: The ending index of the result set. For pagination.

The \texttt{searchCount} method takes the following parameters, which
are treated identically to the ones in \texttt{search}:

\begin{itemize}
\item
  \texttt{userId}
\item
  \texttt{groupIds}
\item
  \texttt{keywords}
\end{itemize}

Read
\href{/docs/7-2/frameworks/-/knowledge_base/f/filtering-and-searching-uad-marked-entities}{here}
for instructions on how to implement search and filtering for your
entity.

\section{Hierarchy Display}\label{hierarchy-display}

Hierarchical UAD display optionally shows entities with a natural
parent-child relationship (for example, Document Library Folders and
Document Library File Entries). Viewing these entities in a hierarchy
helps administrators make sense of the data they're reviewing for
possible erasure.

\begin{figure}
\centering
\includegraphics{./images/uad-hierarchy.png}
\caption{Hierarchical representation of nested entities is useful for
administrators reviewing User data for possible deletion.}
\end{figure}

To implement a hierarchy display, you must do two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/user-associated-data/user-associated-data-api/src/main/java/com/liferay/user/associated/data/display/UADHierarchyDeclaration.java}{\texttt{UADHierarchyDeclaration}}
  class.
\item
  Add a method to the \texttt{*UADDisplay} class for each type involved
  in the hierarchy.
\end{enumerate}

Once implemented, a hierarchy view is displayed for any of the types
returned in the \texttt{UADHierarchyDeclaration}. For container
entities, a count of all child entities is calculated and displayed
using the hierarchy-related methods in \texttt{UADDisplay}.

\section{UAD Hierarchy Declaration}\label{uad-hierarchy-declaration}

The \texttt{UADHierarchyDeclaration} defines the types in the
hierarchical relationship. There are two classifications for a type in a
hierarchy: a \emph{container}, and a \emph{non-container}. These are
defined by \texttt{getContainerUADDisplays} and
\texttt{getNoncontainerUADDisplays}.

Each returns an array of one or more \texttt{UADDisplay} classes.
Containers can be parents or children in the hierarchy. An example is a
folder in a file system, which can contain both files and other folders.
The non-container entities can only be children in the hierarchy. An
example is a file in a file system.

The \texttt{UADHierarchyDeclaration} provides some other methods for
display purposes.

\begin{itemize}
\item
  A label for the hierarchy is provided through the
  \texttt{getEntitiesTypeLabel} method.
\item
  If any additional information is to be displayed in the table for any
  of the entity types in addition to the count, those column names
  should be returned by \texttt{getExtraColumnNames}. This is optional.
\end{itemize}

See
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/document-library/document-library-uad/src/main/java/com/liferay/document/library/uad/display/DLUADHierarchyDeclaration.java}{\texttt{DLUADHierarchyDeclaration}}
for an example.

\section{Add methods to UADDisplay}\label{add-methods-to-uaddisplay}

Each type involved in the hierarchy should implement some additional
methods in \texttt{UADDisplay}.

These methods must be implemented by containers and non-containers
alike, in the \texttt{*UADDisplay} class:

\texttt{getName} returns a display name for the given entity.

\texttt{getParentContainerClass} returns the class of the type that
contains this type. It can return itself (for example, a folder can
contain a folder).

\texttt{getParentContainerId} returns the primary key of the container
that contains the entity passed to this method.

\texttt{isUserOwned} returns whether or not the given entity is owned by
the user.

Additionally, implement \texttt{getTopLevelContainer} in the
\texttt{*UADDisplay} class for all types classified as
\emph{containers}. It's used to derive the count of how many user-owned
entities are contained inside a given container's tree. It answers the
question ``which type \texttt{T} ancestor of \texttt{childObject} is an
immediate child of the container identified by
\texttt{parentContainerClass} and \texttt{parentContainerId}?'' The
method may return \texttt{null} if \texttt{childObject} is not a child
of the parent container. This method is the most complicated to
implement and requires some consideration for each case. Refer to the
test case for examples of the requirements used for \texttt{DLFolder}:
\href{https://github.com/liferay/liferay-portal/blob/c8f78609353d6a83a0b755b0bbf93764959821ee/modules/apps/document-library/document-library-uad-test/src/testIntegration/java/com/liferay/document/library/uad/display/test/DLFolderUADDisplayTest.java\#L67}{DLFolderUADDisplayTest\#testGetTopLevelContainer}

See the actual implementation for \texttt{DLFolder} in
\href{https://github.com/liferay/liferay-portal/blob/c8f78609353d6a83a0b755b0bbf93764959821ee/modules/apps/document-library/document-library-uad/src/main/java/com/liferay/document/library/uad/display/DLFolderUADDisplay.java\#L105}{DLFolderUADDisplay\#getTopLevelContainer}.

The method returns either \texttt{null} or the container object of type
T that is the top level container of the \texttt{childObject} (which
could be any type of object that is a part of the hierarchy). This
container does not necessarily have to be owned by the user, but is
understood to contain data related to the user. This information is used
to count how much user data is inside the container designated by
\texttt{parentContainerClass} and \texttt{parentContainerId}.

\begin{verbatim}
@Override
public DLFolder getTopLevelContainer(
    Class<?> parentContainerClass, Serializable parentContainerId,
    Object childObject) {

    try {
        DLFolder childFolder = null;

        if (childObject instanceof DLFileEntry) {
            DLFileEntry dlFileEntry = (DLFileEntry)childObject;

            childFolder = dlFileEntry.getFolder();
        }
        else {
            childFolder = (DLFolder)childObject;
        }

        long parentFolderId = (long)parentContainerId;

        if ((childFolder.getFolderId() == parentFolderId) ||
            ((parentFolderId !=
                DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&
             !StringUtil.contains(
                 childFolder.getTreePath(), String.valueOf(parentFolderId),
                 "/"))) {

            return null;
        }

        if (childFolder.getParentFolderId() == parentFolderId) {
            return childFolder;
        }

        List<Long> ancestorFolderIds = childFolder.getAncestorFolderIds();

        if (parentFolderId == DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {
            return get(ancestorFolderIds.get(ancestorFolderIds.size() - 1));
        }

        if (ancestorFolderIds.contains(parentFolderId)) {
            return get(
                ancestorFolderIds.get(
                    ancestorFolderIds.indexOf(parentFolderId) - 1));
        }
    }
    catch (PortalException pe) {
        _log.error(pe, pe);
    }

    return null;
}
\end{verbatim}

The exact implementation details vary for each entity type.

\chapter{Filtering and Searching UAD-Marked
Entities}\label{filtering-and-searching-uad-marked-entities}

In the data erasure UI, it's important that administrators can find what
they're looking for. The native Liferay DXP entities support filtering
and search, and when you follow the steps here, your entities will, too.

To add filtering and searching for your custom entities, implement three
methods in the \texttt{UADDisplay} class (in your application's
\texttt{-uad} module):

\section{Filtering}\label{filtering}

The \texttt{isSiteScoped} method returns a boolean denoting if the
entities can be associated with a particular Site: \texttt{false} if
not, and \texttt{true} if the entities are scoped to a Site. This
determines which filter they are associated with (``instance'',
``personal-site'', or ``regular-sites'').

\begin{verbatim}
@Override
public boolean isSiteScoped() {

    return false;
}
\end{verbatim}

\section{Search}\label{search-1}

Implement the \texttt{search} and \texttt{searchCount} methods to enable
search in the UAD interface:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The \texttt{search} method must return a \texttt{List} of entities
  associated with the \texttt{userId}. For example, you could search the
  database for records associated with the \texttt{userId}:

\begin{verbatim}
@Override
public List<T> search(
    long userId, long[] groupIds, String keywords, String orderByField,
    String orderByType, int start, int end) {

    FooService<T> fooService = getFooService();

    return dummyService.getEntities(userId);
}
\end{verbatim}

  But if you've gone through the trouble of indexing your model entity's
  fields in a search engine, it's more likely you'll want to do the
  initial search, querying for documents matching the \texttt{userId},
  at the search engine level. After the search, retrieve the matching
  entities from the database.

\begin{verbatim}
@Override
public List<T> search(
    long userId, long[] groupIds, String keywords, String orderByField,
    String orderByType, int start, int end) {

    SearchContext searchContext = new SearchContext();

    searchContext.setStart(start);
    searchContext.setEnd(end);
    searchContext.setGroupIds(groupIds);
    searchContext.setKeywords(keywords);

    BooleanQuery booleanQuery = BooleanQueryFactoryUtil.create(
        searchContext);

    booleanQuery.addExactTerm("userId", userId);

    BooleanClause booleanClause = BooleanClauseFactoryUtil.create(
        booleanQuery, BooleanClauseOccur.MUST.getName());

    searchContext.setBooleanClauses(new BooleanClause[] {booleanClause});

    Indexer indexer = IndexerRegistryUtil.getIndexer(FooEntry.class);

    Hits hits = indexer.search(searchContext);

    List<FooEntry> fooEntries = new ArrayList<FooEntry>();

    for (int i = 0; i < hits.getDocs().length; i++) {
            Document doc = hits.doc(i);

            long entryId = GetterUtil
            .getLong(doc.get(Field.ENTRY_CLASS_PK));

            Entry entry = null;

            try {
                    entry = _fooEntryLocalService.getFooEntry(fooEntryId);
            } catch (PortalException pe) {
                    _log.error(pe.getLocalizedMessage());
            } catch (SystemException se) {
                    _log.error(se.getLocalizedMessage());
            }

            fooEntries.add(fooEntry);
    }

    return fooEntries;
}
\end{verbatim}

  It largely boils down to instantiating and populating the search
  context, which gets passed to the \texttt{indexer.search} call to
  retrieve the \texttt{Hits}. Subsequently, populate the \texttt{List}
  by iterating through the \texttt{Hits}, using each one's
  \texttt{ENTRY\_CLASS\_PK} field as the primary key of the entity in
  the call to the entity's getter. The \texttt{BooleanClause}
  construction and inclusion in the search context ensures that all the
  results returned correspond to the \texttt{userId} that's passed to
  this method.
\item
  The \texttt{searchCount} method returns a long of the result
  \texttt{List}'s \texttt{size} method. You could just invoke the
  class's \texttt{search} method, then call the \texttt{List} object's
  \texttt{size} method.

\begin{verbatim}
@Override
public long searchCount(long userId, long[] groupIds, String keywords) {
    List<T> results = search(
        userId, groupIds, keywords, null, null, QueryUtil.ALL_POS,
        QueryUtil.ALL_POS);

    return results.size();
}
\end{verbatim}

  But, again, if the model entity is being indexed in a search engine,
  you can use it to get a count without ever hitting the database. Using
  the \texttt{Hits} object returned from a search (see the code from
  step 1, but don't include \texttt{start} and \texttt{end} parameters
  in the \texttt{SearchContext}), call \texttt{hits.getLegnth()} and you
  get the count, as an \texttt{int}.
\end{enumerate}

Now administrators responsible for complying with GDPR or other data
erasure concerns can search and filter your entity from the Liferay DXP
UAD interface.

\chapter{Web Experience Management}\label{web-experience-management}

Web Experience Management encompasses Liferay's features and tools for
building Sites and creating content. Many of these, like Web Content
Management and Page Templates, are graphical tools used by
administrators and marketers. Others, like Page Fragments, let web
developers flex their muscles in content creation. These articles cover
where web development intersects with user experience and how to use
Liferay's Web Experience frameworks to integrate custom applications
into Liferay DXP.

Specifically, you'll learn about

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{Developing
  Fragments}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/supporting-custom-content-types-in-content-and-display-pages}{Supporting
  Custom Content Types}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/screen-navigation-framework}{Screen
  Navigation}
\end{itemize}

For more information on applying these frameworks for users, see the
\href{/docs/7-2/user/-/knowledge_base/u/web-experience-management}{Web
Experience Management} user articles.

\chapter{Page Fragments}\label{page-fragments}

You can use Page Fragments to take your design vision and accurately
realize it on a web page. You start with a ``blank slate.'' You then
have three tools at your disposal to accomplish your vision:

\textbf{HTML}: The markup of the fragment. Fragments use standard HTML
with special tags to add dynamic behavior.

\textbf{CSS}: Styles and positions the fragment's markup.

\textbf{JavaScript}: Provides dynamic behavior to the fragment.

The HTML, CSS, and JavaScript are all completely standard, but can be
enhanced with Liferay-specific features. You can specify text, images,
and links as editable and provide for ``rich'' text with formatting.

You can also access the FreeMarker templates engine from your HTML using
the
\href{https://freemarker.apache.org/docs/dgui_misc_alternativesyntax.html}{alternative
(square bracket) syntax}. Learn more about available FreeMarker objects
in
\href{/docs/7-2/reference/-/knowledge_base/r/front-end-reference}{Front-end
Reference}.

Liferay portlets can also be embedded in Fragments as widgets, making
pages with Fragments more dynamic than regular web content.

Now you'll step through some Page Fragment basics.

\section{Developing Page Fragments}\label{developing-page-fragments}

There are two types of Page Fragments: \emph{Sections} and
\emph{Components}. A Section defines columns, padding, and spacing on
the page. A Component contains content that is added to a Section.

Fragments are created inside of Collections. Collections provide an easy
way to manage and share groups of related Fragments. Users navigate
Collections when selecting Fragments to add to a page. To see examples,
the admin page shows all the out-of-the-box Fragments (and their code).

You can create and manage Fragments and Collections without using any
external tools, but you can also use your preferred web development
tools. For an explanation of Fragment creation using Liferay's built in
tools, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-fragments}{Creating
a Fragment}.

\section{Making a Fragment
Configurable}\label{making-a-fragment-configurable}

\noindent\hrulefill

\textbf{Note:} Defining configurations for Page Fragments is available
in Liferay DXP 7.2 SP1+ and Liferay Portal GA2+.

\noindent\hrulefill

Page Fragments are also configurable: defining configuration options for
your fragment eliminates having to maintain multiple other fragments
similar in style. For example, if you want a dark background banner and
a light background banner, you can create one banner with a
configuration option for background type.

The following field types are supported for Fragment configurations:

\begin{itemize}
\tightlist
\item
  \texttt{checkbox}
\item
  \texttt{colorPalette}
\item
  \texttt{itemSelector}
\item
  \texttt{select}
\item
  \texttt{text}
\end{itemize}

This is available for all Fragment types (e.g., Fragment Renderer,
etc.).

For more information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/making-a-fragment-configurable}{Making
a Fragment Configurable}.

\section{Fragments CLI}\label{fragments-cli}

To streamline fragment development, 7.0 provides command line tools for
generating, importing, and exporting fragments and fragment collections.
For more information about the CLI, see the
\href{https://github.com/liferay/generator-liferay-fragments/blob/master/README.md}{official
Liferay Fragments CLI project} reference. Using this CLI is also covered
in
\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments-desktop-tools}{Developing
a Fragment using Desktop Tools}.

\section{Contributed Collections}\label{contributed-collections}

Most of the time, Page Fragments are created and imported through the
Page Fragments interface or created directly using the built-in tools.
Any user with the right permissions can update or edit Page Fragments
created like this. You may have certain situations, however, where you
want 100\% static fragments that cannot be modified. In this case you
can create a Contributed Fragment Collection.

Contributed Fragment Collections are deployable modules containing Page
Fragments. Those fragments can be used just like regular fragments, but
are not contained in the database, and cannot be modified except by
updating the module they came from. Use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/creating-contributed-fragment-collection}{Creating
Contributed Collections guide} to learn to create your own Contributed
Collections.

\section{Fragment Specific Tags}\label{fragment-specific-tags}

In addition to standard HTML, CSS, and JavaScript you can use
Liferay-specific tags to make editable sections or embed widgets in your
Fragment.

Editable elements can be modified before publication. This means that
web developers can create simple, reusable fragments that have identical
formatting, but contain elements that are adaptable to the specific
context.

You can make text, images, and links in a fragment editable by using an
\texttt{\textless{}lfr-editable\textgreater{}} tag. The
\texttt{\textless{}lfr-editable\textgreater{}} tag requires a unique
\texttt{id}, a type, and some content of the specified type inside.

The following four \texttt{type} options are available in an
\texttt{lfr-editable} tag:

\texttt{text}: Creates a space for editable plain text.

\texttt{image}: Must contain a valid
\texttt{\textless{}img\textgreater{}} tag which can then be replaced
with an image before publishing---including those from Documents and
Media.

\texttt{rich-text}: Provides rich text formatting, such as bold,
italics, underline, links, and predefined styles.

\texttt{link}: Must contain a valid anchor tag for which the style,
target URL, and link text can be edited before publishing.

The text or images you provide here are the default values for the
fields. You may want to display them in the final version of the page,
or you may want filler text that should be replaced before the page is
published.

All of these work together to help you create dynamic, reusable elements
for building a site. For example, if you need a small text box with an
image and link to provide a product description, you can create a
fragment containing editable filler text, space for an editable image,
the appropriate formatting, and an editable link. That fragment can be
added to multiple pages, and marketers can define the image, text, and
link for each product they need to describe.

You can make a Fragment even more dynamic by including a widget.
Currently, portlets are the only embeddable types of widgets, but other
options are planned.

You can find a complete list and usage examples of these in the
\href{/docs/7-2/reference/-/knowledge_base/r/fragment-specific-tags}{Page
Fragments Reference}.

\section{Recommendations and Best
Practices}\label{recommendations-and-best-practices}

In general all your code should be semantic and highly reusable. A main
concern is making sure that everything is namespaced properly so it
won't interfere with other elements on the page outside of the Fragment.

\section{CSS}\label{css}

While you can write any CSS in a fragment, it's recommended to prefix it
with a class specific to the fragment to avoid impacting other
fragments. To facilitate this, when creating a new fragment, the HTML
includes a \texttt{div} with an automatically generated class name and
the CSS shows a sample selector using that class. Use it as the basis
for all selectors you add.

\section{JavaScript}\label{javascript}

Avoid adding a lot of JavaScript code, since it isn't easily reusable.
Instead, reference external JS libraries.

\chapter{Developing Fragments}\label{developing-fragments}

This tutorial assumes you understand Fragments and Collections. If you
don't, read the
\href{/docs/7-2/user/-/knowledge_base/u/creating-page-fragments}{Creating
Page Fragments} article first. Once, you're ready, start by creating a
Collection:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From the menu for your selected site, click \emph{Site Builder} →
  \emph{Page Fragments}.
\item
  Create a new Collection named \emph{Developing Fragments}.
\end{enumerate}

First, you'll create a \emph{Section}.

\section{Creating a Section}\label{creating-a-section}

The list of Collections appears on the left in the Page Fragments page.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Ensure that you are in the \emph{Developing Fragments} collection.
\item
  Click the \emph{New} button \includegraphics{./images/icon-add.png}
  and select \emph{Section}.
\item
  Name your Section \emph{Basic Section}
\end{enumerate}

You're now on the Fragment editing page. There are four panes on this
screen. You enter HTML in the top left pane, CSS in the top right,
JavaScript in the bottom left, and preview the results in the bottom
right. The Fragment Editor even comes with autocomplete functionality!

\begin{figure}
\centering
\includegraphics{./images/fragment-editor-autocomplete.png}
\caption{The Fragment editor provides autocomplete for Liferay Fragment
specific tags.}
\end{figure}

You can look at the three editing panes as if each were writing to a
separate file. Everything in the HTML pane goes to \texttt{index.html},
the CSS pane goes to \texttt{index.css}, and the JavaScript pane goes to
\texttt{index.js}. The preview pane renders everything as it looks on
the page.

\noindent\hrulefill

\textbf{Warning:} Including images inline in base64 in your Page
Fragments can increase publishing, import, and export times for pages
using those Fragments. Use
\href{/docs/7-2/frameworks/-/knowledge_base/f/including-default-resources-in-fragments}{references
to resources} in your Page Fragments instead.

\noindent\hrulefill

A Section defines a work space. Now create a section with an editable
rich text area where content can be entered:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the following code inside the HTML pane:

\begin{verbatim}
<div class="banner py-6 py-md-8 text-white" data-lfr-background-image-id="banner">
    <div class="container my-lg-6">
        <div class="row">
            <div class="col-12 col-md-8 col-xl-6">
                <h1>
                    <lfr-editable id="01-title" type="rich-text">
                        Banner Title Example
                    </lfr-editable>
                </h1>

                <div class="mb-4 lead">
                    <p>
                        <lfr-editable id="02-subtitle" type="rich-text">
                            This is a simple banner component that you can use must provide extra information.
                        </lfr-editable>
                    </p>
                </div>

                <lfr-editable id="03-link" type="link">
                    <a href="#" class="btn btn-primary">Go Somewhere</a>
                </lfr-editable>
            </div>
        </div>
    </div>
</div>
\end{verbatim}
\item
  Replace the code in the CSS pane with the following:

\begin{verbatim}
.banner {
    background-color:#415fa9;
    background-position: center;
    background-size: cover;
}
\end{verbatim}
\item
  Click \emph{Publish} to save your work and make it available to add to
  a content page.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} When you start typing the name of a tag, the HTML editor
provides auto-completion for \texttt{lfr} tags like editable elements
and embeddable widgets.

\noindent\hrulefill

As you work, you can observe your changes in the preview pane.

\begin{figure}
\centering
\includegraphics{./images/fragment-editor-basic.png}
\caption{The Fragment editor with HTML and CSS code and a live preview.}
\end{figure}

\section{Creating a Component}\label{creating-a-component}

Components are simple, reusable elements for building parts of a page.
Next create a button with a link as a Component:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go back to the \emph{Site Builder} → \emph{Page Fragments} page and
  select the \emph{Developing Fragments} Collection.
\item
  Click the \emph{New} button \includegraphics{./images/icon-add.png}
  and select \emph{Component}.
\item
  Name it \emph{Basic Component}.
\item
  Back in the editor, add the following code inside the HTML pane:

\begin{verbatim}
<div class="basic-link-button">
    <lfr-editable id="btn00" type="link">
        <a href="#" class="btn btn-primary">Read More</a>
    </lfr-editable>
</div>
\end{verbatim}
\item
  Click \emph{Publish} to save your work and make it available to add to
  a content page.
\end{enumerate}

This fragment did not require any CSS. For the button link, no target is
provided by default, so the link must be configured when it is added to
the page.

From here, the Fragment can be added to a Page. To see this process in
action, see the
\href{/docs/7-2/user/-/knowledge_base/u/building-content-pages}{Building
Content Pages} article.

\chapter{Making a Fragment
Configurable}\label{making-a-fragment-configurable-1}

\noindent\hrulefill

\textbf{Note:} Defining configurations for Page Fragments is available
in Liferay DXP 7.2 SP1+ and Liferay Portal GA2+.

\noindent\hrulefill

Defining configuration options for a Fragment gives it more flexibility,
reducing the number of Fragments you must maintain. To make a Fragment
configurable,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the \emph{Site Builder} → \emph{Page Fragments} page.
\item
  Click the \emph{Actions} button
  (\includegraphics{./images/icon-actions.png}) → \emph{Edit} for the
  Fragment (Section or Component) you want to make configurable.
\item
  Select the \emph{Configuration} tab at the top of the page.

  \begin{figure}
  \centering
  \includegraphics{./images/fragment-config-tab.png}
  \caption{Switch from the Code tab to the Configuration tab to create
  your configuration logic.}
  \end{figure}
\item
  In the editor, add your JSON code. This code is added to your
  fragment's \texttt{index.json} file. For example, the code below
  provides the \texttt{select} option to choose \emph{dark} or
  \emph{light} for a Fragment's heading:

\begin{verbatim}
{
    "fieldSets": [
        {
            "label": "heading",
            "fields": [
                {
                    "name": "headingAppliedStyle",
                    "label": "applied-style",
                    "description": "this-is-the-style-that-will-be-applied",
                    "type": "select",
                    "dataType": "string",
                    "typeOptions": {
                        "validValues": [
                            {
                                "value": "dark"
                            },
                            {
                                "value": "light"
                            }
                        ]
                    },
                    "defaultValue": "light"
                }
            ]
        }
    ]
}
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The `label` property is optional. If it's left out, your
 configuration option has no title.
\end{verbatim}

\noindent\hrulefill

\noindent\hrulefill

\begin{verbatim}
 **Note:** If your configuration is invalid, you can't save the
 code. Be sure to always have a valid JSON configuration before previewing
 or saving it.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
The configuration values selected by the user are made available to the
Fragment developer through the FreeMarker context. A configuration value can
be referenced using the notation `${configuration.[fieldName]}`. For the
example snippet above, `${configuration.headingAppliedStyle}` returns
`dark` or `light` depending on the configuration value selected by the user.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  You can refer to your Fragment's configuration values in its HTML file
  (e.g., \texttt{index.html}). Navigate back to the \emph{Code} tab at
  the top of the page and add your HTML. For example,

\begin{verbatim}
[#if configuration.headingAppliedStyle == 'dark']
...
[#else]
...
[/#if]
\end{verbatim}

  Configuration values inserted into the FreeMarker context honor the
  defined \texttt{datatype} value specified in the JSON file. Therefore,
  for this example,
  \texttt{configuration.headingAppliedStyle?is\_string} is
  \texttt{true}.
\item
  Click \emph{Publish} to save your work and make it available to add to
  a Content Page.

  \begin{figure}
  \centering
  \includegraphics{./images/fragment-lang-keys.png}
  \caption{You can click your Fragment to view its configuration
  options.}
  \end{figure}
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} You can also make a Fragment configurable by leveraging
the Fragments Toolkit. You can create/modify the Fragment's
configuration JSON file and then reimport the Fragment to your Liferay
instance. For more information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments-desktop-tools}{Page
Fragment Desktop Tools}.

\noindent\hrulefill

Although this example highlights accessing configuration values in HTML
via the FreeMarker context, you can also access these values via
JavaScript. JavaScript configuration objects are named the same as their
FreeMarker counterparts.

For example, a configuration object could be built like this:

\begin{verbatim}
var configuration = {
    field1: value1,
    field2: value2
}
\end{verbatim}

Another example of setting the configuration object and using it is
shown below:

\begin{verbatim}
const configurationValue = configuration.field1

console.log(configurationValue);
\end{verbatim}

For more examples of Fragment configuration, see
\href{/docs/7-2/reference/-/knowledge_base/r/fragment-configuration-types}{Fragment
Configuration Types}.

Awesome! You now have a configurable Fragment!

\chapter{Managing Fragments and
Collections}\label{managing-fragments-and-collections}

After you create Collections and Fragments, you have a handful of
options for managing them. You'll explore several management options
next.

\section{Collections Management Menu}\label{collections-management-menu}

To access the collections management menu,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the Collection you want to manage from the \emph{Collections}
  list.
\item
  Click on the \includegraphics{./images/icon-actions.png} menu next to
  the collection name.
\item
  Select whether you want to \emph{Edit}, \emph{Export}, \emph{Import},
  or \emph{Delete} the collection.

  \textbf{Edit}: change the name or description for the collection.

  \textbf{Export}: download a \texttt{.zip} file containing the full
  collection.

  \textbf{Import}: select a \texttt{.zip} file to upload with additional
  Fragments.

  \textbf{Delete}: remove the current collection and all of its
  contents.
\end{enumerate}

Next, you'll learn about the Fragment Management Menu.

\section{Fragment Management Menu}\label{fragment-management-menu}

To access the fragment management menu,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Select the Collection containing the Fragment you want to manage from
  the \emph{Collections} list.
\item
  Click on the \includegraphics{./images/icon-actions.png} menu next to
  the Fragment name.
\item
  Select whether you want to \emph{Edit}, \emph{Rename}, \emph{Move},
  \emph{Make a Copy}, \emph{Change Thumbnail} \emph{Export}, or
  \emph{Delete}.
\end{enumerate}

Did you know you can enable automatic propagation for Fragments? You'll
do this next.

\section{Propagating Fragment Changes
Automatically}\label{propagating-fragment-changes-automatically}

\noindent\hrulefill

\textbf{Note:} Propagating Fragment changes is available in Liferay DXP
7.2 SP1+ and Liferay Portal GA2+.

\noindent\hrulefill

By default, when a Fragment developer makes a change to an existing
fragment, the change is not automatically propagated to the pages that
were using it. This gives marketers and page authors more control over
the pages they own, avoiding unexpected changes. For example, if three
pages were using the same Fragment, an update to the Fragment could
introduce unintended changes to some of the pages using it. While this
is a safeguard for the production environment, developers must
\href{/docs/7-2/user/-/knowledge_base/u/propagation-of-changes}{manually
propagate Fragment changes} during testing, which can be tedious. To
give developers more freedom, you can enable automatic propagation for
Fragment changes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the Control Panel → \emph{Configuration} → \emph{System
  Settings} → \emph{Page Fragments}.
\item
  Enable the checkbox \emph{Propagate Fragment Changes Automatically}.
\item
  Click \emph{Save}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/fragment-propagation.png}
\caption{Once Fragment propagation is enabled, developers can
automatically propagate Fragment changes to all pages using them.}
\end{figure}

Great! You've enabled Fragment propagation system wide! Now when a
developer publishes a Fragment, the changes apply immediately to all
Content Pages, Content Page Templates, and Display Page Templates using
it, overwriting existing Fragment code. Automatic propagation works only
for HTML, CSS, and JS Fragment code, not the editable values.

\noindent\hrulefill

\textbf{Note:} It's recommended to only leverage this functionality
during testing, as automatic propagation on the production environment
can cause unintended consequences.

\noindent\hrulefill

When using the Fragment Editor, you're now notified that automatic
Fragment propagation is enabled.

\begin{figure}
\centering
\includegraphics{./images/fragment-propagation-info.png}
\caption{You're notified when automatic propagation is enabled.}
\end{figure}

Now that you've seen how to use Liferay's built-in tools to manage
Fragments, you can see how to do it using your own tools of choice and
the Fragments Toolkit.

\chapter{Developing A Fragment Using Desktop
Tools}\label{developing-a-fragment-using-desktop-tools}

You can develop a fragment using any preferred desktop tools. Since the
Fragment is HTML, CSS, and JavaScript, you could use a text editor or a
specialized tool with its own built in previews.

\section{Collection Format}\label{collection-format}

To import a Collection into Liferay DXP, it must be archived in a
\texttt{.zip} with the contents in the following format:

\begin{itemize}
\item
  \texttt{collection.json}: a text file which describes your collection
  with the format
  \texttt{\{"name":"\textless{}collection-name\textgreater{}","description":"\textless{}collection-description\textgreater{}"\}}.
\item
  \texttt{language.properties}: the language keys defined for the
  collection.

  \begin{itemize}
  \item
    \texttt{{[}fragment-name{]}/}: a folder containing all of the files
    for a single Page Fragment.

    \begin{itemize}
    \item
      \texttt{fragment.json}: a text file that describes a Page Fragment
      with the format

\begin{verbatim}
{
    "cssPath": "index.css",
    "configurationPath": "index.json",
    "htmlPath": "index.html",
    "jsPath": "index.js",
    "name": "<fragment-name>",
    "type": "<fragment-type>"
 }
\end{verbatim}

      Update the \texttt{*Path} properties in your
      \texttt{fragment.json} file if you change the names of your
      \texttt{index.*} files.
    \item
      \texttt{index.css}: the CSS source for the fragment.
    \item
      \texttt{index.html}: the HTML source for the fragment.
    \item
      \texttt{index.json}: a JSON file that defines the fragment's
      configuration.
    \item
      \texttt{index.js}: the JavaScript source for the fragment.
    \item
      \texttt{thumbnail.png}: the thumbnail that will display when the
      Fragment is displayed in a list.
    \end{itemize}
  \item
    \texttt{{[}resources{]}/}: a folder containing any additional images
    or other external files needed for the fragment.
  \end{itemize}
\end{itemize}

A collection can contain any number of fragments, so you can have
multiple subfolders in the collection. This format is the same as what's
exported from within Liferay. If you import a \texttt{.zip} file that is
not organized like this, any fragments that are found will be imported
into special collection called \emph{Imported} which is created for
orphaned fragments.

\section{Fragment CLI}\label{fragment-cli}

You can manage Fragment creation and deployment manually, or you can use
Liferay's Fragment CLI:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Follow the project instructions to
  \href{https://github.com/liferay/generator-liferay-fragments/blob/master/README.md}{set
  up the Fragments Toolkit}.
\item
  Run \texttt{yo\ liferay-fragments}.
\item
  Follow the prompts to create a fragment.
\end{enumerate}

Now you will have the basic structure created, but there's still more
that the Fragments Toolkit can help you with.

\noindent\hrulefill

\textbf{Note:} You can see all of the available tasks inside the
\texttt{scripts} section in the Fragment CLI \texttt{package.json}.

\noindent\hrulefill

\section{Creating Collections}\label{creating-collections}

Before you can create any Page Fragments, you must create a Collection.
You can learn more about Collections in the
\href{/docs/7-2/user/-/knowledge_base/u/creating-content-pages\#creating-page-fragments}{Creating
Page Fragments} section. Creating a Collection will create the base
folder structure and some information about your Collection. To do this,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From inside of your project, run \texttt{npm\ run\ add-collection}.
\item
  Follow the prompts to name your Collection.
\end{enumerate}

You can now create Page Fragments inside of this Collection.

\section{Creating Fragments}\label{creating-fragments}

A Page Fragment is made up of three primary files, \texttt{index.html},
\texttt{index.css}, and \texttt{index.js}. However, the files must be
properly arranged in the folder structure and have the appropriate
metadata to be imported onto your server. The Fragments Toolkit will
create the files in the correct hierarchy with all of the necessary
information.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  From inside of the Collection you created, run
  \texttt{npm\ run\ add-fragment}.
\item
  Follow the prompts to add the necessary information about your Page
  Fragment.
\end{enumerate}

Now the files are all created and you can edit them using your editor of
choice.

\section{Importing and Exporting
Fragments}\label{importing-and-exporting-fragments}

The Fragments Toolkit can connect to your currently running Liferay DXP
to import and export fragments. You can even have fragments that you
create with the toolkit imported into Liferay DXP automatically.

\begin{itemize}
\item
  To get collections and fragments from a running server, run
  \texttt{npm\ run\ export}.
\item
  To send the collections and fragments from your current project to a
  running server, run \texttt{npm\ run\ import}. If your Fragment's
  configuration JSON (if available) is invalid, the import fails and
  provides an error message.
\item
  To have collections and fragments automatically imported into Liferay
  DXP as they are created or modified, run
  \texttt{npm\ run\ import:watch}.
\item
  To preview how a fragment will look when it's imported, run
  \texttt{npm\ run\ preview}. This renders a fragment on a specified
  Liferay server without importing it. When changes are made to the
  fragment while it's previewed, changes are auto reloaded to rapidly
  display updates. Note, this is available for Liferay DXP 7.2 SP1+ and
  Liferay Portal 7.2 GA2+. You must install the
  \href{https://web.liferay.com/marketplace/-/mp/application/109571986}{OAuth
  2} plugin in your portal instance for this command to work properly.
\item
  To create a \texttt{.zip} file that can be manually imported into
  Liferay DXP, run \texttt{npm\ run\ compress}.
\end{itemize}

With these tools at your disposal, you can more efficiently manage
creating and editing Page Fragments with whatever tools and environments
work best for you.

\chapter{Creating a Contributed Fragment
Collection}\label{creating-a-contributed-fragment-collection}

{This document has been updated and ported to Liferay Learn and is no
longer maintained here.}

To create a Contributed Fragment Collection, a developer must,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a module which will contain the necessary logic and the
  fragments.
\item
  Extend the class \texttt{BaseFragmentCollectionContributor} with all
  the logic for reading the contributed fragments.
\item
  Add fragments as resources in the module.
\end{enumerate}

Once you deploy the module, any fragments contained in it will be
available for use.

To better understand Contributed Fragment Collections, create one called
\texttt{DemoFragmentCollectionContributor}.

\section{Create a Module}\label{create-a-module}

First you must create the module in your development environment. Follow
the instructions in
\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Creating
a Project}.

\section{Create the Java Class}\label{create-the-java-class}

Next, you must create the Java package and class to handle the logic for
the contributed collection:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a package in your module named
  \texttt{com.liferay.fragment.collection.contributor.demo}
\item
  Inside of that package, create a Java class named
  \texttt{DemoFragmentCollectionContributor} that extends
  \texttt{BaseFragmentCollectionContributor}.
\item
  Above the class declaration, add the \texttt{@Component} annotation to
  set the service class:

\begin{verbatim}
@Component(service = FragmentCollectionContributor.class)
\end{verbatim}
\item
  Create the variable for the servlet context:

\begin{verbatim}
private ServletContext _servletContext;
\end{verbatim}
\item
  Define the \texttt{getFragmentCollectionKey()} and
  \texttt{getServletContext()} methods:

\begin{verbatim}
@Override
public String getFragmentCollectionKey() {
    return "DEMO";
}

@Override
public ServletContext getServletContext() {
    return _servletContext;
}
\end{verbatim}
\item
  Below that use the \texttt{@Reference} annotation to define your
  module's symbolic name:

\begin{verbatim}
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.fragment.collection.contributor.demo)"
)
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** `osgi.web.symbolicname` must match `Bundle-SymbolicName` from `bnd.bnd`
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Organize your imports and save.
\end{enumerate}

\section{Create the Resources}\label{create-the-resources}

Next you need to include the fragments that you want to contribute in
your module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In your module's \texttt{resources/} folder, create the folder
  structure
  \texttt{/com/liferay/fragment/collection/contributor/demo/dependencies}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** The class package name and resources package name must match 
 (e.g. `[my.class.package.structure].dependencies`).
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  Copy the Fragments you want to distribute into the folder. You can
  learn how to create a Fragment in the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/creating-fragments}{Creating
  Fragments section}.
\item
  Create a file named \texttt{collection.json} in the same folder with
  this format:

\begin{verbatim}
{
    "fragments": [
        "[fragment-1]",
        "[fragment-2]",
        "[fragment-3]",
            ...
    ],
    "name": "[collection-name]"
}
\end{verbatim}

  If a fragment is not listed in \texttt{collection.json}, it will not
  be available in the Contributed Collection, even if the files are
  included in the module.
\end{enumerate}

Next, you'll configure the module's metadata so the fragments are
imported.

\section{Configuring the Metadata}\label{configuring-the-metadata}

Follow these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your bundle's \texttt{bnd.bnd} file and add the
  \texttt{Web-ContextPath} header to point to your bundle's folder so
  the fragment resources are loaded properly:

\begin{verbatim}
Web-ContextPath: /my-fragment-collection-contributor
\end{verbatim}
\item
  Add the \texttt{-dsannotations-options} instruction and set it to use
  the \texttt{inherit} option. This specifies to use DS annotations
  found in the class hierarchy of the component class:

\begin{verbatim}
-dsannotations-options: inherit
\end{verbatim}
\end{enumerate}

Next, you'll dive into providing thumbnail images and language
keys/translations.

\section{Providing Thumbnail Images}\label{providing-thumbnail-images}

You can also provide thumbnail images for reference for your fragments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Under \texttt{resources/META-INF/resources} create a folder named
  \texttt{thumbnails}.
\item
  Copy thumbnail images into the folder with the format
  \texttt{{[}fragment-name{]}.png} for each fragment.
\end{enumerate}

\noindent\hrulefill

\textbf{Note:} All fragments added through a Contributed Fragment
Collection will be available globally to all Sites.

\noindent\hrulefill

\section{Providing Language Keys}\label{providing-language-keys}

Providing language keys in your Fragment gives you the option for
translating the text you display. Here's how to do it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must define your language keys in the Fragment's collection
  folder. Create the
  \texttt{{[}COLLECTION{]}/src/main/resources/content/Language.properties}
  file.
\item
  Add your language keys. For example,

\begin{verbatim}
applied-style=Applied Style
this-is-the-style-that-will-be-applied=This is the style that will be applied.
dark=Dark
light=Light
\end{verbatim}
\end{enumerate}

You can learn more about providing translations in the
\href{/docs/7-2/frameworks/-/knowledge_base/f/localizing-your-application}{Localizing
Your Application} article.

\section{Deploy the Contributed Fragment
Collection}\label{deploy-the-contributed-fragment-collection}

Now that you have created the necessary pieces of the module, you can
build it and
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy
it} to Liferay DXP. After it's deployed, the Fragments will be available
for use. This can also be done by using the
\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments-desktop-tools\#importing-and-exporting-fragments}{Fragments
Toolkit}. Contributed Fragments cannot be edited with Liferay, and can
only be updated by editing the fragments in your module and the building
and redeploying them.

\chapter{Including Default Resources in
Fragments}\label{including-default-resources-in-fragments}

When creating Page Fragments, you can upload resources (e.g., images,
documents, etc.) to your Fragment Collection to make them always
available from the Collection, rather than relying on resources uploaded
in other areas of your Site (e.g., Documents and Media). For more
information on how to include resources in your Fragment Collection from
the Page Fragments interface, see
\href{/docs/7-2/user/-/knowledge_base/u/creating-page-fragments}{Creating
Page Fragments}.

Once you've uploaded your resource to a Fragment Collection, you can
specify it in your Fragment:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Navigate to the Fragment editing page by clicking your Fragment's
  \emph{Actions} \includegraphics{./images/icon-actions.png} →
  \emph{Edit} button.
\item
  Specify the image by using this syntax:
  \texttt{{[}resources:IMAGE\_NAME{]}}. For example, you could include
  an image \texttt{building.png} within an HTML image tag like this:

\begin{verbatim}
<img src="[resources:building.png]">
\end{verbatim}

  You can view a full example snippet below:

\begin{verbatim}
<div class="fragment_38314">
    <lfr-editable id="img" type="image">
        <img src="[resources:building.png]">
    </lfr-editable>
</div>
\end{verbatim}
\item
  Add any additional HTML, CSS, or JavaScript to your Fragment and then
  click \emph{Publish}.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** You can also reference your Fragment Collection's resources
 in your CSS code too. It follows the same syntax as its HTML.
\end{verbatim}

\noindent\hrulefill

\begin{figure}
\centering
\includegraphics{./images/fragment-resources.png}
\caption{Any Fragment from the Fragment Collection has access to the
uploaded resources.}
\end{figure}

Great! You've successfully referenced a default resource from your
Fragment Collection!

\chapter{Supporting Custom Content Types in Content and Display
Pages}\label{supporting-custom-content-types-in-content-and-display-pages}

Content Pages and Display Page Templates can display several types of
content out-of-the-box:

\begin{itemize}
\tightlist
\item
  Web Content Article
\item
  Document
\item
  Blogs Entry
\end{itemize}

You can publish these content types in highly customizable ways using
\href{/docs/7-2/frameworks/-/knowledge_base/f/page-fragments}{Page
Fragments}. You can use these page types to map fields of certain
content (e.g., Web Content) to fields defined in a Page Fragment. Then
you can publish the content on a page using the Page Fragment as a
template. To see an example of how Display Page Templates work, see the
\href{/docs/7-2/user/-/knowledge_base/u/display-page-template-example}{Display
Page Template Example}. For more info on creating Content Pages, see the
\href{/docs/7-2/user/-/knowledge_base/u/building-content-pages}{Building
Content Pages} article.

If you want to extend the Content Page or Display Page Template
framework to support other content types, you must use the
\href{/docs/7-2/frameworks/-/knowledge_base/f/the-info-framework}{Info
framework}.

You must complete the following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Provide basic information about your custom content type.
\item
  Provide your content type's fields so they're configurable in the Page
  Editor.
\item
  Provide friendly URLs for your page type.
\item
  Handle the information that the user is requesting.
\end{enumerate}

As an example, you'll step through how to provide this information to
the Content Page and Display Page Template frameworks.

\noindent\hrulefill

\textbf{Note:} This section assumes you're customizing Display Page
Templates' available content types. The same process outlined in these
articles also applies to Content Pages, although it's not explicitly
stated.

\noindent\hrulefill

Continue on to begin!

\chapter{Mapping a Content Type to a
Page}\label{mapping-a-content-type-to-a-page}

You must allow the mapping of your custom content type to the page type.
To do this, implement the
\href{https://docs.liferay.com/dxp/apps/info/2.0.0/javadocs/com/liferay/info/display/contributor/InfoDisplayContributor.html}{\texttt{InfoDisplayContributor}}
interface. Follow the steps below to complete this for the custom User
content type.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside your custom model project, create a new Java package and add a
  class named \texttt{UserInfoDisplayContributor}.
\item
  Implement the \texttt{InfoDisplayContributor} interface and pass the
  \texttt{User} model as the type parameter. Then add the
  \texttt{@Component} annotation:

\begin{verbatim}
@Component(immediate = true, service = InfoDisplayContributor.class)
public class UserInfoDisplayContributor
    implements InfoDisplayContributor<User> {
}
\end{verbatim}

  The \texttt{@Component} annotation registers the class as an info
  display contributor in the OSGi service registry. Set the
  \texttt{service} property to the interface you're implementing.
\item
  Implement the methods. For the example User content type, three
  methods are crucial to mapping its model to the Display Page Template
  framework:

\begin{verbatim}
@Override
public String getClassName() {
    return User.class.getName();
}

@Override
public String getInfoURLSeparator() {
    return "/user/";
}

@Override
public String getLabel(Locale locale) {
    return "Users";
}
\end{verbatim}

  \begin{itemize}
  \tightlist
  \item
    The class name is used to link the Display Page Template to the User
    model.
  \item
    The URL separator is used to generate friendly URLs for the Display
    Page Template.
  \item
    The label is the display name for the new content type.
  \end{itemize}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/custom-model-selectable.png}
\caption{After creating the \texttt{*InfoDisplayContributor} class, you
can create Display Page Templates and map them to your custom model.}
\end{figure}

Great! You've mapped your custom content type to the Display Page
Template framework. Next, you'll provide your content type's fields.

\chapter{Specifying the Fields of a Custom Content
Type}\label{specifying-the-fields-of-a-custom-content-type}

Now that your custom content type is selectable for a Display Page
Template, you must specify the fields you want the user to map to the
fragment's editable fields in the Display Page Template. To do this,
implement the
\href{https://docs.liferay.com/dxp/apps/info/2.0.0/javadocs/com/liferay/info/display/contributor/field/InfoDisplayContributorField.html}{\texttt{InfoDisplayContributorField}}
interface.

Follow the steps below to create a user name field for the User content
type:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside your custom model project, add a class named
  \texttt{UserNameInfoDisplayContributorField}.
\item
  Implement the \texttt{InfoDisplayContributorField} interface and pass
  the \texttt{User} model as the type parameter. Then add the
  \texttt{@Component} annotation:

\begin{verbatim}
@Component(
    property = "model.class.name=com.liferay.portal.kernel.model.User",
    service = InfoDisplayContributorField.class
)
public class UserNameInfoDisplayContributorField
    implements InfoDisplayContributorField<User> {
}
\end{verbatim}

  The \texttt{@Component} annotation declares the class as an info
  display contributor field in the OSGi service registry. You also set
  the property \texttt{model.class.name}, which associates the content
  type you wish to configure with this service.
\item
  Implement the methods.

\begin{verbatim}
@Override
public String getKey() {
    return "userName";
}

@Override
public String getLabel(Locale locale) {
    return "User Name";
}

@Override
public InfoDisplayContributorFieldType getType() {
    return InfoDisplayContributorFieldType.TEXT;
}

@Override
public String getValue(User user, Locale locale) {
    return user.getFullName();
}
\end{verbatim}

  The above methods

  \begin{itemize}
  \tightlist
  \item
    set the content type field key to \texttt{username}.
  \item
    set the field label to \texttt{User\ Name}.
  \item
    set the field type to text.
  \item
    set the field value to the user's full name.
  \end{itemize}
\item
  Now you must override the \texttt{getInfoDisplayFields} method in your
  \texttt{*DisplayContributor} class, so the mappable fields are
  displayed. Open the \texttt{UserInfoDisplayContributor} class and add
  the following method:

\begin{verbatim}
@Override
public Set<InfoDisplayField> getInfoDisplayFields(
        long classTypeId, Locale locale)
    throws PortalException {

    Set<InfoDisplayField> infoDisplayFields = new LinkedHashSet<>();

    List<InfoDisplayContributorField> infoDisplayContributorFields =
        _infoDisplayContributorFieldTracker.getInfoDisplayContributorFields(
        getClassName());

    for (InfoDisplayContributorField infoDisplayContributorField :
    infoDisplayContributorFields) {

        InfoDisplayContributorFieldType infoDisplayContributorFieldType =
            infoDisplayContributorField.getType();

        infoDisplayFields.add(
            new InfoDisplayField(
            infoDisplayContributorField.getKey(),
            infoDisplayContributorField.getLabel(locale),
            infoDisplayContributorFieldType.getValue()));
    }

    return infoDisplayFields;
}

@Reference
private InfoDisplayContributorFieldTracker _infoDisplayContributorFieldTracker;
\end{verbatim}

  This method references your new \texttt{*InfoDisplayContributorField}
  class to specify your content type's fields.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/content-type-custom-fields.png}
\caption{After creating the \texttt{*InfoDisplayContributorField} class,
your custom content type has a new field to map.}
\end{figure}

Awesome! You've mapped the content type's fields to the editable fields
of the provided fragments. Next, you'll provide the friendly URLs for
the Display Page Template.

\chapter{Providing Friendly URLs for a Custom Content
Type}\label{providing-friendly-urls-for-a-custom-content-type}

To provide a friendly URL for your custom content type, you must
implement a friendly URL resolver to retrieve the desired information.
For the User content type example, you'll want to retrieve profiles by a
user's screen name.

To do this, follow the steps below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open the \texttt{*InfoDisplayContributor} class you created previously
  (covered
  \href{/docs/7-2/frameworks/-/knowledge_base/f/mapping-a-content-type-to-a-page}{here}).
  Implement the \texttt{getInfoDisplayObjectProvider} method. For the
  User example, it looks like this:

\begin{verbatim}
@Override
public InfoDisplayObjectProvider<User> getInfoDisplayObjectProvider(
        long groupId, String urlTitle)
    throws PortalException {

    Group group = _groupLocalService.getGroup(groupId);

    User user = _userLocalService.getUserByScreenName(
        group.getCompanyId(), urlTitle);

    return new InfoDisplayObjectProvider<User>() {

        @Override
        public long getClassNameId() {
            return _classNameLocalService.getClassNameId(getClassName());
        }

        @Override
        public long getClassPK() {
            return user.getUserId();
        }

        @Override
        public long getClassTypeId() {
            return 0;
        }

        @Override
        public String getDescription(Locale locale) {
            return StringPool.BLANK;
        }

        @Override
        public User getDisplayObject() {
            return user;
        }

        @Override
        public long getGroupId() {
            return groupId;
        }

        @Override
        public String getKeywords(Locale locale) {
            return StringPool.BLANK;
        }

        @Override
        public String getTitle(Locale locale) {
            return user.getFullName();
        }

        @Override
        public String getURLTitle(Locale locale) {
            return user.getScreenName();
        }

    };
}
\end{verbatim}

  This method returns a new \texttt{InfoDisplayObjectProvider} for the
  User type. This is the specific model instance used to retrieve the
  mapped values and check for the display page. This is required by the
  friendly URL resolver. Now you'll implement the friendly URL resolver
  for the User content type.
\item
  Inside your custom model project, add a class named
  \texttt{UserDisplayPageFriendlyURLResolver}.
\item
  Implement the
  \href{https://docs.liferay.com/dxp/portal//7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/portlet/FriendlyURLResolver.html}{\texttt{FriendlyURLResolver}}
  interface. Then add the \texttt{@Component} annotation:

\begin{verbatim}
@Component(service = FriendlyURLResolver.class)
public class UserDisplayPageFriendlyURLResolver implements FriendlyURLResolver {

}
\end{verbatim}

  The \texttt{@Component} annotation declares the class as a friendly
  URL resolver in the OSGi service registry.
\item
  Implement the methods. The User type's implementation looks like this:

\begin{verbatim}
@Override
public String getActualURL(
    long companyId, long groupId, boolean privateLayout,
      String mainPath, String friendlyURL, Map<String, String[]> params,
    Map<String, Object> requestContext)
throws PortalException {

    HttpServletRequest request = (HttpServletRequest)requestContext.get(
        "request");

    InfoDisplayContributor infoDisplayContributor =
        _getInfoDisplayContributor();

    List<String> paths = StringUtil.split(friendlyURL, CharPool.SLASH);

    InfoDisplayObjectProvider infoDisplayObjectProvider =
        infoDisplayContributor.getInfoDisplayObjectProvider(
            groupId, paths.get(1));

    request.setAttribute(
        AssetDisplayPageWebKeys.INFO_DISPLAY_OBJECT_PROVIDER,
            infoDisplayObjectProvider);

    request.setAttribute(
        InfoDisplayWebKeys.INFO_DISPLAY_CONTRIBUTOR,
            infoDisplayContributor);

    Layout layout = _getInfoDisplayObjectProviderLayout(
        infoDisplayObjectProvider);

    return _portal.getLayoutActualURL(layout, mainPath);
}

@Override
public LayoutFriendlyURLComposite getLayoutFriendlyURLComposite(
    long companyId, long groupId, boolean privateLayout,
    String friendlyURL, Map<String, String[]> params,
    Map<String, Object> requestContext)
throws PortalException {

    Layout layout = _getInfoDisplayObjectProviderLayout(
        _getInfoDisplayObjectProvider(groupId, friendlyURL));

    return new LayoutFriendlyURLComposite(layout, friendlyURL);
}

@Override
public String getURLSeparator() {
    return "/user/";
}

private InfoDisplayContributor _getInfoDisplayContributor()
    throws PortalException {

    InfoDisplayContributor infoDisplayContributor =
        _infoDisplayContributorTracker.
            getInfoDisplayContributorByURLSeparator(getURLSeparator());

    if (infoDisplayContributor == null) {
        throw new PortalException(
            "Info display contributor is not available for " +
            getURLSeparator());
    }

    return infoDisplayContributor;
}

private InfoDisplayObjectProvider _getInfoDisplayObjectProvider(
        long groupId, String friendlyURL)
    throws PortalException {

    List<String> paths = StringUtil.split(friendlyURL, CharPool.SLASH);

    InfoDisplayContributor infoDisplayContributor =
        _infoDisplayContributorTracker.getInfoDisplayContributor(
            User.class.getName());

    return infoDisplayContributor.getInfoDisplayObjectProvider(
        groupId, paths.get(1));
}

private Layout _getInfoDisplayObjectProviderLayout(
    InfoDisplayObjectProvider infoDisplayObjectProvider) {

    LayoutPageTemplateEntry layoutPageTemplateEntry =
        _layoutPageTemplateEntryService.fetchDefaultLayoutPageTemplateEntry(
            infoDisplayObjectProvider.getGroupId(),
            infoDisplayObjectProvider.getClassNameId(),
            infoDisplayObjectProvider.getClassTypeId());

    if (layoutPageTemplateEntry != null) {
        return _layoutLocalService.fetchLayout(
            layoutPageTemplateEntry.getPlid());
    }

    return null;
}

@Reference
private InfoDisplayContributorTracker _infoDisplayContributorTracker;

@Reference
private LayoutLocalService _layoutLocalService;

@Reference
private LayoutPageTemplateEntryService _layoutPageTemplateEntryService;

@Reference
private Portal _portal;
\end{verbatim}

  Notice you're finding the \texttt{InfoDisplayObjectProvider}
  corresponding to the current user. This serves as the
  representation/descriptor of the mapped object.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This `FriendlyURLResolver` implementation uses the default
 display page template for the User model.
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
When this implementation is deployed, you'll receive an empty page when
calling the URL `[host]/web/guest/user/[screenName]`. You must return the
values from the users that are mapped to the display page. You'll do this
next.
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Implement the \texttt{getInfoDisplayFieldsValue} method in the
  previously created \texttt{*InfoDisplayContributor} class.

\begin{verbatim}
@Override
public Map<String, Object> getInfoDisplayFieldsValues(
        User user, Locale locale)
    throws PortalException {

    Map<String, Object> infoDisplayFieldsValues = new HashMap<>();

    List<InfoDisplayContributorField> infoDisplayContributorFields =
        _infoDisplayContributorFieldTracker.getInfoDisplayContributorFields(
            getClassName());

    for (InfoDisplayContributorField infoDisplayContributorField :
        infoDisplayContributorFields) {

        Object fieldValue = infoDisplayContributorField.getValue(
            user, locale);

        infoDisplayFieldsValues.putIfAbsent(
            infoDisplayContributorField.getKey(), fieldValue);
    }

    return infoDisplayFieldsValues;
}
\end{verbatim}
\end{enumerate}

Great! Now you have a friendly URL that maps to your display page
template's custom content type.

\chapter{Integrating Display Pages into Content
Creation}\label{integrating-display-pages-into-content-creation}

After you add support for Display Pages in your custom entities, you can
integrate display page configuration into your entity's creation form.

\section{Display Page Taglib Example}\label{display-page-taglib-example}

To provide the Display Page selector for the User type after you
\href{/docs/7-2/frameworks/-/knowledge_base/f/specifying-the-fields-of-a-custom-content-type}{created
fields for it},

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your JSP used for displaying the editing interface (e.g.,
  \texttt{.../META-INF/resources/.../edit\_entry.jsp}).
\item
  Add this code in the appropriate place in the layout to add the
  Display Page selector:

\begin{verbatim}
<liferay-asset:select-asset-display-page
    classNameId="<%= PortalUtil.getClassNameId(User.class) %>"
    classPK="<%= userId %>"
    groupId="<%= scopeGroupId %>"
/>
\end{verbatim}
\end{enumerate}

Now, a selector is available to define a default Display Page when
editing or creating a User.

\begin{figure}
\centering
\includegraphics{./images/display-pages-select-default-display-page.png}
\caption{You need to add the Display Page selection to your content
type's create/edit page to define the Display Page for each instance of
that asset.}
\end{figure}

Awesome! Your custom content type is now available for Content Pages
and/or Display Page Templates.

\chapter{Screen Navigation Framework}\label{screen-navigation-framework}

The Screen Navigation Framework is for customizing and extending
application UIs. You can use it to make Liferay's applications your own
and to make your applications customizable by others.

The framework uses a specific structure for screens and supports one or
two levels of navigation. Each item in the top level navigation is a
\texttt{ScreenNavigationCategory}. Each item in the second level is a
\texttt{ScreenNavigationEntry}. Categories are usually represented by
tabs, while entries use a second level of navigation. You need not have
any Entries in your application, but you must have at least one
Category.

\begin{figure}
\centering
\includegraphics{./images/screen-nav-sample-screen-1.png}
\caption{The User Management application has three Screen Navigation
Categories: General, Contact, and Preference; and each of those have a
number of Screen Navigation Entries}
\end{figure}

The Screen structure normally renders Navigation Categories as
horizontal tabs at the top of the page and Navigation Entries as a
vertical list of items along the left side of the page. The screen box
containing the content uses the rest of the screen. You can customize
this default layout for your needs.

\begin{figure}
\centering
\includegraphics{./images/screen-nav-one-level.png}
\caption{Many application only use Screen Navigation Categories for
their functionality, and don't have Screen Navigation Entries. For
Blogs, Entries and Images are Categories with no Entries.}
\end{figure}

\section{Using the Framework for Your
Application}\label{using-the-framework-for-your-application}

The Screen Navigation Framework comprises two parts: Java classes for
your screens and a tag library for your front-end. To use Screen
Navigation for your application, first you'll create the necessary Java
classes and then add the front-end support through JSPs.

Your \texttt{ScreenNavigationCategory} class must be a a component that
implements the \texttt{ScreenNavigationCategory} interface with these
methods:

\textbf{\texttt{getCategoryKey()}}: returns the category's primary key.

\textbf{\texttt{getLabel(Locale\ locale)}}: returns the label of the
key.

\textbf{\texttt{getScreenNavigationKey()}}: returns the navigation key
that the category belongs in, as defined in your application.

Your \texttt{ScreenNavigationEntry} class, similarly must be a component
which implements \texttt{ScreenNavigationEntry} with the following
methods:

\textbf{\texttt{getCategoryKey()}}: returns the category's primary key.

\textbf{\texttt{getEntryKey()}}: returns the entry's primary key.

\textbf{\texttt{getLabel()}}: returns the entries label.

\textbf{\texttt{getScreenNavigationKey()}}: returns the navigation key
for the category of the current entry.

\textbf{\texttt{isVisible(User\ user,\ T\ screenModelBean)}}: boolean
for whether or not the entry should be visible for the current user.

\textbf{\texttt{render(HttpServletRequest\ request,\ HttpServletResponse\ response)}}:
renders the entry. The \texttt{render} method is also where any logic
for creating the configuration goes.

\section{Adding Custom Screens to Liferay
Applications}\label{adding-custom-screens-to-liferay-applications}

You can extend certain Liferay Applications with custom screens. Custom
screens can add configuration for features you've developed and added to
a Liferay application, integrating them seamlessly with the original
application.

The parameters it needs are \texttt{key}, \texttt{modelBean}, and
\texttt{portletURL}.

\begin{itemize}
\item
  \textbf{Key}: a unique name for the navigation in this application.
\item
  \textbf{modelBean}: the model that is being rendered
\item
  \textbf{portletURL}: the portlet URL used to build the titles for each
  link.
\end{itemize}

In addition to these parameters, you must build the page that users will
use for configuration, and connect it to your business logic through the
render command.

\chapter{Using Screen Navigation for Your
Application}\label{using-screen-navigation-for-your-application}

To use the Screen Navigation framework with your application you must
create a Screen Navigation Category and Entry, and then create the JSP
to provide the layout for the Screen Navigation Entry.

\section{Adding Screens to Your Application's
Back-end}\label{adding-screens-to-your-applications-back-end}

To add screens to your application, first you must add at least one
Navigation Category for the top level navigation. Then you can add
additional Navigation Entries for each page that you need. To
demonstrate this, follow the instructions for integrating Screen
Navigation for a sample application.

First, create the Navigation Category:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In your existing application, create a component named
  \texttt{SampleScreenNavigationCategory} that implements the
  \texttt{ScreenNavigationCategory} interface.
\item
  In the \texttt{@Component} declaration, set your priority property
  which determines what order items appear in in the side navigation:

\begin{verbatim}
property = "screen.navigation.category.order:Integer=10",
\end{verbatim}
\item
  Add the following methods to the class body:

\begin{verbatim}
@Override
public String getCategoryKey() {
    return SampleScreenNavigationConstants.
        CATEGORY_KEY_SAMPLE_CONFIGURATION;
}

@Override
public String getLabel(Locale locale) {
    return LanguageUtil.get(locale, "general");
}

@Override
public String getScreenNavigationKey() {
    return SampleScreenNavigationConstants.
        SAMPLE_KEY_METHOD;
}
\end{verbatim}

  When you're finished, your \texttt{ScreenNavigationCategory} class
  looks like this:

\begin{verbatim}
@Component(
property = "screen.navigation.category.order:Integer=10",
service = ScreenNavigationCategory.class
)
public class SampleScreenNavigationCategory
  implements ScreenNavigationCategory {

  @Override
  public String getCategoryKey() {
    return SampleScreenNavigationConstants.
        CATEGORY_KEY_SAMPLE_CONFIGURATION;
  }

  @Override
  public String getLabel(Locale locale) {
    return LanguageUtil.get(locale, "general");
  }

  @Override
  public String getScreenNavigationKey() {
    return SampleScreenNavigationConstants.
        SAMPLE_KEY_METHOD;
  }
}
\end{verbatim}
\end{enumerate}

Next, add a Navigation Entry:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a component named \texttt{SampleScreenNavigationEntry} which
  implements \texttt{ScreenNavigationEntry}.
\item
  Create the the \texttt{@Reference} variables you need for the render
  logic:

\begin{verbatim}
@Reference
private ConfigurationProvider _configurationProvider;

@Reference
private JSPRenderer _jspRenderer;

@Reference
private Portal _portal;

@Reference(
    target = "(osgi.web.symbolicname=com.liferay.commerce.payment.method.sample)"
)
private ServletContext _servletContext;
\end{verbatim}
\item
  Implement the following methods in your component:

\begin{verbatim}
@Override
public String getCategoryKey() {
    return SampleScreenNavigationConstants.
        CATEGORY_KEY_SAMPLE_CONFIGURATION;
}

@Override
public String getEntryKey() {
    return SampleScreenNavigationConstants.
        ENTRY_KEY_SAMPLE_CONFIGURATION;
}

@Override
public String getLabel(Locale locale) {
    return LanguageUtil.get(
        locale,
        SampleScreenNavigationConstants.
            CATEGORY_KEY_SAMPLE_CONFIGURATION);
}

@Override
public String getScreenNavigationKey() {
    return SpaceShipScreenNavigationConstants.
        SAMPLE_KEY_METHOD;
}

@Override
public boolean isVisible(
    User user, SamplePermissions spaceShipPermissions) {

    if (samplePermissions.criteriaMethod()) 
    {

        return true;
    }

    return false;
}

@Override
public void render(HttpServletRequest request, HttpServletResponse response)
throws IOException {

    _jspRenderer.renderJSP(request, response, "/my-category/view-category.jsp");
}
\end{verbatim}

  Here is what the \texttt{SampleScreenNavigationEntry} class looks
  like:

\begin{verbatim}
@Component(
property = "screen.navigation.entry.order:Integer=20",
service = ScreenNavigationEntry.class
)
public class
    SampleScreenNavigationEntry
    implements ScreenNavigationEntry<SampleApplication> {

    public static final String
        ENTRY_KEY_SAMPLE_CONFIGURATION =
            "sample-configuration";

    @Override
    public String getCategoryKey() {
        return SpaceShipScreenNavigationConstants.
            CATEGORY_KEY_SAMPLE_CONFIGURATION;
    }

    @Override
    public String getEntryKey() {
        return ENTRY_KEY_SAMPLE_CONFIGURATION;
    }

    @Override
    public String getLabel(Locale locale) {
        return LanguageUtil.get(
            locale,
            SpaceShipScreenNavigationConstants.
                CATEGORY_KEY_SAMPLE_CONFIGURATION);
    }

    @Override
    public String getScreenNavigationKey() {
        return SpaceShipScreenNavigationConstants.
            SAMPLE_KEY_METHOD;
    }

    @Override
    public boolean isVisible(
        User user, SamplePermissions spaceShipPermissions) {

        if (samplePermissions.criteriaMethod()) 
        {

            return true;
        }

            return false;
        }

    @Override
    public void render(HttpServletRequest request, HttpServletResponse response)
    throws IOException {

        _jspRenderer.renderJSP(request, response, "/my-category/view-category.jsp");
    }

    @Reference
    private JSPRenderer _jspRenderer;

    @Reference(
        target = "(osgi.web.symbolicname=com.liferay.commerce.payment.method.sample);

    }
\end{verbatim}
\end{enumerate}

You can implement your render method any way that you want as long as it
provides a way to render HTML. Liferay developers typically use JSPs,
shown below.

\section{Adding Screens to Your Application's
Front-end}\label{adding-screens-to-your-applications-front-end}

The \texttt{render} method that you created in your last step references
\texttt{/my-category/view-category.jsp}. Create the JSP now:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{/src/resources/META-INF/resources} create the
  \texttt{my-category} folder.
\item
  Inside of that folder, create \texttt{view-category.jsp}.
\item
  Inside the JSP add the \texttt{liferay-frontend:screen-navigation}
  taglib with the required parameters:

\begin{verbatim}
<liferay-frontend:screen-navigation key="<%= AssetCategoriesConstants.CATEGORY_KEY_GENERAL %>"
    modelBean="<%= category %>"
    portletURL="<%= portletURL %>"
/>
\end{verbatim}
\end{enumerate}

After that tag, add the rest of the content of the JSP file to handle
user interactions and communication with the back-end for configuration.

\chapter{Extending Categories
Administration}\label{extending-categories-administration}

The Categories Administration application supports adding Custom Screens
to provide additional options for editing a category. To demonstrate
adding a new Screen Navigation Entry and Category, you'll add one to
Categories Administration.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a new Java class in the \texttt{asset-categories-admin-web}
  module named \texttt{CategoryCustomScreenNavigationEntry} that
  implements \texttt{ScreenNavigationCategory} and
  \texttt{ScreenNavigationEntry}.
\item
  Add the following Component annotation above the class declaration:

\begin{verbatim}
@Component(
    property = {
        "screen.navigation.category.order:Integer=1",
        "screen.navigation.entry.order:Integer=1"
        },
         service = {ScreenNavigationCategory.class, ScreenNavigationEntry.class}
    )
\end{verbatim}

  The \texttt{screen.navigation.category.order} and
  \texttt{screen.navigation.entry.order} determine where in the
  navigation the items appear. Higher is first in the navigation.

  In the \texttt{service} declaration, declare it as defining a
  \texttt{ScreenNavigationCategory}, \texttt{ScreenNavigationEntry}, or
  both.
\item
  For the class body, insert this code:

\begin{verbatim}
@Override
public String getCategoryKey() {
    return "custom-screen";
}

@Override
public String getEntryKey() {
    return "custom-screen";
}

@Override
public String getLabel(Locale locale) {
    return LanguageUtil.get(locale, "custom-screen");
}

@Override
public String getScreenNavigationKey() {
    return AssetCategoriesConstants.CATEGORY_KEY_GENERAL;
}

@Override
public void render(HttpServletRequest request, HttpServletResponse response)
    throws IOException {

         _jspRenderer.renderJSP(request, response, "/category/custom-screen.jsp");
}

@Reference
private JSPRenderer _jspRenderer;
\end{verbatim}
\item
  Create a \texttt{custom-screen.jsp} in the
  \texttt{/resources/META-INF/resources/category/} folder.
\item
  At the top of your JSP class, insert the following scriptlet to use
  the Screen Navigation UI:

\begin{verbatim}
<%
String redirect = ParamUtil.getString(request, "redirect", assetCategoriesDisplayContext.getEditCategoryRedirect());

long categoryId = ParamUtil.getLong(request, "categoryId");

AssetCategory category = AssetCategoryLocalServiceUtil.fetchCategory(categoryId);

long parentCategoryId = BeanParamUtil.getLong(category, request, "parentCategoryId");

long vocabularyId = ParamUtil.getLong(request, "vocabularyId");

portletDisplay.setShowBackIcon(true);
portletDisplay.setURLBack(redirect);

renderResponse.setTitle(((category == null) ? LanguageUtil.get(request, "add-new-category") : category.getTitle(locale)));
%>
\end{verbatim}
\item
  Below that, insert the following tag:

\begin{verbatim}
<liferay-frontend:screen-navigation key=
"<%= AssetCategoriesConstants.CATEGORY_KEY_GENERAL %>"
modelBean="<%= category %>"
portletURL="<%= portletURL %>"
/>
\end{verbatim}
\item
  For the rest of the JSP, create your custom screen.
\end{enumerate}

Now you can use that pattern to create additional screens for whatever
you need.

\chapter{Developing a Fragment
Renderer}\label{developing-a-fragment-renderer}

When creating Fragments through Liferay DXP's provided UI, you're given
three front-end languages to leverage: CSS, HTML, and JavaScript.
Although you can harness a lot of power with these languages alone, they
do not provide an easy way to retrieve and process information from the
database or third party systems. A common solution for this issue is
creating a full-fledged portlet to complete common back-end necessities,
but this is sometimes overkill for what you need.

For a lightweight alternative, you can develop a \emph{Fragment
Renderer} to use Liferay's provided Java APIs for back-end tasks related
to your Fragment. To do this, you must
\hyperref[implementing-the-fragmentrenderer-interface]{implement the
\texttt{FragmentRenderer} interface}.

Optionally, you can

\begin{itemize}
\item
  \hyperref[leveraging-the-fragmentrenderercontext]{Leverage the
  \texttt{FragmentRendererContext}}.
\item
  \hyperref[rendering-jsps]{Use JSPs for your Fragment's display}.
\item
  \hyperref[choosing-when-to-display-a-component]{Choose when to display
  the component}.
\item
  \hyperref[translating-the-collection-language-key]{Translate the
  Collection language key}.
\end{itemize}

You'll explore each step next.

\section{Implementing the FragmentRenderer
Interface}\label{implementing-the-fragmentrenderer-interface}

The
\href{https://docs.liferay.com/dxp/apps/fragment/latest/javadocs/com/liferay/fragment/renderer/FragmentRenderer.html}{\texttt{FragmentRenderer}}
interface requires the implementation of two methods:

\texttt{getCollectionKey}: returns the unique key for the component's
Collection. Define this key in several components to group them under a
collapsible panel in the Page Editor.

\texttt{getLabel}: provides the Fragment name.

The remaining methods are optional, but can be useful in many scenarios:

\texttt{getImagePreviewURL}: returns the URL for previewing the
Fragment's image.

\texttt{getKey}: returns the Fragment's key.

\texttt{getType}: returns the Fragment's type. Type values include
\texttt{FragmentConstants.TYPE\_COMPONENT} and
\texttt{FragmentConstants.TYPE\_SECTION}.

\texttt{isSelectable}: defines whether page authors can select the
Fragment Renderer. You'll learn more about this in the
\hyperref[choosing-when-to-display-a-component]{Choosing When to Display
a Component} section.

\texttt{render} (highly recommended): defines how to render the Fragment
Renderer (e.g., JSP or FreeMarker). You can leverage the
\texttt{FragmentRendererContext} in this method to facilitate the
rendering process.

Next, you'll learn about leveraging the
\texttt{FragmentRendererContext}.

\section{Leveraging the
FragmentRendererContext}\label{leveraging-the-fragmentrenderercontext}

The \texttt{render} method receives a read-only instance of the
interface
\href{https://docs.liferay.com/dxp/apps/fragment/latest/javadocs/com/liferay/fragment/renderer/FragmentRendererContext.html}{\texttt{FragmentRendererContext}}.
This provides information about the context in which the Fragment is
being rendered. The fields of information that are accessible through it
include

\textbf{Fragment Entry Link}: The specific instance of the Fragment
being rendered. This information can be used to identify the specific
site or page to which the Fragment was added, when it was added, the
user who added it, etc.

\textbf{Locale}: The current locale to be used for any multi-locale
text.

\textbf{Mode}: There are three available modes:

\begin{itemize}
\tightlist
\item
  \textbf{VIEW}: The component is being rendered within a page being
  viewed (not edited).
\item
  \textbf{ASSET\_DISPLAY\_PAGE}: The component is being edited on a
  Display Page.
\item
  \textbf{EDIT}: The component is being edited on a Content Page.
\end{itemize}

There are other fields which should only be necessary for advanced use
cases:

\textbf{Preview Class PK}: If the Fragment supports displaying content,
this field supports previewing an \emph{In progress} version of the
content before it's ready to publish. In this case, the \texttt{render}
method returns the content's primary key.

\textbf{Preview Type}: Represents the preview type you want to show. The
accepted values include

\begin{itemize}
\tightlist
\item
  \textbf{TYPE\_LATEST\_APPROVED}: The latest approved version of the
  content.
\item
  \textbf{TYPE\_LATEST}: The latest version of the content.
\end{itemize}

\textbf{Field Values}: Fragments can have editable elements through
\texttt{\textless{}lfr-editable\textgreater{}} tags; this also applies
to those created with \texttt{FragmentRenderer}. The
\texttt{getFieldValuesOptional()} method retrieves the field values the
user may have introduced in them. This only applies in the context of a
Display Page with the values of the mapped structure.

\textbf{Segment Experience IDs}: A list of identifiers for experiences
that have been configured for the current page.

\section{Rendering JSPs}\label{rendering-jsps}

Usually you'll want to avoid writing HTML in your Java code.
Fortunately, you can use the \texttt{render} method to use any
templating mechanism of your choice. JSP integration is provided
out-of-the box.

For example, rendering a JSP for your Fragment Renderer would look like
this:

\begin{verbatim}
@Override
public void render(
    FragmentRendererContext fragmentRendererContext,
    HttpServletRequest httpServletRequest,
    HttpServletResponse httpServletResponse) throws IOException {

    httpServletRequest.setAttribute(
        "fragmentRendererContext", fragmentRendererContext);

    _jspRenderer.renderJSP(
        httpServletRequest, httpServletResponse, "/my-component.jsp");
}

@Reference
private JSPRenderer _jspRenderer;

@Reference(
    target = "(osgi.web.symbolicname=com.liferay.fragment.renderer.docs)",
    unbind = "-"
)
private ServletContext _servletContext;
\end{verbatim}

This sets the
\hyperref[leveraging-the-fragmentrenderercontext]{\texttt{FragmentRendererContext}}
in the HTTP servlet request, which is then used to render the included
JSP file (e.g., \texttt{my-component.jsp}).

To leverage JSPs, you must specify the servlet context for the JSP
files. Since your Fragment Renderer is an OSGi module, your
\texttt{bnd.bnd} file must define a web context path:

\begin{verbatim}
Bundle-SymbolicName: com.liferay.fragment.renderer.docs
Web-ContextPath: /my-fragment-renderer
\end{verbatim}

Then you must reference the Servlet context using the symbolic name of
your module, as was shown above:

\begin{verbatim}
@Reference(
    target = "(osgi.web.symbolicname=com.liferay.fragment.renderer.docs)",
    unbind = "-"
)
private ServletContext _servletContext;
\end{verbatim}

\noindent\hrulefill

\textbf{Note:} To use the JSP Renderer, your module must set the
\texttt{com.liferay.frontend.taglib} dependency in its build file.

\noindent\hrulefill

Next, you'll learn about controlling when your Fragment Renderer is
displayed.

\section{Choosing When to Display a
Component}\label{choosing-when-to-display-a-component}

Sometimes offering Fragment components only makes sense in specific
cases. You can implement the \texttt{isSelectable(...)} method to
specify under which conditions the Fragment Renderer is available to
page authors.

For example, if you wanted to make your Fragment Renderer only available
in Display Pages, you could implement the \texttt{isSelectable} method
like this:

\begin{verbatim}
@Override
public boolean isSelectable(HttpServletRequest httpServletRequest) {
    Layout layout = (Layout)httpServletRequest.getAttribute(WebKeys.LAYOUT);

    if (Objects.equals(
        layout.getType(), LayoutConstants.TYPE_ASSET_DISPLAY)) {

        return true;
    }

    return false;
}
\end{verbatim}

This determines the Fragment Renderer's page type and returns
\texttt{true} when the page type is a Display Page or \texttt{false} if
it's not.

\section{Translating the Collection Language
Key}\label{translating-the-collection-language-key}

When setting your Fragment Renderer's collection name via the
\texttt{getCollectionKey} method, you should specify it as a language
key and then define it in a resource bundle.

For example, a \texttt{getCollectionKey} method could look like this:

\begin{verbatim}
@Override
public String getCollectionKey() {
    return "sample-components";
}
\end{verbatim}

To specify \texttt{sample-components} in a resource bundle, create the
\texttt{src/main/resources/content/Language.properties} file within the
Fragment Renderer module and define it using the language key
\texttt{fragment.collection.label.\{collection-key\}}. For example,

\begin{verbatim}
fragment.collection.label.sample-components=Sample Components
\end{verbatim}

To learn more about resource bundles, see the
\href{/docs/7-2/frameworks/-/knowledge_base/f/localization}{Localization}
section.

Next, you'll step through creating a Fragment Renderer.

\chapter{Creating a Fragment
Renderer}\label{creating-a-fragment-renderer}

Creating a Fragment Renderer lets you call Liferay's provided Java APIs
for back-end tasks related to your Fragment. In this article, you'll
create a sample Fragment Renderer that displays values stored in the
current Liferay DXP instance's database.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a default module project} in your development environment.
\item
  Create a unique package name in the module's \texttt{src} directory
  and create a new Java class in that package. To follow naming
  conventions, give your class a unique name followed by
  \texttt{FragmentRenderer} (e.g.,
  \texttt{ShowContextFragmentRenderer}).
\item
  Configure your new class to implement the
  \href{https://docs.liferay.com/dxp/apps/fragment/latest/javadocs/com/liferay/fragment/renderer/FragmentRenderer.html}{\texttt{FragmentRenderer}}
  interface:

\begin{verbatim}
public class ShowContextFragmentRenderer implements FragmentRenderer {
}
\end{verbatim}
\item
  Insert the following \texttt{@Component} annotation above the class
  declaration:

\begin{verbatim}
@Component(service = FragmentRenderer.class)
\end{verbatim}

  This sets the OSGi service type to \texttt{FragmentRenderer}.
\item
  Implement the two required \texttt{FragmentRenderer} methods:

\begin{verbatim}
@Override
public String getCollectionKey() {
    return "sample-components";
}

@Override
public String getLabel(Locale locale) {
    return "Show Context Component";
}
\end{verbatim}

  The \texttt{getCollectionKey()} method returns a language key, which
  you'll define later. The name displayed for this Fragment is defined
  as \emph{Show Context Component}.

  \begin{figure}
  \centering
  \includegraphics{./images/show-context-fragment-renderer.png}
  \caption{The new Fragment Renderer appears in its defined component
  collection.}
  \end{figure}
\item
  Implement the \texttt{render} method:

\begin{verbatim}
@Override
public void render(
    FragmentRendererContext fragmentRendererContext,
    HttpServletRequest httpServletRequest,
    HttpServletResponse httpServletResponse) throws IOException {

        PrintWriter printWriter = httpServletResponse.getWriter();

        printWriter.write("<h3>Context</h3>");
        printWriter.write("<ul>");

        FragmentEntryLink fragmentEntryLink =
        fragmentRendererContext.getFragmentEntryLink();

        printWriter.write("<li>Added by: " + fragmentEntryLink.getUserName());
        printWriter.write("<li>Added in: " + fragmentEntryLink.getCreateDate());

        printWriter.write("<li>Locale: " + fragmentRendererContext.getLocale());
        printWriter.write("<li>Mode: " + fragmentRendererContext.getMode());
        printWriter.write("<li>PreviewClassPK: " + fragmentRendererContext.getPreviewClassPK());
        printWriter.write("<li>PreviewType: " + fragmentRendererContext.getPreviewType());
        printWriter.write("<li>Segment experiences: " + StringUtil.merge(fragmentRendererContext.getSegmentsExperienceIds(), ", "));
        printWriter.write("</ul>");
}
\end{verbatim}

  This method leverages the
  \href{/docs/7-2/frameworks/-/knowledge_base/f/developing-a-fragment-renderer\#leveraging-the-fragmentrenderercontext}{\texttt{FragmentRendererContext}},
  which provides the Fragment's context information stored in the
  database. This information is displayed in the Fragment Renderer when
  it's placed on a page.

  \begin{figure}
  \centering
  \includegraphics{./images/show-context-fragment-renderer-page.png}
  \caption{When adding the new Fragment Renderer to a page, the context
  information is displayed.}
  \end{figure}
\item
  Define the language key \texttt{sample-components} that you used in
  the \texttt{getCollectionKey()} method. To do this, create the
  \texttt{src/main/resources/content/Language.properties} file and add
  the following language key:

\begin{verbatim}
fragment.collection.label.sample-components=Sample Components
\end{verbatim}
\item
  Provide the appropriate dependencies to compile your Fragment Renderer
  project. For example, the following dependencies are defined for the
  Show Context Component Fragment Renderer sample (Gradle build)
  deployed to Liferay Portal 7.2 GA1:

\begin{verbatim}
dependencies {
    compileOnly group: "com.liferay.portal", name: "com.liferay.portal.kernel", version: "4.13.0"
    compileOnly group: "com.liferay", name: "com.liferay.fragment.api", version: "2.7.2"
    compileOnly group: "com.liferay", name: "com.liferay.fragment.service", version: "2.0.10"
    compileOnly group: "com.liferay", name: "com.liferay.frontend.taglib", version: "4.0.15"
    compileOnly group: "com.liferay", name: "com.liferay.petra.string", version: "3.0.0"
    compileOnly group: "javax.portlet", name: "portlet-api", version: "3.0.0"
    compileOnly group: "javax.servlet", name: "javax.servlet-api", version: "3.0.1"
    compileOnly group: "jstl", name: "jstl", version: "1.2"
    compileOnly group: "org.osgi", name: "org.osgi.service.component.annotations", version: "1.3.0"
}
\end{verbatim}

  To stay in sync with the appropriate versions of your project's
  dependencies, consider using the
  \href{/docs/7-2/reference/-/knowledge_base/r/managing-the-target-platform}{Target
  Platform} framework.
\end{enumerate}

That's it! You can compile the sample \emph{Show Context Component}
Fragment Renderer and
\href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{deploy
it}! It'll be available to add for a Fragment-enabled page under the
\emph{Sample Components} collection.

\chapter{Web Services}\label{web-services}

It's important for apps on different machines to communicate. To enable
this, an app can expose APIs so remote components (other apps or
devices) can access the app's features. For example, one service could
have a client app presenting information to users, a server app
processing data in B2B setting, and an IoT device requesting data to do
its work. Exposing web APIs lets external applications or devices
communicate with yours.

Because Liferay DXP contains so many apps and features, it's prudent for
Liferay to let developers access those apps and features from external
apps and devices by exposing their APIs. Additionally, Liferay's
development platform makes it easy to extend them and create new ones.

There are three different approaches for clients to connect to Liferay
DXP's web APIs:

\textbf{Headless REST APIs:} You can consume RESTful web services
independent of Liferay DXP's front end (hence \emph{headless}). These
APIs conform to the
\href{https://swagger.io/docs/specification/about/}{OpenAPI}
specification. This is the modern, preferred way to work with web
services in Liferay DXP.

\textbf{GraphQL:} All the power of doing multiple queries in a unique
request following
\href{https://graphql.github.io/graphql-spec/June2018/}{GraphQL
specification}.

\textbf{Plain Web/REST Services:} This is the old way to build and
consume web services in Liferay DXP, but is still supported.

You can also create your own Headless REST and GraphQL APIs through the
\textbf{REST builder}.

\chapter{Headless REST APIs}\label{headless-rest-apis}

Liferay DXP's headless REST APIs follow the
\href{https://swagger.io/docs/specification/about/}{OpenAPI}
specification and let your apps consume RESTful web services. What's
more, you can consume these APIs without being tied to Liferay DXP's UI
(hence the term \emph{headless}). This gives you a great deal of freedom
when designing and developing your apps.

The articles in this section show you how to navigate and consume
Liferay DXP's headless REST APIs. But first, you'll learn the design
approach for these APIs.

\section{OpenAPI}\label{openapi}

\href{https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md}{OpenAPI}
(originally called Swagger) is a Linux Foundation project specification
that defines machine-readable files that describe REST APIs and how to
consume them.

OpenAPI has become a widely adopted standard for defining REST APIs and
is supported by major players in the API ecosystem such as Google,
Amazon, and Microsoft. As a spec, it is language-agnostic, and many
libraries implement it or provide code generation to help validate,
consume, or produce APIs.

Liferay DXP leverages existing knowledge of OpenAPI to define, create
and consume REST APIs.

\section{API Vocabulary}\label{api-vocabulary}

When defining an API, the developer must decide how to expose the
representation of its resources. This determines its ease of use and how
it can evolve. Traditionally, there are two approaches:

\textbf{Contract Last:} The code is written first and features are
exposed as web or REST services. This approach is typically easier for
developers, as they must only implement and expose the business logic.
Service Builder is an example of this.

\textbf{Contract First:} The structure for client-server messages is
written before the code that implements the services. Such messages are
defined independent of the code. This avoids tight coupling and is less
likely to break clients as APIs evolve.

Liferay DXP's headless web APIs use a mixture of both approaches. An
OpenAPI profile uses a contract first approach by defining the paths and
schemas before writing any code. It then generates an API automatically
based on that profile, using the contract-last characteristic of code
generation (like Service Builder). This allows fast development for
developers.

This mixed approach delivers the best of both worlds, allowing a step of
conscious API design and then simplifying the developer experience by
exposing only the business logic to implement.

When writing the OpenAPI profile, the main focus should be on defining
how client-server messages represent the APIs' resources. In other
words, the APIs' schemas are defined first and the attributes,
resources, and operations are named to clearly define what they
represent and how they should be used.

\chapter{Get Started: Find the API}\label{get-started-find-the-api}

To begin consuming web services, you must first know where they are
(e.g., a service catalog), what operations you can invoke, and how to
invoke them. Because Liferay DXP's headless REST APIs leverage
\href{https://en.wikipedia.org/wiki/OpenAPI_Specification}{OpenAPI}
(originally known as Swagger), you don't need a service catalog. You
only need to know the OpenAPI profile from which to discover the rest of
the API.

Liferay DXP's headless APIs are available in SwaggerHub at
\href{https://app.swaggerhub.com/organizations/liferayinc}{\texttt{https://app.swaggerhub.com/organizations/liferayinc}}.
Each API has its own URL in SwaggerHub. For example, you can access the
delivery API definition at
\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}{\texttt{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}}.

Each OpenAPI profile is also deployed dynamically in your portal
instance under this schema:

\begin{verbatim}
http://[host]:[port]/o/[insert-headless-api]/[version]/openapi.yaml
\end{verbatim}

For example, if you're running Liferay DXP locally on port
\texttt{8080}, the home URL for discovering the headless delivery API
is:

\begin{verbatim}
http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml
\end{verbatim}

You must be logged in to access this URL, or use basic authentication
and a browser or other tool like
\href{https://www.getpostman.com}{Postman},
\href{https://install.advancedrestclient.com/install}{Advanced REST
Client}, or even the \texttt{curl} command in your system console.

For simplicity, the examples in this documentation use the \texttt{curl}
command and send requests to a Liferay DXP instance running locally on
port \texttt{8080}.

Run this \texttt{curl} command to access the home URL:

\begin{verbatim}
curl http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml -u test@example.com:test
\end{verbatim}

You should get a response like this:

\begin{verbatim}
openapi: 3.0.1
info:
  title: Headless Delivery
  version: v1.0
paths:
  /v1.0/blog-posting-images/{blogPostingImageId}:
    get:
      tags:
      - BlogPostingImage
      operationId: getBlogPostingImage
      parameters:
      - name: blogPostingImageId
        in: path
        required: true
        schema:
          type: integer
          format: int64
      responses:
        default:
          description: default response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BlogPostingImage'
(...)
\end{verbatim}

This response follows the OpenAPI version 3.0 syntax to specify the
endpoints (URLs) of the API and schemas returned. You can also open the
OpenAPI profile in an OpenAPI editor like the
\href{https://editor.swagger.io}{Swagger Editor}. You can use this
editor to inspect the documentation and parameters and make requests to
the API.

There are also many other tools that support OpenAPI, such as client
generators, validators, parsers, and more. See
\href{https://openapi.tools/}{OpenAPI.Tools} for a comprehensive list.
Leveraging OpenAPI provides standards support, extensive
\href{https://swagger.io/docs/}{documentation}, and industry-wide
conventions.

\section{Related Topics}\label{related-topics-124}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\chapter{How To Invoke a Service}\label{how-to-invoke-a-service}

Once you know which API you want to call via the
\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-discover-the-api}{OpenAPI
profile}, you can send a request to that resource's URL. For example,
suppose you want to retrieve all the blog entries from a Site. If you
consult the OpenAPI profile for Liferay DXP's delivery API, you can find
this endpoint:

\begin{verbatim}
"/sites/{siteId}/blog-postings":
        get:
            operationId: getSiteBlogPostingsPage
            parameters:
                - in: path
                  name: siteId
                  required: true
                  schema:
                      format: int64
                      type: integer
                - in: query
                  name: filter
                  schema:
                      type: string
                - in: query
                  name: page
                  schema:
                      type: integer
                - in: query
                  name: pageSize
                  schema:
                      type: integer
                - in: query
                  name: search
                  schema:
                      type: string
                - in: query
                  name: sort
                  schema:
                      type: string
            responses:
                200:
                    content:
                        application/json:
                            schema:
                                items:
                                    $ref: "#/components/schemas/BlogPosting"
                                type: array
                    description: ""
            tags: ["BlogPosting"]
\end{verbatim}

The only required parameter is \texttt{siteId}, the ID of the blog
postings' Site. Internally, the \texttt{siteId} is a \texttt{groupId}
that you can retrieve from the database, a URL, or Liferay DXP's UI via
the Site Administration menu. The following GET request gets the site's
blog postings by providing the site ID (\texttt{20124}) in the URL:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/" -u 'test@example.com:test'
\end{verbatim}

If you send such a request to a site that contains some blog entries,
the response should look like this:

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

This response is a JSON object with information about the collection of
blogs. The response's attributes contain information about the resource
(blogs, in this case). Also note that the results are paginated. The
\texttt{*page*} attributes refer to pages of results. Here's a
description of some common attributes:

\texttt{id}: Each item has an ID. You can use the ID to retrieve more
information about that item. For example, there are two \texttt{id}
attributes in the above response: one for the blog posting
(\texttt{59301}) and one for the blog post's creator (\texttt{20130}).

\texttt{lastPage}: The page number of the final page of results. The
above response only contains a single page, so its last page is
\texttt{1}.

\texttt{page}: The page number of the current page. The page in the
above response is \texttt{1}.

\texttt{pageSize}: The possible number of this resource's items to be
included in a single page. In the above response this is \texttt{20}.

\texttt{totalCount}: The total number of this resource's existing items
(independent of pagination). The above response lists the total number
of blog postings (\texttt{1}) in a Site.

To get information on a specific blog posting, send a GET request to the
\texttt{blogPostingId} resource's URL with the blog posting's ID
(\texttt{/blog-postings/\{blogPostingId\}}). For example, the URL for
such a request to the blog posting in the above response is
\texttt{/blog-postings/59301}. Here's an example response:

\begin{verbatim}
{
  "alternativeHeadline": "The power of OpenAPI & Liferay",
  "articleBody": "<p>We are happy to announce...</p>",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "dateModified": "2019-04-22T07:04:51Z",
  "datePublished": "2019-04-22T07:02:00Z",
  "encodingFormat": "text/html",
  "friendlyUrlPath": "new-headless-apis",
  "headline": "New Headless APIs",
  "id": 59301,
  "numberOfComments": 0,
  "siteId": 20124
}
\end{verbatim}

Although this response is JSON, the API's consumer can select other
formats to use (like XML). For more information, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}.

\section{Related Topics}\label{related-topics-125}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-discover-the-api}{Get
Started: Discover the API}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\chapter{Making Authenticated
Requests}\label{making-authenticated-requests}

To make an authenticated request, you must authenticate as a specific
User.

There are three authentication mechanisms available when invoking web
APIs:

\textbf{Basic Authentication:} Sends the user credentials as an encoded
user name and password pair. This is the simplest authentication
protocol (available since HTTP/1.0).

\textbf{OAuth 2.0:} In 7.0, you can use OAuth 2.0 for authentication.
See the \href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0
documentation} for more information.

\textbf{Cookie/Session authentication:} From inside the portal you can
make direct requests to the APIs by sending the session token.

First, you'll learn how send requests with basic authentication.

\section{Basic Authentication}\label{basic-authentication}

Basic authentication requires that you send an HTTP
\texttt{Authorization} header containing the encoded user name and
password. You must first get that encoded value. To do so, you can use
\texttt{openssl} or a \texttt{Base64} encoder. Either way, you must
encode the \texttt{user:password} string. Here's an example of the
\texttt{openssl} command for encoding the \texttt{user:password} string
for a user \texttt{test@example.com} with the password \texttt{Liferay}:

\begin{verbatim}
openssl base64 <<< test@example.com:Liferay
\end{verbatim}

This returns the encoded value:

\begin{verbatim}
dGVzdEBleGFtcGxlLmNvbTpMaWZlcmF5Cg==
\end{verbatim}

If you don't have \texttt{openssl} installed, try the \texttt{base64}
command:

\begin{verbatim}
base64 <<< test@example.com:Liferay
\end{verbatim}

\noindent\hrulefill

\textbf{Warning:} Encoding a string as shown here does not encrypt the
resulting string. An encoded string can easily be decoded by executing
\texttt{base64\ \textless{}\textless{}\textless{}\ the-encoded-string},
which returns the original string.

Anyone listening to your request could therefore decode the
\texttt{Authorization} header and reveal your user name and password. To
prevent this, ensure that all communication is made through HTTPS, which
encrypts the entire message (including headers).

\noindent\hrulefill

Use the encoded value for the HTTP Authorization header when sending the
request:

\begin{verbatim}
curl -H "Authorization: Basic dGVzdEBleGFtcGxlLmNvbTpMaWZlcmF5Cg==" http://localhost:8080/o/headless-delivery/v1.0/sites/{siteId}/blog-postings/
\end{verbatim}

The response contains data instead of the 403 error that an
unauthenticated request receives. For more information on the response's
structure, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}.

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    },
    {
      "alternativeHeadline": "How to work with OAuth",
      "articleBody": "<p>To configure OAuth...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T09:35:09Z",
      "dateModified": "2019-04-22T09:35:09Z",
      "datePublished": "2019-04-22T09:34:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "authenticated-requests",
      "headline": "Authenticated requests",
      "id": 59309,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\section{OAuth 2.0 Authorization}\label{oauth-2.0-authorization}

7.0 supports authorization via OAuth 2.0, which is a token-based
authorization mechanism. For more details, see
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation}. The following sections show you how to use OAuth 2.0
to authenticate web API requests.

\section{Obtaining the OAuth 2.0
Token}\label{obtaining-the-oauth-2.0-token}

Before using OAuth 2.0 to invoke a web API, you must register your
application (your web API's consumer) as an authorized OAuth client. To
do this, follow the instructions in the
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{Creating
an Application} section of the OAuth 2.0 documentation. When creating
the application, fill in the form as follows:

\textbf{Application Name:} Your application's name.

\textbf{Client Profile:} Headless Server.

\textbf{Allowed Authorization Types:} Check \emph{Client Credentials}.

After clicking \emph{Save} to finish creating the application, write
down the Client ID and Client Secret values that appear at the top of
the form.

Next, you must get an OAuth 2.0 access token. To do this, see the
tutorial
\href{/docs/7-2/deploy/-/knowledge_base/d/authorizing-account-access-with-oauth2}{Authorizing
Account Access with OAuth 2}.

\section{Invoking the Service with an OAuth 2.0
Token}\label{invoking-the-service-with-an-oauth-2.0-token}

Once you have a valid OAuth 2.0 token, include it in the request's
\texttt{Authorization} header, specifying that the authentication type
is a \href{https://tools.ietf.org/html/rfc6750}{bearer token}. For
example:

\begin{verbatim}
curl -H "Authorization: Bearer d5571ff781dc555415c478872f0755c773fa159" http://localhost:8080/o/headless-delivery/v1.0/sites/{siteId}/blog-postings/
\end{verbatim}

The response contains the resources that the authenticated user has
permission to access, just like the response from Basic authentication.

\section{Using Cookie Authentication or Making Requests from the
UI}\label{using-cookie-authentication-or-making-requests-from-the-ui}

You can call the REST APIs using the existing session from outside
Liferay DXP by passing the session identifier (the cookie reference) and
the Liferay Auth Token (a Cross-Site Request Forgery---CSRF---token).

To do a request from outside Liferay DXP you must provide the
\texttt{Cookie} identifier in the header. In CURL, pass the \texttt{-H}
parameter:

\begin{verbatim}
 -H 'Cookie: JSESSIONID=27D7C95648D7CDBE3347601FC4543F5D'
\end{verbatim}

You must also provide the CSRF token by passing it in the
\texttt{p\_auth} query parameter, or by adding the URL to the whitelist
of CSRF allowed URLs or disabling CSRF checks altogether with the
\texttt{auth.verifier.auth.verifier.PortalSessionAuthVerifier.check.csrf.token}
property (application level).

Here's a sample CURL request with the cookie and CSRF token:

\begin{verbatim}
curl -H 'Cookie: JSESSIONID=27D7C95648D7CDBE3347601FC4543F5D' http://localhost:8080/o/headless-delivery/v1.0/sites/{siteId}/blog-postings/?p_auth=O4dCU1Mj
\end{verbatim}

To do a cookie request from inside Liferay DXP, from JavaScript code or
a Java method, the session identifier is not needed and you must only
provide the CRSF token or add the API to the whitelist of CSRF allowed
URLs.

\section{Making Unauthenticated
Requests}\label{making-unauthenticated-requests}

Unauthenticated requests are disabled by default in Liferay DXP's
headless REST APIs. You can, however, enable them manually by defining
an exception in the Service Access Policy to allow unauthenticated
requests.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to Control Panel → Configuration → Service Access Policy.
\item
  Add a new Service Access Policy.
\item
  Enable both \emph{Enabled} and \emph{Default} options.
\item
  Use
  \texttt{com.liferay.headless.delivery.internal.resource.v1\_0.OpenAPIResourceImpl}
  for the Service Class and \texttt{getOpenAPI} for the Method Name (or
  the method/class you want to expose).
\item
  Test the APIs by making a request to an OpenAPI profile URL:
\end{enumerate}

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/openapi.yaml"
\end{verbatim}

You should get the OpenAPI profile for the API you sent the request to.

\section{Cross-Origin Resource Sharing
(CORS)}\label{cross-origin-resource-sharing-cors}

Modern web browsers block access to content from domains other than the
one currently being visited. For example, browsers block fetch/ajax
requests from a local JavaScript application (being executed in
localhost:4000) that tries to access a Tomcat server (running in
localhost:8080).

Cross Origin Resource Sharing allows the configuration of safe resource
sharing between sites. A web application using APIs can only request
endpoints that have the same origin/domain unless some special CORS
headers are set that explicitly allow querying from different domains.

For development purposes, it's common to enable CORS headers to allow
scripts to call APIs served by a different server.

\begin{figure}
\centering
\includegraphics{./images/cors.png}
\caption{Configure Cross-Origin Resource Sharing in Liferay}
\end{figure}

Follow these instructions to configure
\href{/docs/7-2/deploy/-/knowledge_base/d/configuring-cors}{Cross-Origin
Resource Sharing (CORS)} in Liferay DXP.

\section{Related Topics}\label{related-topics-126}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{Working with Collections of
Data}\label{working-with-collections-of-data}

Collection resources are common in Liferay DXP web APIs. If you followed
along with the previous examples that sent requests to the portal's
\texttt{blog-postings} resource URL, you've already seen collections in
action: the \texttt{BlogPosting} resource is a collection.

Here, you'll learn more detailed information about working with
collection resources. But first you should learn about how collections
are returned in pages.

\section{Pagination}\label{pagination}

A small collection can be transmitted in a single response without
difficulty. Transmitting a large collection all at once, however, can
consume too much bandwidth, time, and memory. It can also overwhelm the
user with too much data. It's therefore best to get and display the
elements of a large collection in discrete chunks, or pages.

Liferay DXP's headless REST APIs return paginated collections by
default. The following attributes in the responses also contain the
information needed to navigate between those pages:

\texttt{totalCount}: The total number of this resource's items.

\texttt{pageSize}: The number of this resource's items to be included in
this response.

\texttt{page}: The current page's number.

\texttt{lastPage}: The last page's number.

\texttt{items}: The collection elements present in this page. Each
element also contains the data of the object it represents, so there's
no need for additional requests for individual elements.

\texttt{id}: Each item's identifier. You can use this, if necessary, to
get more information on a specific item.

For examples of working with collection pages, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/pagination}{Pagination}.

\chapter{Getting Collections}\label{getting-collections}

Requests for collection resources are the same as those for
non-collection resources. For example, an
\href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{authenticated
request} to the \texttt{UserAccount} endpoint returns a collection
containing the portal's users. When sending this request, use the
credentials of an administrative user who has permission to view other
portal users:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

The response (below) has two main parts:

\begin{itemize}
\item
  The list of collection elements, inside the \texttt{items} attribute.
  This example contains data on two users: an administrator (Test), and
  a user named Javier Gamarra.
\item
  A set of metadata about the collection. This is the rest of the data
  in the response. This lets clients know how to use the collection.
\end{itemize}

This response is in JSON, which is the default response format for web
APIs in Liferay DXP. For information on specifying other response
formats, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}.

\begin{verbatim}
{
  "items": [
    {
      "alternateName": "test",
      "birthDate": "1970-01-01T00:00:00Z",
      "contactInformation": {},
      "dashboardURL": "/user/test",
      "dateCreated": "2019-04-17T20:37:19Z",
      "dateModified": "2019-04-22T09:56:35Z",
      "emailAddress": "test@example.com",
      "familyName": "Test",
      "givenName": "Test",
      "id": 20130,
      "name": "Test Test",
      "profileURL": "/web/test",
      ...
    },
    {
      "alternateName": "nhpatt",
      "birthDate": "1970-01-01T00:00:00Z",
      "contactInformation": {},
      "dateCreated": "2019-04-22T10:38:36Z",
      "dateModified": "2019-04-22T10:38:37Z",
      "emailAddress": "nhpatt@gmail.com",
      "familyName": "Gamarra",
      "givenName": "Javier",
      "id": 59347,
      "name": "Javier Gamarra",
      ...
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\section{Related Topics}\label{related-topics-127}

\href{/docs/7-2/frameworks/-/knowledge_base/f/pagination}{Pagination}

\href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{Making
Authenticated Requests}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\chapter{Pagination}\label{pagination-1}

Collection resources are returned in pages of information.
\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data} explains this in more detail. Here, you'll
learn how to work with collection pages.

For example, suppose that there are 123 users your portal and you want
to get information on them. To do this, send an
\href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{authenticated
request} to the UserAccount URL:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

The response contains the first 30 users and IDs for navigating the rest
of the collection. Note that most of the contents of the \texttt{items}
attribute, which contains the users, are omitted here so you can focus
on the metadata for navigating the collection:

\begin{verbatim}
{
  "items": [
    {
      "id": 20130,
      ...
    },
    {
      "id": 59347,
      ...
    }
  ],
  "lastPage": 5,
  "page": 1,
  "pageSize": 30,
  "totalCount": 123
}
\end{verbatim}

The attributes \texttt{page} and \texttt{pageSize} allow client
applications to navigate through the results. For example, such a client
could send a request for a specific page. This example gets the second
page (\texttt{?page=2}) of documents that exist on the site with the ID
\texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/documents?page=2"  -u 'test@example.com:test'
\end{verbatim}

Similarly, you can customize the number of elements per page via the
optional parameter \texttt{pageSize} (e.g., \texttt{?pageSize=20}).

\section{Related Topics}\label{related-topics-128}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{Making
Authenticated Requests}

\chapter{Navigating from a Collection to its
Elements}\label{navigating-from-a-collection-to-its-elements}

When you
\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-collections}{get a
collection}, you can use the response to get an element of that
collection. Follow these steps to do so:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Get a collection. This example gets a list of users by sending
  \href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{an
  authenticated request} to the \texttt{user-accounts} collection:

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts"  -u 'test@example.com:test'
\end{verbatim}

  Recall from
  \href{/docs/7-2/frameworks/-/knowledge_base/f/getting-collections}{Getting
  Collections} that the response's \texttt{items} attribute contains the
  collection elements. In this case, the collection contains two users:
  Test Test and Javier Gamarra:

  \texttt{json\ \{\ \ \ \ \ "totalItems":\ 2,\ \ \ \ \ "numberOfItems":\ 2,\ \ \ \ \ "view":\ \{\ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ "items":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "alternateName":\ "test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "birthDate":\ "1970-01-01T00:00:00Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "contactInformation":\ \{\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dashboardURL":\ "/user/test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateCreated":\ "2019-04-17T20:37:19Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateModified":\ "2019-04-22T09:56:35Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "emailAddress":\ "test@example.com",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "familyName":\ "Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "givenName":\ "Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20130,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Test\ Test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "profileURL":\ "/web/test",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "roleBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20108,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Administrator"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20111,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Power\ User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20112,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "siteBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20128,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Global"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20124,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Guest"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]}\ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "alternateName":\ "nhpatt",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "birthDate":\ "1970-01-01T00:00:00Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "contactInformation":\ \{\},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateCreated":\ "2019-04-22T10:38:36Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "dateModified":\ "2019-04-22T10:38:37Z",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "emailAddress":\ "nhpatt@gmail.com",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "familyName":\ "Gamarra",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "givenName":\ "Javier",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 59347,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Javier\ Gamarra",\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "roleBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20112,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "User"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "siteBriefs":\ {[}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20128,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Global"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "id":\ 20124,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "name":\ "Guest"\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {]}\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ {]},\ \ \ \ \ \ \ \ \ \ \ "lastPage":\ 1,\ \ \ \ \ \ \ \ \ \ \ "page":\ 1,\ \ \ \ \ \ \ \ \ \ \ "pageSize":\ 20,\ \ \ \ \ \ \ \ \ \ \ "totalCount":\ 2\ \ \ \ \ \ \ \ \ \}}
\item
  In the response, locate the ID of the element you want and look in the
  OpenAPI profile for the appropriate GET item endpoint. For example,
  the \texttt{user-accounts} GET item endpoint is
  \texttt{/user-accounts/\{userAccountId\}}.
\item
  Send a GET request to that endpoint. For example, this request gets
  information for the user with the ID \texttt{59347} (Javier Gamarra):

\begin{verbatim}
curl "http://localhost:8080/o/headless-admin-user/v1.0/user-accounts/59347"  -u 'test@example.com:test'
\end{verbatim}
\end{enumerate}

\section{Related Topics}\label{related-topics-129}

\href{/docs/7-2/frameworks/-/knowledge_base/f/getting-collections}{Getting
Collections}

\href{/docs/7-2/frameworks/-/knowledge_base/f/pagination}{Pagination}

\href{/docs/7-2/frameworks/-/knowledge_base/f/making-authenticated-requests}{Making
Authenticated Requests}

\chapter{API Formats and Content
Negotiation}\label{api-formats-and-content-negotiation}

The responses in the preceding examples use a standard JSON format,
which is the default response format for Liferay DXP's headless REST
APIs. You can also use other formats like XML. Formats typically differ
in the resource metadata's structure or semantics. There's no best
format; use the one that best fits your use case.

You use \emph{content negotiation} to specify different formats for use.
Content negotiation is how the client and server establish the format
they use to exchange messages. The client tells the server its preferred
format via the HTTP headers \texttt{Accept} and \texttt{Content-Type}.
Each format has a string identifier (its MIME type) that you can use in
the HTTP headers to specify the format. The following table lists the
MIME type for each supported format.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2812}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
API Format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
~MIME Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
application/json &
\href{https://www.iana.org/assignments/media-types/application/json}{application/json} \\
application/xml &
\href{https://www.iana.org/assignments/media-types/application/xml}{application/xml} \\
\end{longtable}

\noindent\hrulefill

When you send a request without specifying the API format, the server
responds with the default JSON. For example, here's such a request for a
list of folders from the Site with the ID \texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/document-folders" -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T10:21:20Z",
      "dateModified": "2019-04-22T10:21:20Z",
      "id": 59319,
      "name": "REST APIs Documentation",
      "numberOfDocumentFolders": 0,
      "numberOfDocuments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

If you request the headers, the \texttt{Content-Type} response attribute
lists the content type's format (JSON, in this case):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/document-folders" -u 'test@example.com:test' --head
\end{verbatim}

\begin{verbatim}
HTTP/1.1 200 
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1
Set-Cookie: JSESSIONID=9F61AEB8721DD9149BD577ECBC31AE3F; Path=/; HttpOnly
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: private, no-cache, no-store, must-revalidate
Pragma: no-cache
Set-Cookie: COOKIE_SUPPORT=true; Max-Age=31536000; Expires=Tue, 21-Apr-2020 10:23:57 GMT; Path=/; HttpOnly
Set-Cookie: GUEST_LANGUAGE_ID=en_US; Max-Age=31536000; Expires=Tue, 21-Apr-2020 10:23:57 GMT; Path=/; HttpOnly
Date: Mon, 22 Apr 2019 10:23:57 GMT
Content-Type: application/json
Transfer-Encoding: chunked
\end{verbatim}

To get the response in XML instead, specify \texttt{application/xml} in
the request's \texttt{Accept} header. Note that the XML response
includes the same information as JSON, but is structured differently:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/documents/59203"  -H 'Accept: application/xml'  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
    <Page>
        <items>
            <items>
                <creator>
                    <familyName>Test</familyName>
                    <givenName>Test</givenName>
                    <id>20130</id>
                    <name>Test Test</name>
                    <profileURL>/web/test</profileURL>
                    </creator>
                <dateCreated>2019-04-22T10:21:20Z</dateCreated>
                <dateModified>2019-04-22T10:21:20Z</dateModified>
                <id>59319</id>
                <name>REST APIs Documentation</name>
                <numberOfDocumentFolders>0</numberOfDocumentFolders>
                <numberOfDocuments>0</numberOfDocuments>
                <siteId>20124</siteId>
            </items>
        </items>
        <lastPage>1</lastPage>
        <page>1</page>
        <pageSize>20</pageSize>
        <totalCount>1</totalCount>
    </Page>
\end{verbatim}

Requesting the headers, you can see that the response is in XML
(\texttt{application/xml}):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/documents/59203"  -H 'Accept: application/xml'  -u 'test@example.com:test' --head
\end{verbatim}

\begin{verbatim}
HTTP/1.1 200 
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: private, no-cache, no-store, must-revalidate
Pragma: no-cache
Date: Mon, 22 Apr 2019 10:26:21 GMT
Content-Type: application/xml
Transfer-Encoding: chunked
\end{verbatim}

\section{Language Negotiation}\label{language-negotiation}

The same mechanism used for requesting another response format (content
negotiation) is used for requesting content in another language.

APIs that are available in different languages return the options in a
block called \texttt{availableLanguages}. For example, this block in the
following response lists U.S. English (\texttt{en-US}) and
Spain/Castilian Spanish (\texttt{es-ES}):

\begin{verbatim}
{
  "availableLanguages": [
    "en-US",
    "es-ES"
  ],
  "contentFields": [
    {
      "dataType": "html",
      "name": "content",
      "repeatable": false,
      "value": {
        "data": "<p>The main reason is because Headless APIs have been designed with real use cases in mind...</p>"
      }
    }
  ],
  "contentStructureId": 36801,
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T10:29:40Z",
  "dateModified": "2019-04-22T10:30:31Z",
  "datePublished": "2019-04-22T10:28:00Z",
  "friendlyUrlPath": "why-headless-apis-are-better-than-json-ws-services-",
  "id": 59325,
  "key": "59323",
  "numberOfComments": 0,
  "renderedContents": [
    {
      "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
      "templateName": "Basic Web Content"
    }
  ],
  "siteId": 20124,
  "title": "Why Headless APIs are better than JSON-WS services?",
  "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
}
\end{verbatim}

To request the content in another language, specify your desired locale
in the request's \texttt{Accept-Language} header:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325"  -H 'Accept-Language: es-ES'  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
    {
      "availableLanguages": [
        "en-US",
        "es-ES"
      ],
      "contentFields": [
        {
          "dataType": "html",
          "name": "content",
          "repeatable": false,
          "value": {
            "data": "<p>La principal razón es porque las APIs Headless se han diseñado pensando en casos de uso reales...</p>"
          }
        }
      ],
      "contentStructureId": 36801,
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T10:29:40Z",
      "dateModified": "2019-04-22T10:30:31Z",
      "datePublished": "2019-04-22T10:28:00Z",
      "friendlyUrlPath": "%C2%BFpor-qu%C3%A9-las-apis-headless-son-mejores-que-json-ws-",
      "id": 59325,
      "key": "59323",
      "numberOfComments": 0,
      "renderedContents": [
        {
          "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
          "templateName": "Contenido web básico"
        }
      ],
      "siteId": 20124,
      "title": "¿Por qué las APIs Headless son mejores que JSON-WS?",
      "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
    }
\end{verbatim}

\section{Creating Content with Different
Languages}\label{creating-content-with-different-languages}

By default, when sending a POST/PUT request, the
\texttt{Accept-Language} header is used as the content's language.
However, there is one exception. Some entities require the first POST to
be in the Site's default language. In such cases, a POST request for a
different language results in an error.

After creating a new resource, PUT requests in a different language adds
that translation. PATCH requests return an error (you are expected to
update, not create, in a PATCH request).

\section{Related Topics}\label{related-topics-130}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-discover-the-api}{Get
Started: Discover the API}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\chapter{OpenAPI Profiles}\label{openapi-profiles}

All the APIs exposed by Liferay DXP are available under the
\href{https://app.swaggerhub.com/organizations/liferayinc}{liferayinc
SwaggerHub organization}.

Liferay DXP's headless APIs are categorized in two different use cases:

\begin{itemize}
\tightlist
\item
  Delivering content (delivery APIs)
\item
  Managing and administering content (admin APIs)
\end{itemize}

The available APIs demonstrate this categorization.

\section{Headless Delivery}\label{headless-delivery}

The following table lists the APIs that
\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0}{Headless
Delivery} contains. Note that the second column shows which internal
model in Liferay DXP that the API maps to.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2812}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
API
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
~Internal Model
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{BlogPosting} & \texttt{BlogsEntry} \\
\texttt{BlogPostingImage} & \texttt{DLFileEntry} (associated with a
\texttt{BlogsEntry}) \\
\texttt{Comment} & \texttt{DiscussionComment} \\
\texttt{ContentDocument} & \texttt{DLFileEntry} (associated with a
\texttt{JournalArticle}) \\
\texttt{ContentSet} & \texttt{AssetListEntry} \\
\texttt{ContentStructure} & \texttt{DDMStructure} \\
\texttt{Document} & \texttt{DLFileEntry} \\
\texttt{DocumentFolder} & \texttt{Folder} \\
\texttt{KnowledgeBaseArticle} & \texttt{KBArticle} \\
\texttt{KnowledgeBaseAttachment} & \texttt{FileEntry} (associated with a
\texttt{KBArticle}) \\
\texttt{KnowledgeBaseFolder} & \texttt{KBFolder} \\
\texttt{MessageBoardAttachment} & \texttt{FileEntry} (associated with a
\texttt{MBMessage}) \\
\texttt{MessageBoardMessage} & \texttt{MBMessage} \\
\texttt{MessageBoardSection} & \texttt{MBCategory} \\
\texttt{MessageBoardThread} & \texttt{MBThread} \\
\texttt{Rating} & \texttt{RatingsEntry} \\
\texttt{StructuredContent} & \texttt{JournalArticle} \\
\texttt{StructuredContentFolder} & \texttt{JournalFolder} \\
\end{longtable}

\noindent\hrulefill

\section{Headless Administration}\label{headless-administration}

There are several headless admin APIs, each containing its own set of
APIs. The following tables list these, as well as any internal models in
Liferay DXP that each API maps to.

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-user/1.0}{Headless
Admin User} contains the following APIs for retrieving and managing
information about users and organizations.

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
API & ~Internal Model \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{EmailAddress} & N/A \\
\texttt{Organization} & N/A \\
\texttt{Phone} & N/A \\
\texttt{PostalAddress} & \texttt{Address} \\
\texttt{Role} & N/A \\
\texttt{Segment} & \texttt{SegmentEntry} \\
\texttt{SegmentUser} & N/A \\
\texttt{SiteBrief} & N/A \\
\texttt{UserAccount} & \texttt{User} \\
\texttt{WebUrl} & \texttt{WebSite} \\
\end{longtable}

\noindent\hrulefill

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-taxonomy/1.0}{Headless
Admin Taxonomy} contains the following APIs for managing asset
categories, asset vocabularies, and asset tags.

\noindent\hrulefill

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
API & ~Internal Model \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{Keyword} & \texttt{AssetTag} \\
\texttt{TaxonomyCategory} & \texttt{AssetCategory} \\
\texttt{TaxonomyVocabulary} & \texttt{AssetVocabulary} \\
\end{longtable}

\noindent\hrulefill

\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-workflow/1.0}{Headless
Admin Workflow} contains APIs for transitioning workflows.

\section{Related Topics}\label{related-topics-131}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\chapter{Filter, Sort, and Search}\label{filter-sort-and-search}

You can use Liferay DXP's headless REST APIs to search for content
you're interested in. You can also sort and filter content. Here, you'll
learn how.

\section{Filter}\label{filter}

It's often useful to filter large collections for the exact data that
you need. Not all collections, however, allow filtering. The ones that
support it contain the optional parameter \texttt{filter} in their
OpenAPI profile. To filter a collection based on the value of one or
more fields, use the \texttt{filter} parameter following a subset of the
\href{https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html\#sec_BuiltinFilterOperations}{oData
standard}.

Filtering mainly applies to fields indexed as keywords in Liferay DXP's
search. To find content by terms contained in fields indexed as text,
you should instead use \hyperref[search]{search}.

\section{Comparison Operators}\label{comparison-operators}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{eq} \textbar{} Equal \textbar{}
\texttt{addressLocality\ eq\ \textquotesingle{}Redmond\textquotesingle{}}
\textbar{} \textbar{} Equal null \textbar{}
\texttt{addressLocality\ eq\ null} \textbar{} \texttt{ne} \textbar{} Not
equal \textbar{}
\texttt{addressLocality\ ne\ \textquotesingle{}London\textquotesingle{}}
\textbar{} \textbar{} Not null \textbar{}
\texttt{addressLocality\ ne\ null} \textbar{} \texttt{gt} \textbar{}
Greater than \textbar{} \texttt{price\ gt\ 20} \textbar{} \texttt{ge}
\textbar{} Greater than or equal \textbar{} \texttt{price\ ge\ 10}
\textbar{} \texttt{lt} \textbar{} Less than \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} \texttt{le}
\textbar{} Less than or equal \textbar{}
\texttt{dateCreated\ le\ 2012-05-29T09:13:28Z} \textbar{}
\texttt{startswith} \textbar{} Starts with \textbar{}
\texttt{startswith(addressLocality,\ \textquotesingle{}Lond\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{Logical Operators}\label{logical-operators}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{and} & Logical and &
\texttt{price\ le\ 200\ and\ price\ gt\ 3.5} \\
\texttt{or} & Logical or &
\texttt{price\ le\ 3.5\ or\ price\ gt\ 200} \\
\texttt{not} & Logical not & \texttt{not\ (price\ le\ 3.5)} \\
\end{longtable}

\noindent\hrulefill

Note that the \texttt{not} operator needs a space character after it.

\section{Grouping Operators}\label{grouping-operators}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{(\ )} \textbar{} Precedence grouping \textbar{}
\texttt{(price\ eq\ 5)\ or\ (addressLocality\ eq\ \textquotesingle{}London\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{String Functions}\label{string-functions}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Function & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{contains} & Contains &
\texttt{contains(title,\textquotesingle{}edmon\textquotesingle{})} \\
\end{longtable}

\noindent\hrulefill

\section{Lambda Operators}\label{lambda-operators}

Lambda operators evaluate a boolean expression on a collection. They
must be prepended with a navigation path that identifies a collection.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2206}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1618}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6176}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lambda Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{any} & Any &
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))} \\
\end{longtable}

\noindent\hrulefill

The \texttt{any} operator applies a boolean expression to each
collection element and evaluates to \texttt{true} if the expression is
true for any element.

\section{Operator combinations and OData
syntax}\label{operator-combinations-and-odata-syntax}

Syntax examples and other operator combinations are covered in the
\href{https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html\#sec_BuiltinFilterOperations}{OData
standard reference}.

\section{Escaping in Queries}\label{escaping-in-queries}

You can escape a single quote in a value by adding another single quote.
For example, to filter for a blog posting whose headline is
\texttt{New\ Headless\ APIs}, append this filter string to the request
URL:

\begin{verbatim}
?filter=headline eq 'New Headless APIs'
\end{verbatim}

Here's an example of the full request:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?filter=headline%20eq%20%27New%20Headless%20APIs%27"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\section{Filtering in Structured Content Fields
(ContentField)}\label{filtering-in-structured-content-fields-contentfield}

To filter for a \texttt{ContentField} value (dynamic values created by
the end user), you must use the endpoints that are scoped to an
individual \texttt{ContentStructure}. To do so, find the ID of the
\texttt{ContentStructure} and use it in place of
\texttt{\{contentStructureId\}} in this URL:

\begin{verbatim}
"/content-structures/{contentStructureId}/structured-contents"
\end{verbatim}

\section{Search}\label{search-2}

It's often useful to search large collections with keywords. Use search
when you want results from any field, rather than specific ones. To
perform a search, use the optional parameter \texttt{search} followed by
the search terms. For example, this request searches for all the
\texttt{BlogEntry} fields containing OAuth:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?search=OAuth"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "How to work with OAuth",
      "articleBody": "<p>To configure OAuth...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T09:35:09Z",
      "dateModified": "2019-04-22T09:35:09Z",
      "datePublished": "2019-04-22T09:34:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "authenticated-requests",
      "headline": "Authenticated requests",
      "id": 59309,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\section{Sorting}\label{sorting}

Sorting collection results is another common task. Note, however, that
not all collections allow sorting. The ones that support it contain the
optional parameter \texttt{\{lb\}?sort\{rb\}} in their OpenAPI profile.

To get sorted collection results, append
\texttt{?sort=\textless{}param-name\textgreater{}} to the request URL.
For example, appending \texttt{?sort=title} to the request URL sorts the
results by title.

The default sort order is ascending (0-1, A-Z). To perform a descending
sort, append \texttt{:desc} to the parameter name. For example, to
perform a descending sort by title, append \texttt{?sort=title:desc} to
the request URL.

To sort by more than one parameter, separate the parameter names by
commas and put them in order of priority. For example, to sort first by
title and then by creation date, append \texttt{?sort=title,dateCreated}
to the request URL.

To specify a descending sort for only one parameter, you must explicitly
specify ascending sort order (\texttt{:asc}) for the other parameters.
For example:

\begin{verbatim}
?sort=headline:desc,dateCreated:asc
\end{verbatim}

\section{Flatten}\label{flatten}

Some collections (as defined in their OpenAPI profile) allow the query
parameter \texttt{flatten}, which returns all resources and disregards
folders or other hierarchical classifications. This parameter's default
value is \texttt{false}, so a document query to the root folder returns
only the documents in that folder. With \texttt{flatten} set to
\texttt{true}, the same query also returns documents in any subfolders,
regardless of how deeply those folders are nested. In other words,
setting \texttt{flatten} set to \texttt{true} and querying for documents
in a Site's root folder returns all the documents in the Site.

\section{Related Topics}\label{related-topics-132}

\href{/docs/7-2/frameworks/-/knowledge_base/f/filter-sort-and-search}{Making
Authenticated Requests}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{Restrict Properties}\label{restrict-properties}

Retrieving large entities or collections increases the response's size
and uses more bandwidth. You can alleviate this by telling the server
via the request which fields it should include in the response. This is
known as \emph{sparse fieldsets}. To make a request with sparse
fieldsets, include the \texttt{fields} parameter in the URL with the
name of each field's attribute.

For example, this request doesn't use sparse fieldsets and therefore
returns all the fields of a blog posting:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "alternativeHeadline": "The power of OpenAPI & Liferay",
  "articleBody": "<p>We are happy to announce...</p>",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "dateModified": "2019-04-22T07:04:51Z",
  "datePublished": "2019-04-22T07:02:00Z",
  "encodingFormat": "text/html",
  "friendlyUrlPath": "new-headless-apis",
  "headline": "New Headless APIs",
  "id": 59301,
  "numberOfComments": 0,
  "siteId": 20124
}
\end{verbatim}

To get only the headline, creation date, and creator, append the
\texttt{fields} parameter to the URL with the fields \texttt{headline},
\texttt{dateCreated}, and \texttt{creator}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301?fields=headline,dateCreated,creator"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "headline": "New Headless APIs"
}
\end{verbatim}

In the response, the \texttt{creator} attribute is a nested JSON object.
To return only the creator's name, specify that nested field via dot
notation (\texttt{creator.name}):

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/blog-postings/59301?fields=headline,dateCreated,creator.name"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "creator": {
    "name": "Test Test"
  },
  "dateCreated": "2019-04-22T07:04:47Z",
  "headline": "New Headless APIs"
}
\end{verbatim}

The \texttt{fields} parameter also works with collection resources to
return the specified attributes for every collection item. For example,
this request gets the headlines for all the blog postings in the Site
with the ID \texttt{20124}:

\begin{verbatim}
curl "http://localhost:8080/o/headless-delivery/v1.0/sites/20124/blog-postings/?fields=headline"  -u 'test@example.com:test'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "headline": "New Headless APIs"
    },
    {
      "headline": "Authenticated requests"
    }
  ],
  "lastPage": 1,
  "page": 1,
  "pageSize": 20,
  "totalCount": 2
}
\end{verbatim}

\section{Related Topics}\label{related-topics-133}

\href{/docs/7-2/frameworks/-/knowledge_base/f/filter-sort-and-search}{Making
Authenticated Requests}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{Multipart Requests}\label{multipart-requests}

Several operations accept a binary file via a multipart request. For
example, the definition for posting a file to a \texttt{DocumentFolder}
specifies a multipart request:

\begin{verbatim}
post:
    operationId: postDocumentFolderDocument
    parameters:
        - in: path
          name: documentFolderId
          required: true
          schema:
              format: int64
              type: integer
    requestBody:
        content:
            multipart/form-data:
                schema:
                    properties:
                        document:
                            $ref: "#/components/schemas/Document"
                        file:
                            format: binary
                            type: string
                    type: object
    responses:
        200:
            content:
                application/json:
                    schema:
                        $ref: "#/components/schemas/Document"
                application/xml:
                    schema:
                        $ref: "#/components/schemas/Document"
            description: ""
    tags: ["Document"]
\end{verbatim}

This operation returns a \texttt{Document} (in JSON or XML). To create
this \texttt{Document}, you must supply the operation's multipart
request with 2 components:

\begin{itemize}
\tightlist
\item
  A binary file (bytes) via the \texttt{file} property
\item
  A JSON string with the binary file's metadata, via the
  \texttt{document} property
\end{itemize}

To send this request, the \texttt{Content-Type} must be
\texttt{multipart/form-data}, and you must also specify a boundary name
(the boundary name can be arbitrary).

Here's an example request (without the file's bytes) that creates a
document in the folder with the ID \texttt{38549}:

\begin{verbatim}
curl -X "POST" "http://localhost:8080/o/headless-delivery/v1.0/document-folders/38549/documents" \
     -H 'Accept: application/json' \
     -H 'Content-Type: multipart/form-data; boundary=PART' \
     -u 'test@example.com:test' \
     -F "file=" \
     -F "document={\"title\": \"podcast\"}"
\end{verbatim}

And here's the response:

\begin{verbatim}
{
  "contentUrl": "/documents/20123/38549/podcast.mp3/e978e316-620c-df9f-e0bd-7cc0447cca49?version=1.0&t=1556100111417",
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20129,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-24T10:01:51Z",
  "dateModified": "2019-04-24T10:01:51Z",
  "documentFolderId": 38549,
  "encodingFormat": "audio/mpeg",
  "fileExtension": "mp3",
  "id": 38553,
  "numberOfComments": 0,
  "sizeInBytes": 28482097,
  "title": "podcast"
}
\end{verbatim}

\section{Related Topics}\label{related-topics-134}

\href{/docs/7-2/frameworks/-/knowledge_base/f/filter-sort-and-search}{Making
Authenticated Requests}

\href{/docs/7-2/frameworks/-/knowledge_base/f/api-formats-and-content-negotiation}{API
Formats and Content Negotiation}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{How to get siteId}\label{how-to-get-siteid}

Several APIs (generally all collection APIs) need the \texttt{siteId}
parameter to to execute requests. The \texttt{siteId} is the internal
identifier of the Site where that content was created.

\section{Using siteId or siteKey}\label{using-siteid-or-sitekey}

In all the APIs available from 7.2 GA2+, the \texttt{siteKey} is also
accepted as a valid parameter. The \texttt{siteKey} is the external name
of the Site (for example \texttt{Guest}).

In the REST APIs, you can use \texttt{siteKey} in all the places that
expect a \texttt{siteId}; in GraphQL APIs, there are two different
parameters: \texttt{siteId} and \texttt{siteKey}.

Using the \texttt{siteKey} is recommended over \texttt{siteId} in all
situations because it's more recognizable, doesn't expose an internal
parameter, and doesn't change in import/export processes.

\section{Obtain siteId}\label{obtain-siteid}

There are several ways to retrieve the \texttt{siteId}:

\begin{itemize}
\item
  Use the Site API to query it by name, friendly URL or in the list of a
  User's Sites.
\item
  From Liferay DXP's UI in the Site Administration menu (not
  recommended).
\item
  From the \texttt{Group} table in the database (not recommended).
\item
  From the \texttt{ThemeDisplay} object in JavaScript or Java:

\begin{verbatim}
  themeDisplay.getSiteGroupId()
\end{verbatim}
\end{itemize}

\begin{figure}
\centering
\includegraphics{./images/rest-site-id.png}
\caption{GraphQL BlogPostings definition}
\end{figure}

\chapter{Filterable properties}\label{filterable-properties}

Some APIs return data that can be filtered and sorted by several
properties. This is a non-comprehensive list of the properties that can
be used to filter or sort.

\section{Headless Delivery API}\label{headless-delivery-api}

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/BlogPosting}{BlogPosting}}{BlogPosting}}\label{blogposting}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} taxonomyCategoryIds
\textbar{} list \textbar{} \texttt{taxonomyCategoryIds/any(t:t\ eq\ 1)}
\textbar{} keywords \textbar{} list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
customFields \textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{}
headline \textbar{} string \textbar{}
\texttt{contains(headline,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/BlogPostingImage}{BlogPostingImage}}{BlogPostingImage}}\label{blogpostingimage}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} encodingFormat
\textbar{} id \textbar{} \texttt{encodingFormat\ eq\ 1} \textbar{}
sizeInBytes \textbar{} integer \textbar{} \texttt{sizeInBytes\ eq\ 1}
\textbar{} fileExtension \textbar{} string \textbar{}
\texttt{contains(fileExtension,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} title \textbar{} string \textbar{}
\texttt{contains(title,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/Comment}{Comment}}{Comment}}\label{comment}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z}\textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/ContentStructure}{ContentStructure}}{ContentStructure}}\label{contentstructure}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/Document}{Document}}{Document}}\label{document}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} taxonomyCategoryIds
\textbar{} list \textbar{} \texttt{taxonomyCategoryIds/any(t:t\ eq\ 1)}
\textbar{} keywords \textbar{} list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
customFields \textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{}
encodingFormat \textbar{} id \textbar{} \texttt{encodingFormat\ eq\ 1}
\textbar{} creatorId \textbar{} integer \textbar{}
\texttt{creatorId\ eq\ 1} \textbar{} sizeInBytes \textbar{} integer
\textbar{} \texttt{sizeInBytes\ eq\ 1} \textbar{} fileExtension
\textbar{} string \textbar{}
\texttt{contains(fileExtension,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} title \textbar{} string \textbar{}
\texttt{contains(title,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/DocumentFolder}{DocumentFolder}}{DocumentFolder}}\label{documentfolder}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} customFields
\textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/KnowledgeBaseArticle}{KnowledgeBaseArticle}}{KnowledgeBaseArticle}}\label{knowledgebasearticle}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} taxonomyCategoryIds
\textbar{} list \textbar{} \texttt{taxonomyCategoryIds/any(t:t\ eq\ 1)}
\textbar{} keywords \textbar{} list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
customFields \textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} title
\textbar{} string \textbar{}
\texttt{contains(title,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/MessageBoardMessage}{MessageBoardMessage}}{MessageBoardMessage}}\label{messageboardmessage}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} showAsAnswer
\textbar{} boolean \textbar{} \texttt{showAsAnswer\ eq\ true} \textbar{}
showAsQuestion \textbar{} boolean \textbar{}
\texttt{showAsQuestion\ eq\ true} \textbar{} taxonomyCategoryIds
\textbar{} list \textbar{} \texttt{taxonomyCategoryIds/any(t:t\ eq\ 1)}
\textbar{} keywords \textbar{} list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
customFields \textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{}
messageBoardSectionId \textbar{} integer \textbar{}
\texttt{messageBoardSectionId\ eq\ 1} \textbar{} headline \textbar{}
string \textbar{}
\texttt{contains(headline,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/MessageBoardSection}{MessageBoardSection}}{MessageBoardSection}}\label{messageboardsection}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} customFields
\textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{} title
\textbar{} string \textbar{}
\texttt{contains(title,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/StructuredContent}{StructuredContent}}{StructuredContent}}\label{structuredcontent}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} taxonomyCategoryIds
\textbar{} list \textbar{} \texttt{taxonomyCategoryIds/any(t:t\ eq\ 1)}
\textbar{} keywords \textbar{} list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
contentFields \textbar{} complex \textbar{}
\texttt{contentFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} customFields \textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} datePublished
\textbar{} date \textbar{}
\texttt{datePublished\ lt\ 2018-02-13T12:33:12Z} \textbar{}
contentStructureId \textbar{} integer \textbar{}
\texttt{contentStructureId\ eq\ 1} \textbar{} title \textbar{} string
\textbar{}
\texttt{contains(title,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/StructuredContentFolder}{StructuredContentFolder}}{StructuredContentFolder}}\label{structuredcontentfolder}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} customFields
\textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/WikiNode}{WikiNode}}{WikiNode}}\label{wikinode}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} creatorId
\textbar{} integer \textbar{} \texttt{creatorId\ eq\ 1} \textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-delivery/v1.0\#/WikiPage}{WikiPage}}{WikiPage}}\label{wikipage}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} customFields
\textbar{} complex \textbar{}
\texttt{customFields/Name\ eq\ \textquotesingle{}Article1\textquotesingle{}}
\textbar{} dateCreated \textbar{} date \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} dateModified
\textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} headline
\textbar{} string \textbar{}
\texttt{contains(headline,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{Headless Admin User API}\label{headless-admin-user-api}

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-user/v1.0\#/Organization}{Organization}}{Organization}}\label{organization}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} keywords \textbar{}
list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{}
parentOrganizationId \textbar{} id \textbar{}
\texttt{parentOrganizationId\ eq\ 1} \textbar{} name \textbar{} string
\textbar{}
\texttt{contains(name,\textquotesingle{}category\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-user/v1.0\#/User}{User}}{User}}\label{user}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} keywords \textbar{}
list \textbar{}
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))}\textbar{}
dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z} \textbar{} id \textbar{}
id \textbar{} \texttt{id\ eq\ 1} \textbar{} organizationIds \textbar{}
id \textbar{} \texttt{organizationIds\ eq\ 1} \textbar{} roleIds
\textbar{} id \textbar{} \texttt{roleIds\ eq\ 1} \textbar{} userGroupIds
\textbar{} id \textbar{} \texttt{userGroupIds\ eq\ 1} \textbar{}
alternateName \textbar{} string \textbar{}
\texttt{contains(alternateName,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} emailAddress \textbar{} string \textbar{}
\texttt{contains(emailAddress,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} familyName \textbar{} string \textbar{}
\texttt{contains(familyName,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} givenName \textbar{} string \textbar{}
\texttt{contains(givenName,\textquotesingle{}substring1\textquotesingle{})}
\textbar{} jobTitle \textbar{} string \textbar{}
\texttt{contains(jobTitle,\textquotesingle{}substring1\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{Headless Admin Taxonomy API}\label{headless-admin-taxonomy-api}

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-taxonomy/v1.0\#/Category}{Category}}{Category}}\label{category}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z}\textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}category\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-taxonomy/v1.0\#/Keyword}{Keyword}}{Keyword}}\label{keyword}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z}\textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}category\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{\texorpdfstring{\href{https://app.swaggerhub.com/apis/liferayinc/headless-admin-taxonomy/v1.0\#/Vocabulary}{Vocabulary}}{Vocabulary}}\label{vocabulary}

\noindent\hrulefill

Key \textbar{} Type \textbar{} Example \textbar{} dateCreated \textbar{}
date \textbar{} \texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z}
\textbar{} dateModified \textbar{} date \textbar{}
\texttt{dateModified\ lt\ 2018-02-13T12:33:12Z}\textbar{} name
\textbar{} string \textbar{}
\texttt{contains(name,\textquotesingle{}category\textquotesingle{})}
\textbar{}

\chapter{Using REST APIs}\label{using-rest-apis}

Liferay DXP's headless REST APIs can be used with any REST client you
prefer. The only usual requirements are setting up the
\texttt{Authentication} header (either OAuth, Cookie, Basic\ldots) and
the \texttt{Content-Type} header if you are creating content.

Our recommendation for JavaScript applications is to use \texttt{fetch}
directly, like this:

\begin{verbatim}
fetch(`http://localhost:8080/o/headless-delivery/v1.0/sites/${SITE_ID}/structured-contents/'`, 
    {
        method: 'GET',
        headers: {
            'Authorization': `Basic ${BASIC_AUTH}`
        }
    }
);
\end{verbatim}

Or for a \texttt{POST} request:

\begin{verbatim}
fetch(`http://localhost:8080/o/headless-delivery/v1.0/sites/${SITE_ID}/structured-contents/`, 
    {
        method: 'POST', 
        headers: {
            'Authorization': `Basic ${BASIC_AUTH}`,
            'Content-Type': 'application/json'
        }, 
        body: JSON.stringify(
            {
                "title": "New appointment",
                "contentStructureId": STRUCTURE_ID,
                "contentFields": [
                    {
                        "name": "User",
                        "value": {
                            "data": USER,
                        }
                    },
                ]
            }
        )
    }
)
\end{verbatim}

Here are two examples of JavaScript applications using the Headless REST
APIs:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/dgomezg/liferay-frontend-samples/tree/master/riuvo-alexa-skill}{Alexa
  skill using Headless REST APIs with node-fetch}.
\item
  \href{https://liferay.dev/blogs/-/blogs/creating-headless-apis-part-1}{Example
  API from scratch using REST Builder}.
\end{itemize}

\chapter{JAX-RS}\label{jax-rs}

JAX-RS web services work in Liferay modules the same way they work
outside of Liferay. The only difference is that you must register the
class in the OSGi framework. Liferay makes this easy by providing a
template.

\href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
a project} and choose the \emph{rest} template.

The class that's generated contains a working JAX-RS web service. You
can deploy it and use it immediately.

While it's beyond the scope of this article to cover
\href{https://blog.osgi.org/2018/03/osgi-r7-highlights-jax-rs-whiteboard.html}{JAX-RS
Whiteboard} in its entirety, essentially it's JAX-RS unchanged except
for configuration properties in the \texttt{@Component} annotation.
These properties declare three things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The endpoint for the service
\item
  The service name as it appears in the OAuth 2.0 configuration
\item
  (Optional) Properties you may want to set for further configuration.
\end{enumerate}

The generated class contains this configuration:

\begin{verbatim}
@Component( 
        property = { 
            JaxrsWhiteboardConstants.JAX_RS_APPLICATION_BASE + "=/greetings", 
            JaxrsWhiteboardConstants.JAX_RS_NAME + "=Greetings.Rest"
        }, 
        service = Application.class)
\end{verbatim}

This configuration registers the service at this endpoint:

\begin{verbatim}
https://[server-name]:[port]/o/greetings
\end{verbatim}

If you're testing this locally on Tomcat, the URL is

\begin{verbatim}
https://localhost:8080/o/greetings
\end{verbatim}

As you might guess, you don't have access to the service by just calling
the URL above. You must authenticate first, which you'll learn how to do
next.

\section{Authenticating to JAX-RS Web
Services}\label{authenticating-to-jax-rs-web-services}

Authentication during development can be done through Basic
Authentication or portal sessions, but you don't want to leave that
enabled for production. For production, you want OAuth 2.0. Here's how
to configure JAX-RS authentication.

\section{During Development: Basic
Auth}\label{during-development-basic-auth}

When you deploy a JAX-RS application, an
\href{/docs/7-2/deploy/-/knowledge_base/d/authentication-verifiers}{Auth
Verifier} filter is registered for it. You can set its properties in
your \texttt{@Component} annotation by prefixing the properties with
\texttt{auth.verifier}. For example, to disable guest access to the
service, configure it like this:

\begin{verbatim}
@Component( 
        property = { 
            JaxrsWhiteboardConstants.JAX_RS_APPLICATION_BASE + "=/greetings", 
            JaxrsWhiteboardConstants.JAX_RS_NAME + "=Greetings.Rest",
            "auth.verifier.guest.allowed=false"
        }, 
        service = Application.class)
\end{verbatim}

Basic Auth is great during development, but credentials passed on the
URL appear in server logs, so when you're done developing, you should
disable Basic Auth and use OAuth2 instead. To disable Basic Auth, create
and deploy a configuration file called
\texttt{com.liferay.portal.security.auth.verifier.internal.tracker.AuthVerifierFilterTracker.config}
that contains this property:

\begin{verbatim}
default.registration.property=["filter.init.auth.verifier.OAuth2RESTAuthVerifier.urls.includes=*","filter.init.auth.verifier.PortalSessionAuthVerifier.urls.includes=*"]
\end{verbatim}

This disables Basic Auth for all JAX-RS applications, but keeps Portal
Session and OAuth2 enabled.

\section{Using OAuth 2.0 to Invoke a JAX-RS Web
Service}\label{using-oauth-2.0-to-invoke-a-jax-rs-web-service}

Your JAX-RS web service requires authorization by default. To enable
this, you must create an
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{OAuth
2.0 application} to provide a way to grant access to your service:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Go to the \emph{Control Panel} → \emph{Configuration} → \emph{OAuth2
  Administration} and click the \includegraphics{./images/icon-add.png}
  button to add an application.
\item
  Give your application a descriptive name.
\item
  Choose the Client Profile appropriate for this service. These are
  templates that auto-select the appropriate authorization types or
  ``flows'' from the OAuth 2 standard. For this example choose the
  \emph{Headless Server} profile, which auto-selects the \emph{Client
  Credentials} authorization type.
\item
  Click \emph{Save}.
\end{enumerate}

The form now reappears with two additional generated fields: Client ID
and Client Secret. You'll use these to authenticate to your web service.

To make your service accessible,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Click the \emph{Scopes} tab.
\item
  You'll see an entry for your deployed \texttt{Greetings.Rest} service.
  Expand it by clicking the arrow.
\item
  Check the box labeled \emph{read data on your behalf}.
\item
  Click \emph{Save}.
\end{enumerate}

\begin{figure}
\centering
\includegraphics{./images/jax-rs-oauth2-scope.png}
\caption{Enable the scope to grant access to the service.}
\end{figure}

For simplicity, the examples below use \href{https://curl.haxx.se}{Curl}
to authenticate. You need the two pieces of information generated for
your application: the Client ID and the Client Secret. For example, say
those fields contain these values:

\textbf{Client ID:} \texttt{id-12e14a84-e558-35a7-cf9a-c64aafc7f}

\textbf{Client Secret:}
\texttt{secret-93f14320-dc39-d67f-9dec-97717b814f}

First, you must request an OAuth token. If you're testing locally, you'd
make a request like this:

\begin{verbatim}
curl http://localhost:8080/o/oauth2/token -d 'grant_type=client_credentials&client_id=id-12e14a84-e558-35a7-cf9a-c64aafc7f&client_secret=secret-93f14320-dc39-d67f-9dec-97717b814f'
\end{verbatim}

The response is JSON:

\begin{verbatim}
{"access_token":"a7f12bef7f2e578cf64bce4085db8f17b6a3c2963f865a65b374e89784bbca5","token_type":"Bearer","expires_in":600,"scope":"GET POST PUT"}
\end{verbatim}

It contains a token, generated for this client. It expires in 600
seconds, and it grants GET, POST, and PUT for this web service.

When you want to call the service, you must supply the token in the HTTP
header, like this:

\begin{verbatim}
curl --header "Authorization: Bearer a7f12bef7f2e578cf64bce4085db8f17b6a3c2963f865a65b374e89784bbca5" http://localhost:8080/o/greetings/morning
\end{verbatim}

With authorization, your web service can be called and responds to the
request:

\begin{verbatim}
Good morning!
\end{verbatim}

Of course, this is only one of the authorization flows for OAuth 2.0. If
you're creating a web-based client whose back-end is a JAX-RS web
service hosted on Liferay DXP, you'd want one of the other flows. See
the \href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0
documentation} for further information. Additionally, OAuth 2.0 assumes
the use of HTTPS for its security: the above URLs are only for local
testing purposes. You certainly would not want to pass OAuth tokens
between clients and servers in the clear. Make sure that in production
your server uses HTTPS.

\subsection{OAuth2 Scopes}\label{oauth2-scopes}

Without any special Liferay OAuth2 annotations or properties, a standard
OSGi JAX-RS application is inspected by the Liferay OAuth2 runtime, and
scopes are derived by default based on the HTTP verbs supported by the
application.

When developers want more control, they can use the property
\texttt{oauth2.scopechecker.type=annotations} and the annotation
\texttt{com.liferay.oauth2.provider.scope.RequiresScope} exported from
the \texttt{Liferay\ OAuth2\ Provider\ Scope\ API} bundle to annotate
endpoint resource methods or whole classes like this:

\begin{verbatim}
@RequiresScope("scopeName")
\end{verbatim}

Once deployed, this becomes a scope in the
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth2-scopes}{OAuth 2.0
configuration}. You can disable scope checking (not recommended) by
setting the scope checker to a non-existent type:

\begin{verbatim}
oauth2.scope.checker.type=none
\end{verbatim}

\subsection{Requiring OAuth2}\label{requiring-oauth2}

You can specify OAuth2 authorization as required for your JAX-RS
application by using this property:

\begin{verbatim}
osgi.jaxrs.extension.select=(osgi.jaxrs.name=Liferay.OAuth2)
\end{verbatim}

\section{JAX-RS and Service Access
Policies}\label{jax-rs-and-service-access-policies}

When authenticating via Basic Auth, the
\href{/docs/7-2/deploy/-/knowledge_base/d/service-access-policies}{Service
Access Policy} \texttt{SYSTEM\_USER\_PASSWORD} is enforced. When
authenticating via OAuth 2.0, the \texttt{AUTHORIZED\_OAUTH2\_SAP}
policy is enforced. Configure them appropriately for your environment,
as by default, they allow invoking all remote services. To disable
Service Access Policy enforcement for JAX-RS endpoints (not
recommended), set this property:

\begin{verbatim}
liferay.access.control.disable=true
\end{verbatim}

With this configured, guests can call these endpoints without
administrators having to define a default Service Access Policy.

\section{Public JAX-RS Services}\label{public-jax-rs-services}

To create a public endpoint for development purposes, all you must do is
set two properties:

\begin{verbatim}
@Component(
    property={
        "auth.verifier.guest.allowed=true",
        "liferay.access.control.disable=true"
    },
    service = Application.class
)
\end{verbatim}

Don't keep this configuration for production. For public services, it's
best to leave the security in place and whitelist the particular
endpoints you're making public. See
\href{/docs/7-2/deploy/-/knowledge_base/d/service-access-policies}{Service
Access Policies} for further information.

\section{Using JAX-RS with CORS}\label{using-jax-rs-with-cors}

If you foresee that JavaScript in a browser might access your JAX-RS web
service from a different domain, you might want to use the CORS
annotation. You can use the \texttt{@CORS} annotation to define
\href{/docs/7-2/deploy/-/knowledge_base/d/configuring-cors}{CORS
policies} on your deployed JAX-RS applications. Note that the
annotations
\href{/docs/7-2/deploy/-/knowledge_base/d/configuring-cors}{can be
overridden by an administrator}. It only takes three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add the Portal Remote CORS API dependency to your module:
\end{enumerate}

\begin{verbatim}
compileOnly project(":apps:portal-remote:portal-remote-cors-api")
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Activate the CORS annotation feature in your application properties:
\end{enumerate}

\begin{verbatim}
@Component(
    property = {
        "osgi.jaxrs.application.base=/my-application",
        "osgi.jaxrs.name=My.Application.Name",
        "liferay.cors.annotation=true"
    },
    service = Application.class
    )
    public class MyApplication extends Application {
    ...
    }
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Use the \texttt{@CORS} annotation throughout your application globally
  or by method.
\end{enumerate}

Globally:

\begin{verbatim}
@Component(
    property = {
        "osgi.jaxrs.application.base=/my-application",
        "osgi.jaxrs.name=My.Application.Name",
        "liferay.cors.annotation=true"
    },
    service = Application.class
)
@CORS(allowMethods="GET")
public class MyApplication extends Application {
...
}
\end{verbatim}

By method:

\begin{verbatim}
@CORS
    @GET
    @Path("/users")
    public List<User> getUserList() throws Exception {
        return _users;
    }
\end{verbatim}

You can use the annotation to provide a configuration for any of the
CORS headers. Here are some examples:

\noindent\hrulefill

\begin{verbatim}
  Header      |    Annotation Example    | 
\end{verbatim}

Access-Control-Allow-Credentials\textbar{}\texttt{@CORS(allowCredentials\ =\ false)}\textbar{}
Access-Control-Allow-Headers\textbar{}\texttt{@CORS(allowHeaders\ =\ "X-PINGOTHER")}\textbar{}
Access-Control-Allow-Methods\textbar{}\texttt{@CORS(allowMethods\ =\ "OPTIONS,POST")}\textbar{}
Access-Control-Allow-Origin\textbar{}\texttt{@CORS(allowOrigin\ =\ "http://www.liferay.com")}\textbar{}

\noindent\hrulefill

If for some reason you want to disable the \texttt{@CORS} annotations in
your application, you can do it globally by disabling it in your
\texttt{@Component} annotation:

\begin{verbatim}
@Component(
    property = {
        "osgi.jaxrs.application.base=/no-cors-application",
        "osgi.jaxrs.name=NoCors.Application.Name",
        "liferay.cors.annotation=false"
    },
    service = Application.class
)
\end{verbatim}

Great! Now you know how to create, deploy, and invoke JAX-RS web
services on Liferay DXP's platform!

\section{Related Topics}\label{related-topics-135}

\href{/docs/7-2/appdev/-/knowledge_base/a/rest-builder}{REST Builder}

\chapter{JAX-WS}\label{jax-ws}

Liferay supports
\href{https://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services}{JAX-WS}
via the \href{http://cxf.apache.org/}{Apache CXF} implementation. Apps
can publish JAX-WS web services to the CXF endpoints defined in your
Liferay instance. CXF endpoints are effectively context paths the JAX-WS
web services are deployed to and accessible from. To publish any kind of
JAX-WS web service, one or more CXF endpoints must be defined. To access
JAX-WS web services, an \emph{extender} must also be configured in your
Liferay instance. Extenders specify where the services are deployed and
whether they are augmented with handlers, providers, and so on.

\textbf{SOAP Extenders:} Required to publish JAX-WS web services. Each
SOAP extender can deploy the services to one or more CXF endpoints and
can use a set of
\href{https://jax-ws.java.net/articles/handlers_introduction.html}{JAX-WS
handlers} to augment the services.

SOAP extenders are subsystems that track the services the app developer
registers in OSGi (those matching the provided
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters}), and deploy them under the specified CXF endpoints. For
example, if you create the CXF endpoint \texttt{/soap}, you could later
create a SOAP extender for \texttt{/soap} that publishes SOAP services.
Of course, this is only a rough example: you can fine tune things to
your liking.

CXF endpoints and extenders can be created programmatically or with
Liferay's Control Panel. This tutorial shows you how to do both, and
then shows you how to publish JAX-WS web services. The following topics
are covered:

\begin{itemize}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/jax-ws\#configuring-endpoints-and-extenders-with-the-control-panel}{Configuring
  Endpoints and Extenders with the Control Panel}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/jax-ws\#configuring-endpoints-and-extenders-programmatically}{Configuring
  Endpoints and Extenders Programmatically}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/jax-ws\#publishing-jax-ws-web-services}{Publishing
  JAX-WS Web Services}
\end{itemize}

\section{Configuring Endpoints and Extenders with the Control
Panel}\label{configuring-endpoints-and-extenders-with-the-control-panel}

Liferay's Control Panel lets administrators configure endpoints and
extenders for JAX-WS web services. Note that you must be an
administrator in your Liferay instance to access the settings here.
First, you'll learn how to create CXF endpoints.

To configure a CXF endpoint with the Control Panel, first go to
\emph{Control Panel} → \emph{Configuration} → \emph{System Settings} →
\emph{Web API}. Then select \emph{CXF Endpoints} from the list. If there
are any existing CXF endpoints, they're shown here. To add a new one,
click the \emph{Add} button. The form that appears lets you configure a
new CXF endpoint by filling out these fields:

\textbf{Context Path:} The path the JAX-WS web services are deployed to
on the Liferay server. For example, if you define the context path
\texttt{/web-services}, any services deployed there are available at
\texttt{http://your-server:your-port/o/web-services}.

\textbf{\texttt{AuthVerifier} properties:} Any properties defined here
are passed as-is to the \texttt{AuthVerifier} filter. See the
\href{/docs/7-2/deploy/-/knowledge_base/d/authentication-verifiers}{\texttt{AuthVerifier}
documentation} for more details.

\textbf{Required Extensions:} CXF normally loads its default extension
classes, but in some cases you can override them to replace the default
behavior. In most cases, you can leave this field blank: overriding
extensions isn't common. By specifying custom extensions here via
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters}, Liferay waits until those extensions are registered in the
OSGi framework before creating the CXF servlet and passing the
extensions to the servlet.

\begin{figure}
\centering
\includegraphics{./images/cxf-endpoint-form.png}
\caption{Fill out this form to create a CXF endpoint.}
\end{figure}

For an app to deploy JAX-WS web services, you must configure a SOAP
extender. To configure a SOAP extender with the Control Panel, first go
to \emph{Control Panel} → \emph{Configuration} → \emph{System Settings}
→ \emph{Web API}. Then select \emph{SOAP Extenders} from the list. If
there are any existing SOAP extenders, they're shown here. To add a new
one, click on the \emph{Add} button. The form that appears lets you
configure a new SOAP extender by filling out these fields:

\textbf{Context paths:} Specify at least one CXF endpoint here. This is
where the services affected by this extender are deployed. In the
preceding CXF endpoint example, this would be \texttt{/web-services}.
Note that you can specify more than one CXF endpoint here.

\textbf{jax.ws.handler.filters:} Here you can specify a set of
\href{https://osgi.org/javadoc/r6/core/org/osgi/framework/Filter.html}{OSGi
filters} that select certain services registered in the OSGi framework.
The selected services should implement JAX-WS handlers and augment the
JAX-WS services specified in the \emph{jax.ws.service.filters} property.
These JAX-WS handlers apply to each service selected in this extender.

\textbf{jax.ws.service.filters:} Here you can specify a set of OSGi
filters that select the services registered in the OSGi framework that
are deployed to the CXF endpoints. These OSGi services must be
\href{https://docs.oracle.com/javaee/7/tutorial/jaxws001.htm}{proper
JAX-WS services}.

\textbf{soap.descriptor.builder:} Leave this option empty to use JAX-WS
annotations to describe the SOAP service. To use a different way to
describe the SOAP service, you can provide an OSGi filter here that
selects an implementation of
\texttt{com.liferay.portal.remote.soap.extender.SoapDescriptorBuilder}.

\begin{figure}
\centering
\includegraphics{./images/soap-extenders-form.png}
\caption{Fill out this form to create a SOAP extender.}
\end{figure}

Next, you'll learn how to create endpoints and extenders
programmatically.

\section{Configuring Endpoints and Extenders
Programmatically}\label{configuring-endpoints-and-extenders-programmatically}

To configure endpoints or extenders programmatically, you must use
Liferay's configurator extender. The configurator extender provides a
way for OSGi modules to deploy default configuration values. Modules
that use the configurator extender must provide a
\texttt{ConfigurationPath} header that points to the configuration
files' location inside the module. For example, the following
configuration sets the \texttt{ConfigurationPath} to
\texttt{src/main/resources/configuration}:

\begin{verbatim}
Bundle-Name: Liferay Export Import Service JAX-WS
Bundle-SymbolicName: com.liferay.exportimport.service.jaxws
Bundle-Version: 1.0.0
Liferay-Configuration-Path: /configuration
Include-Resource: configuration=src/main/resources/configuration
Liferay-Releng-Module-Group-Description:
Liferay-Releng-Module-Group-Title: Data Management
\end{verbatim}

Note that Liferay-specific Bnd instructions are prefixed with
\texttt{Liferay} to avoid conflicts.

There are two different configuration types in
\href{https://osgi.org/javadoc/r4v42/org/osgi/service/cm/ConfigurationAdmin.html}{OSGi's
\texttt{ConfigurationAdmin}}: single, and factory. Factory
configurations can have several configuration instances per factory
name. Liferay DXP uses factory configurations. You must provide a
factory configuration's default values in a \texttt{*.properties} file.
In this properties file, use a suffix on the end of the PID (persistent
identifier) and then provide your settings. For example, the following
code uses the \texttt{-staging} suffix on the PID and creates a CXF
endpoint at the context path \texttt{/staging-ws}:

\texttt{com.liferay.portal.remote.cxf.common.configuration.CXFEndpointPublisherConfiguration-staging.properties}:

\begin{verbatim}
contextPath=/staging-ws
\end{verbatim}

As another example, the following code uses the suffix
\texttt{-stagingjaxws} on the PID and creates a SOAP extender at the
context path \texttt{/staging-ws}. This code also includes settings for
the configuration fields \texttt{jaxWsHandlerFilterStrings} and
\texttt{jaxWsServiceFilterStrings}:

\texttt{com.liferay.portal.remote.soap.extender.internal.configuration.SoapExtenderConfiguration-stagingjaxws.properties}:

\begin{verbatim}
contextPaths=/staging-ws
jaxWsHandlerFilterStrings=(staging.jax.ws.handler=true)
jaxWsServiceFilterStrings=(staging.jax.ws.service=true)
\end{verbatim}

You must then use these configuration fields in the configuration class.
For example, the \texttt{SoapExtenderConfiguration} interface below
contains the configuration fields \texttt{contextPaths},
\texttt{jaxWsHandlerFilterStrings}, and
\texttt{jaxWsServiceFilterStrings}:

\begin{verbatim}
@ExtendedObjectClassDefinition(
    category = "foundation", factoryInstanceLabelAttribute = "contextPaths"
)
@Meta.OCD(
    factory = true,
    id = "com.liferay.portal.remote.soap.extender.internal.configuration.SoapExtenderConfiguration",
    localization = "content/Language", name = "soap.extender.internal.configuration.name"
)
public interface SoapExtenderConfiguration {

    @Meta.AD(required = false)
    public String[] contextPaths();

    @Meta.AD(name = "jax.ws.handler.filters", required = false)
    public String[] jaxWsHandlerFilterStrings();

    @Meta.AD(name = "jax.ws.service.filters", required = false)
    public String[] jaxWsServiceFilterStrings();

    @Meta.AD(name = "soap.descriptor.builder", required = false)
    public String soapDescriptorBuilderFilter();

}
\end{verbatim}

Next, you'll learn how to publish JAX-WS web services.

\section{Publishing JAX-WS Web
Services}\label{publishing-jax-ws-web-services}

To publish JAX-WS web services via SOAP in a module, annotate the class
and its methods with standard JAX-WS annotations, and then register it
as a service in the OSGi framework. For example, the following class
uses the \texttt{@WebService} annotation for the class and
\texttt{@WebMethod} annotations for its methods. You must also set the
\texttt{jaxws} property to \texttt{true} in the OSGi \texttt{@Component}
annotation:

\begin{verbatim}
import javax.jws.WebMethod;
import javax.jws.WebService;

import org.osgi.service.component.annotations.Component;

@Component(
    immediate = true, property = "jaxws=true", service = Calculator.class
)
@WebService
public class Calculator {

    @WebMethod
    public int divide(int a, int b) {
        return a / b;
    }

    @WebMethod
    public int multiply(int a, int b) {
        return a * b;
    }

    @WebMethod
    public int subtract(int a, int b) {
        return a - b;
    }

    @WebMethod
    public int sum(int a, int b) {
        return a + b;
    }

}
\end{verbatim}

You should also make sure that you include \texttt{org.osgi.core} and
\texttt{org.osgi.service.component.annotations} as dependencies to your
project.

\chapter{GraphQL APIs}\label{graphql-apis}

Liferay DXP exposes a full
\href{https://graphql.github.io/graphql-spec/June2018/}{GraphQL API}
implementation, and lets your apps fetch several entities from the same
request.

Here you'll learn how to navigate and consume Liferay DXP's GraphQL
APIs. Since GraphQL APIs are discoverable, you'll start with that.

\chapter{Get Started: Discover the
API}\label{get-started-discover-the-api}

To begin consuming the GraphQL APIs, you must first know where they are,
what operations you can invoke, and how to invoke them.

Because Liferay DXP's GraphQL APIs leverage the
\href{https://graphql.github.io/graphql-spec/June2018/}{official
specification}, you don't need a service catalog. You only need to know
the URL from which to discover the rest of the API.

Liferay DXP's GraphQL APIs are available here:

\begin{verbatim}
http://[host]:[port]/o/graphql
\end{verbatim}

For example, if you're running Liferay DXP locally on port
\texttt{8080}, the URL for discovering the GraphQL API is

\begin{verbatim}
http://localhost:8080/o/graphql
\end{verbatim}

To inspect the GraphQL endpoint, use a GraphQL client, such as
\href{https://chrome.google.com/webstore/detail/altair-graphql-client/flnheeellpciglgpaodhkhmapeljopja?hl=en}{Altair}
(a Chrome extension) or
\href{https://github.com/graphql/graphiql}{GraphiQL}.

\begin{figure}
\centering
\includegraphics{./images/graphql-altair.png}
\caption{GraphQL APIs can be browsed in Altair.}
\end{figure}

You don't have to be authenticated to inspect the live documentation,
but you must to be able to make requests. There are several ways of
authenticating in GraphQL APIs (explained
\href{/docs/7-2/frameworks/-/knowledge_base/f/authenticated-requests}{here})
but the simplest way to test APIs locally is to use Basic
Authentication, setting an \texttt{Authorization} header in Altair
(first icon on the left). Remember that Basic Auth is a BASE64
transformation of \texttt{user}:\texttt{password}. This means it's
insecure, and should never be used in production.

Most tools that introspect the GraphQL schema can autocomplete your
query or fill all the fields in for you.

For a list of tools such as client generators, validators, and parsers
supporting GraphQL, see
\href{https://github.com/chentsulin/awesome-graphql}{Awesome GraphQL}.
Leveraging GraphQL provides standards support, extensive automatic
documentation, and industry-wide conventions.

\section{Unique endpoint and
versioning}\label{unique-endpoint-and-versioning}

In contrast with the REST APIs, where endpoints are deployed by suite
(headless-delivery, headless-admin-user\ldots), GraphQL APIs are
deployed under the same endpoint (/o/graphql). That way we can easily
add relationships between entities to leverage GraphQL's powerful
request characteristics.

Liferay DXP's GraphQL APIs also expose the latest published version of
all entities available. If several versions of the same entity are
deployed, only the latest one is exposed under the \texttt{/o/graphql}
endpoint (REST APIs use different endpoints for different versions).
This strategy follows GraphQL standards to avoid breaking versions by
marking deprecated fields and always adding properties to an entity.

\chapter{Get Started: Invoke a
Service}\label{get-started-invoke-a-service}

Once you know which API you want to call via the GraphQL-introspected
documentation, you can send a request using a POST body. For example,
suppose you want to retrieve all the blog entries from a Site. If you
consult the GraphQL documentation you can find this endpoint:

\begin{figure}
\centering
\includegraphics{./images/graphql-blog-postings.png}
\caption{GraphQL exposes a definition for BlogPostings.}
\end{figure}

If you add the full query with Altair/GraphiQL, you'll see a result like
this:

\begin{verbatim}
query{
  blogPostings(filter: ______, page: ______, pageSize: ______, search: ______, siteId: ______, siteKey: ______, sort: ______){
    items
    page
    pageSize
    totalCount
  }
}
\end{verbatim}

The only required parameter is \texttt{siteId} or \texttt{siteKey} (as
of 7.2 FP4), the ID, or the internal name (like \emph{guest}) of the
blog posting's Site. Internally, the \texttt{siteId} is a
\texttt{groupId} that you can retrieve from the database, a URL, or
Liferay DXP's UI via the Site Administration menu. For more information,
see
\href{/docs/7-2/frameworks/-/knowledge_base/f/how-to-get-site-id}{How to
get SiteId}.

A regular query would ignore optional parameters and return more
elements of the list, identified by the property \texttt{items}:

\begin{verbatim}
query {
  blogPostings(siteKey: "guest") {
    items {
      alternativeHeadline
      articleBody
      creator {
        name
      }
      dateCreated
      dateModified
      datePublished
      description
      encodingFormat
      friendlyUrlPath
      headline
      id
      keywords
      numberOfComments
      relatedContents {
        title
      }
      siteId
      taxonomyCategoryIds
      viewableBy
    }
    page
    pageSize
    totalCount
  }
}
\end{verbatim}

In GraphQL, you must list explicitly every field you want to return in
the request. Complex objects, like \texttt{items}, \texttt{creator}, or
\texttt{relatedContents} can not be returned fully: you must specify at
least one field (or none).

To execute the query, make a \texttt{POST} request with an
\texttt{Authentication} header and the query in a JSON object under the
key \texttt{query}. Don't forget to escape strings!

The following request gets the Site's blog postings by providing the
site key (\texttt{guest}):

\begin{verbatim}
curl -X "POST" "http://localhost:8080/o/graphql" \
     -H 'Content-Type: text/plain; charset=utf-8' \
     -u 'test@liferay.com:test' \
     -d $'{
  "query": "query { blogPostings(siteKey: \\"guest\\") { items { alternativeHeadline articleBody creator { id name } dateCreated dateModified datePublished description encodingFormat friendlyUrlPath headline id keywords numberOfComments relatedContents { title } siteId taxonomyCategoryIds viewableBy } page pageSize totalCount } }"
  }'
\end{verbatim}

If you send this request to a Site that contains some Blog entries, the
response may look like this:

\begin{verbatim}
{
  "data": {
    "blogPostings": {
      "items": [
        {
          "alternativeHeadline": "",
          "articleBody": "<p>Content</p>",
          "creator": {
            "id": 20124,
            "name": "Test Test"
          },
          "dateCreated": "2019-10-29T17:48:03Z",
          "dateModified": "2019-10-29T17:48:03Z",
          "datePublished": "2019-10-29T17:47:00Z",
          "description": "",
          "encodingFormat": "text/html",
          "friendlyUrlPath": "title",
          "headline": "Title",
          "id": 37644,
          "keywords": [],
          "numberOfComments": 0,
          "relatedContents": [],
          "siteId": 20118,
          "taxonomyCategoryIds": null,
          "viewableBy": null
        }
      ],
      "page": 1,
      "pageSize": 20,
      "totalCount": 1
    }
  }
}
\end{verbatim}

This response is a JSON object with information about the collection of
blogs. The attributes contain information about the resource (blogs, in
this case). Also, note that the results are paginated. The
\texttt{*page*} attributes refer to pages of results. Here's a
description of some common attributes:

\texttt{id}: Each item has an ID. You can use the ID to retrieve more
information about that item. For example, there are two \texttt{id}
attributes in the above response: one for the blog posting
(\texttt{37644}) and one for the blog post's creator (\texttt{20124}).

\texttt{page}: The current page's page number. The page in the above
response is \texttt{1}.

\texttt{pageSize}: The possible number of this resource's items to be
included in a single page. In the above response this is \texttt{20}.

\texttt{totalCount}: The total number of this resource's existing items
(independent of pagination). The above response lists the total number
of blog postings (\texttt{1}) in a Site.

To get information on a specific blog posting, send a POST request with
the \texttt{blogPostingId} to this query:

\begin{verbatim}
query {
  blogPosting(blogPostingId: 37644) {
    headline
    id
  }
}
\end{verbatim}

\section{GraphQL Clients}\label{graphql-clients}

The examples above show the GraphQL requests as cURL operations but you
can use any GraphQL clients available. We have made heavy use of
\href{https://www.apollographql.com/docs/}{Apollo}, the official React
client and the \href{https://github.com/vuejs/vue-apollo}{Vue
integration} without any issues.

\chapter{Making Authenticated
Requests}\label{making-authenticated-requests-1}

To make an authenticated request, you must authenticate as a specific
User.

There are three authentication mechanisms available when invoking web
APIs:

\textbf{Basic Authentication:} Sends the user credentials as an encoded
user name and password pair. This is the simplest authentication
protocol (available since HTTP/1.0), but should be used only for
development purposes, as it's insecure.

\textbf{OAuth 2.0:} In 7.0, you can use OAuth 2.0 for authorization. See
the \href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0}{OAuth 2.0
documentation} for more information.

\textbf{Cookie/Session authentication:} From inside the portal you can
do direct requests to the APIs by sending the session token.

First, you'll learn how to send requests with basic authentication.

\section{Basic Authentication}\label{basic-authentication-1}

Basic authentication requires that you send an HTTP
\texttt{Authorization} header containing the encoded user name and
password. You must first get that encoded value. To do so, you can use
\texttt{openssl} or a \texttt{Base64} encoder. Either way, you must
encode the \texttt{user:password} string. Here's an example of the
\texttt{openssl} command for encoding the \texttt{user:password} string
for a user \texttt{test@liferay.com} with the password \texttt{Liferay}:

\begin{verbatim}
openssl base64 <<< test@liferay.com:Liferay
\end{verbatim}

This returns the encoded value:

\begin{verbatim}
dGVzdEBsaWZlcmF5LmNvbTpMaWZlcmF5Cg==
\end{verbatim}

If you don't have \texttt{openssl} installed, try the \texttt{base64}
command:

\begin{verbatim}
base64 <<< test@liferay.com:Liferay
\end{verbatim}

\noindent\hrulefill

\textbf{Warning:} Encoding a string as shown here does not encrypt the
resulting string. The encoded string can easily be decoded by executing
\texttt{base64\ \textless{}\textless{}\textless{}\ the-encoded-string},
which returns the original string.

Anyone listening to your request could therefore decode the
\texttt{Authorization} header and reveal your user name and password. To
prevent this, ensure that all communication is made through HTTPS, which
encrypts the entire message (including headers).

\noindent\hrulefill

Use the encoded value for the HTTP Authorization header when sending the
request:

\begin{verbatim}
curl -H "Authorization: Basic dGVzdEBsaWZlcmF5LmNvbTpMaWZlcmF5Cg==" http://localhost:8080/o/graphql ...
\end{verbatim}

The response contains data instead of the 403 error that an
unauthenticated request receives. For more information on the response's
structure, see
\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}.

\section{OAuth 2.0 Authorization}\label{oauth-2.0-authorization-1}

7.0 supports authorization via OAuth 2.0, which is a token-based
authorization mechanism. For more details, see
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0}{Liferay DXP's OAuth
2.0 documentation}. The following sections show you how to use OAuth 2.0
to authenticate web API requests.

\section{Obtaining the OAuth 2.0
Token}\label{obtaining-the-oauth-2.0-token-1}

Before using OAuth 2.0 to invoke a web API, you must register your
application (your web API's consumer) as an authorized OAuth client. To
do this, follow the instructions in
\href{/docs/7-2/deploy/-/knowledge_base/d/oauth-2-0\#creating-an-application}{Creating
an Application}. When creating the application, fill in the form as
follows:

\textbf{Application Name:} Your application's name.

\textbf{Client Profile:} Headless Server.

\textbf{Allowed Authorization Types:} Check \emph{Client Credentials}.

After clicking \emph{Save} to finish creating the application, write
down the Client ID and Client Secret values that appear at the top of
the form.

Next, you must get an OAuth 2.0 access token. To do this, see
\href{/docs/7-2/deploy/-/knowledge_base/d/authorizing-account-access-with-oauth2}{Authorizing
Account Access with OAuth 2}.

\section{Invoking the Service with an OAuth 2.0
Token}\label{invoking-the-service-with-an-oauth-2.0-token-1}

Once you have a valid OAuth 2.0 token, include it in the request's
\texttt{Authorization} header, specifying that the authentication type
is a \href{https://tools.ietf.org/html/rfc6750}{bearer token}:

\begin{verbatim}
curl -H "Authorization: Bearer d5571ff781dc555415c478872f0755c773fa159" http://localhost:8080/o/graphql
\end{verbatim}

The response contains the resources that the authenticated user has
permission to access, just like the response from Basic authentication.
The request could be prevented depending on the scopes defined. If POST
a GraphQL query and there is scope disabling all request except
\texttt{GET}, you see a 403.

\section{Using Cookie Authentication or doing a request from the
portal}\label{using-cookie-authentication-or-doing-a-request-from-the-portal}

You can call the GraphQL APIs using the existing session from outside
the Liferay DXP by passing the session identifier (the cookie reference)
and the Liferay Auth Token (a CSRF---Cross-Site Request
Forgery---token).

To make an unauthenticated request from outside the Liferay DXP you must
provide the \texttt{Cookie} identifier in the header:

\begin{verbatim}
curl -H 'Cookie: JSESSIONID=27D7C95648D7CDBE3347601FC4543F5D'
\end{verbatim}

You must also provide the CSRF token by passing it as a query parameter
called \texttt{p\_auth} or by adding the URL to the whitelist of CSRF
allowed URLs or disabling CSRF checks altogether with the
\texttt{auth.verifier.auth.verifier.PortalSessionAuthVerifier.check.csrf.token}
property (application level).

Here's a sample cURL request with the cookie and CSRF token:

\begin{verbatim}
curl -H 'Cookie: JSESSIONID=27D7C95648D7CDBE3347601FC4543F5D' http://localhost:8080/o/graphql?p_auth=O4dCU1Mj
\end{verbatim}

To do an unauthenticated request from inside the Liferay DXP, from
JavaScript code or a Java method, you don't need the session identifier.
You must only provide the CRSF token or add the API to the whitelist of
CSRF allowed URLs.

\section{Making Unauthenticated
Requests}\label{making-unauthenticated-requests-1}

Unauthenticated requests are disabled by default in Liferay DXP's
GraphQL APIs. As all GraphQL APIs share the same endpoint, you cannot
have the same level of granularity with Service Access Policies as in
REST APIs. For that reason, we do not recommend disabling the security
of the GraphQL APIs.

\section{Related Topics}\label{related-topics-136}

\href{/docs/7-2/frameworks/-/knowledge_base/f/get-started-invoke-a-service}{Get
Started: Invoke a Service}

\href{/docs/7-2/frameworks/-/knowledge_base/f/working-with-collections-of-data}{Working
with Collections of Data}

\chapter{Working with Collections of
Data}\label{working-with-collections-of-data-1}

Collection resources are common in Liferay DXP web APIs. If you followed
along with the previous examples that sent requests to the portal's
\texttt{blog-postings} resource URL, you've already seen collections in
action: the \texttt{BlogPosting} resource is a collection.

Here, you'll learn more detailed information about working with
collection resources. But first, you should learn about collection
pagination.

\section{Pagination}\label{pagination-2}

A small collection can be transmitted in a single response without
difficulty. Transmitting a large collection all at once, however, can
consume too much bandwidth, time, and memory. It can also overwhelm the
user with too much data.

It's therefore best to get and display the elements of a large
collection in discrete chunks, or pages.

Liferay DXP's GraphQL APIs return paginated collections by default. The
following attributes in the responses also contain the information
needed to navigate between those pages:

\texttt{totalCount}: The total number of this resource's items.

\texttt{pageSize}: The number of this resource's items to be included in
this response.

\texttt{page}: The current page's number.

\texttt{items}: The collection elements present on this page. Each
element also contains the data of the object it represents, so there's
no need for additional requests for individual elements.

\texttt{id}: Each item's identifier. You can use this, if necessary, to
get more information on a specific item.

The attributes \texttt{page} and \texttt{pageSize} allow client
applications to navigate through the results. For example, such a client
could send a request for a specific page.

This example gets the second page (\texttt{page:2}) of blog postings
that exist on the content set with the ID \texttt{42345}:

\begin{verbatim}
query {
  contentSetContentSetElements(contentSetId: 42345, page: 2) {
    items {
      id
      title
      content {
        ... on BlogPosting {
          headline
        }
      }
    }
    page
    pageSize
    totalCount
  }
}
\end{verbatim}

\chapter{Mutations}\label{mutations}

The GraphQL spec differentiates between retrieve operations
(\texttt{query}) and create/update/delete operations
(\texttt{mutations}).

\begin{figure}
\centering
\includegraphics{./images/graphql-mutation.png}
\caption{The GraphQL Mutations list for Blog postings shows the possible
operations.}
\end{figure}

To perform a mutation, do a \texttt{POST} request as you did with
\texttt{query} operations, using cURL, a REST client, or a GraphQL
Client like Apollo. The only difference is that create/update
\texttt{mutations} require an Input type, a JSON object to create or
update the content.

A create \texttt{mutation} to insert a new blog posting looks like this:

\begin{verbatim}
mutation {
  createSiteBlogPosting(
    blogPosting: {
      headline: "New GraphQL APIs!"
      articleBody: "WoW! This is cool!"
    }
    siteKey: "guest"
  ) {
    id
    headline
  }
}
\end{verbatim}

Auto-complete also works as expected filling the \texttt{blogPosting}
object. Here's a cURL request to create the same entry:

\begin{verbatim}
curl 'http://localhost:8080/o/graphql' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Basic dGVzdEBsaWZlcmF5LmNvbTp0ZXN0' --data-binary '{"query":"mutation {createSiteBlogPosting(blogPosting: {headline: \"New GraphQL APIs!\" articleBody: \"WoW! This is cool!\"} siteKey: \"guest\") {id headline}}","variables":{}}'
\end{verbatim}

\chapter{Fragments and Node Patterns}\label{fragments-and-node-patterns}

Liferay DXP's GraphQL APIs also supports
\href{https://graphql.org/learn/queries/\#fragments}{GraphQL fragments},
reusable sets of fields that are needed in different requests. A special
type of fragments are
\href{https://graphql.org/learn/queries/\#inline-fragments}{inline
fragments}, which access the underlying concrete type when querying
generic types or interfaces.

You'll use inline fragments to query objects that inherit from a common
interface, like the kind of objects returned from a \texttt{ContentSet}.
\texttt{ContentSet}s allow defining lists of assets that comply with a
set of rules, a segment, or are manually selected. \texttt{ContentSet}s
can return any type of asset. This makes them a perfect fit for inline
fragments.

Here's an example of GraphQL querying \texttt{ContentSet}s:

\begin{verbatim}
query {
  contentSetContentSetElements(contentSetId: 42345) {
    items {
      id
      title
      content {
        ... on BlogPosting {
          headline
        }
        ... on StructuredContent {
          relatedContents {
            id
            title
          }
        }
      }
    }
    page
    pageSize
    totalCount
  }
}
\end{verbatim}

This query returns a set of objects, each of a different type.

\section{Node pattern}\label{node-pattern}

\texttt{graphQLNode} is a special query that leverages the power of
inline fragments. This query accepts a \texttt{dataType} and an ID and
returns any kind of entity that has a query of the type
\texttt{\{dataType\}} and receives an \texttt{id} as a parameter. Inline
fragments can specify the fields you want to return in this special
case:

\begin{verbatim}
query{
  graphQLNode(dataType: ______, id: ______){
    id
    ... on BlogPosting {
      headline
    }
  }
}
\end{verbatim}

You can also use \texttt{graphQLNode} as a field in entities that
contain \texttt{contentType} and \texttt{id} properties. Those entities
have a generated property called \texttt{GraphQLNode} that can return
any type, queried by using inline fragments. A common use case is
returning an asset linked as \texttt{relatedContents} (asset links).

\chapter{Language Negotiation}\label{language-negotiation-1}

The same mechanism for requesting content in another language in the
headless REST APIs is used in GraphQL.

APIs available in different languages return the options in a block
called \texttt{availableLanguages}. For example, this block lists U.S.
English (\texttt{en-US}) and Spain/Castilian Spanish (\texttt{es-ES}):

\begin{verbatim}
{
  "availableLanguages": [
    "en-US",
    "es-ES"
  ],
  "contentFields": [
    {
      "dataType": "html",
      "name": "content",
      "repeatable": false,
      "value": {
        "data": "<p>The main reason is because Headless APIs have been designed with real use cases in mind...</p>"
      }
    }
  ],
  "contentStructureId": 36801,
  "creator": {
    "familyName": "Test",
    "givenName": "Test",
    "id": 20130,
    "name": "Test Test",
    "profileURL": "/web/test"
  },
  "dateCreated": "2019-04-22T10:29:40Z",
  "dateModified": "2019-04-22T10:30:31Z",
  "datePublished": "2019-04-22T10:28:00Z",
  "friendlyUrlPath": "why-headless-apis-are-better-than-json-ws-services-",
  "id": 59325,
  "key": "59323",
  "numberOfComments": 0,
  "renderedContents": [
    {
      "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
      "templateName": "Basic Web Content"
    }
  ],
  "siteId": 20124,
  "title": "Why Headless APIs are better than JSON-WS services?",
  "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
}
\end{verbatim}

To request the content in another language, specify your desired locale
in the request's \texttt{Accept-Language} header:

\begin{verbatim}
curl "http://localhost:8080/o/graphql"  -H 'Accept-Language: es-ES'  -u 'test@liferay.com:test' ...
\end{verbatim}

\begin{verbatim}
    {
      "availableLanguages": [
        "en-US",
        "es-ES"
      ],
      "contentFields": [
        {
          "dataType": "html",
          "name": "content",
          "repeatable": false,
          "value": {
            "data": "<p>La principal razón es porque las APIs Headless se han diseñado pensando en casos de uso reales...</p>"
          }
        }
      ],
      "contentStructureId": 36801,
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T10:29:40Z",
      "dateModified": "2019-04-22T10:30:31Z",
      "datePublished": "2019-04-22T10:28:00Z",
      "friendlyUrlPath": "%C2%BFpor-qu%C3%A9-las-apis-headless-son-mejores-que-json-ws-",
      "id": 59325,
      "key": "59323",
      "numberOfComments": 0,
      "renderedContents": [
        {
          "renderedContentURL": "http://localhost:8080/o/headless-delivery/v1.0/structured-contents/59325/rendered-content/36804",
          "templateName": "Contenido web básico"
        }
      ],
      "siteId": 20124,
      "title": "¿Por qué las APIs Headless son mejores que JSON-WS?",
      "uuid": "e1c4c152-e47c-313f-2d16-2ee4eba5cd26"
    }
\end{verbatim}

\section{Creating Content with Different
Languages}\label{creating-content-with-different-languages-1}

By default, when sending a mutation request, the
\texttt{Accept-Language} header is used as the content's language. There
is one exception, however. Some entities require the first request to be
in the Site's default language. In such cases, the first request for a
different language results in an error.

After creating a new resource, a new request in a different language
adds that translation.

\chapter{Filter, Sort, and Search}\label{filter-sort-and-search-1}

You can use Liferay DXP's headless GraphQL APIs to search for the
content you want. You can also sort and filter content.

\section{Filter}\label{filter-1}

It's often useful to filter large collections for the exact data that
you need. Not all collections, however, allow filtering. The ones that
support it contain the optional parameter \texttt{filter}. To filter a
collection based on the value of one or more fields, use the
\texttt{filter} parameter following a subset of the
\href{https://www.odata.org}{OData} standard.

Filtering mainly applies to fields indexed as keywords in Liferay DXP's
search. To find content by terms contained in fields indexed as text,
you should instead use \hyperref[search]{search}.

\section{Comparison Operators}\label{comparison-operators-1}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{eq} \textbar{} Equal \textbar{}
\texttt{addressLocality\ eq\ \textquotesingle{}Redmond\textquotesingle{}}
\textbar{} \textbar{} Equal null \textbar{}
\texttt{addressLocality\ eq\ null} \textbar{} \texttt{ne} \textbar{} Not
equal \textbar{}
\texttt{addressLocality\ ne\ \textquotesingle{}London\textquotesingle{}}
\textbar{} \textbar{} Not null \textbar{}
\texttt{addressLocality\ ne\ null} \textbar{} \texttt{gt} \textbar{}
Greater than \textbar{} \texttt{price\ gt\ 20} \textbar{} \texttt{ge}
\textbar{} Greater than or equal \textbar{} \texttt{price\ ge\ 10}
\textbar{} \texttt{lt} \textbar{} Less than \textbar{}
\texttt{dateCreated\ lt\ 2018-02-13T12:33:12Z} \textbar{} \texttt{le}
\textbar{} Less than or equal \textbar{}
\texttt{dateCreated\ le\ 2012-05-29T09:13:28Z} \textbar{}
\texttt{startswith} \textbar{} Starts with \textbar{}
\texttt{startswith(addressLocality,\ \textquotesingle{}Lond\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{Logical Operators}\label{logical-operators-1}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{and} & Logical and &
\texttt{price\ le\ 200\ and\ price\ gt\ 3.5} \\
\texttt{or} & Logical or &
\texttt{price\ le\ 3.5\ or\ price\ gt\ 200} \\
\texttt{not} & Logical not & \texttt{not\ (price\ le\ 3.5)} \\
\end{longtable}

\noindent\hrulefill

Note that the \texttt{not} operator requires a trailing space.

\section{Grouping Operators}\label{grouping-operators-1}

\noindent\hrulefill

Operator \textbar{} Description \textbar{} Example \textbar{}
\texttt{(\ )} \textbar{} Precedence grouping \textbar{}
\texttt{(price\ eq\ 5)\ or\ (addressLocality\ eq\ \textquotesingle{}London\textquotesingle{})}
\textbar{}

\noindent\hrulefill

\section{String Functions}\label{string-functions-1}

\noindent\hrulefill

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Function & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{contains} & Contains &
\texttt{contains(title,\textquotesingle{}edmon\textquotesingle{})} \\
\end{longtable}

\noindent\hrulefill

\section{Lambda Operators}\label{lambda-operators-1}

Lambda operators evaluate a boolean expression on a collection. They
must be prepended with a navigation path that identifies a collection.

\noindent\hrulefill

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2206}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.1618}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6176}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lambda Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{any} & Any &
\texttt{keywords/any(k:contains(k,\textquotesingle{}substring1\textquotesingle{}))} \\
\end{longtable}

\noindent\hrulefill

The \texttt{any} operator applies a boolean expression to each
collection element and evaluates to \texttt{true} if the expression is
true for any element.

\section{Escaping in Queries}\label{escaping-in-queries-1}

You can escape a single quote in a value by escaping it with a
backslash. For example, to filter for a blog posting whose headline is
\texttt{New\ Headless\ APIs}, send this filter string to the filter
parameter.

\begin{verbatim}
filter: \\"headline eq \'Title\'\\"
\end{verbatim}

Here's an example of the full request:

\begin{verbatim}
curl -X "POST" "http://localhost:8080/o/graphql" \
     -H 'Content-Type: text/plain; charset=utf-8' \
     -H 'Cookie: COOKIE_SUPPORT=true; GUEST_LANGUAGE_ID=en_US; JSESSIONID=EFEEC1617529C7C85E8CCCE510B0F6CF' \
     -u 'test@liferay.com:test' \
     -d $'{
  "query": "query { blogPostings(siteKey: \\"guest\\", filter: \\"headline eq \'Title\'\\") { items {headline} page pageSize totalCount } }"
}'
\end{verbatim}

And here's a possible response:

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "The power of OpenAPI & Liferay",
      "articleBody": "<p>We are happy to announce...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T07:04:47Z",
      "dateModified": "2019-04-22T07:04:51Z",
      "datePublished": "2019-04-22T07:02:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "new-headless-apis",
      "headline": "New Headless APIs",
      "id": 59301,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\section{Filtering in Structured Content Fields
(ContentField)}\label{filtering-in-structured-content-fields-contentfield-1}

To filter for a \texttt{ContentField} value (dynamic values created by
the end user), you must use the paths that are scoped to an individual
\texttt{ContentStructure}.

Find the ID of the \texttt{ContentStructure} and use it in place of
\texttt{\{contentStructureId\}} in this query:

\begin{verbatim}
"contentStructureStructuredContents"
\end{verbatim}

\section{Search}\label{search-3}

You can search large collections with keywords. Use search when you want
results from any field, rather than specific ones. To perform a search,
use the optional parameter \texttt{search} followed by the search terms.
For example, this request searches for all the \texttt{BlogEntry} fields
containing Title:

\begin{verbatim}
curl -X "POST" "http://localhost:8080/o/graphql" \
     -H 'Content-Type: text/plain; charset=utf-8' \
     -u 'test@liferay.com:test' \
     -d $'{
  "query": "query { blogPostings(siteKey: \\"guest\\", search: \\"Title\\") { items {headline} page pageSize totalCount } }"
}'
\end{verbatim}

\begin{verbatim}
{
  "items": [
    {
      "alternativeHeadline": "How to work with OAuth",
      "articleBody": "<p>To configure OAuth...</p>",
      "creator": {
        "familyName": "Test",
        "givenName": "Test",
        "id": 20130,
        "name": "Test Test",
        "profileURL": "/web/test"
      },
      "dateCreated": "2019-04-22T09:35:09Z",
      "dateModified": "2019-04-22T09:35:09Z",
      "datePublished": "2019-04-22T09:34:00Z",
      "encodingFormat": "text/html",
      "friendlyUrlPath": "authenticated-requests",
      "headline": "Authenticated requests",
      "id": 59309,
      "numberOfComments": 0,
      "siteId": 20124
    }
  ],
  "page": 1,
  "pageSize": 20,
  "totalCount": 1
}
\end{verbatim}

\section{Sorting}\label{sorting-1}

Collection results can be sorted. Note, however, that not all
collections allow sorting. The ones that support it contain the optional
parameter \texttt{\{lb\}?sort\{rb\}} in their GraphQL definition.

To get sorted collection results, append
\texttt{sort:\textbackslash{}"\textless{}param-name\textgreater{}\textbackslash{}"}
to the request URL. For example, appending
\texttt{sort:\textbackslash{}"title\textbackslash{}"} to the request URL
sorts the results by title.

The default sort order is ascending (0-1, A-Z). To perform a descending
sort, append \texttt{:desc} to the parameter name. For example, to
perform a descending sort by title, append
\texttt{sort:\textbackslash{}"title:desc\textbackslash{}"} to the
request URL.

To sort by more than one parameter, separate the parameter names by
commas and put them in order of priority. For example, to sort first by
title and then by creation date, append
\texttt{sort:\textbackslash{}"title,dateCreated\textbackslash{}"} to the
request URL.

To specify a descending sort for only one parameter, you must explicitly
specify ascending sort order (\texttt{:asc}) for the other parameters:

\begin{verbatim}
sort:\"headline:desc,dateCreated:asc\"
\end{verbatim}

\section{Flatten}\label{flatten-1}

The \texttt{flatten} query parameter returns all resources and
disregards folders or other hierarchical classifications. Collection
GraphQL specifications define if \texttt{flatten} is available. Its
default value is \texttt{false}, so a document query to the root folder
returns only the documents in that folder.

With \texttt{flatten} set to \texttt{true}, the same query returns
documents in any subfolders, regardless of how deeply those folders are
nested. Setting \texttt{flatten} set to \texttt{true} and querying for
documents in a Site's root folder returns all the documents in the Site.

\chapter{Multipart Requests}\label{multipart-requests-1}

Several mutations accept a binary file via a multipart request. For
example, the definition for posting a file to a \texttt{DocumentFolder}
specifies a multipart request, \texttt{Upload} type in GraphQL:

\begin{figure}
\centering
\includegraphics{./images/graphql-mutation-upload.png}
\caption{Create Document accepts a \texttt{multipartBody}.}
\end{figure}

The GraphQL specification doesn't support natively multipart uploads,
but an
\href{https://github.com/jaydenseric/graphql-multipart-request-spec}{extension}
contributed by the community covers that use case.

Liferay's implementation includes that extension and allows uploading
files.

Multipart support in GraphQL is disabled by default. To enable it, add
the configuration to upload multipart files in the Liferay application's
\texttt{web.xml} file:

\begin{verbatim}
<servlet>
        <servlet-name>Module Framework Servlet</servlet-name>
        <servlet-class>
            com.liferay.portal.module.framework.ModuleFrameworkServletAdapter
        </servlet-class>
        <load-on-startup>1</load-on-startup>
        <async-supported>true</async-supported>
        <multipart-config>
            <location>/tmp</location>
            <max-file-size>20848820</max-file-size>
            <max-request-size>418018841</max-request-size>
            <file-size-threshold>1048576</file-size-threshold>
        </multipart-config>
</servlet>
\end{verbatim}

To test, use the Altair configuration to upload files. Use the selector
to upload one or multiple files and define a variable in the query.

\begin{figure}
\centering
\includegraphics{./images/graphql-mutation-upload-altair.png}
\caption{Creating a Document in Altair is easy with the selector.}
\end{figure}

\begin{verbatim}
mutation($file: [Upload]) {
  createSiteDocument(multipartBody: $file, siteKey: "guest") {
    id
    title
  }
}
\end{verbatim}

The variable above is \texttt{file} because there's only one. If you
wanted to upload several files, name the variable \texttt{\$files} and
each file should have a numeric sequence: \texttt{files.0},
\texttt{files.1}, \texttt{files.2}, etc.

All multipart APIs allow sending a JSON file containing the file's
metadata (title, description, etc.). That parameter should be the second
file uploaded (defined using the \texttt{file.0}, \texttt{file.1}
syntax).

For example,

\begin{verbatim}
document={\"title\": \"Alternative name\"}"
\end{verbatim}

And here's the response:

\begin{verbatim}
{
  "data": {
    "createSiteDocument": {
      "id": 37701,
      "title": "99-rest-generator.markdown"
    }
  }
}
\end{verbatim}

The cURL request is slightly different (Altair fills out the variables):

\begin{verbatim}
curl 'http://localhost:8080/o/graphql' -H 'Authorization: Basic dGVzdEBsaWZlcmF5LmNvbTp0ZXN0' \
-F operations='{"query":"mutation($files: [Upload]) {createSiteDocument(multipartBody: $files, siteId: 20122) {id}}","variables": { "files": [null] } }' \
-F map='{ "0": ["variables.files.0"]}' \
-F 0=@"99-rest-generator.markdown"
\end{verbatim}

\chapter{Using GraphQL APIs}\label{using-graphql-apis}

Liferay DXP's GraphQL APIs are independent of clients and can be used
with any GraphQL client you want. The only usual requirements are
setting up the \texttt{Authentication} header using OAuth, Cookie,
Basic, etc.

For JavaScript applications, we recommend using
\href{https://www.apollographql.com/}{Apollo Client} or
\href{https://github.com/prisma-labs/graphql-request}{graphql-request},
like this:

\begin{verbatim}
const { GraphQLClient } = require('graphql-request');

const graphQLClient = new GraphQLClient('http://localhost:8080/o/graphql', {
    headers: {
        authorization: `Basic ${AUTHORIZATION_TOKEN}`
    }
});

const getDestinationsQuery = ` {
  destinations: contentSetContentSetElements(contentSetId: ${DESTINATION_CONTENTSET_ID}) {
    items {
        id
        title
    }
    page
    pageSize
    totalCount
  }
}`;

...

const response = await graphQLClient.request(getDestinationsQuery);
\end{verbatim}

Here are several examples of JavaScript applications using GraphQL APIs:

\begin{itemize}
\tightlist
\item
  \href{https://github.com/dgomezg/liferay-frontend-samples/blob/master/lifeair-alexa-skill/}{Alexa
  skill using GraphQL APIs}
\item
  \href{https://github.com/dgomezg/liferay-frontend-samples/tree/master/lifeair-react-showroom}{React
  application using Apollo Client for React}
\item
  \href{https://github.com/dgomezg/liferay-frontend-samples/tree/master/lifeair-vue-showroom}{Vue
  application using Apollo Client for Vue}
\end{itemize}

\chapter{REST Builder}\label{rest-builder}

REST Builder is Liferay DXP's tool to build REST and GraphQL APIs. It's
based on OpenAPI, following an
\href{/docs/7-2/frameworks/-/knowledge_base/f/headless-rest-apis}{API-first
approach}.

Using REST Builder takes only three steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write the OpenAPI profile.
\item
  Use REST builder to generate the scaffolding.
\item
  Fill out the generated classes with your logic.
\end{enumerate}

A good overview of the process is detailed
\href{https://help.liferay.com/hc/es/articles/360028748872-Generating-APIs-with-REST-Builder}{here}.

We'll see each step in detail but first, let's talk about why we want to
use REST Builder.

\section{Why we should use REST
Builder}\label{why-we-should-use-rest-builder}

There are several reasons to prefer REST Builder over rolling our own
\href{https://help.liferay.com/hc/en-us/articles/360031902292-JAX-RS}{JAX-RS
services}. Some of them are the following:

\begin{itemize}
\tightlist
\item
  Development speed: you avoid writing JAX-RS annotations, converters,
  adding support for multipart or layers to organize your code.
  Everything is generated.
\item
  API scaffolding: pagination, filtering, searching, JSON writers, XML
  generation, even unit, and integration tests are generated.
\item
  GraphQL support out of the box: write your REST API and get a GraphQL
  endpoint for free.
\item
  Integration with Liferay's authentication pipelines: Basic, OAuth,
  Cookie, CORS handling. You don't have to search manually for the user
  or the company; everything is already there.
\item
  JSON \& XML support: APIs return whichever format the consumer
  prefers.
\item
  Consistency: all APIs follow the same rules and conventions, enforced
  by REST builder.
\end{itemize}

\chapter{How to install REST Builder}\label{how-to-install-rest-builder}

Use the
\href{https://portal.liferay.dev/docs/7-2/reference/-/knowledge_base/r/rest-builder-gradle-plugin}{Gradle
plugin} to install REST builder by adding this gradle configuration to
your project:

\begin{verbatim}
buildscript {
    dependencies {
        classpath group: "com.liferay", name: "com.liferay.gradle.plugins.rest.builder", version: "1.0.21"
    }

    repositories {
        maven {
            url "https://repository-cdn.liferay.com/nexus/content/groups/public"
        }
    }
}

apply plugin: "com.liferay.portal.tools.rest.builder"
\end{verbatim}

To use it, run \texttt{gradlew\ buildREST}. Note that your Gradle
wrapper may not be in your app's project directory, so you may need to
use \href{/docs/7-2/reference/-/knowledge_base/r/blade-cli}{Blade} to
locate it:

\begin{verbatim}
blade gw buildREST
\end{verbatim}

If you want to use a specific version of REST builder, you can specify
it explicitly:

\begin{verbatim}
dependencies {
    restBuilder group: "com.liferay", name: "com.liferay.portal.tools.rest.builder", version: "1.0.30"
}
\end{verbatim}

\chapter{REST Builder \& OpenAPI}\label{rest-builder-openapi}

REST Builder is based on
\href{https://swagger.io/specification/}{OpenAPI}, and its philosophy is
``OpenAPI first'': first you write the profile and then you use it as
the base of your implementation.

But first you must create a project with two empty bundles (a Blade
template will follow soon). The bundles (-api and -impl) should have the
files you are already used to: a \texttt{build.gradle} and a
\texttt{bnd.bnd}. The novelty is two YAML files, a configuration file
(\texttt{rest-config.yaml}) and the OpenAPI profile
(\texttt{rest-openapi.yaml}). An example project is
\href{https://github.com/nhpatt/liferay-devcon-appointment}{here}.

Let's see the configuration file in detail. In the root of the -impl
project we have to create a YAML file to specify paths and the basic
configuration of our new API. A sample implementation would be:

\begin{verbatim}
apiDir: "../headless-test-api/src/main/java"
apiPackagePath: "com.liferay.headless.test"
application:
    baseURI: "/headless-test"
    className: "HeadlessTestApplication"
    name: "Liferay.Headless.Test"
author: "Javier Gamarra"
\end{verbatim}

This file specifies the path of the -api bundle, the java package that
we will use across all the bundles and the information of the JAX-RS
application: the path of our application, the name of the class and the
JAX-RS name of our API.

I've skipped two advanced features, generating a client and automated
tests, will see them later.

Just one step left, writing our OpenAPI profile.

\section{OpenAPI profile}\label{openapi-profile}

The OpenAPI profile will be the source of all our APIs, in this file, we
will add the paths and entities of our API. First, we'll create a
\href{https://en.wikipedia.org/wiki/YAML}{YAML} file called
rest-openapi.yaml. Writing YAML files is tricky so we recommend using
the \href{http://editor.swagger.io/}{swagger editor} to do it, which
validates the YAML file against YAML syntax and the
\href{https://github.com/OAI/OpenAPI-Specification}{OpenAPI
specification}.

A simple OpenAPI profile that retrieves a fictitious entity might look
like this:

\begin{verbatim}
components:
  schemas:
    Entity:
      description: A very simple entity
      properties:
        name:
          description: The entity name.
          type: string
        id:
          description: The entity ID.
          type: integer
      type: object
info:
  description: ""
  title: "My API"
  version: v1.0
openapi: 3.0.1
paths:
  "/entities/{entityId}":
    get:
      parameters:
        - in: path
          name: entityId
          required: true
          schema:
            type: integer
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Entity"
          description: ""
      tags: ["Entity"]
\end{verbatim}

All OpenAPI profiles have three different sections: components, info,
and paths. The easiest one is the information block. It contains the
OpenAPI version, the title and the version of your API:

\begin{verbatim}
info:
  description: ""
  title: "My API"
  version: v1.0
openapi: 3.0.1
\end{verbatim}

Indentations should be spaces. The
\href{http://editor.swagger.io/}{swagger editor} helps with formatting.

The components section specifies the schemas/entities to return or
accept on your APIs. In this case, you define a schema called
\emph{Entity} that has two string fields: a name and an id.

\begin{verbatim}
components:
  schemas:
    Entity:
      description: A very simple entity
      properties:
        name:
          description: The entity name.
          type: string
        id:
          description: The entity ID.
          type: integer
      type: object
\end{verbatim}

The OpenAPI specification defines
\href{https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md\#schemaObject}{many
types and fields} you can use in your schemas.

The other common type is \texttt{\$ref}, a
\href{https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md\#referenceObject}{reference
type} that allows you to refer to an existing type like this:

\begin{verbatim}
$ref: '#/components/schemas/Entity'
\end{verbatim}

The last block, called paths, defines the URLs that you'll expose in
your APIs, with the type of HTTP verbs, list of parameters, status
codes, etc.

\begin{verbatim}
paths:
  "/entities/{entityId}":
    get:
      parameters:
        - in: path
          name: entityId
          required: true
          schema:
            type: integer
      responses:
        200:
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Entity"
          description: ""
      tags: ["Entity"]
\end{verbatim}

The pattern above, \texttt{"/entities/\{entity\}"}, follows a common
pattern in REST APIs. This is the endpoint that retrieves one element,
\texttt{"/entities"}. It returns a list of elements, and a POST request
creates one.

For every path, it is mandatory to add a tag that points to an existing
schema to indicate where to generate your code. REST Builder creates a
method inside the class \texttt{{[}TAG{]}ResourceImpl.java}.

\section{Generation}\label{generation}

Once you've written your OpenAPI configuration and profile, it's time to
generate your scaffolding for REST and GraphQL.

In the -impl or in the root module folder, execute this command:

\begin{verbatim}
gw buildREST
\end{verbatim}

You can use \texttt{gw\ bR} if you want to save a few keystrokes.

If everything's indented properly and the OpenAPI profile validates,
REST Builder generates your JAX-RS resources and the GraphQL endpoint.
Next, you'll see what has been generated and how to implement our
business logic.

\section{Examples}\label{examples}

Here's a complete example that defines all CRUD operations in OpenAPI.

\section{GET Collection}\label{get-collection}

\begin{verbatim}
paths:
    "/entities":
        get:
            responses:
                200:
                    content:
                        application/json:
                            schema:
                                items:
                                    $ref: "#/components/schemas/Entity"
                                type: array
                    description: ""
            tags: ["Entity"]
\end{verbatim}

\section{DELETE}\label{delete}

\begin{verbatim}
paths:
    "/entities/{entityId}":
        delete:
            parameters:
                - in: path
                  name: entityId
                  required: true
                  schema:
                      type: integer
            responses:
                204:
                    content:
                        application/json: {}
                    description: ""
            tags: ["Entity"]
\end{verbatim}

\section{POST}\label{post}

\begin{verbatim}
paths:
    "/entities":
        post:
            requestBody:
                content:
                    application/json:
                        schema:
                            $ref: "#/components/schemas/Entity"
            responses:
                200:
                    content:
                        application/json:
                            schema:
                                $ref: "#/components/schemas/Entity"
                    description: ""
            tags: ["Entity"]
\end{verbatim}

\section{PUT}\label{put}

\begin{verbatim}
paths:
    "/entities/{entityId}":
        put:
            parameters:
                - in: path
                  name: entityId
                  required: true
                  schema:
                      type: integer
            requestBody:
                content:
                    application/json:
                        schema:
                            $ref: "#/components/schemas/Entity"
            responses:
                200:
                    content:
                        application/json:
                            schema:
                                $ref: "#/components/schemas/Entity"
                    description: ""
            tags: ["Entity"]
\end{verbatim}

\section{Summary}\label{summary}

There are more examples showcasing all the supported OpenAPI syntax
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/headless/headless-delivery/headless-delivery-impl/rest-openapi.yaml}{here}
and
\href{https://github.com/liferay/liferay-portal/blob/master/modules/apps/headless/headless-admin-taxonomy/headless-admin-taxonomy-impl/rest-openapi.yaml}{here}.
Your next step is to
\href{/docs/7-2/frameworks/-/knowledge_base/f/rest-builder-develop}{create
your API}.

\chapter{Developing an API with REST
Builder}\label{developing-an-api-with-rest-builder}

After executing \texttt{gw\ buildREST}, you have two modules:
\emph{headless-test-api} and \emph{headless-test-impl}.

\begin{itemize}
\item
  Headless Test API contains the interfaces for your resources and the
  POJOs of your schemas.
\item
  Headless Test Impl contains your implementation and the JAX-RS
  application.
\end{itemize}

Your generated \texttt{EntityResource} looks like this:

\begin{verbatim}
public interface EntityResource {

    public Page<Entity> getEntitiesPage() throws Exception;

    public Entity postEntity(Entity entity) throws Exception;

    public void deleteEntity(Integer entityId) throws Exception;

    public Entity getEntity(Integer entityId) throws Exception;

    public Entity putEntity(Integer entityId, Entity entity) throws Exception;

    //Context methods

    public default void setContextAcceptLanguage(AcceptLanguage contextAcceptLanguage) {}

    public void setContextCompany(Company contextCompany);

    public default void setContextHttpServletRequest(HttpServletRequest contextHttpServletRequest) {}

    public default void setContextHttpServletResponse(HttpServletResponse contextHttpServletResponse) {}

    public default void setContextUriInfo(UriInfo contextUriInfo) {}

    public void setContextUser(User contextUser);
}
\end{verbatim}

These are generated methods you defined in the OpenAPI profile (the full
set as displayed in the examples).

REST builder also generates two implementation files, a base class, with
all the JAX-RS, GraphQL and OpenAPI annotations and an empty
implementation, \texttt{EntityResourceImpl}:

\begin{verbatim}
@Component(
    properties = "OSGI-INF/liferay/rest/v1_0/entity.properties",
    scope = ServiceScope.PROTOTYPE, service = EntityResource.class
)
public class EntityResourceImpl extends BaseEntityResourceImpl {
}
\end{verbatim}

This is where you implement new methods, by overriding the base class
implementation and returning your code. For example, here's a prototype
implementation storing entities in a Map:

\begin{verbatim}
Map<Integer, Entity> entities = new HashMap<>();

@Override
public Entity getEntity(Integer entityId) throws Exception {
    return entities.get(entityId);
}

@Override
public Page<Entity> getEntitiesPage() throws Exception {
    return Page.of(entities.values());
}

@Override
public void deleteEntity(Integer entityId) throws Exception {
    entities.remove(entityId);
}

@Override
public Entity postEntity(Entity entity) throws Exception {
    entities.put(entity.getId(), entity);
    return entity;
}

@Override
public Entity putEntity(Integer entityId, Entity entity) throws Exception {
    entities.put(entity.getId(), entity);
    return entity;
}
\end{verbatim}

For the collection, you return a \texttt{Page} object based on a list
but there are also utility methods that return the pagination
information:

\begin{verbatim}
Page.of(list, pagination, totalCount)
\end{verbatim}

Don't touch the interfaces or the base classes (those are regenerated
every time you run REST Builder). Like
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder}, you only have to maintain the implementation classes, and if
you change the API, run REST Builder again and the interfaces are
updated. Your business logic could call other REST APIs, use Service
Builder or another persistence mechanism.

\section{Development Cycle}\label{development-cycle}

While implementing your API's business logic, you'll typically improve
your API by adding parameters or other paths. For that, you'll modify
the OpenAPI profile and regenerate the API again calling the
\texttt{buildREST} command.

The cycle starts anew until you get to the final state and deploy your
APIs. They become available at this URL pattern:

\begin{verbatim}
http://localhost:8080/o/[application class name]/[OpenAPI version]/
\end{verbatim}

You can also execute \texttt{jaxrs:check} in the OSGi console to see all
the JAX-RS endpoints.

GraphQL paths and entities are added automatically to the default
GraphQL endpoint:

\begin{verbatim}
localhost:8080/o/graphql 
\end{verbatim}

You can disable GraphQL generation by adding
\texttt{generateGraphQL:\ false} to your \texttt{rest-config.yaml}
(\texttt{generateREST} controls the generation of the REST endpoints).

\section{Wrapping Up}\label{wrapping-up}

So\ldots{} that's all!

When everything is ready, you might want to consider publishing your
Headless API to Swaggerhub so others can consume it. You can use the
following URL pattern for that:

\begin{verbatim}
http://localhost:8080/o/[application name]/[application version]/openapi.yaml
\end{verbatim}

The URL for the example above, therefore, would be

\begin{verbatim}
http://localhost:8080/o/headless-test/v1.0/openapi.yaml
\end{verbatim}

This URL has the content of \texttt{rest-openapi.yaml} plus the classes
that REST Builder generated for you.

\chapter{Managing Collections in REST
Builder}\label{managing-collections-in-rest-builder}

\section{Pagination}\label{pagination-3}

To add pagination to your endpoints, add \texttt{page} and
\texttt{pageSize} as query parameters to your OpenAPI profile, like
this:

\begin{verbatim}
- in: query
  name: page
  schema:
      type: integer
- in: query
  name: pageSize
  schema:
      type: integer
\end{verbatim}

Those two parameters add a \texttt{Pagination\ pagination} parameter in
the method signature to restrict the number of entries to return in the
\texttt{Page.of} constructor.

Pagination is highly recommended for entities that can have many
elements, to avoid very large requests.

\section{Filtering, sorting and
searching}\label{filtering-sorting-and-searching}

Adding support for filtering, sorting, and searching is trickier. The
first step is to add the query parameters to the OpenAPI profile, like
this:

\begin{verbatim}
- in: query
  name: filter
  schema:
      type: string
- in: query
  name: search
  schema:
      type: string
- in: query
  name: sort
  schema:
      type: string
\end{verbatim}

The method signature then receives a Sort object, a Filter object, and
string with the search request. Those objects use
\href{/docs/7-2/frameworks/-/knowledge_base/f/model-entity-indexing-framework}{Liferay's
indexing framework}. This gives you many benefits, like support for
permissions out-of-the-box and having to write very little code to
achieve sort, filter, and search.

So first, you must make sure your entity is indexed and uses the
indexing framework.

Once that's done you have three things to do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add an \texttt{EntityModel} to translate between our indexing
  framework and your code
\item
  Inject your \texttt{entityModel} into your resource implementation.
\item
  Call Search utilities to avoid boilerplate code.
\end{enumerate}

\section{Add an EntityModel}\label{add-an-entitymodel}

The \texttt{EntityModel} is a class that translates the name the
property has in your API to the name used to index it.

\begin{verbatim}
public class EntityEntityModel implements EntityModel {
    public EntityEntityModel() {
        _entityFieldsMap = EntityModel.toEntityFieldsMap(
            new StringEntityField(
                "name", locale -> Field.getSortableFieldName(Field.NAME))
        );
    }

    @Override
    public Map<String, EntityField> getEntityFieldsMap() {
        return _entityFieldsMap;
    }

    private final Map<String, EntityField> _entityFieldsMap;
}
\end{verbatim}

The \texttt{EntityModel} decouples the way you filter/sort from the way
you index the information. You could use one field to sort, backed
internally by several indexed fields or vice-versa.

\section{Inject Your EntityModel}\label{inject-your-entitymodel}

Injecting your \texttt{EntityModel} is really easy, our resource
implementation just has to implement the \texttt{EntityModelResource}
interface.

This entity model is simple and doesn't have any dynamic fields, so you
can instantiate it directly and return it in the \texttt{getEntityModel}
method, like this:

\begin{verbatim}
@Component(
    properties = "OSGI-INF/liferay/rest/v1_0/entity.properties",
    scope = ServiceScope.PROTOTYPE, service = EntityResource.class
)
public class EntityResourceImpl extends BaseEntityResourceImpl implements
    EntityModelResource {

    ...

    @Override
    public EntityModel getEntityModel(MultivaluedMap multivaluedMap) {
        return _entityEntityModel;
    }

    private EntityEntityModel _entityEntityModel = new EntityEntityModel();
}
\end{verbatim}

\section{Call search utilities}\label{call-search-utilities}

Finally, you must call \texttt{SearchUtil.search()} that links
everything together. It requires these parameters:

\texttt{booleanQueryUnsafeConsumer}: a boolean query to restrict the
information we want to retrieve.

\texttt{filter}: pass-through of the filter object.

\texttt{indexerClass}: the class of the entity that to filter/search.

\texttt{keywords}: pass-through of the search string.

\texttt{pagination}: pass-through of the pagination object (to read the
row requested).

\texttt{queryConfigUnsafeConsumer}: the configuration for the fields
that you want to return, typically the id to do a query later, in the
\texttt{transformUnsafeFunction}.

\texttt{searchContextUnsafeConsumer}: global configuration of the query.

\texttt{transformUnsafeFunction}: the function that transforms from
\texttt{Document} (of the indexing framework) to your entity, either
searching in the database, your persistence, another API, etc.

\texttt{sorts}: pass-through of the sorts object.

The code would be similar to this:

\begin{verbatim}
@Override
public Page<Entity> getEntitiesPage(
    String search, Filter filter, Pagination pagination, Sort[] sorts)
    throws Exception {

    return SearchUtil.search(
        booleanQuery -> {},
        filter, Entity.class, search, pagination,
        queryConfig -> queryConfig.setSelectedFieldNames(
            Field.ENTRY_CLASS_PK),
        searchContext -> searchContext.setCompanyId(contextCompany.getCompanyId()),
        document -> new Entity(), //FILL with your implementation
        sorts);
}
\end{verbatim}

\section{Using Your filter, search, and
sort}\label{using-your-filter-search-and-sort}

Lifeay uses OData to express our filter queries, following this
\href{/docs/7-2/frameworks/-/knowledge_base/f/filter-sort-and-search\#filter}{syntax}.

And that's it! Now you can can filter/search and sort by the fields you
defined in your \texttt{EntityModel}.

\chapter{REST Builder Scaffolding}\label{rest-builder-scaffolding}

Apart from the JAX-RS annotations, basic structure and GraphQL support,
there are some other things the REST Builder provides:

\begin{itemize}
\tightlist
\item
  Context Fields
\item
  Automatic Transactions
\item
  Test Generation
\item
  Client Generation
\item
  Common Utilities
\end{itemize}

These are useful and time saving additions to your development cycle.

\section{Context fields}\label{context-fields}

The \texttt{ResourceImpl} classes are JAX-RS-compliant resources. You
can add \texttt{@Context} injections, mix JAX-RS endpoints, and use full
power of the JAX-RS standard.

REST Builder injects several fields (as protected fields in the base
class) to help you implement new APIs, like these:

\begin{itemize}
\tightlist
\item
  \texttt{contextAcceptLanguage}, containing the current
  \texttt{Locale}.
\item
  \texttt{contextCompany}, containing the current \texttt{Company}.
\item
  \texttt{contextHttpServletRequest}, containing the
  \texttt{HttpServletRequest}.
\item
  \texttt{contextHttpServletResponse}, containing the
  \texttt{HttpServletResponse}.
\item
  \texttt{contextUser}, containing the current logged-in \texttt{User}.
\item
  \texttt{contextUriInfo}, containing the \texttt{UriInfo} information
  (paths, endpoints).
\end{itemize}

\section{Automatic transactions}\label{automatic-transactions}

One little-known feature of REST Builder is that it wraps your API calls
in transactions if the HTTP verb used is POST, PUT, PATCH or DELETE
(doesn't apply for GET operations).

If you need to do several Service Builder calls in a sequence, you don't
have to wrap them in a transaction; it happens automatically. The
transaction commits if no exception is thrown and rolls back if an
exception bubbles up to the resource implementation method.

\section{Test generation}\label{test-generation}

You can generate integration tests if you specify a \texttt{testDir}
property:

\begin{verbatim}
testDir: "../headless-admin-taxonomy-test/src/testIntegration/java"
\end{verbatim}

REST Builder generates integration tests under the -test module. Those
tests check the API using a REST client. They check the response, doing
an end-to-end test involving all steps from parsing the request to
returning JSON.

The generated tests are ignored by default and, depending on the path,
may force you to implement a creation method (to be able to add content
to either update/delete or retrieve it).

The
\href{https://github.com/liferay/liferay-portal/tree/master/modules/apps/headless/headless-delivery/headless-delivery-test}{headless-delivery-test}
project contains many examples.

\section{Client generation}\label{client-generation}

You can generate a Java client if you specify a \texttt{clientDir}
property:

\begin{verbatim}
clientDir: "../headless-admin-taxonomy-client/src/main/java"
\end{verbatim}

This is a Java, typed, client that interacts with the APIs using static
methods. The client project contains all the methods to call your paths
and parses the requests and responses.

\section{Common utilities}\label{common-utilities}

REST Builder provides several JAX-RS utilities, from exception mappers
for the most common exceptions in the portal, XML and JSON Body
Readers/Writers, Site validation (that works with \texttt{siteId} and
\texttt{siteKey}), and support for Bean Validation.

There are also utility libraries that can be useful when developing new
APIs:

\begin{itemize}
\tightlist
\item
  \texttt{ContentLanguageUtil}, to deal with the
  \texttt{ContentLanguage} header.
\item
  \texttt{JaxRsLinkUtil}, to create links between APIs.
\item
  \texttt{LocalDateTimeUtil}, to transform between date formats.
\item
  \texttt{LocalizedMapUtil}, to create maps with locales as keys.
\item
  \texttt{SearchUtil}, to use the search framework to return Pages of
  content.
\item
  \texttt{TransformUtil}, to deal with lambdas and conversions.
\end{itemize}

\chapter{Support for oneOf, anyOf and
allOf}\label{support-for-oneof-anyof-and-allof}

OpenAPI 3.0 added several ways of using inheritance and composition to
create complex schemas. Specifically, it added support for
\href{https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/}{\emph{allOf},
\emph{anyOf,} and \emph{oneOf}}, with these semantics:

\begin{itemize}
\tightlist
\item
  allOf -- the value validates against all the subschemas
\item
  anyOf -- the value validates against any of the subschemas
\item
  oneOf -- the value validates against exactly one of the subschemas
\end{itemize}

Next, you'll learn each option's syntax and how its code is generated.

\section{allOf}\label{allof}

With \texttt{allOf} you can use the power of composition to create an
entity that combines several others. It's the most potent way of reusing
code without losing expressiveness and granularity: you can define small
entities that can be reused by composing several to create a larger
entity.

To use \texttt{allOf} you must follow this syntax:

\begin{verbatim}
EntityA:
    properties:
        nameA:
            type: string
EntityB:
    properties:
        nameB:
            type: string
EntityC:
    allOf:
        - $ref: '#/components/schemas/EntityA'
        - $ref: '#/components/schemas/EntityB'
\end{verbatim}

This OpenAPI syntax generates the following Java code inside the
\texttt{EntityC} class:

\begin{verbatim}
@Schema
@Valid
public EntityA getEntityA() {
    return entityA;
}

@Schema
@Valid
public EntityB getEntityB() {
    return entityB;
}
\end{verbatim}

\section{oneOf}\label{oneof}

\texttt{OneOf} is the simplest of the generics properties. It defines a
property that can have different types. Since Java doesn't support Union
Types, use an Object to model the property:

\begin{verbatim}
EntityA:
    properties:
        nameA:
            type: string
EntityB:
    properties:
        nameB:
            anyOf:
                - $ref: "#/components/schemas/EntityA"
                - type: object
                  properties:
                      name:
                          type: string
\end{verbatim}

This syntax generates the following Java code:

\begin{verbatim}
@Schema
@Valid
public Object getNameB() {
    return nameB;
}
\end{verbatim}

\section{anyOf}\label{anyof}

The final generic keyword, \texttt{anyOf} leverages
\texttt{JsonSubTypes} to extend entities with properties using
inheritance. You can define parent relationships (in this example,
\texttt{EntityC}) with two children containing the properties of the
parent and their own properties. Here's how to define YAML to use
inheritance:

\begin{verbatim}
EntityC:
    oneOf:
        - properties:
            nameA:
                type: string
        - properties:
            nameB:
                type: string
    properties:
        nameC:
            type: string
\end{verbatim}

This generates a parent class and two children:

\begin{verbatim}
@JsonSubTypes(
    {
        @JsonSubTypes.Type(name = "nameA", value = NameA.class),
        @JsonSubTypes.Type(name = "nameB", value = NameB.class)
    }
)
@JsonTypeInfo(
    include = JsonTypeInfo.As.PROPERTY, property = "childType",
    use = JsonTypeInfo.Id.NAME
)
@Generated("")
@GraphQLName("EntityC")
@JsonFilter("Liferay.Vulcan")
@XmlRootElement(name = "EntityC")
public class EntityC {

    @Schema
    public String getNameC() {
        return nameC;
    }

    public void setNameC(String nameC) {
        this.nameC = nameC;
    }
\end{verbatim}

And two children classes look like this:

\begin{verbatim}
@JsonTypeInfo(
    defaultImpl = NameA.class, include = JsonTypeInfo.As.PROPERTY,
    property = "childType", use = JsonTypeInfo.Id.NAME
)
@Generated("")
@GraphQLName("NameA")
@JsonFilter("Liferay.Vulcan")
@XmlRootElement(name = "NameA")
public class NameA extends EntityC {

    @Schema
    public String getNameA() {
        return nameA;
    }

    public void setNameA(String nameA) {
        this.nameA = nameA;
    }
\end{verbatim}

\chapter{REST Builder Liferay
Conventions}\label{rest-builder-liferay-conventions}

Liferay's headless APIs follow several patterns and conventions to
provide consistency and uniformity in the APIs.

Below is a list the most important ones. It's a living list.
Improvements are being made all the time, so check back to stay up to
date on the changes.

\section{YAML \& OpenAPI restrictions}\label{yaml-openapi-restrictions}

\begin{itemize}
\tightlist
\item
  \emph{Tags are required}. We can't assign a class to a DELETE
  operation (doesn't return anything, doesn't receive an entity) so we
  need the tag to assign the method to a Java class.
\item
  Responses must return a status code (default is not supported).
\item
  Paths must be quoted.
\item
  Paths only contain the method path (application and version are
  inherited from the JAX-RS application).
\end{itemize}

\section{Conventions}\label{conventions}

\begin{itemize}
\item
  We use path parameters for information that is required (like the id
  in a DELETE operation) and query parameters for optional information
  (filtering, sorting\ldots)
\item
  We don't expose \texttt{className}. If you need to return information
  like the \texttt{className}, use \texttt{contentType} keyword.
\end{itemize}

\chapter{The Workflow Framework}\label{the-workflow-framework}

Blogs Entries, Journal Articles, and Forms Entries are just a few Assets
supporting workflow. There's nothing stopping you from likewise enabling
workflow for your custom Assets. Discover here how the workflow
framework works, and find the steps and code samples for enabling your
custom entities to use the workflow capabilities in subsequent articles.

A workflow process is a set of steps that an Asset must proceed through
before it's marked with the workflow status \emph{Approved}. The steps
are defined in an XML file called a
\href{/7-2/reference/-/knowledge_base/r/crafting-xml-workflow-definitions}{workflow
definition}. Each Asset is configured to run through a specific workflow
definition via the \href{/7-2/user/-/knowledge_base/u/workflow}{Control
Panel}.

\begin{figure}
\centering
\includegraphics{./images/workflow-configuration.png}
\caption{Enable workflow on your custom Asset, and it can be sent
through a workflow process just like a native Asset.}
\end{figure}

The workflow status is a database field that must be present for an
entity to support workflow. If a database has the status field, but no
workflow code has been written, it's auto-marked \emph{Approved} by
Liferay's Service Builder infrastructure, to assure that everything
works smoothly by default.

\section{Supporting Workflow in the
Database}\label{supporting-workflow-in-the-database}

There are several database fields that must be present for an Asset to
support workflow:

\texttt{int\ status} represents the workflow status of each Asset.

\texttt{long\ statusByUserId} is the ID of the user that set the status
(for example, the initial User that hit the Submit for Publication
button to add a new Asset.

\texttt{String\ statusByUserName} is the User Name of the User that set
the status of the Asset.

\texttt{Date\ statusDate} is the date/time when the status was set.

For Service Builder applications, add these as entity columns in the
\texttt{service.xml} file, run Service Builder, and you're good to go.

\section{Setting the Status Fields}\label{setting-the-status-fields}

Once the database table has the proper status fields, set them in your
Entity's \texttt{addEntity} service method. Initially, set the status as
a DRAFT. It's what the workflow framework expects of an entity as it
enters the workflow process. The status is an \texttt{int}, but you
don't have to remember which number corresponds to the DRAFT status.
Instead, use the
\href{https://github.com/liferay/liferay-portal/blob/7.2.x/portal-kernel/src/com/liferay/portal/kernel/workflow/WorkflowConstants.java}{\texttt{WorkflowConstants}}
in \texttt{portal-kernel}. For a draft, pass in

\begin{verbatim}
WorkflowConstants.STATUS_DRAFT
\end{verbatim}

If you're curious, the \texttt{int} represented by this constant is
\texttt{2}. Another important status, APPROVED, is represented by the
\texttt{int} value \texttt{0} and the constant

\begin{verbatim}
WorkflowConstants.STATUS_APPROVED
\end{verbatim}

The User fields (\texttt{statusByUserID} and \texttt{statusByUserName})
are easy, since the \texttt{userId} of the User making the
\texttt{addEntity} request is part of the request itself, and passed
into the \texttt{addEntity} method for most assets. Use the ID directly
as the \texttt{statusByUserId}, and get the full name associated with
the User by using the ID to retrieve the \texttt{User} object.

\begin{verbatim}
entity.setStatusByUserId(userId);
entity.setStatusByUserName(user.getFullName());
\end{verbatim}

The \texttt{statusDate} is usually best set as the date the entity was
modified, and is part of the Service Context in the request:

\begin{verbatim}
entity.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

Once the status dates are set, the entity is ready to be sent into the
workflow framework.

\section{Sending the Entity to the Workflow
Framework}\label{sending-the-entity-to-the-workflow-framework}

When an entity is added to the database, the application must detect
whether workflow is enabled. If not, it automatically marks the entity
as approved so it appears in the UI. Otherwise, it's left in draft
status and the workflow back-end handles it. Thankfully, this whole
process is easily done with a call to
\texttt{WorkflowHandlerRegistryUtil.startWorkflowInstance} in your
persistence code.

\section{Allowing the Workflow Framework to Handle the
Entity}\label{allowing-the-workflow-framework-to-handle-the-entity}

Once the entity is sent to the Workflow Framework, much of the process
is automated, and you need not worry about the details. Write one class
that gives the framework some information on how to process the entity.
It's called a workflow handler
(\texttt{WorkflowHandler\textless{}T\textgreater{}}), and you can create
it by extending the handy abstract implementation,
\texttt{BaseWorkflowHandler\textless{}T\textgreater{}}.

The workflow handler usually goes in the module containing service
implementations. It's nice to keep your back-end code separate from your
view layer and controller (ala the MVC pattern).

Make your workflow handler a Component class so it can be registered
properly with OSGi runtime. It requires one Component property,
\texttt{model.class.name}, which is the fully qualified class name for
class you pass as the type parameter in the class declaration.

In addition to the property, declare the type of service you're
providing in the Component: \texttt{WorkflowHandler.class}.

Workflow handlers extending the \texttt{BaseWorkflowHandler} must
override three methods:

\texttt{getClassName} returns the model class's fully qualified class
name (\texttt{com.my.app.package.model.FooEntity}, for example).

\texttt{getType} returns the model resource name
(\texttt{model.resource.com.my.app.package.model.FooEntity}, for
example).

\texttt{updateStatus} does most of the heavy lifting here. It returns a
call to a local service method of the same name (for example,
\texttt{FooEntityLocalService.updateStatus}), so the status returned
from the workflow back-end can be persisted to the entity table in the
database. The \texttt{updateStatus} method needs a user ID, the primary
key for the class (for example, \texttt{fooEntityId}), the workflow
status, the service context, and the workflow context. The status and
the workflow context can be obtained from the workflow back-end. The
other parameters can be obtained from the workflow context.

\section{Supporting Workflow in the Service
Layer}\label{supporting-workflow-in-the-service-layer}

The service layer must update the status of the entity when it returns
from the Workflow Framework. Make an \texttt{updateStatus} method for
this purpose, and make sure, at a minimum, to set the status fields
again as the Asset comes out of the Workflow Framework, and call the
persistence layer's \texttt{update} method.

After that, provide any additional logic you might want, like checking
the status and updating the Asset's visibility (using the
\texttt{assetEntryLocalService}) based on the condition (visible if
\emph{Approved}, not visible is any other status).

Return the entry once you're through here.

\section{Database Cleanup: Delete the Workflow Instance
Links}\label{database-cleanup-delete-the-workflow-instance-links}

When you send an entity to the workflow framework via the
\texttt{startWorkflowInstance} call, it creates an entry in the
\texttt{workflowinstancelink} database table. In your service layer's
deletion logic, you must delete the workflow instance links. This
\texttt{delete} call ensures there are no orphaned entries in the
\texttt{workflowinstancelinks} table.

To get the \texttt{WorkflowInstanceLocalService} injected into your
\texttt{*LocalServiceBaseImpl} so you can call its methods in the
\texttt{LocalServiceImpl}, add a \texttt{reference\ entity} to your
entity declaration in \texttt{service.xml}, specifying
\texttt{WorkflowInstancelink}.

\section{Updating the User Interface}\label{updating-the-user-interface}

After you finish all the backend work, update your UI. Some common tasks
here include:

\begin{itemize}
\item
  In any public facing portion of the application (accessible to guest
  Users), don't display the entity if the status is anything except
  \emph{Approved}. This task requires the creation of an additional
  \texttt{finder} method that accounts for workflow status, and a
  corresponding \texttt{getter} to expose it in the service layer.
\item
  In administrative portions of the application, display the entities,
  but also display their workflow status. There's a tag library for
  this.
\end{itemize}

See the next article for more concrete steps and code snippets.

\chapter{Liferay's Workflow
Framework}\label{liferays-workflow-framework}

To workflow-enable your entities,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a Workflow Handler
\item
  Update the Service Layer
\item
  Update the User Interface
\end{enumerate}

Time to get started.

\section{Creating a Workflow Handler}\label{creating-a-workflow-handler}

If you're in a Service Builder application, the workflow handler goes in
your \texttt{-service} module.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a Component class that extends
  \texttt{BaseWorkflowHandler\textless{}T\textgreater{}}.

\begin{verbatim}
@Component(immediate = true, service = WorkflowHandler.class)
public class FooEntityWorkflowHandler extends BaseWorkflowHandler<FooEntity>
\end{verbatim}
\item
  Override three methods in the workflow handler.

\begin{verbatim}
@Override
public String getClassName() {
    return FooEntity.class.getName();
}

@Override
public String getType(Locale locale) {
    return ResourceActionsUtil.getModelResource(locale, getClassName());
}

@Override
public FooEntity updateStatus(int status, Map<String, Serializable> workflowContext) throws PortalException {
... }
\end{verbatim}

  Most of the heavy lifting is in the \texttt{updateStatus} method. It
  returns a call to a local service method of the same name (for
  example, \texttt{FooEntityLocalService.updateStatus}), so the status
  returned from the workflow back-end can be persisted to the entity
  table in the database.

  The \texttt{updateStatus} method needs a user ID, the primary key for
  the class (for example, \texttt{fooEntityId}), the workflow status,
  the service context, and the workflow context. The status and the
  workflow context can be obtained from the workflow back-end. The other
  parameters can be obtained from the workflow context. Here's an
  example \texttt{updateStatus} method:

\begin{verbatim}
@Override
public FooEntity updateStatus(
        int status, Map<String, Serializable> workflowContext)
    throws PortalException {

    long userId = GetterUtil.getLong(
        (String)workflowContext.get(WorkflowConstants.CONTEXT_USER_ID));
    long classPK = GetterUtil.getLong(
        (String)workflowContext.get(
            WorkflowConstants.CONTEXT_ENTRY_CLASS_PK));

    ServiceContext serviceContext = (ServiceContext)workflowContext.get(
        WorkflowConstants.CONTEXT_SERVICE_CONTEXT);

    return _fooEntityLocalService.updateStatus(
        userId, classPK, status, serviceContext);
}
\end{verbatim}
\end{enumerate}

Now your entity can be handled by Liferay's workflow framework. Next,
update the service methods to account for workflow status and add a new
method to update the status of an entity in the database.

\section{Updating the Service Layer}\label{updating-the-service-layer}

In most Liferay applications,
\href{/docs/7-2/appdev/-/knowledge_base/a/service-builder}{Service
Builder} is used to create database fields. First, you must update the
service layer:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Make sure your entity database table has \texttt{status},
  \texttt{statusByUserId}, \texttt{statusByUserName}, and
  \texttt{statusDate} fields.

\begin{verbatim}
<column name="status" type="int" />
<column name="statusByUserId" type="long" />
<column name="statusByUserName" type="String" />
<column name="statusDate" type="Date" />
\end{verbatim}
\item
  Wherever you're setting the other database fields in your persistence
  code, set the workflow status as a draft and set the other fields.

\begin{verbatim}
fooEntity.setStatus(WorkflowConstants.STATUS_DRAFT);
fooEntity.setStatusByUserId(userId);
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(null));
\end{verbatim}

  With Service Builder driven Liferay applications, this is in the local
  service implementation class (\texttt{-LocalServiceImpl}).
\item
  At the end of any method that adds a new entity to your database, call
  the workflow service to enable sending the entity into the workflow
  backend:

\begin{verbatim}
WorkflowHandlerRegistryUtil.startWorkflowInstance(
    fooEntity.getCompanyId(), fooEntity.getGroupId(), fooEntity.getUserId(),
    FooEntity.class.getName(), fooEntity.getPrimaryKey(), fooEntity,
    serviceContext);
\end{verbatim}
\item
  Implement the \texttt{updateStatus} method that must be called in the
  workflow handler. In the end, persist the updated entity to the
  database.

\begin{verbatim}
fooEntity.setStatus(status);
fooEntity.setStatusByUserId(user.getUserId());
fooEntity.setStatusByUserName(user.getFullName());
fooEntity.setStatusDate(serviceContext.getModifiedDate(now));

fooEntityPersistence.update(fooEntity);
\end{verbatim}
\item
  Do anything else that might make sense here, like changing the
  visibility of the asset depending on its workflow status:

\begin{verbatim}
if (status == WorkflowConstants.STATUS_APPROVED) {
    assetEntryLocalService.updateVisible(
        FooEntity.class.getName(), fooEntityId, true);
}
else {
    assetEntryLocalService.updateVisible(
        FooEntity.class.getName(), fooEntityId, false);
}
\end{verbatim}

  Here's what a full \texttt{updateStatus} method might look like:

\begin{verbatim}
@Indexable(type = IndexableType.REINDEX)
public FooEntity updateStatus(
    long userId, long fooEntityId, int status, ServiceContext serviceContext
) throws PortalException, SystemException {

        User user = userLocalService.getUser(userId);
        FooEntity fooEntity = getFooEntity(fooEntityId);

        fooEntity.setStatus(status);
        fooEntity.setStatusByUserId(userId);
        fooEntity.setStatusByUserName(user.getFullName());
        fooEntity.setStatusDate(new Date());

        fooEntityPersistence.update(fooEntity);

        if (status == WorkflowConstants.STATUS_APPROVED) {
            assetEntryLocalService.updateVisible(
          FooEntity.class.getName(), fooEntityId, true);
        }
    else {
            assetEntryLocalService.updateVisible(
          FooEntity.class.getName(), fooEntityId, false);
        }

        return fooEntity;
  }
\end{verbatim}
\item
  Add a call to \texttt{deleteWorkflowInstanceLinks} in the
  \texttt{deleteEntity} method:

\begin{verbatim}
workflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(
    fooEntity.getCompanyId(), fooEntity.getGroupId(),
    FooEntity.class.getName(), fooEntity.getFooEntityId());
\end{verbatim}

  To get the \texttt{WorkflowInstanceLocalService} injected into your
  \texttt{*LocalServiceBaseImpl} so you can call its methods in the
  \texttt{LocalServiceImpl}, add this to your entity declaration in
  \texttt{service.xml}:

\begin{verbatim}
<reference entity="WorkflowInstanceLink" package-path="com.liferay.portal" />
\end{verbatim}
\end{enumerate}

For an example of a fully implemented \texttt{updateStatus} method, see
the
\texttt{com.liferay.portlet.blogs.service.impl.BlogsEntryLocalServiceImpl}
class in \texttt{portal-impl}.

Once you've accounted for workflow status in your database and service
layer, there's only one thing left to do: update the user interface.

\section{Workflow Status and the View
Layer}\label{workflow-status-and-the-view-layer}

This is dependent on the needs of your application, but often involves
the following these steps:

\textbf{Display only approved entities:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If you're using Service Builder, define your finder in your
  application's \texttt{service.xml} and let Service Builder generate it
  for you.

\begin{verbatim}
<finder name="G_S" return-type="Collection">
    <finder-column name="groupId"></finder-column>
    <finder-column name="status"></finder-column>
</finder>
\end{verbatim}
\item
  Make sure you have a getter in your service layer that uses the new
  finder.

\begin{verbatim}
public List<FooEntity> getFooEntities(long groupId, int status)
    throws SystemException {

    return fooEntityPersistence.findByG_S(
        groupId, WorkflowConstants.STATUS_APPROVED);
}
\end{verbatim}
\item
  Finally, update your JSP to use the appropriate getter.

\begin{verbatim}
<liferay-ui:search-container-results
    results="<%= FooEntityLocalServiceUtil.getFooEntities(
        scopeGroupId, fooEntityId(), Workflowconstants.STATUS_APPROVED,
        searchContainer.getStart(), searchContainer.getEnd()) %>"
/>
    ...
\end{verbatim}
\end{enumerate}

\textbf{Display the workflow status:}

When you want to display the workflow status, use the
\texttt{\textless{}aui:worklfow-status\textgreater{}} tag.

\begin{verbatim}
<aui:workflow-status markupView="lexicon" showIcon="<%= false %>" showLabel="<%= false %>" status="<%= fooEntity.getStatus() %>" />
\end{verbatim}

Once your user interface accounts for workflow, your Liferay application
is fully workflow enabled.

\chapter{WYSIWYG Editors}\label{wysiwyg-editors}

WYSIWYG editors are an important part of content creation. Liferay's
platform supports several different editors, including CKEditor,
TinyMCE, and our flagship, AlloyEditor. This section shows how to
customize these WYSIWYG editors for your apps and sites.

\chapter{Adding a WYSIWYG Editor to a
Portlet}\label{adding-a-wysiwyg-editor-to-a-portlet}

It's easy to include WYSIWYG editors in your portlet, thanks to the
\texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag. Follow
these steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add the liferay-editor taglib declaration to your portlet's JSP:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/editor" prefix="liferay-editor" %>
\end{verbatim}
\item
  Add the editor to your JSP with the
  \texttt{\textless{}liferay-editor:editor\ /\textgreater{}} tag.
  Configure it using the attributes shown in the table below:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 Attribute | Type | Description |
 --- | --- | --- |
 `autoCreate` | `java.lang.String` | Whether to show the HTML edit view of the editor initially |
 `contents` | `java.lang.String` | Sets the initial contents of the editor |
 `contentsLanguageId` | `java.lang.String` | Sets the language ID for the input editor's text |
 `cssClass` | `java.lang.String` | A CSS class for styling the component. |
 `data` | `java.util.Map` | Data that can be used as the editorConfig |
 `editorName` | `java.lang.String` | The editor you want to use (alloyeditor, ckeditor, tinymce, simple) |
 `name` | `java.lang.String` | A name for the input editor. The default value is `editor`. |
 `onBlurMethod` | `java.lang.String` | A function to be called when the input editor loses focus. |
 `onChangeMethod` | `java.lang.String` | A function to be called on a change in the input editor. |
 `onFocusMethod` | `java.lang.String` | A function to be called when the input editor gets focus. |
 `onInitMethod` | `java.lang.String` | A function to be called when the input editor initializes. |
 `placeholder` | `java.lang.String` | Placeholder text to display in the input editor. |
 `showSource` | `java.lang.String` | Whether to enable editing the HTML source code of the content. The default value  is `true`. |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
See the [taglibdocs](https://docs.liferay.com/dxp/apps/frontend-editor/latest/taglibdocs/liferay-editor/editor.html) 
for the complete list of supported attributes. 

Below is an example configuration:

```html    
<div class="alloy-editor-container">
    <liferay-editor:editor
            contents="Default Content"
            cssClass="my-alloy-editor"
            editorName="alloyeditor"
            name="myAlloyEditor"
            placeholder="description"
            showSource="true" 
    /> 
</div>
```
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\item
  Optionally pass JavaScript functions through the
  \texttt{onBlurMethod}, \texttt{onChangeMethod},
  \texttt{onFocusMethod}, and \texttt{onInitMethod} attributes. Here is
  an example configuration that uses the \texttt{onInitMethod} attribute
  to pass a JavaScript function called \texttt{OnDescriptionEditorInit}:

\begin{verbatim}
<%@ taglib uri="http://liferay.com/tld/editor" prefix="liferay-editor" %>

<div class="alloy-editor-container">
    <liferay-editor:editor
        contents="Default Content"
        cssClass="my-alloy-editor"
        editorName="alloyeditor"
        name="myAlloyEditor"
        onInitMethod="OnDescriptionEditorInit"
        placeholder="description"
        showSource="true" />
</div>
\end{verbatim}

\begin{verbatim}
<aui:script>
    function <portlet:namespace />OnDescriptionEditorInit() {
        <c:if test="<%= !customAbstract %>">
            document.getElementById(
              '<portlet:namespace />myAlloyEditor'
            ).setAttribute('contenteditable', false);
        </c:if>
    }
</aui:script>
\end{verbatim}
\end{enumerate}

As you can see, it's easy to include WYSIWYG editors in your portlets!

\section{Related Topics}\label{related-topics-137}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/modifying-an-editors-configuration}{Modifying
  an Editor's Configuration}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/alloyeditor}{Modifying
  the AlloyEditor}
\end{itemize}

\chapter{Modifying an Editor's
Configuration}\label{modifying-an-editors-configuration}

You can use many different kinds of WYSIWYG editors to edit content in
portlets. Depending on the content you're editing, you may want to
modify the editor to provide a customized configuration for your needs.
In this article, you'll learn how to modify the default configuration
for Liferay DXP's supported WYSIWYG editors to meet your requirements.

To modify the editor's configuration, create a module with a component
that implements the
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}}
interface. Follow these steps to modify one of Liferay DXP's WYSIWYG
editors:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module}.
\item
  Open the portlet's \texttt{build.gradle} file and update the
  \texttt{com.liferay.portal.kernel} \texttt{version} to
  \texttt{4.13.1}. This is the version bundled with the Liferay DXP
  release.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package that extends the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/BaseEditorConfigContributor.html}{\texttt{BaseEditorConfigContributor}}
  class:
\item
  Create a component class that implements the
  \texttt{EditorConfigContributor} service:

\begin{verbatim}
@Component(
    property = {

    },

    service = EditorConfigContributor.class
)
\end{verbatim}
\item
  Add the following imports:

\begin{verbatim}
import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;
\end{verbatim}
\item
  Specify the editor's name, editor's configuration key, and/or the
  portlet name(s) where the editor resides. These three properties can
  be specified independently, or together, in any order. See the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}}
  interface's Javadoc for more information about the available
  properties and how to use them. The example configuration below
  modifies the AlloyEditor's Content Editor, identified by the
  \texttt{contentEditor} configuration key and \texttt{alloyeditor} name
  key.
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** If you're targeting all editors for a portlet, the
 `editor.config.key` is not required. For example, if you just want to target
 the Web Content portlet's editors, you can provide the configuration below:
 
 ```java
 @Component(
 property = {"editor.name=ckeditor",
 "javax.portlet.name=com_liferay_journal_web_portlet_JournalPortlet",
 "service.ranking:Integer=100"
 }
 ```
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
Two portlet names are declared (Blogs and Blogs Admin), specifying that the 
service applies to the content editors in those portlets. Lastly, the 
configuration overrides the default one by providing a higher 
[service ranking](/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service):

```java
@Component(
    property = {
        "editor.config.key=contentEditor", "editor.name=alloyeditor",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
        "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet", 
        "service.ranking:Integer=100"
    },

    service = EditorConfigContributor.class
)
```
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
 **NOTE:** If you want to create a global configuration that applies to an
 editor everywhere it's used, you must create two separate configurations:
 one configuration that targets just the editor and a second configuration
 that targets the Blogs and Blogs Admin portlets. For example, the two
 separate configurations below apply the updates to AlloyEditor everywhere
 it's used:
 
 Configuration one:
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
 
 Configuration two:
 ```java
 @Component(
     immediate = true,
     property = {
         "editor.name=alloyeditor",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsPortlet",
         "javax.portlet.name=com_liferay_blogs_web_portlet_BlogsAdminPortlet",
         "service.ranking:Integer=100"
     },
 
     service = EditorConfigContributor.class
 )
 ```
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\item
  Override the \texttt{populateConfigJSONObject()} method to provide the
  custom configuration for the editor. This method updates the original
  configuration JSON object. It can also Update or delete existing
  configurations, or any other configuration introduced by another
  \texttt{*EditorConfigContributor}.

\begin{verbatim}
@Override
public void populateConfigJSONObject(
    JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
    ThemeDisplay themeDisplay,
    RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

}
\end{verbatim}
\item
  In the \texttt{populateConfigJSONObject} method, you must instantiate
  a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONObject.html}{\texttt{JSONObject}}
  to hold the current configuration of the editor. For instance, you
  could use the code snippet below to retrieve the available toolbars
  for the editor:

\begin{verbatim}
JSONObject toolbars = jsonObject.getJSONObject("toolbars");
\end{verbatim}
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 **Note:** This toolbar configuration is only applicable for the AlloyEditor.
 If you choose a configuration that is supported by multiple editors, you
 could apply it to them all. To do this, you could specify all the editors
 (e.g., `"editor.name=alloyeditor"`, `"editor.name=ckeditor"`,
 `ckeditor_bbcode` etc.) in the `@Component` annotation  of your
 `EditorConfigContributor` implementation, as you did in step six. Use the
 links the bottom of this article to view each editor's configuration
 options and requirements.
\end{verbatim}

\noindent\hrulefill

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\item
  Now that you've retrieved the toolbar, you can modify it. The example
  below adds a camera button to the AlloyEditor's Add toolbar. It
  extracts the \emph{Add} buttons out of the toolbar configuration
  object as a
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/json/JSONArray.html}{\texttt{JSONArray}},
  and then adds the button to that \texttt{JSONArray}:

\begin{verbatim}
if (toolbars != null) {
    JSONObject toolbarAdd = toolbars.getJSONObject("add");

    if (toolbarAdd != null) {
        JSONArray addButtons = toolbarAdd.getJSONArray("buttons");

        addButtons.put("camera");
    }
}
\end{verbatim}

  The configuration JSON object is passed to the editor with the
  modifications you've implemented in the
  \texttt{populateConfigJSONObject} method.
\item
  Finally, generate the module's JAR file and copy it to your
  \texttt{deploy} folder. Once the module is installed and activated in
  the service registry, your new editor configuration is available for
  use.
\end{enumerate}

Liferay DXP supports several different types of WYSIWYG editors, which
include (among others):

\begin{itemize}
\tightlist
\item
  \href{https://alloyeditor.com/api/1.5.0/Core.html}{AlloyEditor}
\item
  \href{http://docs.ckeditor.com/\#!/api/CKEDITOR.config}{CKEditor}
\item
  \href{http://www.tinymce.com/wiki.php/Configuration}{TinyMCE}
\end{itemize}

Make sure to visit each editor's configuration API to learn what each
editor offers for configuration settings.

\section{Related Topics}\label{related-topics-138}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/alloyeditor}{Modifying
  the AlloyEditor}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-a-wysiwyg-editor-to-a-portlet}{Adding
  a WYSIWYG Editor to a Portlet}
\end{itemize}

\chapter{AlloyEditor}\label{alloyeditor}

AlloyEditor is a modern WYSIWYG editor built on top of CKEDITOR,
designed to create modern and gorgeous web content. AlloyEditor is the
default WYSIWYG editor.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-website.png}
\caption{AlloyEditor is the default WYSIWYG editor built on top of
CKEditor.}
\end{figure}

This section shows how to modify the default AlloyEditor configuration
to meet your requirements.

\chapter{Adding Buttons to AlloyEditor's
Toolbars}\label{adding-buttons-to-alloyeditors-toolbars}

AlloyEditor's toolbars contain several useful functions out-of-the-box.
You may, however, want to customize the default configuration to include
a button you've created, to add an existing button to a toolbar, or to
add an
\href{/docs/7-2/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{existing
CKEditor button that's bundled with Liferay DXP's AlloyEditor}. The
\href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}
interface}, provides everything you need to modify an editor's
configuration, including adding buttons to AlloyEditor's toolbars.
\href{https://docs.ckeditor.com/ckeditor4/latest/api/CKEDITOR_config.html}{CKEditor
Configuration settings} that modify the editor's behavior (excluding UI
modifications) can also be passed down through this configuration
object.

The \texttt{com.liferay.docs.my.button} module is used as an example
throughout this section. If you want to use it as a starting point for
your own configuration or follow along with the articles, you can
download the module's zip file from the
\href{https://github.com/liferay/liferay-docs/tree/7.1.x/develop/tutorials/code/osgi/modules/com.liferay.docs.my.button}{Github
repo}.

\chapter{Creating the OSGi Module and Configuring the
EditorConfigContributor
Class}\label{creating-the-osgi-module-and-configuring-the-editorconfigcontributor-class}

To add a button to the AlloyEditor's toolbars, you must first create an
OSGi component class of service type
\texttt{EditorConfigContributor.class}. Follow these steps to create and
configure the OSGi module:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  an OSGi module}, using
  \href{/docs/7-2/reference/-/knowledge_base/r/using-the-mvc-portlet-template}{Blade's
  portlet template}:

\begin{verbatim}
blade create -t portlet -p com.liferay.docs.my.button -c 
MyEditorConfigContributor my-new-button
\end{verbatim}
\item
  Open the portlet's \texttt{build.gradle} file and update the
  \texttt{com.liferay.portal.kernel} \texttt{version} to
  \texttt{4.13.1}. This is the version bundled with the Liferay DXP
  release.
\item
  Open the portlet class you created in step one
  (\texttt{MyEditorConfigContributor}) and add the following imports:

\begin{verbatim}
import com.liferay.portal.kernel.editor.configuration.BaseEditorConfigContributor;
import com.liferay.portal.kernel.editor.configuration.EditorConfigContributor;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.RequestBackedPortletURLFactory;
import com.liferay.portal.kernel.theme.ThemeDisplay;
\end{verbatim}
\item
  Replace the \texttt{@Component} and properties with the properties
  below:

\begin{verbatim}
@Component(
    immediate = true,
    property = {
      "editor.name=alloyeditor",
      "service.ranking:Integer=100"
    },
    service = EditorConfigContributor.class  
)
\end{verbatim}

  This targets AlloyEditor for the configuration and overrides the
  default service by providing a higher
  \href{/docs/7-2/customization/-/knowledge_base/c/creating-a-custom-osgi-service}{service
  ranking}. If you want to target a more specific configuration, you can
  find the available properties in the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/editor/configuration/EditorConfigContributor.html}{\texttt{EditorConfigContributor}
  interface's Javadoc}.
\item
  Extend \texttt{BaseEditorConfigContributor} instead of
  \texttt{GenericPortlet}.
\item
  Replace the \texttt{doView()} method and contents with the
  \texttt{populateConfigJSONObject()} method shown below:

\begin{verbatim}
@Override
public void populateConfigJSONObject(
JSONObject jsonObject, Map<String, Object> inputEditorTaglibAttributes,
ThemeDisplay themeDisplay,
RequestBackedPortletURLFactory requestBackedPortletURLFactory) {

}
\end{verbatim}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  AlloyEditor's toolbars:

\begin{verbatim}
JSONObject toolbarsJSONObject = jsonObject.getJSONObject("toolbars");

if (toolbarsJSONObject == null) {
        toolbarsJSONObject = JSONFactoryUtil.createJSONObject();
}
\end{verbatim}
\item
  If you're adding a button for one of the
  \href{/docs/7-2/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  plugins bundled with the AlloyEditor}, add the code below to retrieve
  the extra plugins and add the plugin to the AlloyEditor's
  configuration. The example below adds the \texttt{clipboard} CKEditor
  plugin:

\begin{verbatim}
String extraPlugins = jsonObject.getString("extraPlugins");

if (Validator.isNotNull(extraPlugins)) {
  extraPlugins = extraPlugins + ",ae_uibridge,ae_autolink,
  ae_buttonbridge,ae_menubridge,ae_panelmenubuttonbridge,ae_placeholder,
  ae_richcombobridge,clipboard";
}
else {
  extraPlugins = "ae_uibridge,ae_autolink,ae_buttonbridge,ae_menubridge,
  ae_panelmenubuttonbridge,ae_placeholder,ae_richcombobridge,clipboard";
}

jsonObject.put("extraPlugins", extraPlugins);
\end{verbatim}

  AlloyEditor also comes with several plugins to bridge the gap between
  the CKEditor's UI and the AlloyEditor's UI. These are prefixed with
  the \texttt{ae\_} you see above. We recommend that you include them
  all to ensure compatibility.
\end{enumerate}

The \texttt{*EditorConfigContributor} class is prepared. Now you must
choose which toolbar you want to add the button(s) to: the
\href{/docs/7-2/frameworks/-/knowledge_base/f/adding-a-button-to-the-add-toolbar}{Add
Toolbar} or one of the
\href{/docs/7-2/frameworks/-/knowledge_base/f/adding-a-button-to-a-styles-toolbar}{Styles
Toolbars}.

\section{Related Topics}\label{related-topics-139}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  Plugin Reference Guide}
\end{itemize}

\chapter{Adding a Button to the Add
Toolbar}\label{adding-a-button-to-the-add-toolbar}

The Add Toolbar appears in the AlloyEditor when your cursor is in the
editor and you click the Add button:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-add-toolbar.png}
\caption{The Add toolbar lets you add content to the editor.}
\end{figure}

Follow these steps to add a button to the AlloyEditor's Add Toolbar:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  Add Toolbar:

\begin{verbatim}
JSONObject addToolbar = toolbarsJSONObject.getJSONObject("add");
\end{verbatim}
\item
  Retrieve the existing Add Toolbar buttons:

\begin{verbatim}
JSONArray addToolbarButtons = addToolbar.getJSONArray("buttons");
\end{verbatim}
\item
  Add the button to the existing buttons. Note that the button's name is
  case sensitive. The example below adds the \texttt{camera} button to
  the Add Toolbar:

\begin{verbatim}
addToolbarButtons.put("camera");
\end{verbatim}

  The camera button is just one of the buttons available by default with
  AlloyEditor, but they are not all enabled. Here's the full list of
  available buttons you can add to the Add Toolbar:

  \begin{itemize}
  \tightlist
  \item
    camera
  \item
    embed
  \item
    hline
  \item
    image
  \item
    table
  \end{itemize}

  See \href{https://alloyeditor.com/docs/features/camera.html}{here} for
  an explanation of each button's features.
\item
  Update the AlloyEditor's configuration with the changes you made:

\begin{verbatim}
addToolbar.put("buttons", addToolbarButtons);

toolbarsJSONObject.put("add", addToolbar);

jsonObject.put("toolbars", toolbarsJSONObject);
\end{verbatim}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module} and create new content that uses the AlloyEditor---like a
  blog entry or web content article---to see your new configuration in
  action!
\end{enumerate}

The \texttt{com.liferay.docs.my.button} module's updated Add Toolbar is
shown in the figure below:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-updated-add-toolbar.png}
\caption{The Updated Add toolbar lets you add pictures from a camera
directly to the editor.}
\end{figure}

\section{Related Topics}\label{related-topics-140}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-a-button-to-a-styles-toolbar}{Adding
  a Button to a Styles Toolbar}
\end{itemize}

\chapter{Adding a Button to a Styles
Toolbar}\label{adding-a-button-to-a-styles-toolbar}

A Styles Toolbar appears when content is selected or highlighted in
AlloyEditor. There are five Styles toolbars to choose from:

\texttt{embedurl}: Appears when embedded content is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-embedurl-toolbar.png}
\caption{The embed URL Styles toolbar lets you format embedded content
in the editor.}
\end{figure}

\texttt{image}: Appears when an image is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-image-toolbar.png}
\caption{The image Styles toolbar lets you format images in the editor.}
\end{figure}

\texttt{link}: Appears when a hyperlink is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-link-toolbar.png}
\caption{The link Styles toolbar lets you format hyperlinks in the
editor.}
\end{figure}

\texttt{table}: Appears when a table is selected.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-table-toolbar.png}
\caption{The table Styles toolbar lets you format tables in the editor.}
\end{figure}

\texttt{text}: Appears when text is highlighted.

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-text-toolbar.png}
\caption{The text Styles toolbar lets you format highlighted text in the
editor.}
\end{figure}

Follow these steps to add a button to one of the Styles toolbars:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside the \texttt{populateConfigJSONObject()} method, retrieve the
  Styles toolbar:

\begin{verbatim}
JSONObject stylesToolbar = toolbarsJSONObject.getJSONObject("styles");

if (stylesToolbar == null) {
        stylesToolbar = JSONFactoryUtil.createJSONObject();
}
\end{verbatim}
\item
  Retrieve the available selection toolbars:

\begin{verbatim}
JSONArray selectionsJSONArray = stylesToolbar.getJSONArray(
"selections");
\end{verbatim}
\item
  Iterate through the selection toolbars, select the one you want to add
  the button(s) to (\texttt{embedurl}, \texttt{image}, \texttt{link},
  \texttt{table}, or \texttt{text}), retrieve the existing buttons, and
  add your button. The example below adds the \texttt{clipboard}
  plugin's \texttt{Copy}, \texttt{Cut}, and \texttt{Paste} buttons to
  the \texttt{text} selection toolbar. Note that buttons are case
  sensitive and may be aliased or not match the name of the plugin.
  Search the plugin's
  \href{/docs/7-1/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{\texttt{plugin.js}
  file} for \texttt{editor.ui.addButton} to find the button's name:

\begin{verbatim}
for (int i = 0; i < selectionsJSONArray.length(); i++) {
        JSONObject selection = selectionsJSONArray.getJSONObject(i);

        if (Objects.equals(selection.get("name"), "text")) {
                JSONArray buttons = selection.getJSONArray("buttons");

                buttons.put("Copy");
                buttons.put("Cut");
                buttons.put("Paste");
        }
}
\end{verbatim}

  The example above adds one of the
  \href{/docs/7-2/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  plugins bundled with Liferay DXP's AlloyEditor}. There are also
  several buttons available by default with the AlloyEditor, but they
  are not all enabled. The full list of existing buttons you can add to
  the Styles toolbars is shown in the table below, ordered by Toolbar:
\end{enumerate}

\noindent\hrulefill

\begin{verbatim}
 text | table | image | link |
 ---- | ----- | ----- | ---- |
 bold | tableHeading | imageCenter | linkEdit |
 code | tableRow | imageLeft | |
 h1 | tableColumn | imageRight | |
 h2 | tableCell | | |
 indentBlock | tableRemove | | |
 italic | | | |
 link | | | |
 ol | | | |
 outdentBlock | | | |
 paragraphLeft | | | |
 paragraphRight | | | |
 paragraphCenter | | | |
 paragraphJustify | | | |
 quote | | | |
 removeFormat | | | |
 strike | | | |
 styles | | | |
 subscript | | | |
 superscript | | | |
 twitter | | | |
 ul | | | |
 underline | | | |
\end{verbatim}

\noindent\hrulefill

\begin{verbatim}
See [here](https://alloyeditor.com/docs/features/camera.html) for an 
explanation of each button's features. 
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  Update the AlloyEditor's configuration with the changes you made:

\begin{verbatim}
stylesToolbar.put("selections", selectionsJSONArray);

toolbarsJSONObject.put("styles", stylesToolbar);

jsonObject.put("toolbars", toolbarsJSONObject);
\end{verbatim}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/deploying-a-project}{Deploy
  your module} and create a new piece of content that uses the
  AlloyEditor---such as a blog entry or web content article---to see
  your new configuration in action!
\end{enumerate}

The \texttt{com.liferay.docs.my.button} module's updated text styles
toolbar is shown in the figure below:

\begin{figure}
\centering
\includegraphics{./images/alloyeditor-updated-styles-toolbar.png}
\caption{The Updated text styles toolbar lets you copy, cut, and paste
text in the editor.}
\end{figure}

\section{Related Topics}\label{related-topics-141}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-a-button-to-the-add-toolbar}{Adding
  a Button to the Add Toolbar}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/ckeditor-plugin-reference-guide}{CKEditor
  Plugin Reference Guide}
\end{itemize}

\chapter{Embedding Content in the
AlloyEditor}\label{embedding-content-in-the-alloyeditor}

Whether it's a video from a popular streaming service, or an
entertaining podcast, embedded content is commonplace on the web.
Sharing content from a third party is sometimes required to properly
cover a topic. The \texttt{EmbedProvider} mechanism lets you embed third
party content in the AlloyEditor, while writing blog posts, web content
articles, etc. By default, the \texttt{EmbedProvider} mechanism is only
configured for embedding video content (Facebook, Twitch, Vimeo, and
YouTube) into the AlloyEditor. This tutorial shows how to include
additional video providers, and even add support for additional content
types.

An \texttt{EmbedProvider} requires four pieces of information:

\begin{itemize}
\tightlist
\item
  An ID: The content's ID
\item
  A Template: The required embed code for the provider
\item
  A URL Schemes: URL patterns that are supported for the provider
  template
\item
  A Type (optional): The provider category
\end{itemize}

When you add a supported URL to the editor, the \texttt{EmbedProvider}
transforms the URL into the embed code.

Follow these steps to create an \texttt{*EmbedProvider}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module} for the Embed Provider.
\item
  Add the following dependencies to the \texttt{build.gradle} file:

\begin{verbatim}
compileOnly group: "com.liferay", name:
"com.liferay.frontend.editor.api", version: "1.0.1"

compileOnly group: "com.liferay", name: "com.liferay.petra.string",
version: "2.0.0"
\end{verbatim}
\item
  Create a component class that implements the
  \texttt{EditorEmbedProvider} service:

\begin{verbatim}
@Component(
  immediate = true,
  service = EditorEmbedProvider.class
)
\end{verbatim}
\item
  Optionally set the \texttt{type} property to the content's type. If
  creating a provider for a content type other than video, you can
  create a new type constant and add a new button for the content type.
  If you do create your own button, we recommend that you use the
  existing
  \href{https://github.com/liferay/liferay-portal/tree/7.2.x/modules/apps/frontend-editor/frontend-editor-api/src/main/java/com/liferay/frontend/editor/embed}{embed
  video button's JSX files} as an example to write your own files. By
  default, the provider is categorized as \texttt{UNKNOWN}. The example
  configuration below specifies the \texttt{VIDEO} type, using a
  constant provided by the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-api/src/main/java/com/liferay/frontend/editor/embed/EditorEmbedProviderTypeConstants.java}{\texttt{EditorEmbedProviderTypeConstants}
  class}:

\begin{verbatim}
@Component(
  immediate = true,
  property = "type=" + EditorEmbedProviderTypeConstants.VIDEO,
  service = EditorEmbedProvider.class
)
\end{verbatim}
\item
  Implement the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-api/src/main/java/com/liferay/frontend/editor/embed/EditorEmbedProvider.java}{\texttt{EditorEmbedProvider}
  interface}. An example configuration is shown below:

\begin{verbatim}
public class MyEditorEmbedProvider implements EditorEmbedProvider {

}
\end{verbatim}
\item
  Add the required imports:

\begin{verbatim}
import com.liferay.frontend.editor.api.embed.EditorEmbedProvider;
import com.liferay.frontend.editor.api.embed.EditorEmbedProviderTypeConstants;
import com.liferay.petra.string.StringBundler;
\end{verbatim}

  Note the \texttt{*TypeConstants} import is only needed if you're
  adding a Video type provider.
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getId()} method to
  return the ID for the provider. An example configuration is shown
  below:

\begin{verbatim}
@Override
public String getId() {
    return "providerName";
}
\end{verbatim}
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getTpl()} method to
  provide the embed template code (usually an iframe for the provider).
  The example below defines the template for a streaming video service.
  Note that \texttt{\{embedId\}} is a placeholder for the unique
  identifier for the embedded content:

\begin{verbatim}
@Override
public String getTpl() {
    return StringBundler.concat(
        "<iframe allow=\"autoplay; encrypted-media\" allowfullscreen ",
        "height=\"315\" frameborder=\"0\" ",
        "src=\"https://www.liferaylunarresortstreaming.com/embed/{embedId}?rel=0\" ",
        "width=\"560\"></iframe>");
}
\end{verbatim}
\item
  Override the \texttt{*EmbedProvider}'s \texttt{getURLSchemes()} method
  to return an array of supported URL schemes that have an embedded
  representation for the provider. URL schemes are defined using a
  JavaScript regular expression that indicates whether a URL matches the
  provider. Every URL scheme should contain a single matching group.
  Matches replace the \texttt{\{embedId\}} placeholder defined in the
  previous step:

\begin{verbatim}
@Override
public String[] getURLSchemes() {
    return new String[] {
        "https?:\\/\\/(?:www\\.)?liferaylunarresortstreaming.com\\/watch\\?v=(\\S*)$"
    };
}
\end{verbatim}
\item
  Deploy your module and open an app that uses the AlloyEditor, such as
  Blogs, and create a new entry. Click the \emph{add button} and select
  the video button---or your new content type button---and paste the
  content's URL. Click the \emph{checkmark} to confirm that the URL
  scheme is supported. The content is embedded into the editor.
\end{enumerate}

Now you know how to embed content in the AlloyEditor. Create a new
content entry, such as a blog post, and click the embed video
button---or the one you created---and paste the content's URL.

\section{Related Topics}\label{related-topics-142}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-buttons-to-alloyeditor-toolbars}{Adding
  Buttons to AlloyEditor's Toolbars}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\end{itemize}

\chapter{Adding New Behavior to an
Editor}\label{adding-new-behavior-to-an-editor}

You can select from several different WYSIWYG editors for your users,
and each is configurable and has its strengths and weaknesses.
Configuration alone, however, doesn't always expose the features you
want. In these cases, you can programmatically access the editor
instance to create the editor experience you want, using the
\texttt{liferay-util:dynamic-include} JavaScript extension point. It
injects JavaScript code right after the editor instantiation to
configure/change the editor.

\noindent\hrulefill

\textbf{Note:} By default, the CKEditor strips empty
\texttt{\textless{}i\textgreater{}} tags, such as those used for Font
Awesome icons, from published content, when switching between the Code
View and the Source View of the editor. You can disable this behavior by
using the \texttt{ckeditor\#additionalResources} or
\texttt{alloyeditor\#additionalResources}
\href{/docs/7-2/customization/-/knowledge_base/c/wysiwyg-editor-dynamic-includes}{extension
points} to add the code shown below to the editor:

\begin{verbatim}
 CKEDITOR.dtd.$removeEmpty.i = 0
\end{verbatim}

\noindent\hrulefill

The \texttt{liferay-util:dynamic-include} extension point is in
configurable editors' JSP files: it's the gateway for injecting
JavaScript into your editor instance. In this article, you'll learn how
to use this JavaScript extension point. Follow these steps to inject
JavaScript into the WYSIWYG editor to modify its behavior:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a JS file containing your editor functionality in a folder that
  makes sense to reference, since you must register the file in your
  module. The extension point injects the JavaScript code right after
  editor initialization.

  Liferay injects JavaScript code for some applications:

  \begin{itemize}
  \tightlist
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_definition.js}{creole\_dialog\_definition.js}
    for the wiki
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/creole_dialog_show.js}{creole\_dialog\_show.js}
    also for the wiki
  \item
    \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/resources/META-INF/resources/_diffs/extension/dialog_definition.js}{dialog\_definition.js}
    for various applications
  \end{itemize}

  These JS files redefine the fields that show in dialogs, depending on
  what the selected language (HTML, BBCode, Creole) supports. For
  example, Creole doesn't support background color in table cells, so
  the table cells are removed from the options displayed to the user
  when running in Creole mode.
\item
  \href{/docs/7-2/reference/-/knowledge_base/r/creating-a-project}{Create
  a module} that can register your new JS file and inject it into your
  editor instance.
\item
  Create a unique package name in the module's \texttt{src} directory,
  and create a new Java class in that package. To follow naming
  conventions, your class name should begin with the editor you're
  modifying, followed by custom attributes, and ending with
  \emph{DynamicInclude} (e.g.,
  \texttt{CKEditorCreoleOnEditorCreateDynamicInclude.java}). Your Java
  class should implement the
  \href{https://docs.liferay.com/dxp/portal/7.2-latest/javadocs/portal-kernel/com/liferay/portal/kernel/servlet/taglib/DynamicInclude.html}{\texttt{DynamicInclude}}
  interface.
\item
  Directly above the class's declaration, insert the following
  annotation:

\begin{verbatim}
@Component(immediate = true, service = DynamicInclude.class)
\end{verbatim}

  This declares the component's implementation class and starts the
  module once deployed to Portal.
\item
  If you have not yet overridden the abstract methods from
  \texttt{DynamicInclude}, do that now. There are two implemented
  methods to edit: \texttt{include(...)} and \texttt{register(...)}.
\item
  In the \texttt{include(...)} method, retrieve the bundle containing
  your custom JS file. Retrieve the JS file as a URL and inject its
  contents into the editor. Here's the code that does this for the
  \texttt{creole\_dialog\_definition.js} file:

\begin{verbatim}
Bundle bundle = _bundleContext.getBundle();

URL entryURL = bundle.getEntry(
    "/META-INF/resources/html/editors/ckeditor/extension" +
        "/creole_dialog_definition.js");

StreamUtil.transfer(entryURL.openStream(), response.getOutputStream());
\end{verbatim}

  In the \texttt{include(...)} method, you can also retrieve editor
  configurations and choose the JS file to inject based on the
  configuration selected by the user. For example, this would be
  applicable for the use case that was suggested previously dealing with
  Creole's deficiency with displaying background colors in table cells.
  Liferay implemented this in the \texttt{include(...)} method in the
  \href{https://github.com/liferay/liferay-portal/blob/7.2.x/modules/apps/frontend-editor/frontend-editor-ckeditor-web/src/main/java/com/liferay/frontend/editor/ckeditor/web/internal/servlet/taglib/CKEditorCreoleOnEditorCreateDynamicInclude.java}{\texttt{CKEditorCreoleOnEditorCreateDynamicInclude}}
  class.
\item
  Make sure you've instantiated your bundle's context so you can
  successfully retrieve your bundle. As a best practice, do this by
  creating an activation method and then setting the
  \texttt{BundleContext} as a private field. Here's an example:

\begin{verbatim}
@Activate
protected void activate(BundleContext bundleContext) {
    _bundleContext = bundleContext;
}

private BundleContext _bundleContext;
\end{verbatim}

  This method uses the \texttt{@Activate} annotation, which specifies
  that it should be invoked once the service component has satisfied its
  requirements. For this default example, the \texttt{\_bundleContext}
  was used in the \texttt{include(...)} method.
\item
  Now register the editor you're customizing. For example, if you were
  injecting JS code into the CKEditor's JSP file, the code would look
  like this:

\begin{verbatim}
dynamicIncludeRegistry.register(
    "com.liferay.frontend.editor.ckeditor.web#ckeditor#onEditorCreate");
\end{verbatim}

  This registers the CKEditor into the Dynamic Include registry and
  specifies that JS code will be injected into the editor once it's
  created.

  Just as you can configure individual JSP pages to use a specific
  implementation of the available WYSIWYG editors, you can use those
  same implementation options for the registration process. Visit the
  \href{https://docs.liferay.com/dxp/portal/7.1-latest/propertiesdoc/portal.properties.html\#Editors}{Editors}
  section of \texttt{portal.properties} for more details. For example,
  to configure the Creole implementation of the CKEditor, you could use
  the following key:

\begin{verbatim}
"com.liferay.frontend.editor.ckeditor.web#ckeditor_creole#onEditorCreate"
\end{verbatim}
\end{enumerate}

That's it! The JS code that you created is now injected into the editor
instance you've specified. You're now able to use JavaScript to add new
behavior to your Liferay DXP supported WYSIWYG editor!

\section{Related Topics}\label{related-topics-143}

\begin{itemize}
\tightlist
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/adding-new-behavior-to-an-editor}{Adding
  New Behavior to an Editor}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/embedding-portlets-in-themes}{Embedding
  Portlets in Themes}
\item
  \href{/docs/7-2/frameworks/-/knowledge_base/f/portlets}{Portlets}
\end{itemize}
